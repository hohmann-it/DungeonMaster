{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { ValueField } from '../../index';\n\n/**\n * Common base class for ValueFields having an HTML input field.\n */\nexport default class BasicField extends ValueField {\n  constructor() {\n    super();\n    this.disabledCopyOverlay = true;\n    this._displayTextModifiedTimeoutId = null;\n    this.updateDisplayTextOnModify = false;\n    this.updateDisplayTextOnModifyDelay = 250; // in milliseconds\n  }\n\n  addField($field) {\n    super.addField($field);\n    if ($field) {\n      $field.on('input', this._onFieldInput.bind(this));\n    }\n  }\n  setUpdateDisplayTextOnModify(updateDisplayTextOnModify) {\n    // Execute pending \"accept input while typing\" function _before_ updating the \"updateDisplayTextOnModify\" property\n    if (this._displayTextModifiedTimeoutId !== null) {\n      // Cancel pending \"acceptInput(true)\" call (see _onDisplayTextModified) and execute it now\n      clearTimeout(this._displayTextModifiedTimeoutId);\n      this._acceptInputWhileTyping();\n    }\n    this.setProperty('updateDisplayTextOnModify', updateDisplayTextOnModify);\n  }\n  setUpdateDisplayTextOnModifyDelay(delay) {\n    this.setProperty('updateDisplayTextOnModifyDelay', delay);\n  }\n  _clear() {\n    if (this.$field) {\n      this.$field.val('');\n    }\n  }\n  _onFieldInput() {\n    this._updateHasText();\n    if (this.updateDisplayTextOnModify) {\n      this._onDisplayTextModified();\n    }\n  }\n\n  /**\n   * Called when the property 'updateDisplayTextOnModified' is TRUE and the display text (field's input\n   * value) has been modified by a user action, e.g. a key or paste event. If the property is FALSE, this\n   * method is _never_ called. Uses the debounce pattern.\n   */\n  _onDisplayTextModified() {\n    clearTimeout(this._displayTextModifiedTimeoutId);\n    if (this.updateDisplayTextOnModifyDelay) {\n      this._displayTextModifiedTimeoutId = setTimeout(this._acceptInputWhileTyping.bind(this), this.updateDisplayTextOnModifyDelay);\n    } else {\n      this._acceptInputWhileTyping();\n    }\n  }\n  _acceptInputWhileTyping() {\n    this._displayTextModifiedTimeoutId = null;\n    if (this.rendered) {\n      // Check needed because field may have been removed in the meantime\n      this.acceptInput(true);\n    }\n  }\n  acceptInput(whileTyping) {\n    if (this._displayTextModifiedTimeoutId !== null) {\n      // Cancel pending \"acceptInput(true)\" call (see _onDisplayTextModified) and execute it now\n      clearTimeout(this._displayTextModifiedTimeoutId);\n      this._displayTextModifiedTimeoutId = null;\n    }\n    super.acceptInput(whileTyping);\n  }\n  _renderDisplayText() {\n    this.$field.val(this.displayText);\n    super._renderDisplayText();\n  }\n  _readDisplayText() {\n    return this.$field ? this.$field.val() : '';\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  _checkDisplayTextChanged(displayText, whileTyping) {\n    let displayTextChanged = super._checkDisplayTextChanged(displayText, whileTyping);\n    if (whileTyping) {\n      if (this.updateDisplayTextOnModify && displayTextChanged) {\n        // Remember that we sent some events to the server with \"whileTyping=true\"\n        this._displayTextChangedWhileTyping = true;\n      }\n    } else {\n      // In 'updateDisplayTextOnModify' mode, each change of text is sent to the server with whileTyping=true,\n      // see _onDisplayTextModified (facade: \"setDisplayTextFromUI\"). On field blur, the text must be sent again\n      // with whileTyping=false to update the model's value as well (facade: \"parseAndSetValueFromUI\").\n      // Usually, the displayText is only sent if it has changed (to prevent too many server requests). But in\n      // the case 'updateDisplayTextOnModify AND whileTyping=false', it has to be sent if the displayText\n      // was previously sent with whileTyping=true. To do so, we make the acceptInput() method think that the\n      // text has changed (even if it has not).\n      if (this._displayTextChangedWhileTyping) {\n        displayTextChanged = true;\n      }\n      this._displayTextChangedWhileTyping = false;\n    }\n    return displayTextChanged;\n  }\n}","map":{"version":3,"names":["ValueField","BasicField","constructor","disabledCopyOverlay","_displayTextModifiedTimeoutId","updateDisplayTextOnModify","updateDisplayTextOnModifyDelay","addField","$field","on","_onFieldInput","bind","setUpdateDisplayTextOnModify","clearTimeout","_acceptInputWhileTyping","setProperty","setUpdateDisplayTextOnModifyDelay","delay","_clear","val","_updateHasText","_onDisplayTextModified","setTimeout","rendered","acceptInput","whileTyping","_renderDisplayText","displayText","_readDisplayText","_checkDisplayTextChanged","displayTextChanged","_displayTextChangedWhileTyping"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/BasicField.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {ValueField} from '../../index';\n\n/**\n * Common base class for ValueFields having an HTML input field.\n */\nexport default class BasicField extends ValueField {\n\n  constructor() {\n    super();\n    this.disabledCopyOverlay = true;\n    this._displayTextModifiedTimeoutId = null;\n    this.updateDisplayTextOnModify = false;\n    this.updateDisplayTextOnModifyDelay = 250; // in milliseconds\n  }\n\n  addField($field) {\n    super.addField($field);\n    if ($field) {\n      $field.on('input', this._onFieldInput.bind(this));\n    }\n  }\n\n  setUpdateDisplayTextOnModify(updateDisplayTextOnModify) {\n    // Execute pending \"accept input while typing\" function _before_ updating the \"updateDisplayTextOnModify\" property\n    if (this._displayTextModifiedTimeoutId !== null) {\n      // Cancel pending \"acceptInput(true)\" call (see _onDisplayTextModified) and execute it now\n      clearTimeout(this._displayTextModifiedTimeoutId);\n      this._acceptInputWhileTyping();\n    }\n\n    this.setProperty('updateDisplayTextOnModify', updateDisplayTextOnModify);\n  }\n\n  setUpdateDisplayTextOnModifyDelay(delay) {\n    this.setProperty('updateDisplayTextOnModifyDelay', delay);\n  }\n\n  _clear() {\n    if (this.$field) {\n      this.$field.val('');\n    }\n  }\n\n  _onFieldInput() {\n    this._updateHasText();\n    if (this.updateDisplayTextOnModify) {\n      this._onDisplayTextModified();\n    }\n  }\n\n  /**\n   * Called when the property 'updateDisplayTextOnModified' is TRUE and the display text (field's input\n   * value) has been modified by a user action, e.g. a key or paste event. If the property is FALSE, this\n   * method is _never_ called. Uses the debounce pattern.\n   */\n  _onDisplayTextModified() {\n    clearTimeout(this._displayTextModifiedTimeoutId);\n    if (this.updateDisplayTextOnModifyDelay) {\n      this._displayTextModifiedTimeoutId = setTimeout(this._acceptInputWhileTyping.bind(this), this.updateDisplayTextOnModifyDelay);\n    } else {\n      this._acceptInputWhileTyping();\n    }\n  }\n\n  _acceptInputWhileTyping() {\n    this._displayTextModifiedTimeoutId = null;\n    if (this.rendered) { // Check needed because field may have been removed in the meantime\n      this.acceptInput(true);\n    }\n  }\n\n  acceptInput(whileTyping) {\n    if (this._displayTextModifiedTimeoutId !== null) {\n      // Cancel pending \"acceptInput(true)\" call (see _onDisplayTextModified) and execute it now\n      clearTimeout(this._displayTextModifiedTimeoutId);\n      this._displayTextModifiedTimeoutId = null;\n    }\n    super.acceptInput(whileTyping);\n  }\n\n  _renderDisplayText() {\n    this.$field.val(this.displayText);\n    super._renderDisplayText();\n  }\n\n  _readDisplayText() {\n    return this.$field ? this.$field.val() : '';\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  _checkDisplayTextChanged(displayText, whileTyping) {\n    let displayTextChanged = super._checkDisplayTextChanged(displayText, whileTyping);\n\n    if (whileTyping) {\n      if (this.updateDisplayTextOnModify && displayTextChanged) {\n        // Remember that we sent some events to the server with \"whileTyping=true\"\n        this._displayTextChangedWhileTyping = true;\n      }\n    } else {\n      // In 'updateDisplayTextOnModify' mode, each change of text is sent to the server with whileTyping=true,\n      // see _onDisplayTextModified (facade: \"setDisplayTextFromUI\"). On field blur, the text must be sent again\n      // with whileTyping=false to update the model's value as well (facade: \"parseAndSetValueFromUI\").\n      // Usually, the displayText is only sent if it has changed (to prevent too many server requests). But in\n      // the case 'updateDisplayTextOnModify AND whileTyping=false', it has to be sent if the displayText\n      // was previously sent with whileTyping=true. To do so, we make the acceptInput() method think that the\n      // text has changed (even if it has not).\n      if (this._displayTextChangedWhileTyping) {\n        displayTextChanged = true;\n      }\n      this._displayTextChangedWhileTyping = false;\n    }\n\n    return displayTextChanged;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}