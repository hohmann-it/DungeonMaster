{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, arrays, ContextMenuPopup, Event, HtmlComponent, icons, MenuExecKeyStroke, MenuKeyStroke, scout, strings, tooltips, TreeVisitResult } from '../index';\nexport default class Menu extends Action {\n  constructor() {\n    super();\n    this.childActions = [];\n    this.defaultMenu = null; // null = determined by the menu bar\n    this.excludedByFilter = false;\n    this.menuTypes = [];\n    this.menuStyle = Menu.MenuStyle.NONE;\n    /**\n     * This property is true when the menu instance was moved into a overflow-menu\n     * when there's not enough space on the screen (see MenuBarLayout.js). When set\n     * to true, button style menus must be displayed as regular menus.\n     */\n    this.overflown = false;\n    /**\n     * This property is set if this is a subMenu\n     */\n    this.parentMenu = null;\n    this.popup = null;\n    this.popupHorizontalAlignment = undefined;\n    this.popupVerticalAlignment = undefined;\n    this.stackable = true;\n    this.separator = false;\n    this.shrinkable = false;\n    this.subMenuVisibility = Menu.SubMenuVisibility.DEFAULT;\n    this.menuFilter = null;\n    this.$submenuIcon = null;\n    this.$subMenuBody = null;\n    this._addCloneProperties(['defaultMenu', 'menuTypes', 'overflow', 'stackable', 'separator', 'shrinkable', 'parentMenu', 'menuFilter', 'subMenuVisibility']);\n    this._addWidgetProperties('childActions');\n  }\n  _init(options) {\n    super._init(options);\n    this._setChildActions(this.childActions);\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke(new MenuExecKeyStroke(this));\n  }\n  _render() {\n    if (this.separator) {\n      this._renderSeparator();\n    } else {\n      this._renderItem();\n    }\n    this.$container.unfocusable();\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderOverflown();\n    this._renderMenuStyle();\n    this._renderActionStyle();\n    this._updateIconAndTextStyle();\n  }\n  _remove() {\n    super._remove();\n    this.$submenuIcon = null;\n    this.$subMenuBody = null;\n  }\n  _renderSeparator() {\n    this.$container = this.$parent.appendDiv('menu-separator');\n  }\n  _renderItem() {\n    this.$container = this.$parent.appendDiv('menu-item');\n    if (this.uiCssClass) {\n      this.$container.addClass(this.uiCssClass);\n    }\n    let mouseEventHandler = this._onMouseEvent.bind(this);\n    this.$container.on('mousedown', mouseEventHandler).on('contextmenu', mouseEventHandler).on('click', mouseEventHandler);\n    this._renderSubMenuIcon();\n  }\n  _renderActionStyle() {\n    this.$container.toggleClass('menu-button', this.isButton() && !this.overflown);\n  }\n  _renderSelected() {\n    if (!this._doActionTogglesSubMenu()) {\n      super._renderSelected();\n      // Cannot be done in ContextMenuPopup,\n      // because the property change event is fired before renderSelected is called,\n      // and updateNextToSelected depends on the UI state\n      if (this.parent instanceof ContextMenuPopup) {\n        this.parent.updateNextToSelected();\n      }\n    }\n    if (this.selected) {\n      if (this._doActionTogglesSubMenu()) {\n        this._renderSubMenuItems(this, this.childActions);\n      } else if (this._doActionTogglesPopup()) {\n        this._openPopup();\n      }\n    } else {\n      if (this._doActionTogglesSubMenu() && this.rendered) {\n        this._removeSubMenuItems(this);\n      } else {\n        this._closePopup();\n        this._closeSubMenues();\n      }\n    }\n    this.$container.toggleClass('has-popup', this._doActionTogglesSubMenu() || this._doActionTogglesPopup());\n  }\n  _closeSubMenues() {\n    this.childActions.forEach(menu => {\n      if (menu._doActionTogglesPopup()) {\n        menu._closeSubMenues();\n        menu.setSelected(false);\n      }\n    });\n  }\n  _removeSubMenuItems(parentMenu) {\n    if (this.parent instanceof ContextMenuPopup) {\n      this.parent.removeSubMenuItems(parentMenu, true);\n    } else if (this.parent instanceof Menu) {\n      this.parent._removeSubMenuItems(parentMenu);\n    }\n  }\n  _renderSubMenuItems(parentMenu, menus) {\n    let parent = this.parent;\n    if (parent instanceof ContextMenuPopup) {\n      parent.renderSubMenuItems(parentMenu, menus, true);\n      let closeHandler = event => parentMenu.setSelected(false);\n      let selectedChangeChangeHandler = event => {\n        if (event.newValue === false) {\n          parent.off('destroy', closeHandler);\n          parentMenu.off('propertyChange:selected', selectedChangeChangeHandler);\n        }\n      };\n      parent.one('destroy', closeHandler);\n      parentMenu.on('propertyChange:selected', selectedChangeChangeHandler);\n    } else if (parent instanceof Menu) {\n      parent._renderSubMenuItems(parentMenu, menus);\n    }\n  }\n\n  /**\n   * Override this method to control the toggles sub-menu behavior when this menu instance is used as parent.\n   * Some menu sub-classes like the ComboMenu need to show the popup menu instead.\n   * @see: #_doActionTogglesSubMenu\n   */\n  _togglesSubMenu() {\n    return true;\n  }\n  _doActionTogglesSubMenu() {\n    if (!this.childActions.length) {\n      return false;\n    }\n    if (this.parent instanceof ContextMenuPopup) {\n      return true;\n    }\n    if (this.parent instanceof Menu) {\n      return this.parent._togglesSubMenu();\n    }\n    return false;\n  }\n  _getSubMenuLevel() {\n    if (this.parent instanceof ContextMenuPopup) {\n      return 0;\n    }\n    return super._getSubMenuLevel() + 1;\n  }\n  _onMouseEvent(event) {\n    if (event.type === 'mousedown') {\n      this._doubleClickSupport.mousedown(event);\n    }\n    if (!this._allowMouseEvent(event)) {\n      return;\n    }\n\n    // When the action is clicked the user wants to execute the action and not see the tooltip -> cancel the task\n    // If it is already displayed it will stay\n    tooltips.cancel(this.$container);\n\n    // If menu has childActions, a popup should be rendered on click. To create\n    // the impression of a faster UI, open the popup already on 'mousedown', not\n    // on 'click'. All other actions are handled on 'click'.\n    if (event.type === 'mousedown' && this._doActionTogglesPopup()) {\n      this.doAction();\n    } else if ((event.type === 'click' || event.type === 'contextmenu') && !this._doActionTogglesPopup()) {\n      this.doAction();\n    }\n  }\n\n  /**\n   * May be overridden if the criteria to open a popup differs\n   */\n  _doActionTogglesPopup() {\n    return this.childActions.length > 0;\n  }\n  _renderChildActions() {\n    // Child action in a sub menu cannot be replaced dynamically, popup has to be closed first.\n    if (!this.rendering) {\n      this._renderSubMenuIcon();\n    }\n  }\n  setSubMenuVisibility(subMenuVisibility) {\n    this.setProperty('subMenuVisibility', subMenuVisibility);\n  }\n  _renderSubMenuVisibility() {\n    this._renderSubMenuIcon();\n  }\n  _renderSubMenuIcon() {\n    let visible = false;\n\n    // calculate visibility of sub-menu icon\n    if (this.childActions.length > 0) {\n      switch (this.subMenuVisibility) {\n        case Menu.SubMenuVisibility.DEFAULT:\n          visible = this._hasText();\n          break;\n        case Menu.SubMenuVisibility.TEXT_OR_ICON:\n          visible = this._hasText() || this.iconId;\n          break;\n        case Menu.SubMenuVisibility.ALWAYS:\n          visible = true;\n          break;\n        case Menu.SubMenuVisibility.NEVER:\n          visible = false;\n          break;\n      }\n    }\n    if (visible) {\n      if (!this.$submenuIcon) {\n        let icon = icons.parseIconId(Menu.SUBMENU_ICON);\n        this.$submenuIcon = this.$container.appendSpan('submenu-icon').text(icon.iconCharacter);\n        this.invalidateLayoutTree();\n      }\n    } else {\n      if (this.$submenuIcon) {\n        this.$submenuIcon.remove();\n        this.$submenuIcon = null;\n        this.invalidateLayoutTree();\n      }\n    }\n    if (!this.rendering) {\n      this._renderTextPosition();\n      this._updateIconAndTextStyle();\n    }\n  }\n  _renderText() {\n    super._renderText();\n    this.$container.toggleClass('has-text', strings.hasText(this.text) && this.textVisible);\n    if (!this.rendering) {\n      this._renderSubMenuIcon();\n    }\n    this.invalidateLayoutTree();\n  }\n  _renderTextPosition() {\n    super._renderTextPosition();\n    let $parent = this.$container;\n    if (this.textPosition === Action.TextPosition.BOTTOM && this.$text && this.iconId) {\n      // Move submenu icon into text\n      $parent = this.$text;\n    }\n    if (this.$submenuIcon) {\n      // Always append to make sure submenu-icon is the last element in the DOM\n      this.$submenuIcon.appendTo($parent);\n    }\n  }\n  _renderIconId() {\n    super._renderIconId();\n    this.$container.toggleClass('has-icon', !!this.iconId);\n    if (!this.rendering) {\n      this._renderSubMenuIcon();\n    }\n    this.invalidateLayoutTree();\n  }\n  isTabTarget() {\n    return this.enabledComputed && this.visible && !this.overflown && (this.isButton() || !this.separator) && (!this.parentMenu || this.parentMenu.visible && !this.parentMenu.overflown); // Necessary for ComboMenu -> must return false if ComboMenu (parentMenu) is not shown\n  }\n\n  /**\n   * @override Widget.js\n   */\n  recomputeEnabled(parentEnabled) {\n    if (parentEnabled === undefined) {\n      parentEnabled = this._getInheritedAccessibility();\n    }\n    let enabledComputed;\n    let enabledStateForChildren;\n    if (this.enabled && this.inheritAccessibility && !parentEnabled && this.childActions.length > 0) {\n      // the enabledComputed state here depends on the child actions:\n      // - if there are childActions which have inheritAccessibility=false (recursively): this action must be enabledComputed=true so that these children can be reached\n      // - otherwise this menu is set to enabledComputed=false\n      enabledComputed = this._hasAccessibleChildMenu();\n      if (enabledComputed) {\n        // this composite menu is only active because it has children with inheritAccessibility=true\n        // but child-menus should consider the container parent instead, otherwise all children would be enabled (because this composite menu is enabled now)\n        enabledStateForChildren = parentEnabled;\n      } else {\n        enabledStateForChildren = false;\n      }\n    } else {\n      enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n      enabledStateForChildren = enabledComputed;\n    }\n    this._updateEnabledComputed(enabledComputed, enabledStateForChildren);\n  }\n\n  /**\n   * Calculates the inherited enabled state of this menu. This is the enabled state of the next relevant parent.\n   * A relevant parent is either\n   * - the next parent menu with inheritAccessibility=false\n   * - or the container of the menu (the parent of the root menu)\n   *\n   * The enabled state of the container must be used because the parent menu might be a menu which is only enabled because it has children with inheritAccessibility=false.\n   * One exception: if a parent menu itself is inheritAccessibility=false. Then the container is not relevant anymore but this parent is taken instead.\n   */\n  _getInheritedAccessibility() {\n    let menu = this;\n    let rootMenu = menu;\n    while (menu) {\n      if (!menu.inheritAccessibility) {\n        // not inherited. no need to check any more parent widgets\n        return menu.enabled; /* do not use enabledComputed here because the parents have no effect */\n      }\n\n      rootMenu = menu;\n      menu = menu.parentMenu;\n    }\n    let container = rootMenu.parent;\n    if (container && container.initialized && container.enabledComputed !== undefined) {\n      return container.enabledComputed;\n    }\n    return true;\n  }\n  _findRootMenu() {\n    let menu = this;\n    let result;\n    while (menu) {\n      result = menu;\n      menu = menu.parentMenu;\n    }\n    return result;\n  }\n  _hasAccessibleChildMenu() {\n    let childFound = false;\n    this.visitChildMenus(child => {\n      if (!child.inheritAccessibility && child.enabled /* do not use enabledComputed here */ && child.visible) {\n        childFound = true;\n        return TreeVisitResult.TERMINATE;\n      }\n      return TreeVisitResult.CONTINUE;\n    });\n    return childFound;\n  }\n\n  /**\n   * cannot use Widget#visitChildren() here because the child actions are not always part of the children collection\n   * e.g. for ellipsis menus which declare childActions as 'PreserveOnPropertyChangeProperties'. this means the childActions are not automatically added to the children list even it is a widget property!\n   */\n  visitChildMenus(visitor) {\n    for (let i = 0; i < this.childActions.length; i++) {\n      let child = this.childActions[i];\n      if (child instanceof Menu) {\n        let treeVisitResult = visitor(child);\n        if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n          // Visitor wants to abort the visiting\n          return TreeVisitResult.TERMINATE;\n        } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n          treeVisitResult = child.visitChildMenus(visitor);\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            return TreeVisitResult.TERMINATE;\n          }\n        }\n      }\n    }\n  }\n  _hasText() {\n    return strings.hasText(this.text) && this.textVisible;\n  }\n  _updateIconAndTextStyle() {\n    let hasText = this._hasText();\n    let hasTextAndIcon = !!(hasText && this.iconId);\n    let hasIcon = !!this.iconId;\n    let hasSubMenuIcon = !!this.$submenuIcon;\n    let hasOneIcon = hasIcon && !hasSubMenuIcon || !hasIcon && hasSubMenuIcon;\n    this.$container.toggleClass('menu-textandicon', hasTextAndIcon);\n    this.$container.toggleClass('menu-icononly', !hasText && hasOneIcon);\n  }\n  _closePopup() {\n    if (this.popup && !this.popup.isRemovalPending()) {\n      this.popup.close();\n    }\n  }\n  _canOpenPopup() {\n    if (this.popup && this.popup.isRemovalPending()) {\n      // If the popup should be opened while it is being removed, the popup needs to be removed immediately before it can be opened (the remove animation won't complete).\n      // This is necessary to always have a consistent state between menu and popup (e.g. if menu is selected while the popup is removed).\n      // The popup will be null afterwards (due to the destroy handler added by openPopup)\n      this.popup.removeImmediately();\n    }\n    if (this.popup) {\n      // already open\n      return false;\n    }\n\n    // Recheck if opening is still possible (maybe destroying the popup changed that, e.g. form of form menu was set to null)\n    if (!this._doActionTogglesPopup()) {\n      return false;\n    }\n    return true;\n  }\n  _openPopup() {\n    if (!this._canOpenPopup()) {\n      return;\n    }\n    this.popup = this._createPopup();\n    this.popup.open();\n    this.popup.one('destroy', event => {\n      this.popup = null;\n    });\n    // Unselect on close which comes earlier than destroy (before the animation), to give more immediate feedback\n    this.popup.on('close', event => {\n      this.setSelected(false);\n    });\n    if (this.uiCssClass) {\n      this.popup.$container.addClass(this.uiCssClass);\n    }\n  }\n  _createPopup(event) {\n    let options = {\n      parent: this,\n      menu: this,\n      menuFilter: this.menuFilter,\n      horizontalAlignment: this.popupHorizontalAlignment,\n      verticalAlignment: this.popupVerticalAlignment\n    };\n    return scout.create('MenuBarPopup', options);\n  }\n  _createActionKeyStroke() {\n    return new MenuKeyStroke(this);\n  }\n  isToggleAction() {\n    return this.childActions.length > 0 || this.toggleAction;\n  }\n  isButton() {\n    return Action.ActionStyle.BUTTON === this.actionStyle;\n  }\n\n  /**\n   * @deprecated use insertChildActions instead\n   * @param childActions\n   */\n  addChildActions(childActions) {\n    this.insertChildActions(childActions);\n  }\n  insertChildAction(actionsToInsert) {\n    this.insertChildActions([actionsToInsert]);\n  }\n  insertChildActions(actionsToInsert) {\n    actionsToInsert = arrays.ensure(actionsToInsert);\n    if (actionsToInsert.length === 0) {\n      return;\n    }\n    this.setChildActions(this.childActions.concat(actionsToInsert));\n  }\n  deleteChildAction(actionToDelete) {\n    this.deleteChildActions([actionToDelete]);\n  }\n  deleteChildActions(actionsToDelete) {\n    actionsToDelete = arrays.ensure(actionsToDelete);\n    if (actionsToDelete.length === 0) {\n      return;\n    }\n    let actions = this.childActions.slice();\n    arrays.removeAll(actions, actionsToDelete);\n    this.setChildActions(actions);\n  }\n  setChildActions(childActions) {\n    this.setProperty('childActions', childActions);\n  }\n  _setChildActions(childActions) {\n    // disconnect existing\n    this.childActions.forEach(childAction => {\n      childAction.parentMenu = null;\n    });\n    this._setProperty('childActions', childActions);\n\n    // connect new actions\n    this.childActions.forEach(childAction => {\n      childAction.parentMenu = this;\n    });\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _setInheritAccessibility(inheritAccessibility) {\n    let changed = this._setProperty('inheritAccessibility', inheritAccessibility);\n    if (changed) {\n      this._recomputeEnabledInMenuHierarchy();\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _setEnabled(enabled) {\n    let changed = this._setProperty('enabled', enabled);\n    if (changed) {\n      this._recomputeEnabledInMenuHierarchy();\n    }\n  }\n  _setVisible(visible) {\n    let changed = this._setProperty('visible', visible);\n    if (changed) {\n      this._recomputeEnabledInMenuHierarchy();\n    }\n  }\n  _recomputeEnabledInMenuHierarchy() {\n    if (!this.initialized) {\n      return;\n    }\n    let rootMenu = this._findRootMenu();\n    rootMenu.recomputeEnabled();\n    if (rootMenu !== this) {\n      // necessary in case this menu or a parent menu has inheritAccessibility=false. Because then this menu and its children are skipped in the line above!\n      this.recomputeEnabled();\n    }\n  }\n  setSelected(selected) {\n    if (selected === this.selected) {\n      return;\n    }\n    super.setSelected(selected);\n    if (!this._doActionTogglesSubMenu() && !this._doActionTogglesPopup()) {\n      return;\n    }\n    // If menu toggles a popup and is in an ellipsis menu which is not selected it needs a special treatment\n    if (this.overflowMenu && !this.overflowMenu.selected) {\n      this._handleSelectedInEllipsis();\n    }\n  }\n  _handleSelectedInEllipsis() {\n    // If the selection toggles a popup, open the ellipsis menu as well, otherwise the popup would not be shown\n    if (this.selected) {\n      this.overflowMenu.setSelected(true);\n    }\n  }\n  setStackable(stackable) {\n    this.setProperty('stackable', stackable);\n  }\n  _renderStackable() {\n    this.invalidateLayoutTree();\n  }\n  setShrinkable(shrinkable) {\n    this.setProperty('shrinkable', shrinkable);\n  }\n  _renderShrinkable() {\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * For internal usage only.\n   * Used by the MenuBarLayout when a menu is moved to the ellipsis drop down.\n   */\n  _setOverflown(overflown) {\n    if (this.overflown === overflown) {\n      return;\n    }\n    this._setProperty('overflown', overflown);\n    if (this.rendered) {\n      this._renderOverflown();\n    }\n  }\n  _renderOverflown() {\n    this.$container.toggleClass('overflown', this.overflown);\n    this._renderActionStyle();\n  }\n  setMenuStyle(menuStyle) {\n    this.setProperty('menuStyle', menuStyle);\n  }\n  _renderMenuStyle() {\n    this.$container.toggleClass('default', this.menuStyle === Menu.MenuStyle.DEFAULT);\n  }\n  setDefaultMenu(defaultMenu) {\n    this.setProperty('defaultMenu', defaultMenu);\n  }\n  setMenuFilter(menuFilter) {\n    this.setProperty('menuFilter', menuFilter);\n    this.childActions.forEach(child => {\n      child.setMenuFilter(menuFilter);\n    });\n  }\n  clone(model, options) {\n    let clone = super.clone(model, options);\n    this._deepCloneProperties(clone, 'childActions', options);\n    clone._setChildActions(clone.childActions);\n    return clone;\n  }\n\n  /**\n   * @override\n   */\n  focus() {\n    let event = new Event({\n      source: this\n    });\n    this.trigger('focus', event);\n    if (!event.defaultPrevented) {\n      return super.focus();\n    }\n    return false;\n  }\n}\n_defineProperty(Menu, \"SUBMENU_ICON\", icons.ANGLE_DOWN_BOLD);\n_defineProperty(Menu, \"MenuStyle\", {\n  NONE: 0,\n  DEFAULT: 1\n});\n_defineProperty(Menu, \"SubMenuVisibility\", {\n  /**\n   * Default: sub-menu icon is only visible when menu has text.\n   */\n  DEFAULT: 'default',\n  /**\n   * Text or icon: sub-menu icon is only visible when menu has text or an icon.\n   */\n  TEXT_OR_ICON: 'textOrIcon',\n  /**\n   * Always: sub-menu icon is always visible when menu has child-actions.\n   */\n  ALWAYS: 'always',\n  /**\n   * Never: sub-menu icon never visible.\n   */\n  NEVER: 'never'\n});","map":{"version":3,"names":["Action","arrays","ContextMenuPopup","Event","HtmlComponent","icons","MenuExecKeyStroke","MenuKeyStroke","scout","strings","tooltips","TreeVisitResult","Menu","constructor","childActions","defaultMenu","excludedByFilter","menuTypes","menuStyle","MenuStyle","NONE","overflown","parentMenu","popup","popupHorizontalAlignment","undefined","popupVerticalAlignment","stackable","separator","shrinkable","subMenuVisibility","SubMenuVisibility","DEFAULT","menuFilter","$submenuIcon","$subMenuBody","_addCloneProperties","_addWidgetProperties","_init","options","_setChildActions","_initKeyStrokeContext","keyStrokeContext","registerKeyStroke","_render","_renderSeparator","_renderItem","$container","unfocusable","htmlComp","install","session","_renderProperties","_renderOverflown","_renderMenuStyle","_renderActionStyle","_updateIconAndTextStyle","_remove","$parent","appendDiv","uiCssClass","addClass","mouseEventHandler","_onMouseEvent","bind","on","_renderSubMenuIcon","toggleClass","isButton","_renderSelected","_doActionTogglesSubMenu","parent","updateNextToSelected","selected","_renderSubMenuItems","_doActionTogglesPopup","_openPopup","rendered","_removeSubMenuItems","_closePopup","_closeSubMenues","forEach","menu","setSelected","removeSubMenuItems","menus","renderSubMenuItems","closeHandler","event","selectedChangeChangeHandler","newValue","off","one","_togglesSubMenu","length","_getSubMenuLevel","type","_doubleClickSupport","mousedown","_allowMouseEvent","cancel","doAction","_renderChildActions","rendering","setSubMenuVisibility","setProperty","_renderSubMenuVisibility","visible","_hasText","TEXT_OR_ICON","iconId","ALWAYS","NEVER","icon","parseIconId","SUBMENU_ICON","appendSpan","text","iconCharacter","invalidateLayoutTree","remove","_renderTextPosition","_renderText","hasText","textVisible","textPosition","TextPosition","BOTTOM","$text","appendTo","_renderIconId","isTabTarget","enabledComputed","recomputeEnabled","parentEnabled","_getInheritedAccessibility","enabledStateForChildren","enabled","inheritAccessibility","_hasAccessibleChildMenu","_computeEnabled","_updateEnabledComputed","rootMenu","container","initialized","_findRootMenu","result","childFound","visitChildMenus","child","TERMINATE","CONTINUE","visitor","i","treeVisitResult","SKIP_SUBTREE","hasTextAndIcon","hasIcon","hasSubMenuIcon","hasOneIcon","isRemovalPending","close","_canOpenPopup","removeImmediately","_createPopup","open","horizontalAlignment","verticalAlignment","create","_createActionKeyStroke","isToggleAction","toggleAction","ActionStyle","BUTTON","actionStyle","addChildActions","insertChildActions","insertChildAction","actionsToInsert","ensure","setChildActions","concat","deleteChildAction","actionToDelete","deleteChildActions","actionsToDelete","actions","slice","removeAll","childAction","_setProperty","_setInheritAccessibility","changed","_recomputeEnabledInMenuHierarchy","_setEnabled","_setVisible","overflowMenu","_handleSelectedInEllipsis","setStackable","_renderStackable","setShrinkable","_renderShrinkable","_setOverflown","setMenuStyle","setDefaultMenu","setMenuFilter","clone","model","_deepCloneProperties","focus","source","trigger","defaultPrevented","ANGLE_DOWN_BOLD"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/menu/Menu.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, arrays, ContextMenuPopup, Event, HtmlComponent, icons, MenuExecKeyStroke, MenuKeyStroke, scout, strings, tooltips, TreeVisitResult} from '../index';\n\nexport default class Menu extends Action {\n\n  constructor() {\n    super();\n\n    this.childActions = [];\n    this.defaultMenu = null; // null = determined by the menu bar\n    this.excludedByFilter = false;\n    this.menuTypes = [];\n    this.menuStyle = Menu.MenuStyle.NONE;\n    /**\n     * This property is true when the menu instance was moved into a overflow-menu\n     * when there's not enough space on the screen (see MenuBarLayout.js). When set\n     * to true, button style menus must be displayed as regular menus.\n     */\n    this.overflown = false;\n    /**\n     * This property is set if this is a subMenu\n     */\n    this.parentMenu = null;\n    this.popup = null;\n    this.popupHorizontalAlignment = undefined;\n    this.popupVerticalAlignment = undefined;\n    this.stackable = true;\n    this.separator = false;\n    this.shrinkable = false;\n    this.subMenuVisibility = Menu.SubMenuVisibility.DEFAULT;\n    this.menuFilter = null;\n    this.$submenuIcon = null;\n    this.$subMenuBody = null;\n    this._addCloneProperties(['defaultMenu', 'menuTypes', 'overflow', 'stackable', 'separator', 'shrinkable', 'parentMenu', 'menuFilter', 'subMenuVisibility']);\n    this._addWidgetProperties('childActions');\n  }\n\n  static SUBMENU_ICON = icons.ANGLE_DOWN_BOLD;\n\n  /**\n   * Special styles of the menu, calculated by the MenuBar. The default value is MenuStyle.NONE.\n   */\n  static MenuStyle = {\n    NONE: 0,\n    DEFAULT: 1\n  };\n\n  static SubMenuVisibility = {\n    /**\n     * Default: sub-menu icon is only visible when menu has text.\n     */\n    DEFAULT: 'default',\n    /**\n     * Text or icon: sub-menu icon is only visible when menu has text or an icon.\n     */\n    TEXT_OR_ICON: 'textOrIcon',\n    /**\n     * Always: sub-menu icon is always visible when menu has child-actions.\n     */\n    ALWAYS: 'always',\n    /**\n     * Never: sub-menu icon never visible.\n     */\n    NEVER: 'never'\n  };\n\n  _init(options) {\n    super._init(options);\n    this._setChildActions(this.childActions);\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke(new MenuExecKeyStroke(this));\n  }\n\n  _render() {\n    if (this.separator) {\n      this._renderSeparator();\n    } else {\n      this._renderItem();\n    }\n    this.$container.unfocusable();\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderOverflown();\n    this._renderMenuStyle();\n    this._renderActionStyle();\n    this._updateIconAndTextStyle();\n  }\n\n  _remove() {\n    super._remove();\n    this.$submenuIcon = null;\n    this.$subMenuBody = null;\n  }\n\n  _renderSeparator() {\n    this.$container = this.$parent.appendDiv('menu-separator');\n  }\n\n  _renderItem() {\n    this.$container = this.$parent.appendDiv('menu-item');\n    if (this.uiCssClass) {\n      this.$container.addClass(this.uiCssClass);\n    }\n\n    let mouseEventHandler = this._onMouseEvent.bind(this);\n    this.$container\n      .on('mousedown', mouseEventHandler)\n      .on('contextmenu', mouseEventHandler)\n      .on('click', mouseEventHandler);\n\n    this._renderSubMenuIcon();\n  }\n\n  _renderActionStyle() {\n    this.$container.toggleClass('menu-button', this.isButton() && !this.overflown);\n  }\n\n  _renderSelected() {\n    if (!this._doActionTogglesSubMenu()) {\n      super._renderSelected();\n      // Cannot be done in ContextMenuPopup,\n      // because the property change event is fired before renderSelected is called,\n      // and updateNextToSelected depends on the UI state\n      if (this.parent instanceof ContextMenuPopup) {\n        this.parent.updateNextToSelected();\n      }\n    }\n    if (this.selected) {\n      if (this._doActionTogglesSubMenu()) {\n        this._renderSubMenuItems(this, this.childActions);\n      } else if (this._doActionTogglesPopup()) {\n        this._openPopup();\n      }\n    } else {\n      if (this._doActionTogglesSubMenu() && this.rendered) {\n        this._removeSubMenuItems(this);\n      } else {\n        this._closePopup();\n        this._closeSubMenues();\n      }\n    }\n    this.$container.toggleClass('has-popup', this._doActionTogglesSubMenu() || this._doActionTogglesPopup());\n  }\n\n  _closeSubMenues() {\n    this.childActions.forEach(menu => {\n      if (menu._doActionTogglesPopup()) {\n        menu._closeSubMenues();\n        menu.setSelected(false);\n      }\n    });\n  }\n\n  _removeSubMenuItems(parentMenu) {\n    if (this.parent instanceof ContextMenuPopup) {\n      this.parent.removeSubMenuItems(parentMenu, true);\n    } else if (this.parent instanceof Menu) {\n      this.parent._removeSubMenuItems(parentMenu);\n    }\n  }\n\n  _renderSubMenuItems(parentMenu, menus) {\n    let parent = this.parent;\n    if (parent instanceof ContextMenuPopup) {\n      parent.renderSubMenuItems(parentMenu, menus, true);\n      let closeHandler = event => parentMenu.setSelected(false);\n      let selectedChangeChangeHandler = event => {\n        if (event.newValue === false) {\n          parent.off('destroy', closeHandler);\n          parentMenu.off('propertyChange:selected', selectedChangeChangeHandler);\n        }\n      };\n      parent.one('destroy', closeHandler);\n      parentMenu.on('propertyChange:selected', selectedChangeChangeHandler);\n    } else if (parent instanceof Menu) {\n      parent._renderSubMenuItems(parentMenu, menus);\n    }\n  }\n\n  /**\n   * Override this method to control the toggles sub-menu behavior when this menu instance is used as parent.\n   * Some menu sub-classes like the ComboMenu need to show the popup menu instead.\n   * @see: #_doActionTogglesSubMenu\n   */\n  _togglesSubMenu() {\n    return true;\n  }\n\n  _doActionTogglesSubMenu() {\n    if (!this.childActions.length) {\n      return false;\n    }\n    if (this.parent instanceof ContextMenuPopup) {\n      return true;\n    }\n    if (this.parent instanceof Menu) {\n      return this.parent._togglesSubMenu();\n    }\n    return false;\n  }\n\n  _getSubMenuLevel() {\n    if (this.parent instanceof ContextMenuPopup) {\n      return 0;\n    }\n    return super._getSubMenuLevel() + 1;\n  }\n\n  _onMouseEvent(event) {\n    if (event.type === 'mousedown') {\n      this._doubleClickSupport.mousedown(event);\n    }\n    if (!this._allowMouseEvent(event)) {\n      return;\n    }\n\n    // When the action is clicked the user wants to execute the action and not see the tooltip -> cancel the task\n    // If it is already displayed it will stay\n    tooltips.cancel(this.$container);\n\n    // If menu has childActions, a popup should be rendered on click. To create\n    // the impression of a faster UI, open the popup already on 'mousedown', not\n    // on 'click'. All other actions are handled on 'click'.\n    if (event.type === 'mousedown' && this._doActionTogglesPopup()) {\n      this.doAction();\n    } else if ((event.type === 'click' || event.type === 'contextmenu') && !this._doActionTogglesPopup()) {\n      this.doAction();\n    }\n  }\n\n  /**\n   * May be overridden if the criteria to open a popup differs\n   */\n  _doActionTogglesPopup() {\n    return this.childActions.length > 0;\n  }\n\n  _renderChildActions() {\n    // Child action in a sub menu cannot be replaced dynamically, popup has to be closed first.\n    if (!this.rendering) {\n      this._renderSubMenuIcon();\n    }\n  }\n\n  setSubMenuVisibility(subMenuVisibility) {\n    this.setProperty('subMenuVisibility', subMenuVisibility);\n  }\n\n  _renderSubMenuVisibility() {\n    this._renderSubMenuIcon();\n  }\n\n  _renderSubMenuIcon() {\n    let visible = false;\n\n    // calculate visibility of sub-menu icon\n    if (this.childActions.length > 0) {\n      switch (this.subMenuVisibility) {\n        case Menu.SubMenuVisibility.DEFAULT:\n          visible = this._hasText();\n          break;\n        case Menu.SubMenuVisibility.TEXT_OR_ICON:\n          visible = this._hasText() || this.iconId;\n          break;\n        case Menu.SubMenuVisibility.ALWAYS:\n          visible = true;\n          break;\n        case Menu.SubMenuVisibility.NEVER:\n          visible = false;\n          break;\n      }\n    }\n\n    if (visible) {\n      if (!this.$submenuIcon) {\n        let icon = icons.parseIconId(Menu.SUBMENU_ICON);\n        this.$submenuIcon = this.$container\n          .appendSpan('submenu-icon')\n          .text(icon.iconCharacter);\n        this.invalidateLayoutTree();\n      }\n    } else {\n      if (this.$submenuIcon) {\n        this.$submenuIcon.remove();\n        this.$submenuIcon = null;\n        this.invalidateLayoutTree();\n      }\n    }\n    if (!this.rendering) {\n      this._renderTextPosition();\n      this._updateIconAndTextStyle();\n    }\n  }\n\n  _renderText() {\n    super._renderText();\n    this.$container.toggleClass('has-text', strings.hasText(this.text) && this.textVisible);\n    if (!this.rendering) {\n      this._renderSubMenuIcon();\n    }\n    this.invalidateLayoutTree();\n  }\n\n  _renderTextPosition() {\n    super._renderTextPosition();\n    let $parent = this.$container;\n    if (this.textPosition === Action.TextPosition.BOTTOM && this.$text && this.iconId) {\n      // Move submenu icon into text\n      $parent = this.$text;\n    }\n    if (this.$submenuIcon) {\n      // Always append to make sure submenu-icon is the last element in the DOM\n      this.$submenuIcon.appendTo($parent);\n    }\n  }\n\n  _renderIconId() {\n    super._renderIconId();\n    this.$container.toggleClass('has-icon', !!this.iconId);\n    if (!this.rendering) {\n      this._renderSubMenuIcon();\n    }\n    this.invalidateLayoutTree();\n  }\n\n  isTabTarget() {\n    return this.enabledComputed && this.visible && !this.overflown && (this.isButton() || !this.separator)\n      && (!this.parentMenu || this.parentMenu.visible && !this.parentMenu.overflown); // Necessary for ComboMenu -> must return false if ComboMenu (parentMenu) is not shown\n  }\n\n  /**\n   * @override Widget.js\n   */\n  recomputeEnabled(parentEnabled) {\n    if (parentEnabled === undefined) {\n      parentEnabled = this._getInheritedAccessibility();\n    }\n\n    let enabledComputed;\n    let enabledStateForChildren;\n    if (this.enabled && this.inheritAccessibility && !parentEnabled && this.childActions.length > 0) {\n      // the enabledComputed state here depends on the child actions:\n      // - if there are childActions which have inheritAccessibility=false (recursively): this action must be enabledComputed=true so that these children can be reached\n      // - otherwise this menu is set to enabledComputed=false\n      enabledComputed = this._hasAccessibleChildMenu();\n      if (enabledComputed) {\n        // this composite menu is only active because it has children with inheritAccessibility=true\n        // but child-menus should consider the container parent instead, otherwise all children would be enabled (because this composite menu is enabled now)\n        enabledStateForChildren = parentEnabled;\n      } else {\n        enabledStateForChildren = false;\n      }\n    } else {\n      enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n      enabledStateForChildren = enabledComputed;\n    }\n\n    this._updateEnabledComputed(enabledComputed, enabledStateForChildren);\n  }\n\n  /**\n   * Calculates the inherited enabled state of this menu. This is the enabled state of the next relevant parent.\n   * A relevant parent is either\n   * - the next parent menu with inheritAccessibility=false\n   * - or the container of the menu (the parent of the root menu)\n   *\n   * The enabled state of the container must be used because the parent menu might be a menu which is only enabled because it has children with inheritAccessibility=false.\n   * One exception: if a parent menu itself is inheritAccessibility=false. Then the container is not relevant anymore but this parent is taken instead.\n   */\n  _getInheritedAccessibility() {\n    let menu = this;\n    let rootMenu = menu;\n    while (menu) {\n      if (!menu.inheritAccessibility) {\n        // not inherited. no need to check any more parent widgets\n        return menu.enabled; /* do not use enabledComputed here because the parents have no effect */\n      }\n      rootMenu = menu;\n      menu = menu.parentMenu;\n    }\n\n    let container = rootMenu.parent;\n    if (container && container.initialized && container.enabledComputed !== undefined) {\n      return container.enabledComputed;\n    }\n    return true;\n  }\n\n  _findRootMenu() {\n    let menu = this;\n    let result;\n    while (menu) {\n      result = menu;\n      menu = menu.parentMenu;\n    }\n    return result;\n  }\n\n  _hasAccessibleChildMenu() {\n    let childFound = false;\n    this.visitChildMenus(child => {\n      if (!child.inheritAccessibility && child.enabled /* do not use enabledComputed here */ && child.visible) {\n        childFound = true;\n        return TreeVisitResult.TERMINATE;\n      }\n      return TreeVisitResult.CONTINUE;\n    });\n    return childFound;\n  }\n\n  /**\n   * cannot use Widget#visitChildren() here because the child actions are not always part of the children collection\n   * e.g. for ellipsis menus which declare childActions as 'PreserveOnPropertyChangeProperties'. this means the childActions are not automatically added to the children list even it is a widget property!\n   */\n  visitChildMenus(visitor) {\n    for (let i = 0; i < this.childActions.length; i++) {\n      let child = this.childActions[i];\n      if (child instanceof Menu) {\n        let treeVisitResult = visitor(child);\n        if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n          // Visitor wants to abort the visiting\n          return TreeVisitResult.TERMINATE;\n        } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n          treeVisitResult = child.visitChildMenus(visitor);\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            return TreeVisitResult.TERMINATE;\n          }\n        }\n      }\n    }\n  }\n\n  _hasText() {\n    return strings.hasText(this.text) && this.textVisible;\n  }\n\n  _updateIconAndTextStyle() {\n    let hasText = this._hasText();\n    let hasTextAndIcon = !!(hasText && this.iconId);\n    let hasIcon = !!this.iconId;\n    let hasSubMenuIcon = !!this.$submenuIcon;\n    let hasOneIcon = (hasIcon && !hasSubMenuIcon) || (!hasIcon && hasSubMenuIcon);\n    this.$container.toggleClass('menu-textandicon', hasTextAndIcon);\n    this.$container.toggleClass('menu-icononly', !hasText && hasOneIcon);\n  }\n\n  _closePopup() {\n    if (this.popup && !this.popup.isRemovalPending()) {\n      this.popup.close();\n    }\n  }\n\n  _canOpenPopup() {\n    if (this.popup && this.popup.isRemovalPending()) {\n      // If the popup should be opened while it is being removed, the popup needs to be removed immediately before it can be opened (the remove animation won't complete).\n      // This is necessary to always have a consistent state between menu and popup (e.g. if menu is selected while the popup is removed).\n      // The popup will be null afterwards (due to the destroy handler added by openPopup)\n      this.popup.removeImmediately();\n    }\n\n    if (this.popup) {\n      // already open\n      return false;\n    }\n\n    // Recheck if opening is still possible (maybe destroying the popup changed that, e.g. form of form menu was set to null)\n    if (!this._doActionTogglesPopup()) {\n      return false;\n    }\n    return true;\n  }\n\n  _openPopup() {\n    if (!this._canOpenPopup()) {\n      return;\n    }\n    this.popup = this._createPopup();\n    this.popup.open();\n    this.popup.one('destroy', event => {\n      this.popup = null;\n    });\n    // Unselect on close which comes earlier than destroy (before the animation), to give more immediate feedback\n    this.popup.on('close', event => {\n      this.setSelected(false);\n    });\n\n    if (this.uiCssClass) {\n      this.popup.$container.addClass(this.uiCssClass);\n    }\n  }\n\n  _createPopup(event) {\n    let options = {\n      parent: this,\n      menu: this,\n      menuFilter: this.menuFilter,\n      horizontalAlignment: this.popupHorizontalAlignment,\n      verticalAlignment: this.popupVerticalAlignment\n    };\n\n    return scout.create('MenuBarPopup', options);\n  }\n\n  _createActionKeyStroke() {\n    return new MenuKeyStroke(this);\n  }\n\n  isToggleAction() {\n    return this.childActions.length > 0 || this.toggleAction;\n  }\n\n  isButton() {\n    return Action.ActionStyle.BUTTON === this.actionStyle;\n  }\n\n  /**\n   * @deprecated use insertChildActions instead\n   * @param childActions\n   */\n  addChildActions(childActions) {\n    this.insertChildActions(childActions);\n  }\n\n  insertChildAction(actionsToInsert) {\n    this.insertChildActions([actionsToInsert]);\n  }\n\n  insertChildActions(actionsToInsert) {\n    actionsToInsert = arrays.ensure(actionsToInsert);\n    if (actionsToInsert.length === 0) {\n      return;\n    }\n    this.setChildActions(this.childActions.concat(actionsToInsert));\n  }\n\n  deleteChildAction(actionToDelete) {\n    this.deleteChildActions([actionToDelete]);\n  }\n\n  deleteChildActions(actionsToDelete) {\n    actionsToDelete = arrays.ensure(actionsToDelete);\n    if (actionsToDelete.length === 0) {\n      return;\n    }\n    let actions = this.childActions.slice();\n    arrays.removeAll(actions, actionsToDelete);\n    this.setChildActions(actions);\n  }\n\n  setChildActions(childActions) {\n    this.setProperty('childActions', childActions);\n  }\n\n  _setChildActions(childActions) {\n    // disconnect existing\n    this.childActions.forEach(childAction => {\n      childAction.parentMenu = null;\n    });\n\n    this._setProperty('childActions', childActions);\n\n    // connect new actions\n    this.childActions.forEach(childAction => {\n      childAction.parentMenu = this;\n    });\n\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _setInheritAccessibility(inheritAccessibility) {\n    let changed = this._setProperty('inheritAccessibility', inheritAccessibility);\n    if (changed) {\n      this._recomputeEnabledInMenuHierarchy();\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _setEnabled(enabled) {\n    let changed = this._setProperty('enabled', enabled);\n    if (changed) {\n      this._recomputeEnabledInMenuHierarchy();\n    }\n  }\n\n  _setVisible(visible) {\n    let changed = this._setProperty('visible', visible);\n    if (changed) {\n      this._recomputeEnabledInMenuHierarchy();\n    }\n  }\n\n  _recomputeEnabledInMenuHierarchy() {\n    if (!this.initialized) {\n      return;\n    }\n    let rootMenu = this._findRootMenu();\n    rootMenu.recomputeEnabled();\n    if (rootMenu !== this) {\n      // necessary in case this menu or a parent menu has inheritAccessibility=false. Because then this menu and its children are skipped in the line above!\n      this.recomputeEnabled();\n    }\n  }\n\n  setSelected(selected) {\n    if (selected === this.selected) {\n      return;\n    }\n    super.setSelected(selected);\n    if (!this._doActionTogglesSubMenu() && !this._doActionTogglesPopup()) {\n      return;\n    }\n    // If menu toggles a popup and is in an ellipsis menu which is not selected it needs a special treatment\n    if (this.overflowMenu && !this.overflowMenu.selected) {\n      this._handleSelectedInEllipsis();\n    }\n  }\n\n  _handleSelectedInEllipsis() {\n    // If the selection toggles a popup, open the ellipsis menu as well, otherwise the popup would not be shown\n    if (this.selected) {\n      this.overflowMenu.setSelected(true);\n    }\n  }\n\n  setStackable(stackable) {\n    this.setProperty('stackable', stackable);\n  }\n\n  _renderStackable() {\n    this.invalidateLayoutTree();\n  }\n\n  setShrinkable(shrinkable) {\n    this.setProperty('shrinkable', shrinkable);\n  }\n\n  _renderShrinkable() {\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * For internal usage only.\n   * Used by the MenuBarLayout when a menu is moved to the ellipsis drop down.\n   */\n  _setOverflown(overflown) {\n    if (this.overflown === overflown) {\n      return;\n    }\n    this._setProperty('overflown', overflown);\n    if (this.rendered) {\n      this._renderOverflown();\n    }\n  }\n\n  _renderOverflown() {\n    this.$container.toggleClass('overflown', this.overflown);\n    this._renderActionStyle();\n  }\n\n  setMenuStyle(menuStyle) {\n    this.setProperty('menuStyle', menuStyle);\n  }\n\n  _renderMenuStyle() {\n    this.$container.toggleClass('default', this.menuStyle === Menu.MenuStyle.DEFAULT);\n  }\n\n  setDefaultMenu(defaultMenu) {\n    this.setProperty('defaultMenu', defaultMenu);\n  }\n\n  setMenuFilter(menuFilter) {\n    this.setProperty('menuFilter', menuFilter);\n    this.childActions.forEach(child => {\n      child.setMenuFilter(menuFilter);\n    });\n  }\n\n  clone(model, options) {\n    let clone = super.clone(model, options);\n    this._deepCloneProperties(clone, 'childActions', options);\n    clone._setChildActions(clone.childActions);\n    return clone;\n  }\n\n  /**\n   * @override\n   */\n  focus() {\n    let event = new Event({source: this});\n    this.trigger('focus', event);\n    if (!event.defaultPrevented) {\n      return super.focus();\n    }\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}