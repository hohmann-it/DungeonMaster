{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, fields, FormField, InputFieldKeyStrokeContext, keys, LookupCall, objects, QueryBy, scout, SimpleLoadingSupport, SmartFieldCancelKeyStroke, SmartFieldLayout, Status, strings, ValueField } from '../../../index';\nimport $ from 'jquery';\nexport default class SmartField extends ValueField {\n  constructor() {\n    super();\n    this.popup = null;\n    this.lookupCall = null;\n    this.codeType = null;\n    this._pendingLookup = null;\n    this._pendingOpenPopup = false;\n    this._tabPrevented = null;\n    this.lookupRow = null;\n    this.browseHierarchy = false;\n    this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT; // a positive number, _not_ null or undefined!\n    this.browseAutoExpandAll = true;\n    this.browseLoadIncremental = false;\n    this.searchRequired = false;\n    this.activeFilterEnabled = false;\n    this.activeFilter = null;\n    this.activeFilterLabels = [];\n    this.columnDescriptors = null;\n    this.displayStyle = SmartField.DisplayStyle.DEFAULT;\n    this.touchMode = false;\n    this.embedded = false;\n    this._userWasTyping = false; // used to detect whether the last thing the user did was typing (a proposal) or something else, like selecting a proposal row\n    this._acceptInputEnabled = true; // used to prevent multiple execution of blur/acceptInput\n    this._acceptInputDeferred = $.Deferred();\n    this._notUnique = false; // used to store the error state 'not unique' which must not be showed while typing, but when the field loses focus\n    this._lastSearchText = null;\n    this.lookupStatus = null;\n    this._currentLookupCall = null; // should only be accessed on the original widget since the adapter accesses it\n    this.lookupSeqNo = 0; // used to detect if the proposal chooser contains the results of the latest lookup, or an out-dated result.\n    // only when the result is up-to-date, we can use the selected lookup row\n    this.initActiveFilter = null;\n    this.disabledCopyOverlay = true;\n    this.maxLength = 500;\n    this.maxLengthHandler = scout.create('MaxLengthHandler', {\n      target: this\n    });\n    this._addCloneProperties(['lookupRow', 'codeType', 'lookupCall', 'activeFilter', 'activeFilterEnabled', 'activeFilterLabels', 'browseHierarchy', 'browseMaxRowCount', 'browseAutoExpandAll', 'browseLoadIncremental', 'searchRequired', 'columnDescriptors', 'displayStyle']);\n  }\n  _init(model) {\n    super._init(model);\n    if (this.activeFilterLabels.length === 0) {\n      this.activeFilterLabels = [this.session.text('ui.All'), this.session.text('ui.Inactive'), this.session.text('ui.Active')];\n    }\n    fields.initTouch(this, model);\n  }\n\n  /**\n   * Initializes lookup call and code type before calling set value.\n   * This cannot be done in _init because the value field would call _setValue first\n   */\n  _initValue(value) {\n    this._setLookupCall(this.lookupCall);\n    this._setCodeType(this.codeType);\n    this._setLookupRow(this.lookupRow);\n    super._initValue(value);\n  }\n  markAsSaved() {\n    super.markAsSaved();\n    this.setInitActiveFilter(this.activeFilter);\n  }\n  resetValue() {\n    super.resetValue();\n    this.setActiveFilter(this.initActiveFilter);\n  }\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke(new SmartFieldCancelKeyStroke(this));\n  }\n  _render() {\n    this.addContainer(this.$parent, 'has-icon ' + this.cssClassName(), new SmartFieldLayout(this));\n    this.addLabel();\n    let fieldFunc = this.isDropdown() ? fields.makeInputDiv : fields.makeInputOrDiv;\n    let $field = fieldFunc.call(scout.fields, this).on('mousedown', this._onFieldMouseDown.bind(this));\n    if (!this.touchMode) {\n      $field.keyup(this._onFieldKeyUp.bind(this)).keydown(this._onFieldKeyDown.bind(this)).on('input', this._onFieldInput.bind(this));\n    }\n    this.addField($field);\n    this.maxLengthHandler.install($field);\n    if (!this.embedded) {\n      this.addMandatoryIndicator();\n    }\n    this.addIcon();\n    this.addStatus();\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderMaxLength();\n  }\n  _renderGridData() {\n    super._renderGridData();\n    this.updateInnerAlignment({\n      useHorizontalAlignment: !this.browseHierarchy\n    });\n  }\n  _renderGridDataHints() {\n    super._renderGridDataHints();\n    this.updateInnerAlignment({\n      useHorizontalAlignment: !this.browseHierarchy\n    });\n  }\n  cssClassName() {\n    let prefix = this.displayStyle;\n    if (this.displayStyle === SmartField.DisplayStyle.DEFAULT) {\n      prefix = 'smart';\n    }\n    return prefix + '-field';\n  }\n  _readSearchText() {\n    let fieldText = this._readDisplayText(),\n      displayText = scout.nvl(this.displayText, ''),\n      textLines = displayText.split('\\n');\n    if (textLines.length === 1 || strings.empty(fieldText)) {\n      return fieldText;\n    }\n    textLines.shift(); // remove first line\n    arrays.insert(textLines, fieldText, 0);\n    return strings.join('\\n', textLines);\n  }\n  _readDisplayText() {\n    return fields.valOrText(this.$field);\n  }\n  _renderDisplayText() {\n    let displayText = this._prepareDisplayText();\n    fields.valOrText(this.$field, displayText);\n    super._renderDisplayText();\n  }\n  _prepareDisplayText() {\n    let displayText = scout.nvl(this.displayText, ''),\n      textLines = displayText.split('\\n');\n    if (textLines.length) {\n      displayText = textLines[0];\n    }\n    return displayText;\n  }\n\n  /**\n   * Accepts the selected lookup row and sets its id as value.\n   * This function is called on blur, by a keystroke or programmatically at any time.\n   *\n   * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n   */\n  acceptInput(sync) {\n    if (!this._acceptInputEnabled) {\n      $.log.isTraceEnabled() && $.log.trace('(SmartField#acceptInput) Skipped acceptInput because _acceptInputEnabled=false');\n      return this._acceptInputDeferred.promise();\n    }\n\n    // Use a timeout to prevent multiple execution within the same user action\n    this._acceptInputEnabled = false;\n    setTimeout(() => {\n      this._acceptInputEnabled = true;\n    });\n    let searchText = this._readSearchText(),\n      searchTextEmpty = strings.empty(searchText),\n      searchTextChanged = this._checkSearchTextChanged(searchText),\n      selectedLookupRow = this._getSelectedLookupRow(searchTextChanged);\n    this._setProperty('displayText', searchText);\n    this._acceptInputDeferred = $.Deferred();\n    this._flushLookupStatus();\n    this._clearPendingLookup();\n    if (this.touchMode) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#acceptInput) Always send acceptInput for touch field');\n      this._inputAccepted();\n      return;\n    }\n    return this._acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow);\n  }\n\n  /**\n   * This function is used to determine if the currently selected lookup row can be\n   * used when acceptInput is called. Basically we don't want to use the row in case\n   * the result is out-dated.\n   */\n  _getSelectedLookupRow(searchTextChanged) {\n    // don't use selected lookup row if...\n    if (!this.isPopupOpen() ||\n    // 1. popup has been closed\n    searchTextChanged && this._userWasTyping) {\n      // 2. search text has changed and user was typing\n      return null;\n    }\n    // 3. if the result row is from an out-dated result\n    return this.lookupSeqNo === this.popup.lookupResult.seqNo ? this.popup.getSelectedLookupRow() : null;\n  }\n  _checkSearchTextChanged(searchText) {\n    if (this.isDropdown() || !this._userWasTyping) {\n      return false; // search text cannot change in drop-down fields\n    }\n\n    // check if search text has changed since the last search, when it has changed\n    // we cannot use the currently selected lookup row, because these proposals are\n    // out-dated.\n    return !this._searchTextEquals(searchText, this._lastSearchText);\n  }\n  _searchTextEquals(searchText, lastSearchText) {\n    let a = strings.nullIfEmpty(this._firstTextLine(searchText));\n    let b = strings.nullIfEmpty(lastSearchText);\n    return strings.equalsIgnoreCase(a, b);\n  }\n  _clearPendingLookup() {\n    if (this._pendingLookup) {\n      clearTimeout(this._pendingLookup);\n      this._pendingLookup = null;\n    }\n  }\n\n  /**\n   * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n   *\n   * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n   */\n  _acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow) {\n    let unchanged = false;\n    if (this.removing) {\n      // Rare case: _acceptInput may be called when the field is being removed. In that case\n      // we do nothing and leave the lookupRow unchanged.\n      unchanged = true;\n    } else if (!selectedLookupRow && this.lookupRow) {\n      // Do nothing when search text is equals to the text of the current lookup row\n      let lookupRowText = strings.nvl(this.lookupRow.text);\n      unchanged = lookupRowText === searchText;\n    }\n    if (unchanged) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: widget is removing or searchText is equals. Close popup');\n      this._clearLookupStatus();\n      this._inputAccepted(false);\n      return;\n    }\n\n    // Don't show the not-unique error when the search-text becomes empty while typing (see ticket #229775)\n    if (this._notUnique && !searchTextEmpty) {\n      this._setNotUniqueError(searchText);\n    }\n\n    // Do nothing when we don't have a current lookup row and search text is empty\n    // trigger event when search text has changed. This is required for the case where\n    // a field is cleared, and the remote model must be updated (value=null)\n    if (!selectedLookupRow && !this.lookupRow && searchTextEmpty) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: text is empty. Close popup');\n      this._clearLookupStatus();\n      if (this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n        // clear the error status from previous search which did not find any results. This error status is no longer valid as we accept the null content here.\n        this.clearErrorStatus();\n      }\n      this._inputAccepted(searchTextChanged || this._userWasTyping);\n      return;\n    }\n\n    // 1.) when search text is empty and no lookup-row is selected, simply set the value to null\n    // Note: here we assume that a current lookup row is set.\n    if (!selectedLookupRow && searchTextEmpty) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) empty. Set lookup-row to null, close popup');\n      this._clearLookupStatus();\n      this.setLookupRow(null);\n      this._inputAccepted();\n      return;\n    }\n\n    // 2.) proposal chooser is open -> use the selected row as value\n    if (selectedLookupRow) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) lookup-row selected. Set lookup-row, close popup lookupRow=', selectedLookupRow.toString());\n      this._clearLookupStatus();\n      this.setLookupRow(selectedLookupRow);\n      this._inputAccepted();\n      return;\n    }\n\n    // 3.) proposal chooser is not open -> try to accept the current display text\n    // this causes a lookup which may fail and open a new proposal chooser (property\n    // change for 'result').\n    if (searchTextChanged || this._userWasTyping) {\n      this._acceptByText(sync, this._firstTextLine(searchText));\n    } else if (!this._hasUiError()) {\n      this._inputAccepted(false);\n    } else if (this._hasNotUniqueError() && this.popup) {\n      // popup has been opened (again) with errorStatus NOT_UNIQUE, and search text is still the same\n      this.popup.selectFirstLookupRow();\n    } else {\n      // even though there's nothing to do, someone could wait for our promise to be resolved\n      this._acceptInputDeferred.resolve();\n    }\n    return this._acceptInputDeferred.promise();\n  }\n\n  /**\n   * Required for multiline smart-field. Only use first line of search text for accept by text.\n   * Note: for the regular lookup by text, we use the readDisplayText() function which always\n   * returns a single line. But in acceptInput we need the full search text (=display text + additional\n   * lines) in order to check whether or not the display text has changed, compared to the current\n   * lookup row. That's why we must extract the first line here.\n   */\n  _firstTextLine(text) {\n    if (strings.empty(text)) {\n      return text;\n    }\n    return text.split('\\n')[0];\n  }\n\n  /**\n   * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n   *\n   * @param sync when set to true it's not allowed to start an asynchronous lookup to search by text, the\n   *     current search text is discarded. The flag is set to true in case we click on another field, where\n   *     we must make sure the order of (browser) events is not changed by the lookup that would return _after_\n   *     the events for the clicked field are handled.\n   */\n  _acceptByText(sync, searchText) {\n    sync = scout.nvl(sync, false);\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptByText) sync=' + sync + ' searchText=', searchText);\n    if (sync) {\n      this._acceptByTextSync(searchText);\n    } else {\n      this._acceptByTextAsync(searchText);\n    }\n  }\n  _acceptByTextSync(searchText) {\n    this._lastSearchText = null;\n    this._inputAccepted();\n    if (!this._hasUiError()) {\n      this.resetDisplayText();\n    }\n  }\n  _acceptByTextAsync(searchText) {\n    this._lastSearchText = searchText;\n    this._executeLookup(this.lookupCall.cloneForText(searchText), true).done(this._acceptByTextDone.bind(this)).done(this._triggerLookupCallDone.bind(this));\n    this._triggerAcceptByText(searchText);\n  }\n  _inputAccepted(triggerEvent, acceptByLookupRow) {\n    triggerEvent = scout.nvl(triggerEvent, true);\n    acceptByLookupRow = scout.nvl(acceptByLookupRow, true);\n    // don't close when shown in touch popup (also called when clear() is executed)\n    if (!this.embedded) {\n      this.closePopup();\n    }\n    this._userWasTyping = false;\n    if (triggerEvent) {\n      this._triggerAcceptInput(acceptByLookupRow);\n    }\n    this._focusNextTabbable();\n    this._acceptInputDeferred.resolve();\n  }\n  _focusNextTabbable() {\n    if (this._tabPrevented) {\n      let $tabElements = this.entryPoint().find(':tabbable'),\n        direction = this._tabPrevented.shiftKey ? -1 : 1,\n        fieldIndex = $tabElements.index(this.$field),\n        nextIndex = fieldIndex + direction;\n      if (nextIndex < 0) {\n        nextIndex = $tabElements.length - 1;\n      } else if (nextIndex >= $tabElements.length) {\n        nextIndex = 0;\n      }\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_inputAccepted) tab-index=' + fieldIndex + ' next tab-index=' + nextIndex);\n      let $nextElement = $tabElements.eq(nextIndex).focus();\n      if (objects.isFunction($nextElement[0].select)) {\n        $nextElement[0].select();\n      }\n      // This is normally done by FocusManager, but since propagation is stopped, we need to do it here as well\n      $nextElement.addClass('keyboard-navigation');\n      this._tabPrevented = null;\n    }\n  }\n  _acceptByTextDone(result) {\n    this._userWasTyping = false;\n    this._extendResult(result);\n    this._notUnique = result.numLookupRows > 1;\n\n    // when there's exactly one result, we accept that lookup row\n    if (result.uniqueMatch) {\n      let lookupRow = result.uniqueMatch;\n      if (this._isLookupRowActive(lookupRow)) {\n        this.setLookupRow(lookupRow);\n        this._inputAccepted();\n      } else {\n        this.setErrorStatus(Status.error({\n          message: this.session.text('SmartFieldInactiveRow', result.text)\n        }));\n      }\n      return;\n    }\n    this._acceptInputFail(result);\n  }\n\n  /**\n   * Extends the properties 'uniqueMatch' and 'numLookupRows' on the given result object.\n   * The implementation is different depending on the browseHierarchy property.\n   */\n  _extendResult(result) {\n    result.seqNo = this.lookupSeqNo;\n    result.uniqueMatch = null;\n\n    // Set query type on result, e.g. 'byAll'\n    let propertyName = 'by' + strings.toUpperCaseFirstLetter(result.queryBy.toLowerCase());\n    result[propertyName] = true;\n    if (this.browseHierarchy) {\n      // tree (hierarchical)\n      let proposalChooser = scout.create('TreeProposalChooser', {\n        parent: this,\n        smartField: this\n      });\n      proposalChooser.setLookupResult(result);\n      let leafs = proposalChooser.findLeafs();\n      result.numLookupRows = leafs.length;\n      if (result.numLookupRows === 1) {\n        result.uniqueMatch = leafs[0].lookupRow;\n      }\n    } else {\n      // table\n      result.numLookupRows = result.lookupRows.length;\n      if (result.numLookupRows === 1) {\n        result.uniqueMatch = result.lookupRows[0];\n      }\n    }\n    result.empty = result.numLookupRows === 0;\n  }\n  _acceptInputFail(result) {\n    let searchText = result.text;\n\n    // in any other case something went wrong\n    if (result.empty) {\n      if (!this.embedded) {\n        this.closePopup();\n      }\n      this.setValue(null);\n      this.setDisplayText(searchText);\n      this.setErrorStatus(Status.error({\n        message: this.session.text('SmartFieldCannotComplete', searchText),\n        code: SmartField.ErrorCode.NO_RESULTS\n      }));\n    }\n    if (result.numLookupRows > 1) {\n      this.setValue(null);\n      this.setDisplayText(searchText);\n      this._setNotUniqueError(searchText);\n      if (this.isPopupOpen()) {\n        this.popup.setLookupResult(result);\n      } else {\n        this._lookupByTextOrAllDone(result);\n      }\n      // check again if popup is open yet (might have been opened by _lookupByTextOrAllDone)\n      if (this.isPopupOpen()) {\n        this.popup.selectFirstLookupRow();\n      }\n    }\n    this._acceptInputDeferred.resolve();\n    this._triggerAcceptInputFail();\n  }\n  lookupByRec(rec) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#lookupByRec) rec=', rec);\n    this._lastSearchText = null;\n    return this._executeLookup(this.lookupCall.cloneForRec(rec)).then(result => {\n      // Since this function is only used for hierarchical trees we\n      // can simply set the appendResult flag always to true here\n      result.appendResult = true;\n      result.rec = rec;\n      if (this.isPopupOpen()) {\n        this.popup.setLookupResult(result);\n      }\n    }).then(this._triggerLookupCallDone.bind(this));\n  }\n\n  /**\n   * Validates the given lookup row is enabled and matches the current activeFilter settings.\n   *\n   * @returns {boolean}\n   */\n  _isLookupRowActive(lookupRow) {\n    if (!lookupRow.enabled) {\n      return false;\n    }\n    if (!this.activeFilterEnabled) {\n      return true;\n    }\n    if (this.activeFilter === 'TRUE') {\n      return lookupRow.active;\n    }\n    if (this.activeFilter === 'FALSE') {\n      return !lookupRow.active;\n    }\n    return true;\n  }\n  _renderEnabled() {\n    super._renderEnabled();\n    this.$field.setTabbable(this.enabledComputed);\n  }\n  setMaxLength(maxLength) {\n    this.setProperty('maxLength', maxLength);\n  }\n  _renderMaxLength() {\n    this.maxLengthHandler.render();\n  }\n  setLookupCall(lookupCall) {\n    this.setProperty('lookupCall', lookupCall);\n  }\n  _setLookupCall(lookupCall) {\n    this._setProperty('lookupCall', LookupCall.ensure(lookupCall, this.session));\n    this._syncBrowseMaxRowCountWithLookupCall();\n  }\n  _setCodeType(codeType) {\n    this._setProperty('codeType', codeType);\n    if (!codeType) {\n      return;\n    }\n    let lookupCall = scout.create('CodeLookupCall', {\n      session: this.session,\n      codeType: codeType\n    });\n    this.setProperty('lookupCall', lookupCall);\n  }\n  _formatValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return '';\n    }\n\n    // we already have a lookup row - Note: in Scout Classic (remote case)\n    // we always end here and don't need to perform a getByKey lookup.\n    if (this.lookupRow) {\n      return this._formatLookupRow(this.lookupRow);\n    }\n\n    // we must do a lookup first to get the display text\n    // Note: this has a side-effect as it sets the property lookupRow on the smart field\n    this._lastSearchText = null;\n    return this._executeLookup(this.lookupCall.cloneForKey(value), true).then(this._lookupByKeyDone.bind(this)).then(this._triggerLookupCallDone.bind(this));\n  }\n  _lookupByKeyDone(result) {\n    this._notUnique = false;\n    let lookupRow = LookupCall.firstLookupRow(result);\n    this.setLookupRow(lookupRow);\n    return this._formatLookupRow(lookupRow);\n  }\n\n  /**\n   * This function is called when we need to format a display text from a given lookup\n   * row. By default the property 'text' is used for that purpose. Override this function\n   * if you need to format different properties from the lookupRow.\n   */\n  _formatLookupRow(lookupRow) {\n    return lookupRow ? lookupRow.text : '';\n  }\n\n  /**\n   * @param {boolean} [browse] whether or not the lookup call should execute getAll() or getByText() with the current display text.\n   *     if browse is undefined, browse is set to true automatically if search text is empty\n   * @returns {Promise}\n   */\n  openPopup(browse) {\n    // In case searchRequired is set to true, we always start a new search with the text from the field as query\n    let searchText = this._readDisplayText(),\n      searchAlways = this.searchRequired ? true : null;\n    $.log.isInfoEnabled() && $.log.info('SmartField#openPopup browse=' + browse + ' searchText=' + searchText + ' popup=' + this.popup + ' pendingOpenPopup=' + this._pendingOpenPopup);\n\n    // Reset scheduled focus next tabbable when user clicks on the smartfield while a lookup is resolved.\n    this._tabPrevented = null;\n    this._pendingOpenPopup = true;\n    if (strings.empty(searchText)) {\n      // if search text is empty - always do 'browse', no matter what the error code is\n      browse = true;\n    } else if (this.errorStatus) {\n      // In case the search yields a not-unique error, we always want to start a lookup\n      // with the current display text in every other case we better do browse again\n      if (this._hasNotUniqueError()) {\n        searchAlways = true;\n        browse = false;\n      } else if (!this.searchRequired) {\n        browse = true;\n      }\n    }\n    return this._lookupByTextOrAll(browse, searchText, searchAlways);\n  }\n  _hasUiError(codes) {\n    let status = this._errorStatus();\n    if (!status) {\n      return false;\n    }\n    if (codes) {\n      codes = arrays.ensure(codes);\n    } else {\n      codes = [SmartField.ErrorCode.NO_RESULTS, SmartField.ErrorCode.NOT_UNIQUE];\n    }\n\n    // collect codes from the status hierarchy\n    let statusList = Status.asFlatList(status);\n    let foundCodes = statusList.reduce((list, status) => {\n      if (status.code && list.indexOf(status.code) === -1) {\n        list.push(status.code);\n      }\n      return list;\n    }, []);\n\n    // if one of the requested codes exist in the list of found codes\n    return codes.some(code => {\n      return foundCodes.indexOf(code) > -1;\n    });\n  }\n\n  /**\n   * @param browse [boolean] optional, whether to perform a lookupByAll (=browse) or a lookupByText.\n   *        By default the param is set to <code>true</code> if the search-text is not empty\n   * @param searchText [String] optional, when not set the search-text from the smart-field is used\n   * @param searchAlways [boolean] optional, only used when browse=false. When set to true the search\n   *        is always performed, event when the search-text has not changed. By default the param is\n   *        set to <code>false</code>.\n   * @returns {Promise}\n   */\n  _lookupByTextOrAll(browse, searchText, searchAlways) {\n    // default values\n    searchText = scout.nvl(searchText, this._readDisplayText());\n    browse = scout.nvl(browse, strings.empty(searchText));\n    searchAlways = scout.nvl(searchAlways, false);\n\n    // never do a text-lookup if field has dropdown style\n    if (this.isDropdown()) {\n      browse = true;\n    }\n\n    // this avoids unnecessary lookup-calls when a keyboard event has triggered\n    // the lookupByTextOrAll function but the search-text has not changed #226643.\n    if (!browse && !searchAlways) {\n      let lastSearchText = null;\n      if (this._lastSearchText) {\n        lastSearchText = this._lastSearchText;\n      } else {\n        lastSearchText = this._getLastSearchText();\n      }\n      if (this._searchTextEquals(searchText, lastSearchText)) {\n        this._pendingOpenPopup = false;\n        $.log.debug('(SmartField#_lookupByTextOrAll) searchText is equals -> skip lookup');\n        return;\n      }\n    }\n    this._clearPendingLookup();\n    let deferred = $.Deferred();\n    let doneHandler = function (result) {\n      this._lookupByTextOrAllDone(result);\n      deferred.resolve(result);\n    }.bind(this);\n\n    // execute lookup byAll immediately\n    if (browse) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byAll (searchText empty)');\n      this._lastSearchText = null;\n      if (this.searchRequired) {\n        doneHandler({\n          queryBy: QueryBy.TEXT,\n          lookupRows: []\n        });\n        this.setLookupStatus(Status.warning({\n          message: this.session.text('TooManyRows'),\n          code: SmartField.ErrorCode.SEARCH_REQUIRED\n        }));\n      } else {\n        this._executeLookup(this.lookupCall.cloneForAll(), true).done(doneHandler).done(this._triggerLookupCallDone.bind(this));\n      }\n    } else {\n      // execute lookup byText with a debounce/delay\n      this._pendingLookup = setTimeout(() => {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byText searchText=' + searchText);\n        this._lastSearchText = searchText;\n        this._executeLookup(this.lookupCall.cloneForText(searchText), true).done(doneHandler).done(this._triggerLookupCallDone.bind(this));\n      }, SmartField.DEBOUNCE_DELAY);\n    }\n    return deferred.promise();\n  }\n\n  /**\n   * Returns the text used to store the 'last search-text'. The implementation differs between SmartField and ProposalField.\n   */\n  _getLastSearchText() {\n    return objects.optProperty(this.lookupRow, 'text');\n  }\n  _lookupByTextOrAllDone(result) {\n    this._extendResult(result);\n    this._notUnique = !result.byAll && result.numLookupRows > 1;\n    if (this._handleException(result)) {\n      return;\n    }\n\n    // In cases where the user has tabbed to the next field, while results for the previous\n    // smart-field are still loading: don't show the proposal popup. In the case of a cell-editor\n    // it's also possible that the smart-field is not rendered anymore when the lookup is done\n    if (!this.rendered || !this.isFocused() && !this.isTouchable()) {\n      this.closePopup();\n      return;\n    }\n\n    // 'No data' case\n    if (result.empty && result.byAll) {\n      // When active filter is enabled we must always show the popup, because the user\n      // must be able to switch the filter properties. Otherwise a user could set the filter\n      // to 'inactive', and receives an empty result for that query, the popup is closed\n      // and the user can not switch the filter back to 'active' again because the filter\n      // control is not visible.\n      if (this.activeFilterEnabled) {\n        this._ensurePopup(result);\n      } else {\n        this.closePopup();\n      }\n      this.setLookupStatus(Status.warning({\n        message: this.session.text('SmartFieldNoDataFound'),\n        code: SmartField.ErrorCode.NO_DATA\n      }));\n      return;\n    }\n    if (result.empty) {\n      this._handleEmptyResult();\n      this.setLookupStatus(Status.warning({\n        message: this.session.text('SmartFieldCannotComplete', result.text),\n        code: SmartField.ErrorCode.NO_RESULTS\n      }));\n      return;\n    }\n    let popupStatus = null;\n    if (result.numLookupRows > this.browseMaxRowCount) {\n      // Info: we limit the lookup rows here, but this is more a last line of defense\n      // limit should be always performed on the server, so we don't have to transfer\n      // unnecessary lookup rows over the slow network. Make sure your Scout lookup call\n      // or REST service impl. respects the max. row count property.\n      result.lookupRows = result.lookupRows.slice(0, this.browseMaxRowCount);\n      popupStatus = Status.info({\n        message: this.session.text('SmartFieldMoreThanXRows', this.browseMaxRowCount)\n      });\n    }\n\n    // Render popup, if not yet rendered and set results\n    this._ensurePopup(result, popupStatus);\n  }\n  _ensurePopup(result, status) {\n    if (this.popup) {\n      this.popup.setLookupResult(result);\n      this.popup.setStatus(status);\n    } else {\n      this._renderPopup(result, status);\n    }\n  }\n  _handleException(result) {\n    // Oops! Something went wrong while the lookup has been processed.\n    if (result.exception) {\n      this.setErrorStatus(Status.error({\n        message: result.exception\n      }));\n      this.closePopup();\n      return true;\n    }\n    return false;\n  }\n  _handleEmptyResult() {\n    if (this.touchMode || this.activeFilterEnabled) {\n      // In mobile mode we always open the popup, event if we don't have a result\n      // Otherwise it would be impossible to enter text in a proposal field with\n      // an empty proposal list. The same goes for activeFilterEnabled state -\n      // a filter can lead to an empty result (for instance when there are no\n      // inactive proposals), and it's hard to switch to another filter value\n      // when the popup does not show up at all.\n      let emptyResult = {\n        lookupRows: []\n      };\n      this._ensurePopup(emptyResult);\n    } else if (this.embedded) {\n      this.popup.clearLookupRows();\n    } else {\n      this.closePopup();\n    }\n  }\n  _renderPopup(result, status) {\n    // On touch devices the field does not get the focus.\n    // But it should look focused when the popup is open.\n    this.$field.addClass('focused');\n    this.$container.addClass('popup-open');\n    let useTouch = this.touchMode && !this.isDropdown();\n    let popupType = useTouch ? 'SmartFieldTouchPopup' : 'SmartFieldPopup';\n    this._pendingOpenPopup = false;\n    this.popup = scout.create(popupType, {\n      parent: this,\n      $anchor: this.$field,\n      boundToAnchor: !useTouch,\n      closeOnAnchorMouseDown: false,\n      field: this,\n      lookupResult: result,\n      status: status\n    });\n    this.popup.open();\n    this.popup.$container.css('--inactive-lookup-row-suffix-text', \"'\".concat(this.session.text('InactiveState'), \"'\"));\n\n    /* This variable is required to route events to the right field:\n     * - in normal mode popup events should be processed by the normal smart-field\n     * - in touch mode, the field flagged with the 'touch' property should process no\n     *   events at all, instead the field flagged with the 'embedded' property should\n     *   process these events.\n     *\n     * (*1) because the lookup is processed by the field flagged with 'touch' we must\n     *      set the activeFilter on that field too, because the java-model on the server\n     *      is stateful. The java field always passes the activeFilter property to the\n     *      lookup call.\n     */\n    let fieldForPopup = useTouch ? this.popup._field : this;\n    this.popup.on('lookupRowSelected', fieldForPopup._onLookupRowSelected.bind(fieldForPopup));\n    this.popup.on('activeFilterSelected', this._onActiveFilterSelected.bind(this)); // intentionally use this instead of fieldForPopup *1\n    this.popup.one('remove', () => {\n      this.popup = null;\n      if (this.rendered) {\n        this.$container.removeClass('popup-open');\n        this.$field.removeClass('focused');\n        this._renderErrorStatus();\n      }\n    });\n  }\n  closePopup() {\n    this._pendingOpenPopup = false;\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n\n  /**\n   * Calls acceptInput if mouse down happens outside of the field or popup\n   * @override\n   */\n  aboutToBlurByMouseDown(target) {\n    if (this.touchMode) {\n      return false;\n    }\n    if (fields.eventOutsideProposalField(this, target)) {\n      this.acceptInput(true);\n    }\n  }\n  _onFieldMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldMouseDown)');\n    this.activate(true);\n  }\n  activate(onField) {\n    if (!this.enabledComputed || !this.rendered) {\n      return;\n    }\n    if (!this.isDropdown() && !fields.handleOnClick(this)) {\n      if (this.popup && this.popup.removalPending) {\n        // If smart field is activated while it is closing (during remove animation), wait for the animation to finish and activate it afterwards\n        this.popup.one('remove', () => {\n          if (this.rendered) {\n            this.activate(onField);\n          }\n        });\n      }\n      return;\n    }\n    // Don't focus on desktop devices when click is on field #217192\n    // Also required for touch case where field is a DIV and not an INPUT field\n    if (!onField || Device.get().supportsOnlyTouch()) {\n      this.$field.focus();\n    }\n    this.togglePopup();\n  }\n  _onIconMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onIconMouseDown)');\n    if (!this.enabledComputed) {\n      return;\n    }\n    event.preventDefault();\n    this.$field.focus();\n    if (!this.embedded) {\n      if (this.isDropdown()) {\n        this.togglePopup();\n      } else if (!this.popup) {\n        this.openPopup(!this.searchRequired);\n      }\n    }\n  }\n  _onClearIconMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onClearIconMouseDown)');\n    if (!this.enabledComputed) {\n      return;\n    }\n    event.preventDefault();\n    this.$field.focus();\n    this.clear();\n  }\n  _clear() {\n    // don't tab next field when user clicks on clear icon (acceptInput is called later)\n    this._tabPrevented = null;\n    // the state of these two flags is important. See #_checkSearchTextChanged\n    this._lastSearchText = this._readDisplayText();\n    this._userWasTyping = true;\n    fields.valOrText(this.$field, '');\n    if (this.touchMode) {\n      // There is actually no \"x\" the user can press in touch mode, but if the developer calls clear() manually, it should work too.\n      // Because accept input works differently in touch mode we need to explicitly set the value to null\n      this.setValue(null);\n    }\n    if (this.isPopupOpen()) {\n      // When cleared, browse by all again, need to do it in setTimeout because sending acceptInput and lookupAll at the same time does not seem to work\n      setTimeout(this._lookupByTextOrAll.bind(this, true));\n    }\n    this._updateHasText();\n  }\n  togglePopup() {\n    $.log.isInfoEnabled() && $.log.info('(SmartField#togglePopup) popupOpen=', this.isPopupOpen());\n    if (this.isPopupOpen()) {\n      this.closePopup();\n    } else {\n      this.openPopup(!this.searchRequired);\n    }\n  }\n  _onFieldBlur(event) {\n    this.setFocused(false);\n    this.setLoading(false);\n    if (this.isTouchable()) {\n      return;\n    }\n    this.acceptInput(false);\n    this.closePopup();\n  }\n\n  /**\n   * @returns {boolean} true if the field is either 'embedded' or in 'touchMode'.\n   */\n  isTouchable() {\n    return this.embedded || this.touchMode;\n  }\n  _onFieldKeyUp(event) {\n    // Escape\n    if (event.which === keys.ESC) {\n      return;\n    }\n\n    // Pop-ups shouldn't open when one of the following keys is pressed\n    let w = event.which;\n    let isPaste = (event.ctrlKey || event.metaKey) && w === keys.V || event.shiftKey && w === keys.INSERT;\n    let isCut = (event.ctrlKey || event.metaKey) && w === keys.X || event.shiftKey && w === keys.DELETE;\n    let isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n    if (!isCutOrPaste && (event.ctrlKey || event.altKey || event.metaKey || w === keys.ENTER || w === keys.TAB || w === keys.SHIFT || w === keys.CTRL || w === keys.ALT || w === keys.HOME || w === keys.END || w === keys.LEFT || w === keys.RIGHT || w === keys.WIN_LEFT || w === keys.WIN_RIGHT || w === keys.SELECT || w === keys.NUM_LOCK || w === keys.CAPS_LOCK || w === keys.SCROLL_LOCK || w === keys.PAUSE || w === keys.PRINT_SCREEN || this._isNavigationKey(event) || this._isFunctionKey(event))) {\n      return;\n    }\n\n    // The typed character is not available until the keyUp event happens\n    // That's why we must deal with that event here (and not in keyDown)\n    // We don't use _displayText() here because we always want the text the\n    // user has typed.\n    this._handleInput();\n  }\n  _handleInput() {\n    if (this._pendingOpenPopup || this.isPopupOpen()) {\n      if (!this.isDropdown()) {\n        this._lookupByTextOrAll();\n      }\n    } else if (!this._pendingOpenPopup) {\n      this.openPopup();\n    }\n  }\n  isPopupOpen() {\n    return !!(this.popup && !this.popup.removalPending);\n  }\n  _onFieldKeyDown(event) {\n    this._updateUserWasTyping(event);\n\n    // We must prevent default focus handling\n    if (event.which === keys.TAB) {\n      if (this.mode === FormField.Mode.DEFAULT) {\n        event.preventDefault(); // prevent browser default TAB behavior\n        event.stopPropagation(); // prevent FocusContext#._onKeyDown\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldKeyDown) set _tabPrevented');\n        this._tabPrevented = {\n          shiftKey: event.shiftKey\n        };\n      }\n      this.acceptInput();\n      return;\n    }\n    if (event.which === keys.ENTER) {\n      this._handleEnterKey(event);\n      return;\n    }\n\n    // For dropdowns, not only navigation keys trigger the popup (see code below).\n    // However, there are still some exceptions that should be ignored:\n    let w = event.which;\n    if (this.isDropdown() && (event.ctrlKey || event.altKey || event.metaKey || w === keys.ESC || w === keys.SHIFT || w === keys.CTRL || w === keys.ALT || w === keys.WIN_LEFT || w === keys.WIN_RIGHT || w === keys.SELECT || w === keys.NUM_LOCK || w === keys.CAPS_LOCK || w === keys.SCROLL_LOCK || w === keys.PAUSE || w === keys.PRINT_SCREEN || this._isFunctionKey(event))) {\n      return;\n    }\n\n    // If field has dropdown style, we open the popup immediately\n    // because we must not wait until text has been typed\n    if (this._isNavigationKey(event) || this.isDropdown()) {\n      if (this.isPopupOpen()) {\n        this.popup.delegateKeyEvent(event);\n      } else if (!this._pendingOpenPopup) {\n        this.openPopup(!this.searchRequired);\n      }\n      event.stopPropagation(); // key has been handled (popup open). do not allow propagation to other listeners because this could remove tooltips\n      event.preventDefault(); // prevent scrolling of container\n    }\n  }\n\n  _onFieldInput() {\n    this._updateHasText();\n    // Handling for undo/redo events which can affect this field, even tough the focus is on another field\n    // we must have the focus, because otherwise acceptInput would be skipped, which could cause the smart-field\n    // to have an invalid displayText which does not reflect the current value. #246765\n    if (!this._userWasTyping) {\n      if (!this.isFocused()) {\n        this.focus();\n      }\n      this._handleInput();\n    }\n  }\n  _updateUserWasTyping(event) {\n    let w = event.which;\n    let isPaste = (event.ctrlKey || event.metaKey) && w === keys.V || event.shiftKey && w === keys.INSERT;\n    let isCut = (event.ctrlKey || event.metaKey) && w === keys.X || event.shiftKey && w === keys.DELETE;\n    let isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n    if (!isCutOrPaste && (event.ctrlKey || event.altKey || event.metaKey || w === keys.ESC || w === keys.TAB || w === keys.SHIFT || w === keys.CTRL || w === keys.ALT || w === keys.HOME || w === keys.END || w === keys.LEFT || w === keys.RIGHT || w === keys.WIN_LEFT || w === keys.WIN_RIGHT || w === keys.SELECT || w === keys.NUM_LOCK || w === keys.CAPS_LOCK || w === keys.SCROLL_LOCK || w === keys.PAUSE || w === keys.PRINT_SCREEN || this._isFunctionKey(event))) {\n      // neutral, don't change flag\n      return;\n    }\n    this._userWasTyping = !(this._isNavigationKey(event) || w === keys.ENTER);\n  }\n  _isNavigationKey(event) {\n    let navigationKeys = [keys.PAGE_UP, keys.PAGE_DOWN, keys.UP, keys.DOWN];\n    if (this.isDropdown()) {\n      navigationKeys.push(keys.HOME);\n      navigationKeys.push(keys.END);\n    }\n    return scout.isOneOf(event.which, navigationKeys);\n  }\n  _handleEnterKey(event) {\n    if (this.isPopupOpen()) {\n      this.popup.selectLookupRow();\n      event.stopPropagation();\n    }\n  }\n  _isFunctionKey(event) {\n    return event.which >= keys.F1 && event.which <= keys.F12;\n  }\n  _onLookupRowSelected(event) {\n    // When a row has been selected in the proposal chooser, cancel all\n    // pending and running lookup-calls. This avoids situations where the\n    // lookup-call returns with results after the user has pressed the\n    // enter key in order to select a result (see ticket #229775).\n    this._clearPendingLookup();\n    let currentLookupCall = this.original()._currentLookupCall;\n    if (currentLookupCall) {\n      currentLookupCall.abort();\n      this.original()._currentLookupCall = null;\n      this.setLoading(false);\n    }\n    this.setLookupRow(event.lookupRow);\n    this._inputAccepted();\n    this.closePopup();\n  }\n\n  /**\n   * When the user changes the active-filter we must always perform a new search. When the user has typed a searchText\n   * we must perform a lookupByText. When the searchText is empty or different from the text of the selected lookup-row\n   * we are in browse mode where we use the default given by the 'searchRequired' property. See: #237229.\n   */\n  _onActiveFilterSelected(event) {\n    this.setActiveFilter(event.activeFilter);\n    let browse = !this.searchRequired;\n    let searchText = this._readSearchText();\n    if (this.lookupRow) {\n      if (this.lookupRow.text !== searchText) {\n        browse = false;\n      }\n    } else if (strings.hasText(searchText)) {\n      browse = false;\n    }\n    this._lookupByTextOrAll(browse, searchText, true);\n  }\n\n  /**\n   * @param {number} browseMaxRowCount - a positive number, _not_ null or undefined!\n   */\n  setBrowseMaxRowCount(browseMaxRowCount) {\n    this.setProperty('browseMaxRowCount', browseMaxRowCount);\n    this._syncBrowseMaxRowCountWithLookupCall();\n  }\n  _syncBrowseMaxRowCountWithLookupCall() {\n    if (this.lookupCall) {\n      // sync max rows with lookup call => request one more row to detect if there would be more rows than browseMaxRowCount.\n      this.lookupCall.setMaxRowCount(this.browseMaxRowCount + 1);\n    }\n  }\n  setBrowseAutoExpandAll(browseAutoExpandAll) {\n    this.setProperty('browseAutoExpandAll', browseAutoExpandAll);\n  }\n  setBrowseLoadIncremental(browseLoadIncremental) {\n    this.setProperty('browseLoadIncremental', browseLoadIncremental);\n    if (this.lookupCall) {\n      // change template here. Will be used on the next clone\n      this.lookupCall.setLoadIncremental(browseLoadIncremental);\n    }\n  }\n  setActiveFilter(activeFilter) {\n    this.setProperty('activeFilter', this.activeFilterEnabled ? activeFilter : null);\n  }\n  setActiveFilterEnabled(activeFilterEnabled) {\n    this.setProperty('activeFilterEnabled', activeFilterEnabled);\n  }\n  setInitActiveFilter(initActiveFilter) {\n    this.setProperty('initActiveFilter', initActiveFilter);\n  }\n  setSearchRequired(searchRequired) {\n    this.setProperty('searchRequired', searchRequired);\n  }\n\n  /**\n   * A wrapper function around lookup calls used to display the state in the UI.\n   */\n  _executeLookup(lookupCall, abortExisting) {\n    this.lookupSeqNo++;\n    this.setLoading(true);\n    let currentLookupCall = this.original()._currentLookupCall;\n    if (abortExisting && currentLookupCall) {\n      currentLookupCall.abort();\n    }\n    this.original()._currentLookupCall = lookupCall;\n    this.trigger('prepareLookupCall', {\n      lookupCall: lookupCall\n    });\n    return lookupCall.execute().always(() => {\n      this.original()._currentLookupCall = null;\n      this.setLoading(false);\n      this._clearLookupStatus();\n      this._clearNoResultsErrorStatus();\n    });\n  }\n\n  /**\n   * Reset error status NO_RESULTS when a lookup is performed, otherwise it would interfere with the\n   * temporary lookupStatus and we'd see an out-dated error-status message while the user is typing.\n   */\n  _clearNoResultsErrorStatus() {\n    if (this.isTouchable()) {\n      return;\n    }\n    if (this._userWasTyping && this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n      this.setErrorStatus(null);\n    }\n  }\n\n  /**\n   * Returns true if the smart-field lookup returns a lot of rows. In that case\n   * the proposal chooser must create a table with virtual scrolling, which means\n   * only the rows visible in the UI are rendered in the DOM. By default we render\n   * all rows, since this avoids problems with layout-invalidation with rows\n   * that have a bitmap-image (PNG) which is loaded asynchronously.\n   */\n  virtual() {\n    return this.browseMaxRowCount > SmartField.DEFAULT_BROWSE_MAX_COUNT;\n  }\n  isDropdown() {\n    return this.displayStyle === SmartField.DisplayStyle.DROPDOWN;\n  }\n  _setLookupRow(lookupRow) {\n    // remove css classes from old lookup-row\n    if (this.lookupRow) {\n      this.removeCssClass(this.lookupRow.cssClass);\n    }\n    this._setProperty('lookupRow', lookupRow);\n\n    // add css classes from new lookup-row\n    if (lookupRow) {\n      this.addCssClass(lookupRow.cssClass);\n    }\n  }\n  setLookupRow(lookupRow) {\n    if (this.lookupRow === lookupRow) {\n      return;\n    }\n    this._notUnique = false;\n    this.clearErrorStatus();\n    this._setLookupRow(lookupRow);\n    // this flag is required so lookup row is not changed again, when _setValue is called\n    this._lockLookupRow = true;\n    if (lookupRow) {\n      this.setValue(this._getValueFromLookupRow(lookupRow));\n    } else {\n      this.setValue(null);\n    }\n    this._lockLookupRow = false;\n\n    // In case we have a value X set, start to type search text, and then choose the lookup\n    // row from the proposal with exactly the same value X, setValue() does nothing because\n    // the value has not changed (even though the display text has) thus _formatValue is\n    // never called. That's why we always reset the display text to make sure the display\n    // text is correct.\n    this.resetDisplayText();\n  }\n  setDisplayText(displayText) {\n    super.setDisplayText(displayText);\n    this._userWasTyping = false;\n  }\n  resetDisplayText() {\n    let returned = this.formatValue(this.value);\n    if (returned && $.isFunction(returned.promise)) {\n      // Promise is returned -> set display text later\n      returned.done(this._setAndRenderDisplayText.bind(this)).fail(() => {\n        $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + this.value);\n      });\n    } else {\n      this._setAndRenderDisplayText(returned);\n    }\n  }\n\n  /**\n   * This method is very similar to setDisplayText(), but does _not_ check for equality with\n   * the current value. The property is always set and (if the field is rendered) the given\n   * display text is always rendered. This is important when resetting the display text,\n   * because the visible text in the input field may differ from the \"displayText\" property\n   * value. If setDisplayText() was used, the visible text would not always be reset.\n   */\n  _setAndRenderDisplayText(displayText) {\n    this._setProperty('displayText', displayText);\n    if (this.rendered) {\n      this._renderDisplayText();\n    }\n  }\n  _getValueFromLookupRow(lookupRow) {\n    return lookupRow.key;\n  }\n  _setValue(value) {\n    // set the cached lookup row to null. Keep in mind that the lookup row is set async in a timeout\n    // must of the time. Thus we must remove the reference to the old lookup row as early as possible\n    if (!this._lockLookupRow) {\n      if (objects.isNullOrUndefined(value)) {\n        // when value is set to null, we must also reset the cached lookup row\n        this._setLookupRow(null);\n      } else {\n        // when a value is set, we only keep the cached lookup row when the key of the lookup row is equals to the value\n        if (this._checkResetLookupRow(value)) {\n          this._setLookupRow(null);\n        }\n      }\n    }\n    super._setValue(value);\n    this._notUnique = false;\n  }\n\n  /**\n   * Sub-classes like the proposal field may override this function to implement a different behavior.\n   */\n  _checkResetLookupRow(value) {\n    return this.lookupRow && this.lookupRow.key !== value;\n  }\n\n  /**\n   * This function may be overridden to return another value than this.value.\n   * For instance the proposal field does'nt use the value but the key from the\n   * lookup row for comparison.\n   *\n   * @returns {*} the value used to find the selected element in a proposal chooser.\n   */\n  getValueForSelection() {\n    return this._showSelection() ? this.value : null;\n  }\n  _showSelection() {\n    if (objects.isNullOrUndefined(this.value) || objects.isNullOrUndefined(this.lookupRow)) {\n      return false;\n    }\n    let text;\n    if (this.rendered) {\n      // check if text matches (deal with multi-line)\n      text = this._readDisplayText();\n      let additionalLines = this.additionalLines();\n      if (additionalLines) {\n        text = [text].concat(additionalLines).join('\\n');\n      }\n    } else {\n      text = this.displayText;\n    }\n    return text === this.lookupRow.text;\n  }\n\n  /**\n   * override to ensure dropdown fields and touch mode smart fields does not have a clear icon.\n   */\n  isClearable() {\n    return super.isClearable() && !this.isDropdown() && !this.touchMode;\n  }\n  _triggerLookupCallDone(result) {\n    this.trigger('lookupCallDone', {\n      result: result\n    });\n    return result;\n  }\n  _triggerAcceptInputFail() {\n    this._triggerAcceptInput(false, true);\n  }\n  _triggerAcceptInput(acceptByLookupRow, failure) {\n    this.trigger('acceptInput', {\n      displayText: this.displayText,\n      errorStatus: this.errorStatus,\n      value: this.value,\n      lookupRow: this.lookupRow,\n      acceptByLookupRow: scout.nvl(acceptByLookupRow, true),\n      failure: scout.nvl(failure, false)\n    });\n  }\n  _triggerAcceptByText(searchText) {\n    this.trigger('acceptByText', {\n      searchText: searchText,\n      errorStatus: this.errorStatus\n    });\n  }\n\n  /**\n   * Function invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n   */\n  onCellEditorRendered(options) {\n    if (options.openFieldPopup) {\n      this._cellEditorPopup = options.cellEditorPopup;\n      this.openPopup(!this.searchRequired);\n    }\n  }\n  additionalLines() {\n    let text = scout.nvl(this.displayText, ''),\n      textLines = text.split('\\n');\n    if (textLines.length > 1) {\n      textLines.shift();\n      return textLines;\n    }\n    return null;\n  }\n  _createLoadingSupport() {\n    return new SimpleLoadingSupport({\n      widget: this,\n      loadingIndicatorDelay: 400 // ms\n    });\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _isInitialShowStatus() {\n    if (this.touchMode && (this._pendingOpenPopup || this.isPopupOpen())) {\n      // Do not display a tooltip if the touch popup is open, the tooltip will be displayed there\n      return false;\n    }\n    return super._isInitialShowStatus();\n  }\n\n  /**\n   * In touch mode, we must close the cell editor popup explicitly, because the touch-popup and its glasspane\n   * prevents the cell editor popup from receiving mouse down events.\n   */\n  acceptInputFromField(otherField) {\n    this._copyValuesFromField(otherField);\n    if (this._cellEditorPopup) {\n      // this will call acceptInput on the touch smart-field (== this)\n      this._cellEditorPopup.completeEdit();\n      this._cellEditorPopup = null;\n    } else {\n      this.acceptInput();\n    }\n  }\n\n  /**\n   * This function is overridden by ProposalField because it has a different behavior than the smart-field.\n   */\n  _copyValuesFromField(otherField) {\n    if (this.lookupRow !== otherField.lookupRow) {\n      this.setLookupRow(otherField.lookupRow);\n    }\n    this.setErrorStatus(otherField.errorStatus);\n    this.setDisplayText(otherField.displayText);\n  }\n  _setNotUniqueError(searchText) {\n    this.setErrorStatus(Status.error({\n      message: this.session.text('SmartFieldNotUnique', searchText),\n      code: SmartField.ErrorCode.NOT_UNIQUE\n    }));\n  }\n  _hasNotUniqueError(searchText) {\n    return this._notUnique || this._hasUiError(SmartField.ErrorCode.NOT_UNIQUE);\n  }\n  _errorStatus() {\n    return this.lookupStatus || this.errorStatus;\n  }\n  setLookupStatus(lookupStatus) {\n    this.setProperty('lookupStatus', lookupStatus);\n    if (this.rendered) {\n      this._renderErrorStatus();\n    }\n  }\n  clearErrorStatus() {\n    this.setErrorStatus(null);\n    this._clearLookupStatus();\n  }\n  _clearLookupStatus() {\n    this.setLookupStatus(null);\n  }\n\n  /**\n   * Checks if there is a lookup status that needs to be set as error status\n   * before we leave the smart-field. The lookup status is set to null, because\n   * it is a temporary state that is only important while the user executes a lookup.\n   */\n  _flushLookupStatus() {\n    if (!this.lookupStatus) {\n      return;\n    }\n    if (this.lookupStatus.code === SmartField.ErrorCode.NO_RESULTS || this.lookupStatus.code === SmartField.ErrorCode.NOT_UNIQUE) {\n      let errorStatus = this.lookupStatus.clone();\n      errorStatus.severity = Status.Severity.ERROR;\n      this.setErrorStatus(errorStatus);\n    }\n    this._clearLookupStatus();\n  }\n  requestInput() {\n    if (this.enabledComputed && this.rendered) {\n      this.focus();\n      this.openPopup(!this.searchRequired);\n    }\n  }\n}\n_defineProperty(SmartField, \"DisplayStyle\", {\n  DEFAULT: 'default',\n  DROPDOWN: 'dropdown'\n});\n_defineProperty(SmartField, \"ErrorCode\", {\n  NOT_UNIQUE: 1,\n  NO_RESULTS: 2,\n  NO_DATA: 3,\n  SEARCH_REQUIRED: 4\n});\n_defineProperty(SmartField, \"DEBOUNCE_DELAY\", 200);\n_defineProperty(SmartField, \"DEFAULT_BROWSE_MAX_COUNT\", 100);\n_defineProperty(SmartField, \"ACTIVE_FILTER_VALUES\", ['UNDEFINED', 'FALSE', 'TRUE']);","map":{"version":3,"names":["arrays","Device","fields","FormField","InputFieldKeyStrokeContext","keys","LookupCall","objects","QueryBy","scout","SimpleLoadingSupport","SmartFieldCancelKeyStroke","SmartFieldLayout","Status","strings","ValueField","$","SmartField","constructor","popup","lookupCall","codeType","_pendingLookup","_pendingOpenPopup","_tabPrevented","lookupRow","browseHierarchy","browseMaxRowCount","DEFAULT_BROWSE_MAX_COUNT","browseAutoExpandAll","browseLoadIncremental","searchRequired","activeFilterEnabled","activeFilter","activeFilterLabels","columnDescriptors","displayStyle","DisplayStyle","DEFAULT","touchMode","embedded","_userWasTyping","_acceptInputEnabled","_acceptInputDeferred","Deferred","_notUnique","_lastSearchText","lookupStatus","_currentLookupCall","lookupSeqNo","initActiveFilter","disabledCopyOverlay","maxLength","maxLengthHandler","create","target","_addCloneProperties","_init","model","length","session","text","initTouch","_initValue","value","_setLookupCall","_setCodeType","_setLookupRow","markAsSaved","setInitActiveFilter","resetValue","setActiveFilter","_createKeyStrokeContext","_initKeyStrokeContext","keyStrokeContext","registerKeyStroke","_render","addContainer","$parent","cssClassName","addLabel","fieldFunc","isDropdown","makeInputDiv","makeInputOrDiv","$field","call","on","_onFieldMouseDown","bind","keyup","_onFieldKeyUp","keydown","_onFieldKeyDown","_onFieldInput","addField","install","addMandatoryIndicator","addIcon","addStatus","_renderProperties","_renderMaxLength","_renderGridData","updateInnerAlignment","useHorizontalAlignment","_renderGridDataHints","prefix","_readSearchText","fieldText","_readDisplayText","displayText","nvl","textLines","split","empty","shift","insert","join","valOrText","_renderDisplayText","_prepareDisplayText","acceptInput","sync","log","isTraceEnabled","trace","promise","setTimeout","searchText","searchTextEmpty","searchTextChanged","_checkSearchTextChanged","selectedLookupRow","_getSelectedLookupRow","_setProperty","_flushLookupStatus","_clearPendingLookup","isDebugEnabled","debug","_inputAccepted","_acceptInput","isPopupOpen","lookupResult","seqNo","getSelectedLookupRow","_searchTextEquals","lastSearchText","a","nullIfEmpty","_firstTextLine","b","equalsIgnoreCase","clearTimeout","unchanged","removing","lookupRowText","_clearLookupStatus","_setNotUniqueError","errorStatus","code","ErrorCode","NO_RESULTS","clearErrorStatus","setLookupRow","toString","_acceptByText","_hasUiError","_hasNotUniqueError","selectFirstLookupRow","resolve","_acceptByTextSync","_acceptByTextAsync","resetDisplayText","_executeLookup","cloneForText","done","_acceptByTextDone","_triggerLookupCallDone","_triggerAcceptByText","triggerEvent","acceptByLookupRow","closePopup","_triggerAcceptInput","_focusNextTabbable","$tabElements","entryPoint","find","direction","shiftKey","fieldIndex","index","nextIndex","$nextElement","eq","focus","isFunction","select","addClass","result","_extendResult","numLookupRows","uniqueMatch","_isLookupRowActive","setErrorStatus","error","message","_acceptInputFail","propertyName","toUpperCaseFirstLetter","queryBy","toLowerCase","proposalChooser","parent","smartField","setLookupResult","leafs","findLeafs","lookupRows","setValue","setDisplayText","_lookupByTextOrAllDone","_triggerAcceptInputFail","lookupByRec","rec","cloneForRec","then","appendResult","enabled","active","_renderEnabled","setTabbable","enabledComputed","setMaxLength","setProperty","render","setLookupCall","ensure","_syncBrowseMaxRowCountWithLookupCall","_formatValue","isNullOrUndefined","_formatLookupRow","cloneForKey","_lookupByKeyDone","firstLookupRow","openPopup","browse","searchAlways","isInfoEnabled","info","_lookupByTextOrAll","codes","status","_errorStatus","NOT_UNIQUE","statusList","asFlatList","foundCodes","reduce","list","indexOf","push","some","_getLastSearchText","deferred","doneHandler","TEXT","setLookupStatus","warning","SEARCH_REQUIRED","cloneForAll","DEBOUNCE_DELAY","optProperty","byAll","_handleException","rendered","isFocused","isTouchable","_ensurePopup","NO_DATA","_handleEmptyResult","popupStatus","slice","setStatus","_renderPopup","exception","emptyResult","clearLookupRows","$container","useTouch","popupType","$anchor","boundToAnchor","closeOnAnchorMouseDown","field","open","css","fieldForPopup","_field","_onLookupRowSelected","_onActiveFilterSelected","one","removeClass","_renderErrorStatus","close","aboutToBlurByMouseDown","eventOutsideProposalField","event","activate","onField","handleOnClick","removalPending","get","supportsOnlyTouch","togglePopup","_onIconMouseDown","preventDefault","_onClearIconMouseDown","clear","_clear","_updateHasText","_onFieldBlur","setFocused","setLoading","which","ESC","w","isPaste","ctrlKey","metaKey","V","INSERT","isCut","X","DELETE","isCutOrPaste","altKey","ENTER","TAB","SHIFT","CTRL","ALT","HOME","END","LEFT","RIGHT","WIN_LEFT","WIN_RIGHT","SELECT","NUM_LOCK","CAPS_LOCK","SCROLL_LOCK","PAUSE","PRINT_SCREEN","_isNavigationKey","_isFunctionKey","_handleInput","_updateUserWasTyping","mode","Mode","stopPropagation","_handleEnterKey","delegateKeyEvent","navigationKeys","PAGE_UP","PAGE_DOWN","UP","DOWN","isOneOf","selectLookupRow","F1","F12","currentLookupCall","original","abort","hasText","setBrowseMaxRowCount","setMaxRowCount","setBrowseAutoExpandAll","setBrowseLoadIncremental","setLoadIncremental","setActiveFilterEnabled","setSearchRequired","abortExisting","trigger","execute","always","_clearNoResultsErrorStatus","virtual","DROPDOWN","removeCssClass","cssClass","addCssClass","_lockLookupRow","_getValueFromLookupRow","returned","formatValue","_setAndRenderDisplayText","fail","key","_setValue","_checkResetLookupRow","getValueForSelection","_showSelection","additionalLines","concat","isClearable","failure","onCellEditorRendered","options","openFieldPopup","_cellEditorPopup","cellEditorPopup","_createLoadingSupport","widget","loadingIndicatorDelay","_isInitialShowStatus","acceptInputFromField","otherField","_copyValuesFromField","completeEdit","clone","severity","Severity","ERROR","requestInput"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/smartfield/SmartField.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, fields, FormField, InputFieldKeyStrokeContext, keys, LookupCall, objects, QueryBy, scout, SimpleLoadingSupport, SmartFieldCancelKeyStroke, SmartFieldLayout, Status, strings, ValueField} from '../../../index';\nimport $ from 'jquery';\n\nexport default class SmartField extends ValueField {\n\n  constructor() {\n    super();\n\n    this.popup = null;\n    this.lookupCall = null;\n    this.codeType = null;\n    this._pendingLookup = null;\n    this._pendingOpenPopup = false;\n    this._tabPrevented = null;\n    this.lookupRow = null;\n    this.browseHierarchy = false;\n    this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT; // a positive number, _not_ null or undefined!\n    this.browseAutoExpandAll = true;\n    this.browseLoadIncremental = false;\n    this.searchRequired = false;\n    this.activeFilterEnabled = false;\n    this.activeFilter = null;\n    this.activeFilterLabels = [];\n    this.columnDescriptors = null;\n    this.displayStyle = SmartField.DisplayStyle.DEFAULT;\n    this.touchMode = false;\n    this.embedded = false;\n    this._userWasTyping = false; // used to detect whether the last thing the user did was typing (a proposal) or something else, like selecting a proposal row\n    this._acceptInputEnabled = true; // used to prevent multiple execution of blur/acceptInput\n    this._acceptInputDeferred = $.Deferred();\n    this._notUnique = false; // used to store the error state 'not unique' which must not be showed while typing, but when the field loses focus\n    this._lastSearchText = null;\n    this.lookupStatus = null;\n    this._currentLookupCall = null; // should only be accessed on the original widget since the adapter accesses it\n    this.lookupSeqNo = 0; // used to detect if the proposal chooser contains the results of the latest lookup, or an out-dated result.\n    // only when the result is up-to-date, we can use the selected lookup row\n    this.initActiveFilter = null;\n    this.disabledCopyOverlay = true;\n    this.maxLength = 500;\n    this.maxLengthHandler = scout.create('MaxLengthHandler', {target: this});\n\n    this._addCloneProperties(['lookupRow', 'codeType', 'lookupCall', 'activeFilter', 'activeFilterEnabled', 'activeFilterLabels',\n      'browseHierarchy', 'browseMaxRowCount', 'browseAutoExpandAll', 'browseLoadIncremental', 'searchRequired', 'columnDescriptors',\n      'displayStyle'\n    ]);\n  }\n\n  static DisplayStyle = {\n    DEFAULT: 'default',\n    DROPDOWN: 'dropdown'\n  };\n\n  static ErrorCode = {\n    NOT_UNIQUE: 1,\n    NO_RESULTS: 2,\n    NO_DATA: 3,\n    SEARCH_REQUIRED: 4\n  };\n\n  static DEBOUNCE_DELAY = 200;\n\n  static DEFAULT_BROWSE_MAX_COUNT = 100;\n\n  /**\n   * @see \"IContentAssistField#getActiveFilterLabels()\" - should have the same order.\n   */\n  static ACTIVE_FILTER_VALUES = ['UNDEFINED', 'FALSE', 'TRUE'];\n\n  _init(model) {\n    super._init(model);\n\n    if (this.activeFilterLabels.length === 0) {\n      this.activeFilterLabels = [\n        this.session.text('ui.All'),\n        this.session.text('ui.Inactive'),\n        this.session.text('ui.Active')\n      ];\n    }\n\n    fields.initTouch(this, model);\n  }\n\n  /**\n   * Initializes lookup call and code type before calling set value.\n   * This cannot be done in _init because the value field would call _setValue first\n   */\n  _initValue(value) {\n    this._setLookupCall(this.lookupCall);\n    this._setCodeType(this.codeType);\n    this._setLookupRow(this.lookupRow);\n    super._initValue(value);\n  }\n\n  markAsSaved() {\n    super.markAsSaved();\n    this.setInitActiveFilter(this.activeFilter);\n  }\n\n  resetValue() {\n    super.resetValue();\n    this.setActiveFilter(this.initActiveFilter);\n  }\n\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke(new SmartFieldCancelKeyStroke(this));\n  }\n\n  _render() {\n    this.addContainer(this.$parent, 'has-icon ' + this.cssClassName(), new SmartFieldLayout(this));\n    this.addLabel();\n\n    let fieldFunc = this.isDropdown() ? fields.makeInputDiv : fields.makeInputOrDiv;\n    let $field = fieldFunc.call(scout.fields, this)\n      .on('mousedown', this._onFieldMouseDown.bind(this));\n\n    if (!this.touchMode) {\n      $field\n        .keyup(this._onFieldKeyUp.bind(this))\n        .keydown(this._onFieldKeyDown.bind(this))\n        .on('input', this._onFieldInput.bind(this));\n    }\n    this.addField($field);\n    this.maxLengthHandler.install($field);\n\n    if (!this.embedded) {\n      this.addMandatoryIndicator();\n    }\n    this.addIcon();\n    this.addStatus();\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderMaxLength();\n  }\n\n  _renderGridData() {\n    super._renderGridData();\n    this.updateInnerAlignment({\n      useHorizontalAlignment: !this.browseHierarchy\n    });\n  }\n\n  _renderGridDataHints() {\n    super._renderGridDataHints();\n    this.updateInnerAlignment({\n      useHorizontalAlignment: !this.browseHierarchy\n    });\n  }\n\n  cssClassName() {\n    let prefix = this.displayStyle;\n    if (this.displayStyle === SmartField.DisplayStyle.DEFAULT) {\n      prefix = 'smart';\n    }\n    return prefix + '-field';\n  }\n\n  _readSearchText() {\n    let fieldText = this._readDisplayText(),\n      displayText = scout.nvl(this.displayText, ''),\n      textLines = displayText.split('\\n');\n\n    if (textLines.length === 1 || strings.empty(fieldText)) {\n      return fieldText;\n    }\n    textLines.shift(); // remove first line\n    arrays.insert(textLines, fieldText, 0);\n    return strings.join('\\n', textLines);\n  }\n\n  _readDisplayText() {\n    return fields.valOrText(this.$field);\n  }\n\n  _renderDisplayText() {\n    let displayText = this._prepareDisplayText();\n    fields.valOrText(this.$field, displayText);\n    super._renderDisplayText();\n  }\n\n  _prepareDisplayText() {\n    let displayText = scout.nvl(this.displayText, ''),\n      textLines = displayText.split('\\n');\n    if (textLines.length) {\n      displayText = textLines[0];\n    }\n    return displayText;\n  }\n\n  /**\n   * Accepts the selected lookup row and sets its id as value.\n   * This function is called on blur, by a keystroke or programmatically at any time.\n   *\n   * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n   */\n  acceptInput(sync) {\n    if (!this._acceptInputEnabled) {\n      $.log.isTraceEnabled() && $.log.trace('(SmartField#acceptInput) Skipped acceptInput because _acceptInputEnabled=false');\n      return this._acceptInputDeferred.promise();\n    }\n\n    // Use a timeout to prevent multiple execution within the same user action\n    this._acceptInputEnabled = false;\n    setTimeout(() => {\n      this._acceptInputEnabled = true;\n    });\n\n    let\n      searchText = this._readSearchText(),\n      searchTextEmpty = strings.empty(searchText),\n      searchTextChanged = this._checkSearchTextChanged(searchText),\n      selectedLookupRow = this._getSelectedLookupRow(searchTextChanged);\n\n    this._setProperty('displayText', searchText);\n    this._acceptInputDeferred = $.Deferred();\n    this._flushLookupStatus();\n    this._clearPendingLookup();\n\n    if (this.touchMode) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#acceptInput) Always send acceptInput for touch field');\n      this._inputAccepted();\n      return;\n    }\n\n    return this._acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow);\n  }\n\n  /**\n   * This function is used to determine if the currently selected lookup row can be\n   * used when acceptInput is called. Basically we don't want to use the row in case\n   * the result is out-dated.\n   */\n  _getSelectedLookupRow(searchTextChanged) {\n    // don't use selected lookup row if...\n    if (!this.isPopupOpen() || // 1. popup has been closed\n      (searchTextChanged && this._userWasTyping)) { // 2. search text has changed and user was typing\n      return null;\n    }\n    // 3. if the result row is from an out-dated result\n    return this.lookupSeqNo === this.popup.lookupResult.seqNo ?\n      this.popup.getSelectedLookupRow() : null;\n  }\n\n  _checkSearchTextChanged(searchText) {\n    if (this.isDropdown() || !this._userWasTyping) {\n      return false; // search text cannot change in drop-down fields\n    }\n\n    // check if search text has changed since the last search, when it has changed\n    // we cannot use the currently selected lookup row, because these proposals are\n    // out-dated.\n    return !this._searchTextEquals(searchText, this._lastSearchText);\n  }\n\n  _searchTextEquals(searchText, lastSearchText) {\n    let a = strings.nullIfEmpty(this._firstTextLine(searchText));\n    let b = strings.nullIfEmpty(lastSearchText);\n    return strings.equalsIgnoreCase(a, b);\n  }\n\n  _clearPendingLookup() {\n    if (this._pendingLookup) {\n      clearTimeout(this._pendingLookup);\n      this._pendingLookup = null;\n    }\n  }\n\n  /**\n   * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n   *\n   * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n   */\n  _acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow) {\n\n    let unchanged = false;\n    if (this.removing) {\n      // Rare case: _acceptInput may be called when the field is being removed. In that case\n      // we do nothing and leave the lookupRow unchanged.\n      unchanged = true;\n    } else if (!selectedLookupRow && this.lookupRow) {\n      // Do nothing when search text is equals to the text of the current lookup row\n      let lookupRowText = strings.nvl(this.lookupRow.text);\n      unchanged = lookupRowText === searchText;\n    }\n\n    if (unchanged) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: widget is removing or searchText is equals. Close popup');\n      this._clearLookupStatus();\n      this._inputAccepted(false);\n      return;\n    }\n\n    // Don't show the not-unique error when the search-text becomes empty while typing (see ticket #229775)\n    if (this._notUnique && !searchTextEmpty) {\n      this._setNotUniqueError(searchText);\n    }\n\n    // Do nothing when we don't have a current lookup row and search text is empty\n    // trigger event when search text has changed. This is required for the case where\n    // a field is cleared, and the remote model must be updated (value=null)\n    if (!selectedLookupRow && !this.lookupRow && searchTextEmpty) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: text is empty. Close popup');\n      this._clearLookupStatus();\n      if (this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n        // clear the error status from previous search which did not find any results. This error status is no longer valid as we accept the null content here.\n        this.clearErrorStatus();\n      }\n      this._inputAccepted(searchTextChanged || this._userWasTyping);\n      return;\n    }\n\n    // 1.) when search text is empty and no lookup-row is selected, simply set the value to null\n    // Note: here we assume that a current lookup row is set.\n    if (!selectedLookupRow && searchTextEmpty) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) empty. Set lookup-row to null, close popup');\n      this._clearLookupStatus();\n      this.setLookupRow(null);\n      this._inputAccepted();\n      return;\n    }\n\n    // 2.) proposal chooser is open -> use the selected row as value\n    if (selectedLookupRow) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) lookup-row selected. Set lookup-row, close popup lookupRow=', selectedLookupRow.toString());\n      this._clearLookupStatus();\n      this.setLookupRow(selectedLookupRow);\n      this._inputAccepted();\n      return;\n    }\n\n    // 3.) proposal chooser is not open -> try to accept the current display text\n    // this causes a lookup which may fail and open a new proposal chooser (property\n    // change for 'result').\n    if (searchTextChanged || this._userWasTyping) {\n      this._acceptByText(sync, this._firstTextLine(searchText));\n    } else if (!this._hasUiError()) {\n      this._inputAccepted(false);\n    } else if (this._hasNotUniqueError() && this.popup) {\n      // popup has been opened (again) with errorStatus NOT_UNIQUE, and search text is still the same\n      this.popup.selectFirstLookupRow();\n    } else {\n      // even though there's nothing to do, someone could wait for our promise to be resolved\n      this._acceptInputDeferred.resolve();\n    }\n\n    return this._acceptInputDeferred.promise();\n  }\n\n  /**\n   * Required for multiline smart-field. Only use first line of search text for accept by text.\n   * Note: for the regular lookup by text, we use the readDisplayText() function which always\n   * returns a single line. But in acceptInput we need the full search text (=display text + additional\n   * lines) in order to check whether or not the display text has changed, compared to the current\n   * lookup row. That's why we must extract the first line here.\n   */\n  _firstTextLine(text) {\n    if (strings.empty(text)) {\n      return text;\n    }\n    return text.split('\\n')[0];\n  }\n\n  /**\n   * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n   *\n   * @param sync when set to true it's not allowed to start an asynchronous lookup to search by text, the\n   *     current search text is discarded. The flag is set to true in case we click on another field, where\n   *     we must make sure the order of (browser) events is not changed by the lookup that would return _after_\n   *     the events for the clicked field are handled.\n   */\n  _acceptByText(sync, searchText) {\n    sync = scout.nvl(sync, false);\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptByText) sync=' + sync + ' searchText=', searchText);\n\n    if (sync) {\n      this._acceptByTextSync(searchText);\n    } else {\n      this._acceptByTextAsync(searchText);\n    }\n  }\n\n  _acceptByTextSync(searchText) {\n    this._lastSearchText = null;\n    this._inputAccepted();\n    if (!this._hasUiError()) {\n      this.resetDisplayText();\n    }\n  }\n\n  _acceptByTextAsync(searchText) {\n    this._lastSearchText = searchText;\n    this._executeLookup(this.lookupCall.cloneForText(searchText), true)\n      .done(this._acceptByTextDone.bind(this))\n      .done(this._triggerLookupCallDone.bind(this));\n    this._triggerAcceptByText(searchText);\n  }\n\n  _inputAccepted(triggerEvent, acceptByLookupRow) {\n    triggerEvent = scout.nvl(triggerEvent, true);\n    acceptByLookupRow = scout.nvl(acceptByLookupRow, true);\n    // don't close when shown in touch popup (also called when clear() is executed)\n    if (!this.embedded) {\n      this.closePopup();\n    }\n    this._userWasTyping = false;\n    if (triggerEvent) {\n      this._triggerAcceptInput(acceptByLookupRow);\n    }\n    this._focusNextTabbable();\n    this._acceptInputDeferred.resolve();\n  }\n\n  _focusNextTabbable() {\n    if (this._tabPrevented) {\n      let $tabElements = this.entryPoint().find(':tabbable'),\n        direction = this._tabPrevented.shiftKey ? -1 : 1,\n        fieldIndex = $tabElements.index(this.$field),\n        nextIndex = fieldIndex + direction;\n\n      if (nextIndex < 0) {\n        nextIndex = $tabElements.length - 1;\n      } else if (nextIndex >= $tabElements.length) {\n        nextIndex = 0;\n      }\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_inputAccepted) tab-index=' + fieldIndex + ' next tab-index=' + nextIndex);\n      let $nextElement = $tabElements.eq(nextIndex).focus();\n      if (objects.isFunction($nextElement[0].select)) {\n        $nextElement[0].select();\n      }\n      // This is normally done by FocusManager, but since propagation is stopped, we need to do it here as well\n      $nextElement.addClass('keyboard-navigation');\n      this._tabPrevented = null;\n    }\n  }\n\n  _acceptByTextDone(result) {\n    this._userWasTyping = false;\n    this._extendResult(result);\n    this._notUnique = result.numLookupRows > 1;\n\n    // when there's exactly one result, we accept that lookup row\n    if (result.uniqueMatch) {\n      let lookupRow = result.uniqueMatch;\n      if (this._isLookupRowActive(lookupRow)) {\n        this.setLookupRow(lookupRow);\n        this._inputAccepted();\n      } else {\n        this.setErrorStatus(Status.error({\n          message: this.session.text('SmartFieldInactiveRow', result.text)\n        }));\n      }\n      return;\n    }\n\n    this._acceptInputFail(result);\n  }\n\n  /**\n   * Extends the properties 'uniqueMatch' and 'numLookupRows' on the given result object.\n   * The implementation is different depending on the browseHierarchy property.\n   */\n  _extendResult(result) {\n    result.seqNo = this.lookupSeqNo;\n    result.uniqueMatch = null;\n\n    // Set query type on result, e.g. 'byAll'\n    let propertyName = 'by' + strings.toUpperCaseFirstLetter(result.queryBy.toLowerCase());\n    result[propertyName] = true;\n\n    if (this.browseHierarchy) {\n      // tree (hierarchical)\n      let proposalChooser = scout.create('TreeProposalChooser', {\n        parent: this,\n        smartField: this\n      });\n      proposalChooser.setLookupResult(result);\n      let leafs = proposalChooser.findLeafs();\n      result.numLookupRows = leafs.length;\n      if (result.numLookupRows === 1) {\n        result.uniqueMatch = leafs[0].lookupRow;\n      }\n    } else {\n      // table\n      result.numLookupRows = result.lookupRows.length;\n      if (result.numLookupRows === 1) {\n        result.uniqueMatch = result.lookupRows[0];\n      }\n    }\n\n    result.empty = (result.numLookupRows === 0);\n  }\n\n  _acceptInputFail(result) {\n    let searchText = result.text;\n\n    // in any other case something went wrong\n    if (result.empty) {\n      if (!this.embedded) {\n        this.closePopup();\n      }\n      this.setValue(null);\n      this.setDisplayText(searchText);\n      this.setErrorStatus(Status.error({\n        message: this.session.text('SmartFieldCannotComplete', searchText),\n        code: SmartField.ErrorCode.NO_RESULTS\n      }));\n    }\n\n    if (result.numLookupRows > 1) {\n      this.setValue(null);\n      this.setDisplayText(searchText);\n      this._setNotUniqueError(searchText);\n      if (this.isPopupOpen()) {\n        this.popup.setLookupResult(result);\n      } else {\n        this._lookupByTextOrAllDone(result);\n      }\n      // check again if popup is open yet (might have been opened by _lookupByTextOrAllDone)\n      if (this.isPopupOpen()) {\n        this.popup.selectFirstLookupRow();\n      }\n    }\n\n    this._acceptInputDeferred.resolve();\n    this._triggerAcceptInputFail();\n  }\n\n  lookupByRec(rec) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#lookupByRec) rec=', rec);\n    this._lastSearchText = null;\n    return this._executeLookup(this.lookupCall.cloneForRec(rec))\n      .then(result => {\n\n        // Since this function is only used for hierarchical trees we\n        // can simply set the appendResult flag always to true here\n        result.appendResult = true;\n        result.rec = rec;\n\n        if (this.isPopupOpen()) {\n          this.popup.setLookupResult(result);\n        }\n      })\n      .then(this._triggerLookupCallDone.bind(this));\n  }\n\n  /**\n   * Validates the given lookup row is enabled and matches the current activeFilter settings.\n   *\n   * @returns {boolean}\n   */\n  _isLookupRowActive(lookupRow) {\n    if (!lookupRow.enabled) {\n      return false;\n    }\n    if (!this.activeFilterEnabled) {\n      return true;\n    }\n    if (this.activeFilter === 'TRUE') {\n      return lookupRow.active;\n    }\n    if (this.activeFilter === 'FALSE') {\n      return !lookupRow.active;\n    }\n    return true;\n  }\n\n  _renderEnabled() {\n    super._renderEnabled();\n    this.$field.setTabbable(this.enabledComputed);\n  }\n\n  setMaxLength(maxLength) {\n    this.setProperty('maxLength', maxLength);\n  }\n\n  _renderMaxLength() {\n    this.maxLengthHandler.render();\n  }\n\n  setLookupCall(lookupCall) {\n    this.setProperty('lookupCall', lookupCall);\n  }\n\n  _setLookupCall(lookupCall) {\n    this._setProperty('lookupCall', LookupCall.ensure(lookupCall, this.session));\n    this._syncBrowseMaxRowCountWithLookupCall();\n  }\n\n  _setCodeType(codeType) {\n    this._setProperty('codeType', codeType);\n    if (!codeType) {\n      return;\n    }\n    let lookupCall = scout.create('CodeLookupCall', {\n      session: this.session,\n      codeType: codeType\n    });\n    this.setProperty('lookupCall', lookupCall);\n  }\n\n  _formatValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return '';\n    }\n\n    // we already have a lookup row - Note: in Scout Classic (remote case)\n    // we always end here and don't need to perform a getByKey lookup.\n    if (this.lookupRow) {\n      return this._formatLookupRow(this.lookupRow);\n    }\n\n    // we must do a lookup first to get the display text\n    // Note: this has a side-effect as it sets the property lookupRow on the smart field\n    this._lastSearchText = null;\n    return this._executeLookup(this.lookupCall.cloneForKey(value), true)\n      .then(this._lookupByKeyDone.bind(this))\n      .then(this._triggerLookupCallDone.bind(this));\n  }\n\n  _lookupByKeyDone(result) {\n    this._notUnique = false;\n    let lookupRow = LookupCall.firstLookupRow(result);\n    this.setLookupRow(lookupRow);\n    return this._formatLookupRow(lookupRow);\n  }\n\n  /**\n   * This function is called when we need to format a display text from a given lookup\n   * row. By default the property 'text' is used for that purpose. Override this function\n   * if you need to format different properties from the lookupRow.\n   */\n  _formatLookupRow(lookupRow) {\n    return lookupRow ? lookupRow.text : '';\n  }\n\n  /**\n   * @param {boolean} [browse] whether or not the lookup call should execute getAll() or getByText() with the current display text.\n   *     if browse is undefined, browse is set to true automatically if search text is empty\n   * @returns {Promise}\n   */\n  openPopup(browse) {\n    // In case searchRequired is set to true, we always start a new search with the text from the field as query\n    let searchText = this._readDisplayText(),\n      searchAlways = this.searchRequired ? true : null;\n    $.log.isInfoEnabled() && $.log.info('SmartField#openPopup browse=' + browse + ' searchText=' + searchText +\n      ' popup=' + this.popup + ' pendingOpenPopup=' + this._pendingOpenPopup);\n\n    // Reset scheduled focus next tabbable when user clicks on the smartfield while a lookup is resolved.\n    this._tabPrevented = null;\n    this._pendingOpenPopup = true;\n\n    if (strings.empty(searchText)) {\n      // if search text is empty - always do 'browse', no matter what the error code is\n      browse = true;\n    } else if (this.errorStatus) {\n      // In case the search yields a not-unique error, we always want to start a lookup\n      // with the current display text in every other case we better do browse again\n      if (this._hasNotUniqueError()) {\n        searchAlways = true;\n        browse = false;\n      } else if (!this.searchRequired) {\n        browse = true;\n      }\n    }\n\n    return this._lookupByTextOrAll(browse, searchText, searchAlways);\n  }\n\n  _hasUiError(codes) {\n    let status = this._errorStatus();\n\n    if (!status) {\n      return false;\n    }\n\n    if (codes) {\n      codes = arrays.ensure(codes);\n    } else {\n      codes = [SmartField.ErrorCode.NO_RESULTS, SmartField.ErrorCode.NOT_UNIQUE];\n    }\n\n    // collect codes from the status hierarchy\n    let statusList = Status.asFlatList(status);\n    let foundCodes = statusList.reduce((list, status) => {\n      if (status.code && list.indexOf(status.code) === -1) {\n        list.push(status.code);\n      }\n      return list;\n    }, []);\n\n    // if one of the requested codes exist in the list of found codes\n    return codes.some(code => {\n      return foundCodes.indexOf(code) > -1;\n    });\n  }\n\n  /**\n   * @param browse [boolean] optional, whether to perform a lookupByAll (=browse) or a lookupByText.\n   *        By default the param is set to <code>true</code> if the search-text is not empty\n   * @param searchText [String] optional, when not set the search-text from the smart-field is used\n   * @param searchAlways [boolean] optional, only used when browse=false. When set to true the search\n   *        is always performed, event when the search-text has not changed. By default the param is\n   *        set to <code>false</code>.\n   * @returns {Promise}\n   */\n  _lookupByTextOrAll(browse, searchText, searchAlways) {\n    // default values\n    searchText = scout.nvl(searchText, this._readDisplayText());\n    browse = scout.nvl(browse, strings.empty(searchText));\n    searchAlways = scout.nvl(searchAlways, false);\n\n    // never do a text-lookup if field has dropdown style\n    if (this.isDropdown()) {\n      browse = true;\n    }\n\n    // this avoids unnecessary lookup-calls when a keyboard event has triggered\n    // the lookupByTextOrAll function but the search-text has not changed #226643.\n    if (!browse && !searchAlways) {\n      let lastSearchText = null;\n      if (this._lastSearchText) {\n        lastSearchText = this._lastSearchText;\n      } else {\n        lastSearchText = this._getLastSearchText();\n      }\n      if (this._searchTextEquals(searchText, lastSearchText)) {\n        this._pendingOpenPopup = false;\n        $.log.debug('(SmartField#_lookupByTextOrAll) searchText is equals -> skip lookup');\n        return;\n      }\n    }\n\n    this._clearPendingLookup();\n\n    let deferred = $.Deferred();\n    let doneHandler = function(result) {\n      this._lookupByTextOrAllDone(result);\n      deferred.resolve(result);\n    }.bind(this);\n\n    // execute lookup byAll immediately\n    if (browse) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byAll (searchText empty)');\n      this._lastSearchText = null;\n      if (this.searchRequired) {\n        doneHandler({\n          queryBy: QueryBy.TEXT,\n          lookupRows: []\n        });\n        this.setLookupStatus(Status.warning({\n          message: this.session.text('TooManyRows'),\n          code: SmartField.ErrorCode.SEARCH_REQUIRED\n        }));\n      } else {\n        this._executeLookup(this.lookupCall.cloneForAll(), true)\n          .done(doneHandler)\n          .done(this._triggerLookupCallDone.bind(this));\n      }\n    } else {\n      // execute lookup byText with a debounce/delay\n      this._pendingLookup = setTimeout(() => {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byText searchText=' + searchText);\n        this._lastSearchText = searchText;\n        this._executeLookup(this.lookupCall.cloneForText(searchText), true)\n          .done(doneHandler)\n          .done(this._triggerLookupCallDone.bind(this));\n      }, SmartField.DEBOUNCE_DELAY);\n    }\n\n    return deferred.promise();\n  }\n\n  /**\n   * Returns the text used to store the 'last search-text'. The implementation differs between SmartField and ProposalField.\n   */\n  _getLastSearchText() {\n    return objects.optProperty(this.lookupRow, 'text');\n  }\n\n  _lookupByTextOrAllDone(result) {\n    this._extendResult(result);\n    this._notUnique = !result.byAll && result.numLookupRows > 1;\n\n    if (this._handleException(result)) {\n      return;\n    }\n\n    // In cases where the user has tabbed to the next field, while results for the previous\n    // smart-field are still loading: don't show the proposal popup. In the case of a cell-editor\n    // it's also possible that the smart-field is not rendered anymore when the lookup is done\n    if (!this.rendered ||\n      !this.isFocused() && !this.isTouchable()) {\n      this.closePopup();\n      return;\n    }\n\n    // 'No data' case\n    if (result.empty && result.byAll) {\n      // When active filter is enabled we must always show the popup, because the user\n      // must be able to switch the filter properties. Otherwise a user could set the filter\n      // to 'inactive', and receives an empty result for that query, the popup is closed\n      // and the user can not switch the filter back to 'active' again because the filter\n      // control is not visible.\n      if (this.activeFilterEnabled) {\n        this._ensurePopup(result);\n      } else {\n        this.closePopup();\n      }\n\n      this.setLookupStatus(Status.warning({\n        message: this.session.text('SmartFieldNoDataFound'),\n        code: SmartField.ErrorCode.NO_DATA\n      }));\n      return;\n    }\n\n    if (result.empty) {\n      this._handleEmptyResult();\n      this.setLookupStatus(Status.warning({\n        message: this.session.text('SmartFieldCannotComplete', result.text),\n        code: SmartField.ErrorCode.NO_RESULTS\n      }));\n      return;\n    }\n\n    let popupStatus = null;\n    if (result.numLookupRows > this.browseMaxRowCount) {\n      // Info: we limit the lookup rows here, but this is more a last line of defense\n      // limit should be always performed on the server, so we don't have to transfer\n      // unnecessary lookup rows over the slow network. Make sure your Scout lookup call\n      // or REST service impl. respects the max. row count property.\n      result.lookupRows = result.lookupRows.slice(0, this.browseMaxRowCount);\n      popupStatus = Status.info({\n        message: this.session.text('SmartFieldMoreThanXRows', this.browseMaxRowCount)\n      });\n    }\n\n    // Render popup, if not yet rendered and set results\n    this._ensurePopup(result, popupStatus);\n  }\n\n  _ensurePopup(result, status) {\n    if (this.popup) {\n      this.popup.setLookupResult(result);\n      this.popup.setStatus(status);\n    } else {\n      this._renderPopup(result, status);\n    }\n  }\n\n  _handleException(result) {\n    // Oops! Something went wrong while the lookup has been processed.\n    if (result.exception) {\n      this.setErrorStatus(Status.error({\n        message: result.exception\n      }));\n      this.closePopup();\n      return true;\n    }\n    return false;\n  }\n\n  _handleEmptyResult() {\n    if (this.touchMode || this.activeFilterEnabled) {\n      // In mobile mode we always open the popup, event if we don't have a result\n      // Otherwise it would be impossible to enter text in a proposal field with\n      // an empty proposal list. The same goes for activeFilterEnabled state -\n      // a filter can lead to an empty result (for instance when there are no\n      // inactive proposals), and it's hard to switch to another filter value\n      // when the popup does not show up at all.\n      let emptyResult = {\n        lookupRows: []\n      };\n      this._ensurePopup(emptyResult);\n    } else if (this.embedded) {\n      this.popup.clearLookupRows();\n    } else {\n      this.closePopup();\n    }\n  }\n\n  _renderPopup(result, status) {\n    // On touch devices the field does not get the focus.\n    // But it should look focused when the popup is open.\n    this.$field.addClass('focused');\n    this.$container.addClass('popup-open');\n\n    let useTouch = this.touchMode && !this.isDropdown();\n    let popupType = useTouch ? 'SmartFieldTouchPopup' : 'SmartFieldPopup';\n    this._pendingOpenPopup = false;\n    this.popup = scout.create(popupType, {\n      parent: this,\n      $anchor: this.$field,\n      boundToAnchor: !useTouch,\n      closeOnAnchorMouseDown: false,\n      field: this,\n      lookupResult: result,\n      status: status\n    });\n\n    this.popup.open();\n    this.popup.$container.css('--inactive-lookup-row-suffix-text', `'${this.session.text('InactiveState')}'`);\n\n    /* This variable is required to route events to the right field:\n     * - in normal mode popup events should be processed by the normal smart-field\n     * - in touch mode, the field flagged with the 'touch' property should process no\n     *   events at all, instead the field flagged with the 'embedded' property should\n     *   process these events.\n     *\n     * (*1) because the lookup is processed by the field flagged with 'touch' we must\n     *      set the activeFilter on that field too, because the java-model on the server\n     *      is stateful. The java field always passes the activeFilter property to the\n     *      lookup call.\n     */\n    let fieldForPopup = useTouch ? this.popup._field : this;\n    this.popup.on('lookupRowSelected', fieldForPopup._onLookupRowSelected.bind(fieldForPopup));\n    this.popup.on('activeFilterSelected', this._onActiveFilterSelected.bind(this)); // intentionally use this instead of fieldForPopup *1\n    this.popup.one('remove', () => {\n      this.popup = null;\n      if (this.rendered) {\n        this.$container.removeClass('popup-open');\n        this.$field.removeClass('focused');\n        this._renderErrorStatus();\n      }\n    });\n  }\n\n  closePopup() {\n    this._pendingOpenPopup = false;\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n\n  /**\n   * Calls acceptInput if mouse down happens outside of the field or popup\n   * @override\n   */\n  aboutToBlurByMouseDown(target) {\n    if (this.touchMode) {\n      return false;\n    }\n    if (fields.eventOutsideProposalField(this, target)) {\n      this.acceptInput(true);\n    }\n  }\n\n  _onFieldMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldMouseDown)');\n    this.activate(true);\n  }\n\n  activate(onField) {\n    if (!this.enabledComputed || !this.rendered) {\n      return;\n    }\n    if (!this.isDropdown() && !fields.handleOnClick(this)) {\n      if (this.popup && this.popup.removalPending) {\n        // If smart field is activated while it is closing (during remove animation), wait for the animation to finish and activate it afterwards\n        this.popup.one('remove', () => {\n          if (this.rendered) {\n            this.activate(onField);\n          }\n        });\n      }\n      return;\n    }\n    // Don't focus on desktop devices when click is on field #217192\n    // Also required for touch case where field is a DIV and not an INPUT field\n    if (!onField || Device.get().supportsOnlyTouch()) {\n      this.$field.focus();\n    }\n    this.togglePopup();\n  }\n\n  _onIconMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onIconMouseDown)');\n    if (!this.enabledComputed) {\n      return;\n    }\n    event.preventDefault();\n    this.$field.focus();\n    if (!this.embedded) {\n      if (this.isDropdown()) {\n        this.togglePopup();\n      } else if (!this.popup) {\n        this.openPopup(!this.searchRequired);\n      }\n    }\n  }\n\n  _onClearIconMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onClearIconMouseDown)');\n    if (!this.enabledComputed) {\n      return;\n    }\n    event.preventDefault();\n    this.$field.focus();\n    this.clear();\n  }\n\n  _clear() {\n    // don't tab next field when user clicks on clear icon (acceptInput is called later)\n    this._tabPrevented = null;\n    // the state of these two flags is important. See #_checkSearchTextChanged\n    this._lastSearchText = this._readDisplayText();\n    this._userWasTyping = true;\n    fields.valOrText(this.$field, '');\n    if (this.touchMode) {\n      // There is actually no \"x\" the user can press in touch mode, but if the developer calls clear() manually, it should work too.\n      // Because accept input works differently in touch mode we need to explicitly set the value to null\n      this.setValue(null);\n    }\n    if (this.isPopupOpen()) {\n      // When cleared, browse by all again, need to do it in setTimeout because sending acceptInput and lookupAll at the same time does not seem to work\n      setTimeout(this._lookupByTextOrAll.bind(this, true));\n    }\n    this._updateHasText();\n  }\n\n  togglePopup() {\n    $.log.isInfoEnabled() && $.log.info('(SmartField#togglePopup) popupOpen=', this.isPopupOpen());\n    if (this.isPopupOpen()) {\n      this.closePopup();\n    } else {\n      this.openPopup(!this.searchRequired);\n    }\n  }\n\n  _onFieldBlur(event) {\n    this.setFocused(false);\n    this.setLoading(false);\n    if (this.isTouchable()) {\n      return;\n    }\n    this.acceptInput(false);\n    this.closePopup();\n  }\n\n  /**\n   * @returns {boolean} true if the field is either 'embedded' or in 'touchMode'.\n   */\n  isTouchable() {\n    return this.embedded || this.touchMode;\n  }\n\n  _onFieldKeyUp(event) {\n    // Escape\n    if (event.which === keys.ESC) {\n      return;\n    }\n\n    // Pop-ups shouldn't open when one of the following keys is pressed\n    let w = event.which;\n    let isPaste = ((event.ctrlKey || event.metaKey) && w === keys.V) || (event.shiftKey && w === keys.INSERT);\n    let isCut = ((event.ctrlKey || event.metaKey) && w === keys.X) || (event.shiftKey && w === keys.DELETE);\n    let isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n\n    if (!isCutOrPaste && (\n      event.ctrlKey ||\n      event.altKey ||\n      event.metaKey ||\n      w === keys.ENTER ||\n      w === keys.TAB ||\n      w === keys.SHIFT ||\n      w === keys.CTRL ||\n      w === keys.ALT ||\n      w === keys.HOME ||\n      w === keys.END ||\n      w === keys.LEFT ||\n      w === keys.RIGHT ||\n      w === keys.WIN_LEFT ||\n      w === keys.WIN_RIGHT ||\n      w === keys.SELECT ||\n      w === keys.NUM_LOCK ||\n      w === keys.CAPS_LOCK ||\n      w === keys.SCROLL_LOCK ||\n      w === keys.PAUSE ||\n      w === keys.PRINT_SCREEN ||\n      this._isNavigationKey(event) ||\n      this._isFunctionKey(event)\n    )) {\n      return;\n    }\n\n    // The typed character is not available until the keyUp event happens\n    // That's why we must deal with that event here (and not in keyDown)\n    // We don't use _displayText() here because we always want the text the\n    // user has typed.\n    this._handleInput();\n  }\n\n  _handleInput() {\n    if (this._pendingOpenPopup || this.isPopupOpen()) {\n      if (!this.isDropdown()) {\n        this._lookupByTextOrAll();\n      }\n    } else if (!this._pendingOpenPopup) {\n      this.openPopup();\n    }\n  }\n\n  isPopupOpen() {\n    return !!(this.popup && !this.popup.removalPending);\n  }\n\n  _onFieldKeyDown(event) {\n    this._updateUserWasTyping(event);\n\n    // We must prevent default focus handling\n    if (event.which === keys.TAB) {\n      if (this.mode === FormField.Mode.DEFAULT) {\n        event.preventDefault(); // prevent browser default TAB behavior\n        event.stopPropagation(); // prevent FocusContext#._onKeyDown\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldKeyDown) set _tabPrevented');\n        this._tabPrevented = {\n          shiftKey: event.shiftKey\n        };\n      }\n      this.acceptInput();\n      return;\n    }\n\n    if (event.which === keys.ENTER) {\n      this._handleEnterKey(event);\n      return;\n    }\n\n    // For dropdowns, not only navigation keys trigger the popup (see code below).\n    // However, there are still some exceptions that should be ignored:\n    let w = event.which;\n    if (this.isDropdown() && (\n      event.ctrlKey ||\n      event.altKey ||\n      event.metaKey ||\n      w === keys.ESC ||\n      w === keys.SHIFT ||\n      w === keys.CTRL ||\n      w === keys.ALT ||\n      w === keys.WIN_LEFT ||\n      w === keys.WIN_RIGHT ||\n      w === keys.SELECT ||\n      w === keys.NUM_LOCK ||\n      w === keys.CAPS_LOCK ||\n      w === keys.SCROLL_LOCK ||\n      w === keys.PAUSE ||\n      w === keys.PRINT_SCREEN ||\n      this._isFunctionKey(event)\n    )) {\n      return;\n    }\n\n    // If field has dropdown style, we open the popup immediately\n    // because we must not wait until text has been typed\n    if (this._isNavigationKey(event) || this.isDropdown()) {\n      if (this.isPopupOpen()) {\n        this.popup.delegateKeyEvent(event);\n      } else if (!this._pendingOpenPopup) {\n        this.openPopup(!this.searchRequired);\n      }\n      event.stopPropagation(); // key has been handled (popup open). do not allow propagation to other listeners because this could remove tooltips\n      event.preventDefault(); // prevent scrolling of container\n    }\n  }\n\n  _onFieldInput() {\n    this._updateHasText();\n    // Handling for undo/redo events which can affect this field, even tough the focus is on another field\n    // we must have the focus, because otherwise acceptInput would be skipped, which could cause the smart-field\n    // to have an invalid displayText which does not reflect the current value. #246765\n    if (!this._userWasTyping) {\n      if (!this.isFocused()) {\n        this.focus();\n      }\n      this._handleInput();\n    }\n  }\n\n  _updateUserWasTyping(event) {\n    let w = event.which;\n    let isPaste = ((event.ctrlKey || event.metaKey) && w === keys.V) || (event.shiftKey && w === keys.INSERT);\n    let isCut = ((event.ctrlKey || event.metaKey) && w === keys.X) || (event.shiftKey && w === keys.DELETE);\n    let isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n\n    if (!isCutOrPaste && (\n      event.ctrlKey ||\n      event.altKey ||\n      event.metaKey ||\n      w === keys.ESC ||\n      w === keys.TAB ||\n      w === keys.SHIFT ||\n      w === keys.CTRL ||\n      w === keys.ALT ||\n      w === keys.HOME ||\n      w === keys.END ||\n      w === keys.LEFT ||\n      w === keys.RIGHT ||\n      w === keys.WIN_LEFT ||\n      w === keys.WIN_RIGHT ||\n      w === keys.SELECT ||\n      w === keys.NUM_LOCK ||\n      w === keys.CAPS_LOCK ||\n      w === keys.SCROLL_LOCK ||\n      w === keys.PAUSE ||\n      w === keys.PRINT_SCREEN ||\n      this._isFunctionKey(event)\n    )) {\n      // neutral, don't change flag\n      return;\n    }\n\n    this._userWasTyping = !(this._isNavigationKey(event) || w === keys.ENTER);\n  }\n\n  _isNavigationKey(event) {\n    let navigationKeys = [\n      keys.PAGE_UP,\n      keys.PAGE_DOWN,\n      keys.UP,\n      keys.DOWN\n    ];\n\n    if (this.isDropdown()) {\n      navigationKeys.push(keys.HOME);\n      navigationKeys.push(keys.END);\n    }\n\n    return scout.isOneOf(event.which, navigationKeys);\n  }\n\n  _handleEnterKey(event) {\n    if (this.isPopupOpen()) {\n      this.popup.selectLookupRow();\n      event.stopPropagation();\n    }\n  }\n\n  _isFunctionKey(event) {\n    return event.which >= keys.F1 && event.which <= keys.F12;\n  }\n\n  _onLookupRowSelected(event) {\n    // When a row has been selected in the proposal chooser, cancel all\n    // pending and running lookup-calls. This avoids situations where the\n    // lookup-call returns with results after the user has pressed the\n    // enter key in order to select a result (see ticket #229775).\n    this._clearPendingLookup();\n\n    let currentLookupCall = this.original()._currentLookupCall;\n\n    if (currentLookupCall) {\n      currentLookupCall.abort();\n      this.original()._currentLookupCall = null;\n      this.setLoading(false);\n    }\n\n    this.setLookupRow(event.lookupRow);\n    this._inputAccepted();\n    this.closePopup();\n  }\n\n  /**\n   * When the user changes the active-filter we must always perform a new search. When the user has typed a searchText\n   * we must perform a lookupByText. When the searchText is empty or different from the text of the selected lookup-row\n   * we are in browse mode where we use the default given by the 'searchRequired' property. See: #237229.\n   */\n  _onActiveFilterSelected(event) {\n    this.setActiveFilter(event.activeFilter);\n    let browse = !this.searchRequired;\n    let searchText = this._readSearchText();\n    if (this.lookupRow) {\n      if (this.lookupRow.text !== searchText) {\n        browse = false;\n      }\n    } else if (strings.hasText(searchText)) {\n      browse = false;\n    }\n    this._lookupByTextOrAll(browse, searchText, true);\n  }\n\n  /**\n   * @param {number} browseMaxRowCount - a positive number, _not_ null or undefined!\n   */\n  setBrowseMaxRowCount(browseMaxRowCount) {\n    this.setProperty('browseMaxRowCount', browseMaxRowCount);\n    this._syncBrowseMaxRowCountWithLookupCall();\n  }\n\n  _syncBrowseMaxRowCountWithLookupCall() {\n    if (this.lookupCall) {\n      // sync max rows with lookup call => request one more row to detect if there would be more rows than browseMaxRowCount.\n      this.lookupCall.setMaxRowCount(this.browseMaxRowCount + 1);\n    }\n  }\n\n  setBrowseAutoExpandAll(browseAutoExpandAll) {\n    this.setProperty('browseAutoExpandAll', browseAutoExpandAll);\n  }\n\n  setBrowseLoadIncremental(browseLoadIncremental) {\n    this.setProperty('browseLoadIncremental', browseLoadIncremental);\n    if (this.lookupCall) {\n      // change template here. Will be used on the next clone\n      this.lookupCall.setLoadIncremental(browseLoadIncremental);\n    }\n  }\n\n  setActiveFilter(activeFilter) {\n    this.setProperty('activeFilter', this.activeFilterEnabled ? activeFilter : null);\n  }\n\n  setActiveFilterEnabled(activeFilterEnabled) {\n    this.setProperty('activeFilterEnabled', activeFilterEnabled);\n  }\n\n  setInitActiveFilter(initActiveFilter) {\n    this.setProperty('initActiveFilter', initActiveFilter);\n  }\n\n  setSearchRequired(searchRequired) {\n    this.setProperty('searchRequired', searchRequired);\n  }\n\n  /**\n   * A wrapper function around lookup calls used to display the state in the UI.\n   */\n  _executeLookup(lookupCall, abortExisting) {\n    this.lookupSeqNo++;\n    this.setLoading(true);\n\n    let currentLookupCall = this.original()._currentLookupCall;\n\n    if (abortExisting && currentLookupCall) {\n      currentLookupCall.abort();\n    }\n    this.original()._currentLookupCall = lookupCall;\n    this.trigger('prepareLookupCall', {\n      lookupCall: lookupCall\n    });\n\n    return lookupCall\n      .execute()\n      .always(() => {\n        this.original()._currentLookupCall = null;\n        this.setLoading(false);\n        this._clearLookupStatus();\n        this._clearNoResultsErrorStatus();\n      });\n  }\n\n  /**\n   * Reset error status NO_RESULTS when a lookup is performed, otherwise it would interfere with the\n   * temporary lookupStatus and we'd see an out-dated error-status message while the user is typing.\n   */\n  _clearNoResultsErrorStatus() {\n    if (this.isTouchable()) {\n      return;\n    }\n    if (this._userWasTyping && this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n      this.setErrorStatus(null);\n    }\n  }\n\n  /**\n   * Returns true if the smart-field lookup returns a lot of rows. In that case\n   * the proposal chooser must create a table with virtual scrolling, which means\n   * only the rows visible in the UI are rendered in the DOM. By default we render\n   * all rows, since this avoids problems with layout-invalidation with rows\n   * that have a bitmap-image (PNG) which is loaded asynchronously.\n   */\n  virtual() {\n    return this.browseMaxRowCount > SmartField.DEFAULT_BROWSE_MAX_COUNT;\n  }\n\n  isDropdown() {\n    return this.displayStyle === SmartField.DisplayStyle.DROPDOWN;\n  }\n\n  _setLookupRow(lookupRow) {\n    // remove css classes from old lookup-row\n    if (this.lookupRow) {\n      this.removeCssClass(this.lookupRow.cssClass);\n    }\n\n    this._setProperty('lookupRow', lookupRow);\n\n    // add css classes from new lookup-row\n    if (lookupRow) {\n      this.addCssClass(lookupRow.cssClass);\n    }\n  }\n\n  setLookupRow(lookupRow) {\n    if (this.lookupRow === lookupRow) {\n      return;\n    }\n    this._notUnique = false;\n    this.clearErrorStatus();\n    this._setLookupRow(lookupRow);\n    // this flag is required so lookup row is not changed again, when _setValue is called\n    this._lockLookupRow = true;\n    if (lookupRow) {\n      this.setValue(this._getValueFromLookupRow(lookupRow));\n    } else {\n      this.setValue(null);\n    }\n    this._lockLookupRow = false;\n\n    // In case we have a value X set, start to type search text, and then choose the lookup\n    // row from the proposal with exactly the same value X, setValue() does nothing because\n    // the value has not changed (even though the display text has) thus _formatValue is\n    // never called. That's why we always reset the display text to make sure the display\n    // text is correct.\n    this.resetDisplayText();\n  }\n\n  setDisplayText(displayText) {\n    super.setDisplayText(displayText);\n    this._userWasTyping = false;\n  }\n\n  resetDisplayText() {\n    let returned = this.formatValue(this.value);\n    if (returned && $.isFunction(returned.promise)) {\n      // Promise is returned -> set display text later\n      returned\n        .done(this._setAndRenderDisplayText.bind(this))\n        .fail(() => {\n          $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + this.value);\n        });\n    } else {\n      this._setAndRenderDisplayText(returned);\n    }\n  }\n\n  /**\n   * This method is very similar to setDisplayText(), but does _not_ check for equality with\n   * the current value. The property is always set and (if the field is rendered) the given\n   * display text is always rendered. This is important when resetting the display text,\n   * because the visible text in the input field may differ from the \"displayText\" property\n   * value. If setDisplayText() was used, the visible text would not always be reset.\n   */\n  _setAndRenderDisplayText(displayText) {\n    this._setProperty('displayText', displayText);\n    if (this.rendered) {\n      this._renderDisplayText();\n    }\n  }\n\n  _getValueFromLookupRow(lookupRow) {\n    return lookupRow.key;\n  }\n\n  _setValue(value) {\n    // set the cached lookup row to null. Keep in mind that the lookup row is set async in a timeout\n    // must of the time. Thus we must remove the reference to the old lookup row as early as possible\n    if (!this._lockLookupRow) {\n      if (objects.isNullOrUndefined(value)) {\n        // when value is set to null, we must also reset the cached lookup row\n        this._setLookupRow(null);\n      } else {\n        // when a value is set, we only keep the cached lookup row when the key of the lookup row is equals to the value\n        if (this._checkResetLookupRow(value)) {\n          this._setLookupRow(null);\n        }\n      }\n    }\n    super._setValue(value);\n    this._notUnique = false;\n  }\n\n  /**\n   * Sub-classes like the proposal field may override this function to implement a different behavior.\n   */\n  _checkResetLookupRow(value) {\n    return this.lookupRow && this.lookupRow.key !== value;\n  }\n\n  /**\n   * This function may be overridden to return another value than this.value.\n   * For instance the proposal field does'nt use the value but the key from the\n   * lookup row for comparison.\n   *\n   * @returns {*} the value used to find the selected element in a proposal chooser.\n   */\n  getValueForSelection() {\n    return this._showSelection() ? this.value : null;\n  }\n\n  _showSelection() {\n    if (objects.isNullOrUndefined(this.value) ||\n      objects.isNullOrUndefined(this.lookupRow)) {\n      return false;\n    }\n\n    let text;\n    if (this.rendered) {\n      // check if text matches (deal with multi-line)\n      text = this._readDisplayText();\n      let additionalLines = this.additionalLines();\n      if (additionalLines) {\n        text = [text].concat(additionalLines).join('\\n');\n      }\n    } else {\n      text = this.displayText;\n    }\n\n    return text === this.lookupRow.text;\n  }\n\n  /**\n   * override to ensure dropdown fields and touch mode smart fields does not have a clear icon.\n   */\n  isClearable() {\n    return super.isClearable() && !this.isDropdown() && !this.touchMode;\n  }\n\n  _triggerLookupCallDone(result) {\n    this.trigger('lookupCallDone', {\n      result: result\n    });\n    return result;\n  }\n\n  _triggerAcceptInputFail() {\n    this._triggerAcceptInput(false, true);\n  }\n\n  _triggerAcceptInput(acceptByLookupRow, failure) {\n    this.trigger('acceptInput', {\n      displayText: this.displayText,\n      errorStatus: this.errorStatus,\n      value: this.value,\n      lookupRow: this.lookupRow,\n      acceptByLookupRow: scout.nvl(acceptByLookupRow, true),\n      failure: scout.nvl(failure, false)\n    });\n  }\n\n  _triggerAcceptByText(searchText) {\n    this.trigger('acceptByText', {\n      searchText: searchText,\n      errorStatus: this.errorStatus\n    });\n  }\n\n  /**\n   * Function invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n   */\n  onCellEditorRendered(options) {\n    if (options.openFieldPopup) {\n      this._cellEditorPopup = options.cellEditorPopup;\n      this.openPopup(!this.searchRequired);\n    }\n  }\n\n  additionalLines() {\n    let text = scout.nvl(this.displayText, ''),\n      textLines = text.split('\\n');\n    if (textLines.length > 1) {\n      textLines.shift();\n      return textLines;\n    }\n    return null;\n\n  }\n\n  _createLoadingSupport() {\n    return new SimpleLoadingSupport({\n      widget: this,\n      loadingIndicatorDelay: 400 // ms\n    });\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _isInitialShowStatus() {\n    if (this.touchMode && (this._pendingOpenPopup || this.isPopupOpen())) {\n      // Do not display a tooltip if the touch popup is open, the tooltip will be displayed there\n      return false;\n    }\n    return super._isInitialShowStatus();\n  }\n\n  /**\n   * In touch mode, we must close the cell editor popup explicitly, because the touch-popup and its glasspane\n   * prevents the cell editor popup from receiving mouse down events.\n   */\n  acceptInputFromField(otherField) {\n    this._copyValuesFromField(otherField);\n\n    if (this._cellEditorPopup) {\n      // this will call acceptInput on the touch smart-field (== this)\n      this._cellEditorPopup.completeEdit();\n      this._cellEditorPopup = null;\n    } else {\n      this.acceptInput();\n    }\n  }\n\n  /**\n   * This function is overridden by ProposalField because it has a different behavior than the smart-field.\n   */\n  _copyValuesFromField(otherField) {\n    if (this.lookupRow !== otherField.lookupRow) {\n      this.setLookupRow(otherField.lookupRow);\n    }\n    this.setErrorStatus(otherField.errorStatus);\n    this.setDisplayText(otherField.displayText);\n  }\n\n  _setNotUniqueError(searchText) {\n    this.setErrorStatus(Status.error({\n      message: this.session.text('SmartFieldNotUnique', searchText),\n      code: SmartField.ErrorCode.NOT_UNIQUE\n    }));\n  }\n\n  _hasNotUniqueError(searchText) {\n    return this._notUnique || this._hasUiError(SmartField.ErrorCode.NOT_UNIQUE);\n  }\n\n  _errorStatus() {\n    return this.lookupStatus || this.errorStatus;\n  }\n\n  setLookupStatus(lookupStatus) {\n    this.setProperty('lookupStatus', lookupStatus);\n    if (this.rendered) {\n      this._renderErrorStatus();\n    }\n  }\n\n  clearErrorStatus() {\n    this.setErrorStatus(null);\n    this._clearLookupStatus();\n  }\n\n  _clearLookupStatus() {\n    this.setLookupStatus(null);\n  }\n\n  /**\n   * Checks if there is a lookup status that needs to be set as error status\n   * before we leave the smart-field. The lookup status is set to null, because\n   * it is a temporary state that is only important while the user executes a lookup.\n   */\n  _flushLookupStatus() {\n    if (!this.lookupStatus) {\n      return;\n    }\n\n    if (this.lookupStatus.code === SmartField.ErrorCode.NO_RESULTS ||\n      this.lookupStatus.code === SmartField.ErrorCode.NOT_UNIQUE) {\n      let errorStatus = this.lookupStatus.clone();\n      errorStatus.severity = Status.Severity.ERROR;\n      this.setErrorStatus(errorStatus);\n    }\n\n    this._clearLookupStatus();\n  }\n\n  requestInput() {\n    if (this.enabledComputed && this.rendered) {\n      this.focus();\n      this.openPopup(!this.searchRequired);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}