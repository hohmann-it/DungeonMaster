{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ContextMenuPopup, defaultValues, Device, DoubleClickSupport, dragAndDrop, FilterSupport, graphics, HtmlComponent, KeyStrokeContext, keyStrokeModifier, LazyNodeFilter, MenuBar, MenuDestinations, MenuItemsOrder, menus as menus_1, objects, Range, scout, scrollbars, tooltips, TreeBreadcrumbFilter, TreeCollapseAllKeyStroke, TreeCollapseOrDrillUpKeyStroke, TreeExpandOrDrillDownKeyStroke, TreeLayout, TreeNavigationDownKeyStroke, TreeNavigationEndKeyStroke, TreeNavigationUpKeyStroke, TreeNode, TreeSpaceKeyStroke, Widget } from '../index';\nimport $ from 'jquery';\n\n/**\n * @class\n * @constructor\n */\nexport default class Tree extends Widget {\n  constructor() {\n    super();\n    this.toggleBreadcrumbStyleEnabled = false;\n    this.breadcrumbTogglingThreshold = null;\n    this.autoCheckChildren = false;\n    this.checkable = false;\n    this.checkableStyle = Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n    this.displayStyle = Tree.DisplayStyle.DEFAULT;\n    this.dropType = 0;\n    this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    this.lazyExpandingEnabled = true;\n    this.menus = [];\n    this.contextMenu = null;\n    this.menuBar = null;\n    this.keyStrokes = [];\n    this.multiCheck = true;\n    this.nodes = []; // top-level nodes\n    this.nodesMap = {}; // all nodes by id\n    this.nodePaddingLevelCheckable = 23; /* padding for one tree-level if the tree is checkable */\n    this.nodePaddingLevelNotCheckable = 18; /* padding for one tree-level if the tree is not checkable. this includes outline trees! */\n    this.nodePaddingLevelDiffParentHasIcon = null; /* is read from CSS */\n    this.nodePaddingLeft = null; /* is read from CSS */\n    this.nodeCheckBoxPaddingLeft = 29;\n    this.nodeControlPaddingLeft = null; /* is read from CSS */\n    this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n    this.scrollToSelection = false;\n    this.scrollTop = 0;\n    this.scrollTopHistory = []; // Only necessary for breadcrumb mode\n    this.selectedNodes = [];\n    this.prevSelectedNode = null; // The previously selected node, relevant for breadcrumb in compact mode\n\n    this.filters = [];\n    this.textFilterEnabled = true;\n    this.filterSupport = this._createFilterSupport();\n    this.filteredElementsDirty = false;\n    this.filterAnimated = true;\n\n    // performance optimization: E.g. rather than iterating over the whole tree when unchecking all nodes,\n    // we explicitly keep track of nodes to uncheck (useful e.g. for single-check mode in very large trees).\n    this.checkedNodes = [];\n    this.groupedNodes = {};\n    this.visibleNodesFlat = [];\n    this.visibleNodesMap = {};\n    this._addWidgetProperties(['menus', 'keyStrokes']);\n    this._additionalContainerClasses = ''; // may be used by subclasses to set additional CSS classes\n    this._doubleClickSupport = new DoubleClickSupport();\n    this._$animationWrapper = null; // used by _renderExpansion()\n    this._$expandAnimationWrappers = [];\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._popupOpenHandler = this._onDesktopPopupOpen.bind(this);\n\n    // contains all parents of a selected node, the selected node and the first level children\n    this._inSelectionPathList = {};\n    this._changeNodeTaskScheduled = false;\n    this.viewRangeRendered = new Range(0, 0);\n    this.viewRangeSize = 20;\n    this.startAnimationFunc = function () {\n      this.runningAnimations++;\n    }.bind(this);\n    this.runningAnimations = 0;\n    this.runningAnimationsFinishFunc = function () {\n      this.runningAnimations--;\n      if (this.runningAnimations <= 0) {\n        this.runningAnimations = 0;\n        this._renderViewportBlocked = false;\n        this.invalidateLayoutTree();\n      }\n    }.bind(this);\n    this.nodeHeight = 0;\n    this.nodeWidth = 0;\n    this.maxNodeWidth = 0;\n    this.nodeWidthDirty = false;\n    this.$data = null;\n    this._scrolldirections = 'both';\n    this.requestFocusOnNodeControlMouseDown = true;\n    this._$mouseDownNode = null;\n  }\n  _init(model) {\n    super._init(model);\n    this.setFilters(this.filters, false);\n    this.addFilter(new LazyNodeFilter(this), false);\n    this.breadcrumbFilter = new TreeBreadcrumbFilter(this);\n    if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n      this.addFilter(this.breadcrumbFilter, false);\n    }\n    this.initialTraversing = true;\n    this._setCheckable(this.checkable);\n    this._ensureTreeNodes(this.nodes);\n    this._initNodes(this.nodes);\n    this.initialTraversing = false;\n    this.menuBar = scout.create('MenuBar', {\n      parent: this,\n      position: MenuBar.Position.BOTTOM,\n      menuOrder: new MenuItemsOrder(this.session, 'Tree'),\n      menuFilter: this._filterMenusHandler,\n      cssClass: 'bounded'\n    });\n    this._updateItemPath(true);\n    this._setDisplayStyle(this.displayStyle);\n    this._setKeyStrokes(this.keyStrokes);\n    this._setMenus(this.menus);\n  }\n\n  /**\n   * Initialize nodes, applies filters and updates flat list\n   */\n  _initNodes(nodes, parentNode) {\n    if (!nodes) {\n      nodes = this.nodes;\n    }\n    Tree.visitNodes(this._initTreeNode.bind(this), nodes, parentNode);\n    if (typeof this.selectedNodes[0] === 'string') {\n      this.selectedNodes = this._nodesByIds(this.selectedNodes);\n    }\n    this._updateSelectionPath();\n    nodes.forEach(node => this.applyFiltersForNode(node));\n    Tree.visitNodes((node, parentNode) => this._addToVisibleFlatList(node, false), nodes, parentNode);\n  }\n\n  /**\n   * Iterates through the given array and converts node-models to instances of TreeNode (or a subclass).\n   * If the array element is already a TreeNode the function leaves the element untouched. This function also\n   * ensures that the attribute childNodeIndex is set. By default we use the order of the nodes array as index\n   * but only if childNodeIndex is undefined.\n   *\n   * @param nodes Array of node-models (plain object) or nodes (instance of TreeNode)\n   */\n  _ensureTreeNodes(nodes) {\n    let i, node;\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      node.childNodeIndex = scout.nvl(node.childNodeIndex, i);\n      if (node instanceof TreeNode) {\n        continue;\n      }\n      nodes[i] = this._createTreeNode(node);\n    }\n  }\n  _createTreeNode(nodeModel) {\n    nodeModel = scout.nvl(nodeModel, {});\n    nodeModel.parent = this;\n    return scout.create('TreeNode', nodeModel);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this._initTreeKeyStrokeContext();\n  }\n  _initTreeKeyStrokeContext() {\n    let modifierBitMask = keyStrokeModifier.NONE;\n    this.keyStrokeContext.registerKeyStroke([new TreeSpaceKeyStroke(this), new TreeNavigationUpKeyStroke(this, modifierBitMask), new TreeNavigationDownKeyStroke(this, modifierBitMask), new TreeCollapseAllKeyStroke(this, modifierBitMask), new TreeCollapseOrDrillUpKeyStroke(this, modifierBitMask), new TreeNavigationEndKeyStroke(this, modifierBitMask), new TreeExpandOrDrillDownKeyStroke(this, modifierBitMask)]);\n  }\n  _setMenus(argMenus) {\n    this.updateKeyStrokes(argMenus, this.menus);\n    this._setProperty('menus', argMenus);\n    this._updateMenuBar();\n  }\n  _updateMenuBar() {\n    let menuItems = this._filterMenus(this.menus, MenuDestinations.MENU_BAR, false, true);\n    this.menuBar.setMenuItems(menuItems);\n    let contextMenuItems = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true);\n    if (this.contextMenu) {\n      this.contextMenu.updateMenuItems(contextMenuItems);\n    }\n  }\n  _setKeyStrokes(keyStrokes) {\n    this.updateKeyStrokes(keyStrokes, this.keyStrokes);\n    this._setProperty('keyStrokes', keyStrokes);\n  }\n  _resetTreeNode(node, parentNode) {\n    node.reset();\n  }\n  isSelectedNode(node) {\n    return this.selectedNodes.indexOf(node) > -1;\n  }\n  _updateSelectionPath() {\n    let selectedNode = this.selectedNodes[0];\n    if (!selectedNode) {\n      return;\n    }\n    this._inSelectionPathList[selectedNode.id] = true;\n    selectedNode.childNodes.forEach(child => {\n      this._inSelectionPathList[child.id] = true;\n    });\n    let parentNode = selectedNode.parentNode;\n    while (parentNode) {\n      this._inSelectionPathList[parentNode.id] = true;\n      parentNode = parentNode.parentNode;\n    }\n  }\n  _initTreeNode(node, parentNode) {\n    this.nodesMap[node.id] = node;\n    if (parentNode) {\n      node.parentNode = parentNode;\n      node.level = node.parentNode.level + 1;\n    }\n    if (node.checked) {\n      this.checkedNodes.push(node);\n    }\n    this._initTreeNodeInternal(node, parentNode);\n    this._updateMarkChildrenChecked(node, true, node.checked);\n    node.initialized = true;\n  }\n  _applyNodeDefaultValues(node) {\n    defaultValues.applyTo(node, 'TreeNode');\n  }\n\n  /**\n   * Override this function if you want a custom node init before filtering.\n   * The default impl. applies default values to the given node.\n   */\n  _initTreeNodeInternal(node, parentNode) {\n    this._applyNodeDefaultValues(node);\n  }\n  _destroy() {\n    super._destroy();\n    this.visitNodes(this._destroyTreeNode.bind(this));\n    this.nodes = []; // finally, clear array with root tree-nodes\n  }\n\n  _destroyTreeNode(node) {\n    delete this.nodesMap[node.id];\n    this._removeFromFlatList(node, false); // ensure node is not longer in visible nodes list.\n    node.destroy();\n\n    // noinspection JSUnresolvedVariable\n    if (this._onNodeDeleted) {\n      // Necessary for subclasses\n      this._onNodeDeleted(node);\n    }\n  }\n\n  /**\n   * pre-order (top-down) traversal of the tree-nodes of this tree.<br>\n   * if func returns true the children of the visited node are not visited.\n   */\n  visitNodes(func, parentNode) {\n    return Tree.visitNodes(func, this.nodes, parentNode);\n  }\n  _render() {\n    this.$container = this.$parent.appendDiv('tree');\n    if (this._additionalContainerClasses) {\n      this.$container.addClass(this._additionalContainerClasses);\n    }\n    let layout = new TreeLayout(this);\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(layout);\n    this._renderData();\n    this.menuBar.render();\n    this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    this._renderCheckableStyle();\n  }\n  _renderData() {\n    this.$data = this.$container.appendDiv('tree-data').on('contextmenu', this._onContextMenu.bind(this)).on('mousedown', '.tree-node', this._onNodeMouseDown.bind(this)).on('mouseup', '.tree-node', this._onNodeMouseUp.bind(this)).on('dblclick', '.tree-node', this._onNodeDoubleClick.bind(this)).on('mousedown', '.tree-node-control', this._onNodeControlMouseDown.bind(this)).on('mouseup', '.tree-node-control', this._onNodeControlMouseUp.bind(this)).on('dblclick', '.tree-node-control', this._onNodeControlDoubleClick.bind(this));\n    HtmlComponent.install(this.$data, this.session);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$data.toggleClass('scrollable-tree', true);\n    }\n    this._installScrollbars({\n      axis: this._scrolldirections\n    });\n    this._installNodeTooltipSupport();\n    this._updateNodeDimensions();\n    // render display style before viewport (not in renderProperties) to have a correct style from the beginning\n    this._renderDisplayStyle();\n    this._renderViewport();\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderTextFilterEnabled();\n  }\n  _postRender() {\n    super._postRender();\n    this._renderSelection();\n  }\n  _remove() {\n    this.session.desktop.off('popupOpen', this._popupOpenHandler);\n    this.filterSupport.remove();\n\n    // stop all animations\n    if (this._$animationWrapper) {\n      this._$animationWrapper.stop(false, true);\n    }\n    // Detach nodes from jQuery objects (because those will be removed)\n    this.visitNodes(this._resetTreeNode.bind(this));\n    dragAndDrop.uninstallDragAndDropHandler(this);\n    this._uninstallNodeTooltipSupport();\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.$data = null;\n    // reset rendered view range because no range is rendered\n    this.viewRangeRendered = new Range(0, 0);\n    super._remove();\n  }\n  isHorizontalScrollingEnabled() {\n    return this._scrolldirections === 'both' || this._scrolldirections === 'x';\n  }\n  isTreeNodeCheckEnabled() {\n    return this.checkableStyle === Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    let scrollToSelectionBackup = this.scrollToSelection;\n    this.scrollToSelection = false;\n    let scrollTop = this.$data[0].scrollTop;\n    let scrollLeft = this.$data[0].scrollLeft;\n    if (this.scrollTop !== scrollTop && this.rendered) {\n      this._renderViewport();\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n    this.scrollToSelection = scrollToSelectionBackup;\n  }\n\n  /**\n   * @override\n   */\n  setScrollTop(scrollTop) {\n    this.setProperty('scrollTop', scrollTop);\n    // call _renderViewport to make sure nodes are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed\n    if (this.rendered) {\n      this._renderViewport();\n      // Render scroll top again to make sure the data really is at the expected position\n      // This seems only to be necessary for Chrome and the tree, it seems to work for IE and table.\n      // It is not optimal, because actually it should be possible to modify the $data[0].scrollTop without using this function\n      // Some debugging showed that after reducing the height of the afterFiller in _renderFiller the scrollTop will be wrong.\n      // Updating the scrollTop in renderFiller or other view range relevant function is bad because it corrupts smooth scrolling (see also commit c14ce92e0a7bff568d4f2d715e3061a782e728c2)\n      this._renderScrollTop();\n    }\n  }\n\n  /**\n   * @override\n   */\n  _renderScrollTop() {\n    if (this.rendering) {\n      // Not necessary to do it while rendering since it will be done by the layout\n      return;\n    }\n    scrollbars.scrollTop(this.$data, this.scrollTop);\n  }\n\n  /**\n   * @override\n   */\n  get$Scrollable() {\n    return this.$data;\n  }\n  _renderViewport() {\n    if (this.runningAnimations > 0 || this._renderViewportBlocked) {\n      // animation pending do not render view port because finishing should rerenderViewport\n      return;\n    }\n    if (!this.$container.isEveryParentVisible()) {\n      // If the tree is invisible, the width and height of the nodes cannot be determined\n      // In that case, the tree won't be layouted either -> as soon as it will be layouted, renderViewport will be called again\n      return;\n    }\n    let viewRange = this._calculateCurrentViewRange();\n    this._renderViewRange(viewRange);\n  }\n  _calculateCurrentViewRange() {\n    let node,\n      scrollTop = this.$data[0].scrollTop,\n      maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;\n    if (maxScrollTop === 0 && this.visibleNodesFlat.length > 0) {\n      // no scrollbars visible\n      node = this.visibleNodesFlat[0];\n    } else {\n      node = this._nodeAtScrollTop(scrollTop);\n    }\n    return this._calculateViewRangeForNode(node);\n  }\n  _rerenderViewport() {\n    if (this._renderViewportBlocked) {\n      return;\n    }\n    this._removeRenderedNodes();\n    this._renderFiller();\n    this._updateDomNodeWidth();\n    this._renderViewport();\n  }\n  _removeRenderedNodes() {\n    let $nodes = this.$data.find('.tree-node');\n    $nodes.each((i, elem) => {\n      let $node = $(elem),\n        node = $node.data('node');\n      if ($node.hasClass('hiding')) {\n        // Do not remove nodes which are removed using an animation\n        return;\n      }\n      this._removeNode(node);\n    });\n    this.viewRangeRendered = new Range(0, 0);\n  }\n  _renderViewRangeForNode(node) {\n    let viewRange = this._calculateViewRangeForNode(node);\n    this._renderViewRange(viewRange);\n  }\n  _renderNodesInRange(range) {\n    let prepend = false;\n    let nodes = this.visibleNodesFlat;\n    if (nodes.length === 0) {\n      return;\n    }\n    let maxRange = new Range(0, nodes.length);\n    range = maxRange.intersect(range);\n    if (this.viewRangeRendered.size() > 0 && !range.intersect(this.viewRangeRendered).equals(new Range(0, 0))) {\n      throw new Error('New range must not intersect with existing.');\n    }\n    if (range.to <= this.viewRangeRendered.from) {\n      prepend = true;\n    }\n    let newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n    let numNodesRendered = this.ensureRangeVisible(range);\n    $.log.isTraceEnabled() && $.log.trace(numNodesRendered + ' new nodes rendered from ' + range);\n  }\n  ensureRangeVisible(range) {\n    let nodes = this.visibleNodesFlat;\n    let nodesToInsert = [];\n    for (let r = range.from; r < range.to; r++) {\n      let node = nodes[r];\n      if (!node.attached) {\n        nodesToInsert.push(node);\n      }\n    }\n    this._insertNodesInDOM(nodesToInsert);\n    return nodesToInsert.length;\n  }\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$data.prependDiv('tree-data-fill');\n    }\n    let fillBeforeDimensions = this._calculateFillerDimension(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeDimensions.height);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$fillBefore.cssWidth(fillBeforeDimensions.width);\n      this.maxNodeWidth = Math.max(fillBeforeDimensions.width, this.maxNodeWidth);\n    }\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeDimensions.height);\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$data.appendDiv('tree-data-fill');\n    }\n    let fillAfterDimensions = {\n      height: 0,\n      width: 0\n    };\n    fillAfterDimensions = this._calculateFillerDimension(new Range(this.viewRangeRendered.to, this.visibleNodesFlat.length));\n    this.$fillAfter.cssHeight(fillAfterDimensions.height);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$fillAfter.cssWidth(fillAfterDimensions.width);\n      this.maxNodeWidth = Math.max(fillAfterDimensions.width, this.maxNodeWidth);\n    }\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterDimensions.height);\n  }\n  _calculateFillerDimension(range) {\n    let dataWidth = 0;\n    if (this.rendered) {\n      // the outer-width is only correct if this tree is already rendered. otherwise wrong values are returned.\n      dataWidth = this.$data.width();\n    }\n    let dimension = {\n      height: 0,\n      width: Math.max(dataWidth, this.maxNodeWidth)\n    };\n    for (let i = range.from; i < range.to; i++) {\n      let node = this.visibleNodesFlat[i];\n      dimension.height += this._heightForNode(node);\n      dimension.width = Math.max(dimension.width, this._widthForNode(node));\n    }\n    return dimension;\n  }\n  _removeNodesInRange(range) {\n    let fromNode,\n      toNode,\n      node,\n      i,\n      numNodesRemoved = 0,\n      nodes = this.visibleNodesFlat;\n    let maxRange = new Range(0, nodes.length);\n    range = maxRange.intersect(range);\n    fromNode = nodes[range.from];\n    toNode = nodes[range.to];\n    let newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove nodes at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n    for (i = range.from; i < range.to; i++) {\n      node = nodes[i];\n      this._removeNode(node);\n      numNodesRemoved++;\n    }\n    $.log.isTraceEnabled() && $.log.trace(numNodesRemoved + ' nodes removed from ' + range + '.');\n  }\n\n  /**\n   * Just removes the node, does NOT adjust this.viewRangeRendered\n   */\n  _removeNode(node) {\n    let $node = node.$node;\n    if (!$node) {\n      return;\n    }\n    if ($node.hasClass('hiding')) {\n      // Do not remove nodes which are removed using an animation\n      return;\n    }\n    // only remove node\n    $node.detach();\n    node.attached = false;\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {\n      // When node with has changed (because of changes in layout) we must at least\n      // update the internal node width even though the view-range has not changed.\n      if (this.nodeWidthDirty) {\n        this._renderFiller();\n        this._updateDomNodeWidth();\n      }\n\n      // Range already rendered -> do nothing\n      return;\n    }\n    if (!this.viewRangeDirty) {\n      let rangesToRender = viewRange.subtract(this.viewRangeRendered);\n      let rangesToRemove = this.viewRangeRendered.subtract(viewRange);\n      let maxRange = new Range(0, this.visibleNodesFlat.length);\n      rangesToRemove.forEach(range => {\n        this._removeNodesInRange(range);\n        if (maxRange.to < range.to) {\n          this.viewRangeRendered = viewRange;\n        }\n      });\n      rangesToRender.forEach(range => {\n        this._renderNodesInRange(range);\n      });\n    } else {\n      // expansion changed\n      this.viewRangeRendered = viewRange;\n      this.ensureRangeVisible(viewRange);\n    }\n\n    // check if at least last and first row in range got correctly rendered\n    if (this.viewRangeRendered.size() > 0) {\n      let nodes = this.visibleNodesFlat;\n      let firstNode = nodes[this.viewRangeRendered.from];\n      let lastNode = nodes[this.viewRangeRendered.to - 1];\n      if (this.viewRangeDirty) {\n        // cleanup nodes before range and after\n        let $nodesBeforeFirstNode = firstNode.$node.prevAll('.tree-node');\n        let $nodesAfterLastNode = lastNode.$node.nextAll('.tree-node');\n        this._cleanupNodes($nodesBeforeFirstNode);\n        this._cleanupNodes($nodesAfterLastNode);\n      }\n      if (!firstNode.attached || !lastNode.attached) {\n        throw new Error('Nodes not rendered as expected. ' + this.viewRangeRendered + '. First: ' + graphics.debugOutput(firstNode.$node) + '. Last: ' + graphics.debugOutput(lastNode.$node) + '. Length: visibleNodesFlat=' + this.visibleNodesFlat.length + ' nodes=' + this.nodes.length + ' nodesMap=' + Object.keys(this.nodesMap).length);\n      }\n    }\n    this._postRenderViewRange();\n    this.viewRangeDirty = false;\n  }\n  _postRenderViewRange() {\n    this._renderFiller();\n    this._updateDomNodeWidth();\n    this._renderSelection();\n  }\n  _visibleNodesInViewRange() {\n    return this.visibleNodesFlat.slice(this.viewRangeRendered.from, this.viewRangeRendered.to);\n  }\n  _updateDomNodeWidth() {\n    if (!this.isHorizontalScrollingEnabled()) {\n      return;\n    }\n    if (!this.rendered || !this.nodeWidthDirty) {\n      return;\n    }\n    let nodes = this._visibleNodesInViewRange();\n    let maxNodeWidth = this.maxNodeWidth;\n    // find max-width\n    maxNodeWidth = nodes.reduce((aggr, node) => {\n      return Math.max(node.width, aggr);\n    }, scout.nvl(maxNodeWidth, 0));\n    // set max width on all nodes\n    nodes.forEach(node => {\n      node.$node.cssWidth(maxNodeWidth);\n    });\n    this.nodeWidthDirty = false;\n  }\n  _cleanupNodes($nodes) {\n    for (let i = 0; i < $nodes.length; i++) {\n      this._removeNode($nodes.eq(i).data('node'));\n    }\n  }\n\n  /**\n   * Returns the index of the node which is at position scrollTop.\n   */\n  _nodeAtScrollTop(scrollTop) {\n    let height = 0,\n      nodeTop;\n    this.visibleNodesFlat.some((node, i) => {\n      height += this._heightForNode(node);\n      if (scrollTop < height) {\n        nodeTop = node;\n        return true;\n      }\n      return false;\n    });\n    let visibleNodesLength = this.visibleNodesFlat.length;\n    if (!nodeTop && visibleNodesLength > 0) {\n      nodeTop = this.visibleNodesFlat[visibleNodesLength - 1];\n    }\n    return nodeTop;\n  }\n  _heightForNode(node) {\n    let height = 0;\n    if (node.height) {\n      height = node.height;\n    } else {\n      height = this.nodeHeight;\n    }\n    return height;\n  }\n  _widthForNode(node) {\n    let width = 0;\n    if (node.width) {\n      width = node.width;\n    } else {\n      width = this.nodeWidth;\n    }\n    return width;\n  }\n\n  /**\n   * Returns a range of size this.viewRangeSize. Start of range is nodeIndex - viewRangeSize / 4.\n   * -> 1/4 of the nodes are before the viewport 2/4 in the viewport 1/4 after the viewport,\n   * assuming viewRangeSize is 2*number of possible nodes in the viewport (see calculateViewRangeSize).\n   */\n  _calculateViewRangeForNode(node) {\n    let viewRange = new Range(),\n      quarterRange = Math.floor(this.viewRangeSize / Tree.VIEW_RANGE_DIVISOR),\n      diff;\n    let nodeIndex = this.visibleNodesFlat.indexOf(node);\n    viewRange.from = Math.max(nodeIndex - quarterRange, 0);\n    viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleNodesFlat.length);\n    if (!node || nodeIndex === -1) {\n      return viewRange;\n    }\n\n    // Try to use the whole viewRangeSize (extend from if necessary)\n    diff = this.viewRangeSize - viewRange.size();\n    if (diff > 0) {\n      viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n    }\n    return viewRange;\n  }\n\n  /**\n   * Calculates the optimal view range size (number of nodes to be rendered).\n   * It uses the default node height to estimate how many nodes fit in the view port.\n   * The view range size is this value * 2.\n   * <p>\n   * Note: the value calculated by this function is important for calculating the\n   * 'insertBatch'. When the value becomes smaller than 4 ({@link Tree.VIEW_RANGE_DIVISOR}) this\n   * will cause errors on inserting nodes at the right position. See #262890.\n   */\n  calculateViewRangeSize() {\n    // Make sure row height is up to date (row height may be different after zooming)\n    this._updateNodeDimensions();\n    if (this.nodeHeight === 0) {\n      throw new Error('Cannot calculate view range with nodeHeight = 0');\n    }\n    let viewRangeMultiplier = Tree.VIEW_RANGE_DIVISOR / 2; // See  _calculateViewRangeForNode\n    let viewRange = Math.ceil(this.$data.outerHeight() / this.nodeHeight) * viewRangeMultiplier;\n    return Math.max(Tree.VIEW_RANGE_DIVISOR, viewRange);\n  }\n  setViewRangeSize(viewRangeSize) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    if (this.rendered) {\n      this._renderViewport();\n    }\n  }\n  _updateNodeDimensions() {\n    let emptyNode = this._createTreeNode();\n    let $node = this._renderNode(emptyNode).appendTo(this.$data);\n    this.nodeHeight = $node.outerHeight(true);\n    if (this.isHorizontalScrollingEnabled()) {\n      let oldNodeWidth = this.nodeWidth;\n      this.nodeWidth = $node.outerWidth(true);\n      if (oldNodeWidth !== this.nodeWidth) {\n        this.viewRangeDirty = true;\n      }\n    }\n    emptyNode.reset();\n  }\n\n  /**\n   * Updates the node heights for every visible node and clears the height of the others\n   */\n  updateNodeHeights() {\n    this.visibleNodesFlat.forEach(node => {\n      if (!node.attached) {\n        node.height = null;\n      } else {\n        node.height = node.$node.outerHeight(true);\n      }\n    });\n  }\n  removeAllNodes() {\n    this._removeNodes(this.nodes);\n  }\n\n  /**\n   * @param parentNode\n   *          Optional. If provided, this node's state will be updated (e.g. it will be collapsed\n   *          if it does no longer have child nodes). Can also be an array, in which case all of\n   *          those nodes are updated.\n   */\n  _removeNodes(nodes, parentNode) {\n    if (nodes.length === 0) {\n      return;\n    }\n    nodes.forEach(function (node) {\n      this._removeFromFlatList(node, true);\n      if (node.childNodes.length > 0) {\n        this._removeNodes(node.childNodes, node);\n      }\n      if (node.$node) {\n        if (this._$animationWrapper && this._$animationWrapper.find(node.$node).length > 0) {\n          this._$animationWrapper.stop(false, true);\n        }\n        node.reset();\n      }\n    }, this);\n\n    // If every child node was deleted mark node as collapsed (independent of the model state)\n    // --> makes it consistent with addNodes and expand (expansion is not allowed if there are no child nodes)\n    arrays.ensure(parentNode).forEach(p => {\n      if (p && p.$node && p.childNodes.length === 0) {\n        p.$node.removeClass('expanded lazy');\n      }\n    });\n    if (this.rendered) {\n      this.viewRangeDirty = true;\n      this.invalidateLayoutTree();\n    }\n  }\n  _renderNode(node) {\n    let paddingLeft = this._computeNodePaddingLeft(node);\n    node.render(this.$container, paddingLeft);\n    return node.$node;\n  }\n  _removeMenus() {\n    // menubar takes care about removal\n  }\n  _filterMenus(argMenus, destination, onlyVisible, enableDisableKeyStroke) {\n    return menus_1.filterAccordingToSelection('Tree', this.selectedNodes.length, argMenus, destination, onlyVisible, enableDisableKeyStroke);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n    this._installOrUninstallDragAndDropHandler();\n    let enabled = this.enabledComputed;\n    this.$data.setEnabled(enabled);\n    this.$container.setTabbableOrFocusable(enabled);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$data);\n  }\n  setCheckable(checkable) {\n    this.setProperty('checkable', checkable);\n  }\n  _setCheckable(checkable) {\n    this._setProperty('checkable', checkable);\n    this._updateNodePaddingLevel();\n  }\n  _updateNodePaddingLevel() {\n    if (this.isBreadcrumbStyleActive()) {\n      this.nodePaddingLevel = 0;\n    } else if (this.checkable) {\n      this.nodePaddingLevel = this.nodePaddingLevelCheckable;\n    } else {\n      this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n    }\n  }\n  setCheckableStyle(checkableStyle) {\n    this.setProperty('checkableStyle', checkableStyle);\n  }\n  _renderCheckable() {\n    // Define helper functions\n    let isNodeRendered = node => Boolean(node.$node);\n    let updateCheckableStateRec = node => {\n      let $node = node.$node;\n      let $control = $node.children('.tree-node-control');\n      let $checkbox = $node.children('.tree-node-checkbox');\n      node._updateControl($control);\n      if (this.checkable) {\n        if ($checkbox.length === 0) {\n          node._renderCheckbox();\n        }\n      } else {\n        $checkbox.remove();\n      }\n      $node.cssPaddingLeft(this._computeNodePaddingLeft(node));\n\n      // Recursion\n      if (node.childNodes) {\n        node.childNodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n      }\n    };\n\n    // Start recursion\n    this.nodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n  }\n  _renderDisplayStyle() {\n    this.$container.toggleClass('breadcrumb', this.isBreadcrumbStyleActive());\n    this.nodePaddingLeft = null;\n    this.nodeControlPaddingLeft = null;\n    this._updateNodePaddingsLeft();\n    // update scrollbar if mode has changed (from tree to bc or vice versa)\n    this.invalidateLayoutTree();\n  }\n  _renderExpansion(node, options) {\n    let opts = {\n      expandLazyChanged: false,\n      expansionChanged: false\n    };\n    $.extend(opts, options);\n    let $node = node.$node,\n      expanded = node.expanded;\n\n    // Only render if node is rendered to make it possible to expand/collapse currently hidden nodes (used by collapseAll).\n    if (!$node || $node.length === 0) {\n      return;\n    }\n\n    // Only expand / collapse if there are child nodes\n    if (node.childNodes.length === 0) {\n      return true;\n    }\n    $node.toggleClass('lazy', expanded && node.expandedLazy);\n    if (!opts.expansionChanged && !opts.expandLazyChanged) {\n      // Expansion state has not changed -> return\n      return;\n    }\n    if (expanded) {\n      $node.addClass('expanded');\n    } else {\n      $node.removeClass('expanded');\n    }\n  }\n  _renderSelection() {\n    // Add children class to root nodes if no nodes are selected\n    if (this.selectedNodes.length === 0) {\n      this.nodes.forEach(childNode => {\n        if (childNode.rendered) {\n          childNode.$node.addClass('child-of-selected');\n        }\n      }, this);\n    }\n    this.$container.toggleClass('no-nodes-selected', this.selectedNodes.length === 0);\n    this.selectedNodes.forEach(function (node) {\n      if (!this.visibleNodesMap[node.id]) {\n        return;\n      }\n\n      // Mark all ancestor nodes, especially necessary for bread crumb mode\n      let parentNode = node.parentNode;\n      if (parentNode && parentNode.rendered) {\n        parentNode.$node.addClass('parent-of-selected');\n      }\n      while (parentNode) {\n        if (parentNode.rendered) {\n          parentNode.$node.addClass('ancestor-of-selected');\n        }\n        parentNode = parentNode.parentNode;\n      }\n\n      // Mark all child nodes\n      if (node.expanded) {\n        node.childNodes.forEach(childNode => {\n          if (childNode.rendered) {\n            childNode.$node.addClass('child-of-selected');\n          }\n        }, this);\n      }\n      if (node.rendered) {\n        node.$node.select(true);\n      }\n    }, this);\n\n    // Update 'group' markers for all rendered nodes\n    for (let i = this.viewRangeRendered.from; i < this.viewRangeRendered.to; i++) {\n      if (i >= this.visibleNodesFlat.length) {\n        break;\n      }\n      let node = this.visibleNodesFlat[i];\n      if (node && node.rendered) {\n        node.$node.toggleClass('group', Boolean(this.groupedNodes[node.id]));\n      }\n    }\n    this._updateNodePaddingsLeft();\n    this._highlightPrevSelectedNode();\n    if (this.scrollToSelection) {\n      this.revealSelection();\n    }\n  }\n  _renderCheckableStyle() {\n    this.$data.toggleClass('checkable', this.isTreeNodeCheckEnabled());\n  }\n  _highlightPrevSelectedNode() {\n    if (!this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    if (!this.prevSelectedNode || !this.prevSelectedNode.rendered || this.prevSelectedNode.prevSelectionAnimationDone) {\n      return;\n    }\n    // Highlight previously selected node, but do it only once\n    if (this.prevSelectedNode.$node.hasClass('animate-prev-selected')) {\n      return this;\n    }\n    this.prevSelectedNode.$node.addClassForAnimation('animate-prev-selected').oneAnimationEnd(() => {\n      this.prevSelectedNode.prevSelectionAnimationDone = true;\n    });\n  }\n  _removeSelection() {\n    // Remove children class on root nodes if no nodes were selected\n    if (this.selectedNodes.length === 0) {\n      this.nodes.forEach(childNode => {\n        if (childNode.rendered) {\n          childNode.$node.removeClass('child-of-selected');\n        }\n      }, this);\n    }\n\n    // Ensure animate-prev-selected class is removed (in case animation did not start)\n    if (this.prevSelectedNode && this.prevSelectedNode.rendered) {\n      this.prevSelectedNode.$node.removeClass('animate-prev-selected');\n    }\n    this.selectedNodes.forEach(this._removeNodeSelection, this);\n  }\n  _removeNodeSelection(node) {\n    if (node.rendered) {\n      node.$node.select(false);\n    }\n\n    // remove ancestor and child classes\n    let parentNode = node.parentNode;\n    if (parentNode && parentNode.rendered) {\n      parentNode.$node.removeClass('parent-of-selected');\n    }\n    while (parentNode && parentNode.rendered) {\n      parentNode.$node.removeClass('ancestor-of-selected');\n      parentNode = parentNode.parentNode;\n    }\n    if (node.expanded) {\n      node.childNodes.forEach(childNode => {\n        if (childNode.rendered) {\n          childNode.$node.removeClass('child-of-selected');\n        }\n      }, this);\n    }\n  }\n  setDropType(dropType) {\n    this.setProperty('dropType', dropType);\n  }\n  _renderDropType() {\n    this._installOrUninstallDragAndDropHandler();\n  }\n  setDropMaximumSize(dropMaximumSize) {\n    this.setProperty('dropMaximumSize', dropMaximumSize);\n  }\n  _installOrUninstallDragAndDropHandler() {\n    dragAndDrop.installOrUninstallDragAndDropHandler({\n      target: this,\n      doInstall: () => this.dropType && this.enabledComputed,\n      selector: '.tree-data,.tree-node',\n      onDrop: event => this.trigger('drop', event),\n      dropType: () => this.dropType,\n      additionalDropProperties: event => {\n        let $target = $(event.currentTarget);\n        let properties = {\n          nodeId: ''\n        };\n        if ($target.hasClass('tree-node')) {\n          let node = $target.data('node');\n          properties.nodeId = node.id;\n        }\n        return properties;\n      }\n    });\n  }\n  _updateMarkChildrenChecked(node, init, checked, checkChildrenChecked) {\n    if (!this.checkable) {\n      return;\n    }\n    if (checkChildrenChecked) {\n      let childrenFound = false;\n      for (let j = 0; j < node.childNodes.length > 0; j++) {\n        let childNode = node.childNodes[j];\n        if (childNode.checked || childNode.childrenChecked) {\n          node.childrenChecked = true;\n          checked = true;\n          childrenFound = true;\n          if (this.rendered && node.$node) {\n            node.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', true);\n          }\n          break;\n        }\n      }\n      if (!childrenFound) {\n        node.childrenChecked = false;\n        if (this.rendered && node.$node) {\n          node.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', false);\n        }\n      }\n    }\n    if (!node.parentNode || node.parentNode.checked) {\n      return;\n    }\n    let stateChanged = false;\n    if (!checked && !init) {\n      // node was unchecked check siblings\n      let hasCheckedSiblings = false;\n      for (let i = 0; i < node.parentNode.childNodes.length > 0; i++) {\n        let siblingNode = node.parentNode.childNodes[i];\n        if (siblingNode.checked || siblingNode.childrenChecked) {\n          hasCheckedSiblings = true;\n          break;\n        }\n      }\n      if (hasCheckedSiblings !== node.parentNode.childrenChecked) {\n        // parentNode.checked should be false\n        node.parentNode.childrenChecked = hasCheckedSiblings;\n        stateChanged = true;\n      }\n    }\n    if (checked && !node.parentNode.childrenChecked) {\n      node.parentNode.childrenChecked = true;\n      stateChanged = true;\n    }\n    if (stateChanged) {\n      this._updateMarkChildrenChecked(node.parentNode, init, checked);\n      if (this.rendered && node.parentNode.$node) {\n        if (checked) {\n          node.parentNode.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', true);\n        } else {\n          node.parentNode.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', false);\n        }\n      }\n    }\n  }\n  _installNodeTooltipSupport() {\n    tooltips.install(this.$data, {\n      parent: this,\n      selector: '.tree-node',\n      text: this._nodeTooltipText.bind(this),\n      arrowPosition: 50,\n      arrowPositionUnit: '%',\n      nativeTooltip: !Device.get().isCustomEllipsisTooltipPossible()\n    });\n  }\n  _uninstallNodeTooltipSupport() {\n    tooltips.uninstall(this.$data);\n  }\n  _nodeTooltipText($node) {\n    let node = $node.data('node');\n    if (node.tooltipText) {\n      return node.tooltipText;\n    } else if (this._isTruncatedNodeTooltipEnabled() && $node.isContentTruncated()) {\n      return node.$text.text();\n    }\n  }\n  _isTruncatedNodeTooltipEnabled() {\n    return true;\n  }\n  setDisplayStyle(displayStyle) {\n    if (this.displayStyle === displayStyle) {\n      return;\n    }\n    this._renderViewportBlocked = true;\n    this._setDisplayStyle(displayStyle);\n    if (this.rendered) {\n      this._renderDisplayStyle();\n    }\n    this._renderViewportBlocked = false;\n  }\n  _setDisplayStyle(displayStyle) {\n    this._setProperty('displayStyle', displayStyle);\n    if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n      if (this.selectedNodes.length > 0) {\n        let selectedNode = this.selectedNodes[0];\n        if (!selectedNode.expanded) {\n          this.expandNode(selectedNode);\n        }\n      }\n      this.filterAnimated = false;\n      this.addFilter(this.breadcrumbFilter, false);\n      this.filterVisibleNodes();\n    } else {\n      this.removeFilter(this.breadcrumbFilter);\n      this.filterAnimated = true;\n    }\n    this._updateNodePaddingLevel();\n  }\n  _updateNodePaddingsLeft() {\n    this.$nodes().each((index, element) => {\n      let $node = $(element);\n      let node = $node.data('node');\n      let paddingLeft = this._computeNodePaddingLeft(node);\n      $node.cssPaddingLeft(objects.isNullOrUndefined(paddingLeft) ? '' : paddingLeft);\n      node._updateControl($node.children('.tree-node-control'));\n    });\n  }\n  setBreadcrumbStyleActive(active) {\n    if (active) {\n      this.setDisplayStyle(Tree.DisplayStyle.BREADCRUMB);\n    } else {\n      this.setDisplayStyle(Tree.DisplayStyle.DEFAULT);\n    }\n  }\n  isNodeInBreadcrumbVisible(node) {\n    return this._inSelectionPathList[node.id] === undefined ? false : this._inSelectionPathList[node.id];\n  }\n  isBreadcrumbStyleActive() {\n    return this.displayStyle === Tree.DisplayStyle.BREADCRUMB;\n  }\n  setToggleBreadcrumbStyleEnabled(enabled) {\n    this.setProperty('toggleBreadcrumbStyleEnabled', enabled);\n  }\n  setBreadcrumbTogglingThreshold(width) {\n    this.setProperty('breadcrumbTogglingThreshold', width);\n  }\n  expandNode(node, opts) {\n    this.setNodeExpanded(node, true, opts);\n  }\n  collapseNode(node, opts) {\n    this.setNodeExpanded(node, false, opts);\n  }\n  collapseAll() {\n    this.rebuildSuppressed = true;\n    // Collapse all expanded child nodes (only model)\n    this.visitNodes(node => {\n      this.collapseNode(node);\n    });\n    if (this.rendered) {\n      // ensure correct rendering\n      this._rerenderViewport();\n    }\n    this.rebuildSuppressed = false;\n  }\n  setNodeExpanded(node, expanded, opts) {\n    opts = opts || {};\n    let lazy = opts.lazy;\n    if (objects.isNullOrUndefined(lazy)) {\n      if (node.expanded === expanded) {\n        // no state change: Keep the current \"expandedLazy\" state\n        lazy = node.expandedLazy;\n      } else if (expanded) {\n        // collapsed -> expanded: Set the \"expandedLazy\" state to the node's \"lazyExpandingEnabled\" flag\n        lazy = node.lazyExpandingEnabled;\n      } else {\n        // expanded -> collapsed: Set the \"expandedLazy\" state to false\n        lazy = false;\n      }\n    }\n    let renderAnimated = scout.nvl(opts.renderAnimated, true);\n\n    // Never do lazy expansion if it is disabled on the tree\n    if (!this.lazyExpandingEnabled) {\n      lazy = false;\n    }\n    if (this.isBreadcrumbStyleActive()) {\n      // Do not allow to collapse a selected node\n      if (!expanded && this.selectedNodes.indexOf(node) > -1) {\n        this.setNodeExpanded(node, true, opts);\n        return;\n      }\n    }\n\n    // Optionally collapse all children (recursively)\n    if (opts.collapseChildNodes) {\n      // Suppress render expansion\n      let childOpts = objects.valueCopy(opts);\n      childOpts.renderExpansion = false;\n      node.childNodes.forEach(childNode => {\n        if (childNode.expanded) {\n          this.collapseNode(childNode, childOpts);\n        }\n      });\n    }\n    let renderExpansionOpts = {\n      expansionChanged: false,\n      expandLazyChanged: false\n    };\n\n    // Set expansion state\n    if (node.expanded !== expanded || node.expandedLazy !== lazy) {\n      renderExpansionOpts.expansionChanged = node.expanded !== expanded;\n      renderExpansionOpts.expandLazyChanged = node.expandedLazy !== lazy;\n      node.expanded = expanded;\n      node.expandedLazy = lazy;\n      if (renderExpansionOpts.expansionChanged) {\n        if (node.parentNode) {\n          // ensure node is visible under the parent node if there is a parent.\n          this._rebuildParent(node.parentNode, opts);\n        } else if (node.filterAccepted) {\n          this._addToVisibleFlatList(node, false);\n        } else {\n          this._removeFromFlatList(node, false);\n        }\n      } else if (renderExpansionOpts.expandLazyChanged) {\n        this.applyFiltersForNode(node, false, renderAnimated);\n      }\n      if (this.groupedNodes[node.id]) {\n        this._updateItemPath(false, node);\n      }\n      if (node.expanded) {\n        node.ensureLoadChildren().done(this._addChildrenToFlatList.bind(this, node, null, renderAnimated, null, true /* required that ctrl+shift+add expands all rows of a table-page */));\n      } else {\n        this._removeChildrenFromFlatList(node, renderAnimated);\n      }\n      this.trigger('nodeExpanded', {\n        node: node,\n        expanded: expanded,\n        expandedLazy: lazy\n      });\n      this.viewRangeDirty = true;\n    }\n\n    // Render expansion\n    if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n      this._renderExpansion(node, renderExpansionOpts);\n    }\n    if (this.rendered) {\n      this.ensureExpansionVisible(node);\n    }\n  }\n  setNodeExpandedRecursive(nodes, expanded, opts) {\n    Tree.visitNodes(childNode => {\n      this.setNodeExpanded(childNode, expanded, opts);\n    }, nodes);\n  }\n  _rebuildParent(node, opts) {\n    if (this.rebuildSuppressed) {\n      return;\n    }\n    if (node.expanded || node.expandedLazy) {\n      this._addChildrenToFlatList(node, null, true, null, true /* required so that double clicking a table-page-row expands the clicked child row */);\n    } else {\n      this._removeChildrenFromFlatList(node, false);\n    }\n    // Render expansion\n    if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n      let renderExpansionOpts = {\n        expansionChanged: true\n      };\n      this._renderExpansion(node, renderExpansionOpts);\n    }\n  }\n  _removeChildrenFromFlatList(parentNode, animatedRemove) {\n    // Only if a parent is available the children are available.\n    if (this.visibleNodesMap[parentNode.id]) {\n      let parentIndex = this.visibleNodesFlat.indexOf(parentNode);\n      let elementsToDelete = 0;\n      let parentLevel = parentNode.level;\n      let removedNodes = [];\n      animatedRemove = animatedRemove && this.rendered;\n      if (this._$animationWrapper) {\n        // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n        // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n        // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n        // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n        this._$animationWrapper.stop(false, true);\n      }\n      this._$expandAnimationWrappers.forEach($wrapper => {\n        $wrapper.stop(false, true);\n      });\n      for (let i = parentIndex + 1; i < this.visibleNodesFlat.length; i++) {\n        if (this.visibleNodesFlat[i].level > parentLevel) {\n          let node = this.visibleNodesFlat[i];\n          if (this.isHorizontalScrollingEnabled()) {\n            // if node is the node which defines the widest width then recalculate width for render\n            if (node.width === this.maxNodeWidth) {\n              this.maxNodeWidth = 0;\n              this.nodeWidthDirty = true;\n            }\n          }\n          delete this.visibleNodesMap[this.visibleNodesFlat[i].id];\n          if (node.attached && animatedRemove) {\n            if (!this._$animationWrapper) {\n              this._$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(node.$node);\n              this._$animationWrapper.data('parentNode', parentNode);\n            }\n            if (node.isDescendantOf(this._$animationWrapper.data('parentNode'))) {\n              this._$animationWrapper.append(node.$node);\n            }\n            node.attached = false;\n            node.displayBackup = node.$node.css('display');\n            removedNodes.push(node);\n          } else if (node.attached && !animatedRemove) {\n            this.hideNode(node, false, false);\n          }\n          elementsToDelete++;\n        } else {\n          break;\n        }\n      }\n      this.visibleNodesFlat.splice(parentIndex + 1, elementsToDelete);\n      // animate closing\n      if (animatedRemove) {\n        // don't animate while rendering (not necessary, or may even lead to timing issues)\n        this._renderViewportBlocked = true;\n        if (removedNodes.length > 0) {\n          this._$animationWrapper.animate({\n            height: 0\n          }, {\n            start: this.startAnimationFunc,\n            complete: onAnimationComplete.bind(this, removedNodes),\n            step: this.revalidateLayoutTree.bind(this),\n            duration: 200,\n            queue: false\n          });\n        } else if (this._$animationWrapper) {\n          this._$animationWrapper.remove();\n          this._$animationWrapper = null;\n          onAnimationComplete.call(this, removedNodes);\n        } else {\n          this._renderViewportBlocked = false;\n        }\n      }\n      return removedNodes;\n    }\n\n    // ----- Helper functions -----\n    function onAnimationComplete(affectedNodes) {\n      affectedNodes.forEach(node => {\n        node.$node.detach();\n        node.$node.css('display', node.displayBackup);\n        node.displayBackup = null;\n      });\n      if (this._$animationWrapper) {\n        this._$animationWrapper.remove();\n        this._$animationWrapper = null;\n      }\n      this.runningAnimationsFinishFunc();\n    }\n  }\n  _removeFromFlatList(node, animatedRemove) {\n    if (this.visibleNodesMap[node.id]) {\n      let index = this.visibleNodesFlat.indexOf(node);\n      this._removeChildrenFromFlatList(node, false);\n      if (this.isHorizontalScrollingEnabled()) {\n        // if node is the node which defines the widest width then recalculate width for render\n        if (node.width === this.maxNodeWidth) {\n          this.maxNodeWidth = 0;\n          this.nodeWidthDirty = true;\n        }\n      }\n      this.visibleNodesFlat.splice(index, 1);\n      delete this.visibleNodesMap[node.id];\n      this.hideNode(node, animatedRemove);\n    }\n  }\n\n  /**\n   * @returns {boolean} whether or not the function added a node to the flat list\n   */\n  _addToVisibleFlatList(node, renderingAnimated) {\n    // if node already is in visible list don't do anything. If no parentNode is available this node is on toplevel, if a parent is available\n    // it has to be in visible list and also be expanded\n    if (!this.visibleNodesMap[node.id] && node.filterAccepted && (!node.parentNode || node.parentNode.expanded && this.visibleNodesMap[node.parentNode.id])) {\n      if (this.initialTraversing) {\n        // for faster index calculation\n        this._addToVisibleFlatListNoCheck(node, this.visibleNodesFlat.length, renderingAnimated);\n      } else {\n        let insertIndex = this._findInsertPositionInFlatList(node);\n        this._addToVisibleFlatListNoCheck(node, insertIndex, renderingAnimated);\n      }\n    }\n  }\n\n  // TODO [7.0] CGU applies to all the add/remove to/from flat list methods:\n  // Is it really necessary to update dom on every operation? why not just update the list and renderViewport at the end?\n  // The update of the flat list is currently implemented quite complicated -> it should be simplified.\n  // And: because add to flat list renders all the children the rendered node count is greater than the viewRangeSize until\n  // the layout renders the viewport again -> this must not happen (can be seen when a node gets expanded)\n  _addChildrenToFlatList(parentNode, parentIndex, animatedRendering, insertBatch, forceFilter) {\n    // add nodes recursively\n    if (!this.visibleNodesMap[parentNode.id]) {\n      return 0;\n    }\n    let isSubAdding = Boolean(insertBatch);\n    parentIndex = parentIndex ? parentIndex : this.visibleNodesFlat.indexOf(parentNode);\n    animatedRendering = animatedRendering && this.rendered; // don't animate while rendering (not necessary, or may even lead to timing issues)\n    if (this._$animationWrapper && !isSubAdding) {\n      // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n      // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n      // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n      // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n      this._$animationWrapper.stop(false, true);\n    }\n    if (insertBatch) {\n      insertBatch.setInsertAt(parentIndex);\n    } else {\n      insertBatch = this.newInsertBatch(parentIndex + 1);\n    }\n    parentNode.childNodes.forEach((node, index) => {\n      if (!node.initialized || !node.isFilterAccepted(forceFilter)) {\n        return;\n      }\n      let insertIndex,\n        isAlreadyAdded = this.visibleNodesMap[node.id];\n      if (isAlreadyAdded) {\n        this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n        // Animate rendering is always false because it would generate a bunch of animation wrappers which stay forever without really starting an animation...\n        this.checkAndHandleBatchAnimationWrapper(parentNode, false, insertBatch);\n        insertBatch = this.newInsertBatch(insertBatch.nextBatchInsertIndex());\n        insertBatch = this._addChildrenToFlatListIfExpanded(1, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n      } else {\n        insertBatch.insertNodes.push(node);\n        this.visibleNodesMap[node.id] = true;\n        insertBatch = this.checkAndHandleBatch(insertBatch, parentNode, animatedRendering);\n        insertBatch = this._addChildrenToFlatListIfExpanded(0, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n      }\n    });\n    if (!isSubAdding) {\n      // animation is not done yet and all added nodes are in visible range\n      this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n      this.invalidateLayoutTree();\n    }\n    return insertBatch;\n  }\n\n  /**\n   * Checks if the given node is expanded, and if that's the case determine the insert index of the node and add its children to the flat list.\n   *\n   * @param {number} indexOffset either 0 or 1, offset is added to the insert index\n   */\n  _addChildrenToFlatListIfExpanded(indexOffset, node, insertIndex, animatedRendering, insertBatch, forceFilter) {\n    if (node.expanded && node.childNodes.length) {\n      if (insertBatch.containsNode(node.parentNode) || insertBatch.length() > 1) {\n        // if parent node is already in the batch, do not change the insertIndex,\n        // only append child nodes below that parent node\n        // Also, if the batch is not empty (i.e. contains more nodes than the current node),\n        // the insert index was already calculated previously and must not be changed.\n        insertIndex = insertBatch.insertAt();\n      } else {\n        insertIndex = this._findInsertPositionInFlatList(node);\n      }\n      insertIndex += indexOffset;\n      insertBatch = this._addChildrenToFlatList(node, insertIndex, animatedRendering, insertBatch, forceFilter);\n    }\n    return insertBatch;\n  }\n  _showNodes(insertBatch) {\n    return this.viewRangeRendered.from + this.viewRangeSize >= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex();\n  }\n\n  /**\n   * This function tries to find the correct insert position within the flat list for the given node.\n   * The function must consider the order of child nodes in the original tree structure and then check\n   * where in the flat list this position is.\n   */\n  _findInsertPositionInFlatList(node) {\n    let childNodes,\n      parentNode = node.parentNode;\n\n    // use root nodes as nodes when no other parent node is available (root case)\n    if (parentNode) {\n      childNodes = parentNode.childNodes;\n    } else {\n      childNodes = this.nodes;\n    }\n\n    // find all visible siblings for our node (incl. our own node, which is probably not yet\n    // in the visible nodes map)\n    let thatNode = node;\n    let siblings = childNodes.filter(node => {\n      return Boolean(this.visibleNodesMap[node.id]) || node === thatNode;\n    });\n\n    // when there are no visible siblings, insert below the parent node\n    if (siblings.length === 0) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n    let nodePos = siblings.indexOf(node);\n\n    // when there are no prev. siblings in the flat list, insert below the parent node\n    if (nodePos === 0) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n    let prevSiblingNode = siblings[nodePos - 1];\n    let prevSiblingPos = this._findPositionInFlatList(prevSiblingNode);\n\n    // when the prev. sibling is not in the flat list, insert below the parent node\n    if (prevSiblingPos === -1) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    // find the index of the last child element of our prev. sibling node\n    // that's where we want to insert the new node. We go down the flat list\n    // starting from the prev. sibling node, until we hit a node that does not\n    // belong to the sub tree of the prev. sibling node.\n    let i, checkNode;\n    for (i = prevSiblingPos; i < this.visibleNodesFlat.length; i++) {\n      checkNode = this.visibleNodesFlat[i];\n      if (!this._isInSameSubTree(prevSiblingNode, checkNode)) {\n        return i;\n      }\n    }\n\n    // insert at the end of the list\n    return this.visibleNodesFlat.length;\n  }\n  _findPositionInFlatList(node) {\n    return this.visibleNodesFlat.indexOf(node);\n  }\n\n  /**\n   * Checks whether the given checkNode belongs to the same sub tree (or is) the given node.\n   * The function goes up all parentNodes of the checkNode.\n   *\n   * @param {TreeNode} node which is used to for the sub tree comparison\n   * @param {TreeNode} checkNode node which is checked against the given node\n   * @returns {boolean}\n   */\n  _isInSameSubTree(node, checkNode) {\n    do {\n      if (checkNode === node || checkNode.parentNode === node) {\n        return true;\n      }\n      checkNode = checkNode.parentNode;\n    } while (checkNode);\n    return false;\n  }\n\n  /**\n   * Returns true if the given node is a child of one of the selected nodes.\n   * The functions goes up the parent node hierarchy.\n   *\n   * @param {TreeNode} node to check\n   * @returns {boolean}\n   */\n  _isChildOfSelectedNodes(node) {\n    while (node) {\n      if (this.selectedNodes.indexOf(node.parentNode) > -1) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * Info: the object created here is a bit weird: the array 'insertNodes' is used as function arguments to the Array#splice function at some point.\n   * The signature of that function is: array.splice(index, deleteCount[, element1[,  element2 [, ...]]])\n   * So the first two elements are numbers and all the following elements are TreeNodes or Pages.\n   * @returns {*}\n   */\n  newInsertBatch(insertIndex) {\n    return {\n      insertNodes: [insertIndex, 0],\n      // second element is always 0 (used as argument for deleteCount in Array#splice)\n      $animationWrapper: null,\n      lastBatchInsertIndex: function () {\n        if (this.isEmpty()) {\n          return this.insertAt();\n        }\n        return this.insertAt() + this.insertNodes.length - 3;\n      },\n      nextBatchInsertIndex: function () {\n        // only NBU knows what this means\n        return this.lastBatchInsertIndex() + (this.isEmpty() ? 1 : 2);\n      },\n      isEmpty: function () {\n        return this.insertNodes.length === 2;\n      },\n      length: function () {\n        return this.insertNodes.length - 2;\n      },\n      insertAt: function () {\n        return this.insertNodes[0];\n      },\n      setInsertAt: function (insertAt) {\n        this.insertNodes[0] = insertAt;\n      },\n      containsNode: function (node) {\n        return this.insertNodes.indexOf(node) !== -1;\n      }\n    };\n  }\n  checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch) {\n    if (animatedRendering && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.to >= insertBatch.lastBatchInsertIndex() && !insertBatch.$animationWrapper) {\n      // we are in visible area so we need a animation wrapper\n      // if parent is in visible area insert after parent else insert before first node.\n      let lastNodeIndex = insertBatch.lastBatchInsertIndex() - 1,\n        nodeBefore = this.viewRangeRendered.from === insertBatch.lastBatchInsertIndex() ? null : this.visibleNodesFlat[lastNodeIndex];\n      if (nodeBefore && lastNodeIndex >= this.viewRangeRendered.from && lastNodeIndex < this.viewRangeRendered.to && !nodeBefore.attached) {\n        // ensure node before is visible\n        this.showNode(nodeBefore, false, lastNodeIndex);\n      }\n      if (nodeBefore && nodeBefore.attached) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(nodeBefore.$node);\n      } else if (parentNode.attached) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(parentNode.$node);\n      } else if (this.$fillBefore) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(this.$fillBefore);\n      } else {\n        let nodeAfter = this.visibleNodesFlat[insertBatch.lastBatchInsertIndex()];\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(nodeAfter.$node);\n      }\n      insertBatch.animationCompleteFunc = onAnimationComplete;\n      this._$expandAnimationWrappers.push(insertBatch.$animationWrapper);\n    }\n\n    // ----- Helper functions ----- //\n\n    function onAnimationComplete() {\n      insertBatch.$animationWrapper.replaceWith(insertBatch.$animationWrapper.contents());\n      arrays.remove(this._$expandAnimationWrappers, insertBatch.$animationWrapper);\n      insertBatch.$animationWrapper = null;\n      this.runningAnimationsFinishFunc();\n    }\n  }\n  checkAndHandleBatch(insertBatch, parentNode, animatedRendering) {\n    if (this.viewRangeRendered.from - 1 === insertBatch.lastBatchInsertIndex()) {\n      // do immediate rendering because list could be longer\n      this.insertBatchInVisibleNodes(insertBatch, false, false);\n      insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n    }\n    this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);\n    if (this.viewRangeRendered.from + this.viewRangeSize - 1 === insertBatch.lastBatchInsertIndex()) {\n      // do immediate rendering because list could be longer\n      this.insertBatchInVisibleNodes(insertBatch, true, animatedRendering);\n      insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n    }\n    return insertBatch;\n  }\n  insertBatchInVisibleNodes(insertBatch, showNodes, animate) {\n    if (insertBatch.isEmpty()) {\n      // nothing to add\n      return;\n    }\n    this.visibleNodesFlat.splice(...insertBatch.insertNodes);\n    if (showNodes) {\n      let indexHint = insertBatch.insertAt();\n      for (let i = 2; i < insertBatch.insertNodes.length; i++) {\n        let node = insertBatch.insertNodes[i];\n        this.showNode(node, false, indexHint);\n        if (insertBatch.$animationWrapper) {\n          insertBatch.$animationWrapper.append(node.$node);\n        }\n        indexHint++;\n      }\n      if (insertBatch.$animationWrapper) {\n        let h = insertBatch.$animationWrapper.outerHeight();\n        insertBatch.$animationWrapper.css('height', 0).animate({\n          height: h\n        }, {\n          start: this.startAnimationFunc,\n          complete: insertBatch.animationCompleteFunc.bind(this),\n          step: this.revalidateLayoutTree.bind(this),\n          duration: 200,\n          queue: false\n        });\n      }\n    } else if (insertBatch.$animationWrapper && insertBatch.animationCompleteFunc) {\n      insertBatch.animationCompleteFunc.call(this);\n    }\n  }\n  _addToVisibleFlatListNoCheck(node, insertIndex, animatedRendering) {\n    arrays.insert(this.visibleNodesFlat, node, insertIndex);\n    this.visibleNodesMap[node.id] = true;\n    this.showNode(node, animatedRendering, insertIndex);\n  }\n  scrollTo(node, options) {\n    if (this.viewRangeRendered.size() === 0) {\n      // Cannot scroll to a node if no node is rendered\n      return;\n    }\n    if (!node.attached) {\n      this._renderViewRangeForNode(node);\n    }\n    if (!node.attached) {\n      // Node may not be visible due to the filter -> don't try to scroll because it would fail\n      return;\n    }\n    scrollbars.scrollTo(this.$data, node.$node, options);\n  }\n  revealSelection() {\n    if (!this.rendered) {\n      // Execute delayed because tree may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n    if (this.selectedNodes.length > 0) {\n      if (!this.visibleNodesMap[this.selectedNodes[0].id]) {\n        this._expandAllParentNodes(this.selectedNodes[0]);\n      }\n      this.scrollTo(this.selectedNodes[0]);\n      this.ensureExpansionVisible(this.selectedNodes[0]);\n    }\n  }\n  ensureExpansionVisible(node) {\n    // only scroll if treenode is in dom and the current node is selected (user triggered expansion change)\n    if (!node || !node.$node || this.selectedNodes[0] !== node) {\n      return;\n    }\n    scrollbars.ensureExpansionVisible({\n      element: node,\n      $element: node.$node,\n      $scrollable: this.get$Scrollable(),\n      isExpanded: element => element.expanded,\n      getChildren: parent => parent.childNodes,\n      nodePaddingLevel: this.nodePaddingLevel,\n      defaultChildHeight: this.nodeHeight\n    });\n  }\n  deselectAll() {\n    this.selectNodes([]);\n  }\n  selectNode(node, debounceSend) {\n    this.selectNodes(node, debounceSend);\n  }\n  selectNodes(nodes, debounceSend) {\n    nodes = arrays.ensure(nodes);\n\n    // TODO [8.0] CGU Actually, the nodes should be filtered here so that invisible nodes may not be selected\n    // But this is currently not possible because the LazyNodeFilter would not accept the nodes\n    // We would have to keep track of the clicked nodes and check them in the lazy node filter (e.g. selectedNode.parentNode.lazySelectedChildNodes[selectedNode.id] = selectedNode).\n    // But since this requires a change in setNodeExpanded as well we decided to not implement it until the TODO at _addChildrenToFlatList is solved\n\n    if (arrays.equalsIgnoreOrder(nodes, this.selectedNodes)) {\n      return;\n    }\n    if (this.rendered) {\n      this._rememberScrollTopBeforeSelection();\n      this._removeSelection();\n    }\n    if (this.prevSelectedNode) {\n      this.prevSelectedNode.prevSelectionAnimationDone = false;\n    }\n    this.prevSelectedNode = this.selectedNodes[0];\n    this._setSelectedNodes(nodes, debounceSend);\n    if (this.rendered) {\n      this._renderSelection();\n      this._updateScrollTopAfterSelection();\n    }\n  }\n  _rememberScrollTopBeforeSelection() {\n    if (this.isBreadcrumbStyleActive()) {\n      // Save the current scrollTop for future up navigation\n      if (this.selectedNodes.length > 0) {\n        this.scrollTopHistory[this.selectedNodes[0].level] = this.$data[0].scrollTop;\n      }\n    } else {\n      // Clear history if user now works with tree to not get confused when returning to bc mode\n      this.scrollTopHistory = [];\n    }\n  }\n  _updateScrollTopAfterSelection() {\n    if (!this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    let currentLevel = -1;\n    if (this.selectedNodes.length > 0) {\n      currentLevel = this.selectedNodes[0].level;\n    }\n    // Remove positions after the current level (no restore when going down, only when going up)\n    this.scrollTopHistory.splice(currentLevel + 1);\n    // Read the scroll top for the current level and use that one if it is set\n    let scrollTopForLevel = this.scrollTopHistory[currentLevel];\n    if (scrollTopForLevel >= 0) {\n      this.setScrollTop(scrollTopForLevel);\n    }\n  }\n  _setSelectedNodes(nodes, debounceSend) {\n    // Make a copy so that original array stays untouched\n    this.selectedNodes = nodes.slice();\n    this._nodesSelectedInternal();\n    this._triggerNodesSelected(debounceSend);\n    if (this.selectedNodes.length > 0 && !this.visibleNodesMap[this.selectedNodes[0].id]) {\n      this._expandAllParentNodes(this.selectedNodes[0]);\n    }\n    this._updateItemPath(true);\n    if (this.isBreadcrumbStyleActive()) {\n      // In breadcrumb mode selected node has to be expanded\n      if (this.selectedNodes.length > 0 && !this.selectedNodes[0].expanded) {\n        this.expandNode(this.selectedNodes[0]);\n        this.selectedNodes[0].filterDirty = true;\n      }\n      this.filter();\n    }\n    this.session.onRequestsDone(this._updateMenuBar.bind(this));\n  }\n\n  /**\n   * This method is overridden by subclasses of Tree. The default impl. does nothing.\n   */\n  _nodesSelectedInternal(node) {\n    // NOP\n  }\n  deselectNode(node) {\n    this.deselectNodes(node);\n  }\n\n  /**\n   * @param nodes the nodes to deselect\n   * @param options.collectChildren true to add the selected children to the list of nodes to deselect\n   */\n  deselectNodes(nodes, options) {\n    nodes = arrays.ensure(nodes);\n    options = options || {};\n    if (options.collectChildren) {\n      nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.selectedNodes));\n    }\n    let selectedNodes = this.selectedNodes.slice(); // copy\n    if (arrays.removeAll(selectedNodes, nodes)) {\n      this.selectNodes(selectedNodes);\n    }\n  }\n  isNodeSelected(node) {\n    return this.selectedNodes.indexOf(node) > -1;\n  }\n  _computeNodePaddingLeft(node) {\n    this._computeNodePaddings();\n    if (this.isBreadcrumbStyleActive()) {\n      return this.nodePaddingLeft;\n    }\n    let padding = this.nodePaddingLeft + this._computeNodePaddingLeftForLevel(node);\n    if (this.checkable) {\n      padding += this.nodeCheckBoxPaddingLeft;\n    }\n    return padding;\n  }\n  _computeNodeControlPaddingLeft(node) {\n    return this.nodeControlPaddingLeft + this._computeNodePaddingLeftForLevel(node);\n  }\n  _computeNodePaddingLeftForLevel(node) {\n    if (this.checkable || !this.nodePaddingLevelDiffParentHasIcon) {\n      return node.level * this.nodePaddingLevel;\n    }\n    let padding = 0;\n    let parentNode = node.parentNode;\n    while (parentNode) {\n      padding += this.nodePaddingLevel;\n      // Increase the padding if the parent node has an icon to make the hierarchy more clear\n      // This is not necessary if the child nodes have icons as well, the padding even looks too big, as it is the case for checkable trees.\n      // We only check the first child node for an icon because that one has the biggest impact on the hierarchy visualization. It also increases performance a little.\n      if (parentNode.iconId && !parentNode.childNodes[0].iconId) {\n        padding += this.nodePaddingLevelDiffParentHasIcon;\n      }\n      parentNode = parentNode.parentNode;\n    }\n    return padding;\n  }\n\n  /**\n   * Reads the paddings from CSS and stores them in nodePaddingLeft and nodeControlPaddingLeft\n   */\n  _computeNodePaddings() {\n    if (this.nodePaddingLeft !== null && this.nodeControlPaddingLeft !== null && this.nodePaddingLevelDiffParentHasIcon !== null) {\n      return;\n    }\n    let $dummyNode = this.$data.appendDiv('tree-node');\n    let $dummyNodeControl = $dummyNode.appendDiv('tree-node-control');\n    if (this.nodePaddingLeft === null) {\n      this.nodePaddingLeft = $dummyNode.cssPaddingLeft();\n    }\n    if (this.nodeControlPaddingLeft === null) {\n      this.nodeControlPaddingLeft = $dummyNodeControl.cssPaddingLeft();\n    }\n    if (this.nodePaddingLevelDiffParentHasIcon === null) {\n      this.nodePaddingLevelDiffParentHasIcon = this.$container.cssPxValue('--node-padding-level-diff-parent-has-icon');\n    }\n    $dummyNode.remove();\n  }\n  _expandAllParentNodes(node) {\n    let i,\n      currNode = node,\n      parentNodes = [];\n    currNode = node;\n    let nodesToInsert = [];\n    while (currNode.parentNode) {\n      parentNodes.push(currNode.parentNode);\n      if (!this.visibleNodesMap[currNode.id]) {\n        nodesToInsert.push(currNode);\n      }\n      currNode = currNode.parentNode;\n    }\n    for (i = parentNodes.length - 1; i >= 0; i--) {\n      if (nodesToInsert.indexOf(parentNodes[i]) !== -1) {\n        this._addToVisibleFlatList(parentNodes[i], false);\n      }\n      if (!parentNodes[i].expanded) {\n        this.expandNode(parentNodes[i], {\n          renderExpansion: false,\n          renderAnimated: false\n        });\n      }\n    }\n    if (this.rendered && nodesToInsert.length > 0) {\n      this._rerenderViewport();\n      this.invalidateLayoutTree();\n    }\n  }\n  _updateChildNodeIndex(nodes, startIndex) {\n    if (!nodes || !nodes.length) {\n      return;\n    }\n    for (let i = scout.nvl(startIndex, 0); i < nodes.length; i++) {\n      nodes[i].childNodeIndex = i;\n    }\n  }\n\n  /**\n   * @param {TreeNode} [parentNode]\n   */\n  insertNode(node, parentNode) {\n    this.insertNodes([node], parentNode);\n  }\n\n  /**\n   * @param {TreeNode} [parentNode]\n   */\n  insertNodes(nodes, parentNode) {\n    nodes = arrays.ensure(nodes).slice();\n    if (nodes.length === 0) {\n      return;\n    }\n    this._ensureTreeNodes(nodes);\n    if (parentNode && !(parentNode instanceof TreeNode)) {\n      throw new Error('parent has to be a tree node: ' + parentNode);\n    }\n\n    // Append continuous node blocks\n    nodes.sort((a, b) => {\n      return a.childNodeIndex - b.childNodeIndex;\n    });\n\n    // Update parent with new child nodes\n    if (parentNode) {\n      if (parentNode.childNodes && parentNode.childNodes.length > 0) {\n        nodes.forEach(entry => {\n          // only insert node if not already existing\n          if (parentNode.childNodes.indexOf(entry) < 0) {\n            arrays.insert(parentNode.childNodes, entry, entry.childNodeIndex);\n          }\n        });\n        this._updateChildNodeIndex(parentNode.childNodes, nodes[0].childNodeIndex);\n      } else {\n        nodes.forEach(entry => {\n          parentNode.childNodes.push(entry);\n        });\n      }\n      this._initNodes(nodes, parentNode);\n      if (this.groupedNodes[parentNode.id]) {\n        this._updateItemPath(false, parentNode);\n      }\n      if (this.rendered) {\n        let opts = {\n          expansionChanged: true\n        };\n        this._renderExpansion(parentNode, opts);\n        this.ensureExpansionVisible(parentNode);\n      }\n    } else {\n      if (this.nodes && this.nodes.length > 0) {\n        nodes.forEach(entry => {\n          // only insert node if not already existing\n          if (this.nodes.indexOf(entry) < 0) {\n            arrays.insert(this.nodes, entry, entry.childNodeIndex);\n          }\n        });\n        this._updateChildNodeIndex(this.nodes, nodes[0].childNodeIndex);\n      } else {\n        arrays.pushAll(this.nodes, nodes);\n      }\n      this._initNodes(nodes, parentNode);\n    }\n    if (this.rendered) {\n      this.viewRangeDirty = true;\n      this.invalidateLayoutTree();\n    }\n    this.trigger('nodesInserted', {\n      nodes: nodes,\n      parentNode: parentNode\n    });\n  }\n  updateNode(node) {\n    this.updateNodes([node]);\n  }\n  updateNodes(nodes) {\n    nodes = arrays.ensure(nodes);\n    if (nodes.length === 0) {\n      return;\n    }\n    nodes.forEach(function (updatedNode) {\n      let propertiesChanged,\n        oldNode = this.nodesMap[updatedNode.id];\n\n      // if same instance has been updated we must set the flag always to true\n      // because we cannot compare against an \"old\" node\n      if (updatedNode === oldNode) {\n        propertiesChanged = true;\n      } else {\n        this._applyNodeDefaultValues(updatedNode);\n        propertiesChanged = this._applyUpdatedNodeProperties(oldNode, updatedNode);\n      }\n      if (propertiesChanged) {\n        this.applyFiltersForNode(oldNode);\n        this._updateItemPath(false, oldNode.parentNode);\n        if (this.rendered) {\n          oldNode._decorate();\n        }\n      }\n    }, this);\n    this.trigger('nodesUpdated', {\n      nodes: nodes\n    });\n  }\n\n  /**\n   * Called by _onNodesUpdated for every updated node. The function is expected to apply\n   * all updated properties from the updatedNode to the oldNode. May be overridden by\n   * subclasses so update their specific node properties.\n   *\n   * @param oldNode\n   *          The target node to be updated\n   * @param updatedNode\n   *          The new node with potentially updated properties. Default values are already applied!\n   * @returns {boolean}\n   *          true if at least one property has changed, false otherwise. This value is used to\n   *          determine if the node has to be rendered again.\n   */\n  _applyUpdatedNodeProperties(oldNode, updatedNode) {\n    // Note: We only update _some_ of the properties, because everything else will be handled\n    // with separate events. --> See also: JsonTree.java/handleModelNodesUpdated()\n    let propertiesChanged = false;\n    if (oldNode.leaf !== updatedNode.leaf) {\n      oldNode.leaf = updatedNode.leaf;\n      propertiesChanged = true;\n    }\n    if (oldNode.enabled !== updatedNode.enabled) {\n      oldNode.enabled = updatedNode.enabled;\n      propertiesChanged = true;\n    }\n    if (oldNode.lazyExpandingEnabled !== updatedNode.lazyExpandingEnabled) {\n      oldNode.lazyExpandingEnabled = updatedNode.lazyExpandingEnabled;\n      // Also make sure expandedLazy is reset to false when lazyExpanding is disabled (same code as in AbstractTreeNode.setLazyExpandingEnabled)\n      if (!updatedNode.lazyExpandingEnabled || !this.lazyExpandingEnabled) {\n        oldNode.expandedLazy = false;\n      }\n      propertiesChanged = true;\n    }\n    return propertiesChanged;\n  }\n  deleteNode(node, parentNode) {\n    this.deleteNodes([node], parentNode);\n  }\n  deleteAllNodes() {\n    this.deleteAllChildNodes();\n  }\n  deleteNodes(nodes, parentNode) {\n    let deletedNodes = [];\n    let parentNodesToReindex = [];\n    let topLevelNodesToReindex = [];\n    nodes = arrays.ensure(nodes).slice(); // copy\n    if (nodes.length === 0) {\n      return;\n    }\n    nodes.forEach(function (node) {\n      let p = parentNode || node.parentNode;\n      if (p) {\n        if (node.parentNode !== p) {\n          throw new Error('Unexpected parent. Node.parent: ' + node.parentNode + ', parentNode: ' + parentNode);\n        }\n        arrays.remove(p.childNodes, node);\n        if (parentNodesToReindex.indexOf(p) === -1) {\n          parentNodesToReindex.push(p);\n        }\n      } else {\n        arrays.remove(this.nodes, node);\n        topLevelNodesToReindex = this.nodes;\n      }\n      this._destroyTreeNode(node);\n      deletedNodes.push(node);\n      this._updateMarkChildrenChecked(node, false, false);\n\n      // remove children from node map\n      Tree.visitNodes(this._destroyTreeNode.bind(this), node.childNodes);\n    }, this);\n\n    // update child node indices\n    parentNodesToReindex.forEach(p => this._updateChildNodeIndex(p.childNodes));\n    this._updateChildNodeIndex(topLevelNodesToReindex);\n    this.deselectNodes(deletedNodes, {\n      collectChildren: true\n    });\n    this.uncheckNodes(deletedNodes, {\n      collectChildren: true\n    });\n\n    // remove node from html document\n    if (this.rendered) {\n      this._removeNodes(deletedNodes, parentNode || parentNodesToReindex);\n    }\n    this.trigger('nodesDeleted', {\n      nodes: nodes,\n      parentNode: parentNode\n    });\n  }\n  _collectNodesIfDescendants(nodes, nodesToCheck) {\n    let result = [];\n    nodesToCheck.forEach(nodeToCheck => {\n      if (nodes.some(node => {\n        return node.isAncestorOf(nodeToCheck);\n      })) {\n        result.push(nodeToCheck);\n      }\n    });\n    return result;\n  }\n  deleteAllChildNodes(parentNode) {\n    let nodes;\n    if (parentNode) {\n      nodes = parentNode.childNodes;\n      parentNode.childNodes = [];\n    } else {\n      nodes = this.nodes;\n      this.nodes = [];\n    }\n    Tree.visitNodes(updateNodeMap.bind(this), nodes);\n    this.deselectNodes(nodes, {\n      collectChildren: true\n    });\n    this.uncheckNodes(nodes, {\n      collectChildren: true\n    });\n\n    // remove node from html document\n    if (this.rendered) {\n      this._removeNodes(nodes, parentNode);\n    }\n    this.trigger('allChildNodesDeleted', {\n      parentNode: parentNode\n    });\n\n    // --- Helper functions ---\n\n    // Update model and nodemap\n    function updateNodeMap(node) {\n      this._destroyTreeNode(node);\n      this._updateMarkChildrenChecked(node, false, false);\n    }\n  }\n  updateNodeOrder(childNodes, parentNode) {\n    childNodes = arrays.ensure(childNodes);\n    this._updateChildNodeIndex(childNodes);\n    if (parentNode) {\n      if (parentNode.childNodes.length !== childNodes.length) {\n        throw new Error('Node order may not be updated because lengths of the arrays differ.');\n      }\n      // Make a copy so that original array stays untouched\n      parentNode.childNodes = childNodes.slice();\n      this._removeChildrenFromFlatList(parentNode, false);\n      if (parentNode.expanded) {\n        this._addChildrenToFlatList(parentNode, null, false);\n      }\n    } else {\n      if (this.nodes.length !== childNodes.length) {\n        throw new Error('Node order may not be updated because lengths of the arrays differ.');\n      }\n      // Make a copy so that original array stays untouched\n      this.nodes = childNodes.slice();\n      this.nodes.forEach(function (node) {\n        this._removeFromFlatList(node, false);\n        this._addToVisibleFlatList(node, false);\n        if (node.expanded) {\n          this._addChildrenToFlatList(node, null, false);\n        }\n      }, this);\n    }\n    this.trigger('childNodeOrderChanged', {\n      parentNode: parentNode\n    });\n  }\n  checkNode(node, checked, options) {\n    let opts = $.extend(options, {\n      checked: checked\n    });\n    this.checkNodes([node], opts);\n  }\n  checkNodes(nodes, options) {\n    let opts = {\n      checked: true,\n      checkOnlyEnabled: true,\n      checkChildren: this.autoCheckChildren,\n      triggerNodesChecked: true\n    };\n    $.extend(opts, options);\n    let updatedNodes = [];\n    // use enabled computed because when the parent of the table is disabled, it should not be allowed to check rows\n    if (!this.checkable || !this.enabledComputed && opts.checkOnlyEnabled) {\n      return;\n    }\n    nodes = arrays.ensure(nodes);\n    nodes.forEach(function (node) {\n      if (!node.enabled && opts.checkOnlyEnabled || node.checked === opts.checked || !node.filterAccepted) {\n        if (opts.checkChildren) {\n          this.checkNodes(node.childNodes, opts);\n        }\n        return;\n      }\n      if (!this.multiCheck && opts.checked) {\n        for (let i = 0; i < this.checkedNodes.length; i++) {\n          this.checkedNodes[i].checked = false;\n          this._updateMarkChildrenChecked(this.checkedNodes[i], false, false, true);\n          updatedNodes.push(this.checkedNodes[i]);\n        }\n        this.checkedNodes = [];\n      }\n      node.checked = opts.checked;\n      if (node.checked) {\n        this.checkedNodes.push(node);\n      } else {\n        arrays.remove(this.checkedNodes, node);\n      }\n      updatedNodes.push(node);\n      this._updateMarkChildrenChecked(node, false, opts.checked, true);\n      if (opts.checkChildren) {\n        let childOpts = $.extend({}, opts, {\n          triggerNodesChecked: false\n        });\n        this.checkNodes(node.childNodes, childOpts);\n      }\n    }, this);\n    if (opts.triggerNodesChecked && updatedNodes.length > 0) {\n      this.trigger('nodesChecked', {\n        nodes: updatedNodes\n      });\n    }\n    if (this.rendered) {\n      updatedNodes.forEach(node => {\n        node._renderChecked();\n      });\n    }\n  }\n  uncheckNode(node, options) {\n    let opts = $.extend({\n      checkOnlyEnabled: true\n    }, options);\n    this.uncheckNodes([node], opts);\n  }\n\n  /**\n   * @param nodes the nodes to uncheck\n   * @param options.collectChildren true to add the checked children to the list of nodes to uncheck\n   */\n  uncheckNodes(nodes, options) {\n    let opts = {\n      checked: false\n    };\n    $.extend(opts, options);\n    if (opts.collectChildren) {\n      nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.checkedNodes));\n    }\n    this.checkNodes(nodes, opts);\n  }\n  _triggerNodesSelected(debounce) {\n    this.trigger('nodesSelected', {\n      debounce: debounce\n    });\n  }\n  _showContextMenu(event) {\n    let func = function (event) {\n      if (!this.rendered) {\n        // check needed because function is called asynchronously\n        return;\n      }\n      let filteredMenus = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true),\n        $part = $(event.currentTarget);\n      if (filteredMenus.length === 0) {\n        return; // at least one menu item must be visible\n      }\n      // Prevent firing of 'onClose'-handler during contextMenu.open()\n      // (Can lead to null-access when adding a new handler to this.contextMenu)\n      if (this.contextMenu) {\n        this.contextMenu.close();\n      }\n      this.contextMenu = scout.create('ContextMenuPopup', {\n        parent: this,\n        menuItems: filteredMenus,\n        location: {\n          x: event.pageX,\n          y: event.pageY\n        },\n        $anchor: $part,\n        menuFilter: this._filterMenusHandler\n      });\n      this.contextMenu.open();\n    };\n    this.session.onRequestsDone(func.bind(this), event);\n  }\n  _onNodeMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n    let $node = $(event.currentTarget);\n    let node = $node.data('node');\n    if (!this.hasNode(node)) {\n      // if node does not belong to this tree, do nothing (may happen if another tree is embedded inside the node)\n      return;\n    }\n    this._$mouseDownNode = $node;\n    $node.window().one('mouseup', () => {\n      this._$mouseDownNode = null;\n    });\n    this.selectNodes(node);\n    if (this.checkable && node.enabled && this._isCheckboxClicked(event)) {\n      if (Device.get().loosesFocusIfPseudoElementIsRemoved()) {\n        this.focusAndPreventDefault(event);\n      }\n      this.checkNode(node, !node.checked);\n    }\n    return true;\n  }\n  _onNodeMouseUp(event) {\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n    let $node = $(event.currentTarget);\n    let node = $node.data('node');\n    if (!this._$mouseDownNode || this._$mouseDownNode[0] !== $node[0]) {\n      // Don't accept if mouse up happens on another node than mouse down, or mousedown didn't happen on a node at all\n      return;\n    }\n    this.trigger('nodeClick', {\n      node: node\n    });\n    return true;\n  }\n  _isCheckboxClicked(event) {\n    // with CheckableStyle.CHECKBOX_TREE_NODE a click anywhere on the node should trigger the check\n    if (this.isTreeNodeCheckEnabled()) {\n      return true;\n    }\n    return $(event.target).is('.check-box');\n  }\n  _updateItemPath(selectionChanged, ultimate) {\n    let selectedNodes, node, level;\n    if (selectionChanged) {\n      // first remove and select selected\n      this.groupedNodes = {};\n      this._inSelectionPathList = {};\n    }\n    if (!ultimate) {\n      // find direct children\n      selectedNodes = this.selectedNodes;\n      if (selectedNodes.length === 0) {\n        return;\n      }\n      node = selectedNodes[0];\n      if (selectionChanged) {\n        this._inSelectionPathList[node.id] = true;\n        if (node.childNodes) {\n          node.childNodes.forEach(child => {\n            this._inSelectionPathList[child.id] = true;\n          });\n        }\n      }\n      level = node.level;\n\n      // find grouping end (ultimate parent)\n      while (node.parentNode) {\n        let parent = node.parentNode;\n        if (this._isGroupingEnd(parent) && !ultimate) {\n          ultimate = node;\n          if (!selectionChanged) {\n            break;\n          }\n        }\n        if (selectionChanged) {\n          this._inSelectionPathList[parent.id] = true;\n        }\n        node = parent;\n      }\n      // find group with same ultimate parent\n      ultimate = ultimate || selectedNodes[0];\n      this.groupedNodes[ultimate.id] = true;\n    }\n    node = ultimate;\n    if (node && node.expanded && this.groupedNodes[node.id]) {\n      addToGroup.call(this, node.childNodes);\n    }\n\n    // ------ helper function ------//\n\n    function addToGroup(nodes) {\n      nodes.forEach(node => {\n        this.groupedNodes[node.id] = true;\n        node._decorate();\n        if (node.expanded && node.isFilterAccepted()) {\n          addToGroup.call(this, node.childNodes);\n        }\n      });\n    }\n  }\n  _isGroupingEnd(node) {\n    // May be implemented by subclasses, default tree has no grouping parent\n    return false;\n  }\n\n  /**\n   * @returns {TreeNode} the first selected node or null when no node is selected.\n   */\n  selectedNode() {\n    if (this.selectedNodes.length === 0) {\n      return null;\n    }\n    return this.selectedNodes[0];\n  }\n  $selectedNodes() {\n    return this.$data.find('.selected');\n  }\n  $nodes() {\n    return this.$data.find('.tree-node');\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to add.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  addFilter(filter) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.addFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to remove.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  removeFilter(filter) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.removeFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The new filters.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  setFilters(filters) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.setFilters(filters, applyFilter);\n  }\n  filter() {\n    this.filterSupport.filter();\n  }\n  _filter() {\n    let newlyHidden = [],\n      newlyShown = [];\n    // Filter nodes\n    this.nodes.forEach(node => {\n      let result = this.applyFiltersForNode(node, false, this.filterAnimated);\n      newlyHidden.push(...result.newlyHidden);\n      newlyShown.push(...result.newlyShown);\n    });\n    return {\n      newlyHidden: newlyHidden,\n      newlyShown: newlyShown\n    };\n  }\n  updateFilteredElements(result, opts) {\n    if (!this.filteredElementsDirty) {\n      return;\n    }\n    if (opts.textFilterText) {\n      this._nodesByIds(Object.keys(this.nodesMap)).filter(it => it.filterAccepted).forEach(node => this._expandAllParentNodes(node));\n    }\n    result.newlyShown.forEach(node => this._addToVisibleFlatList(node, this.filterAnimated));\n    result.newlyHidden.forEach(node => this._removeFromFlatList(node, this.filterAnimated));\n    this.filteredElementsDirty = false;\n  }\n  filterVisibleNodes(animated) {\n    // Filter nodes\n    let newlyHidden = [];\n    // iterate from end to beginning (child nodes first) so that the state of the children has already been updated\n    for (let i = this.visibleNodesFlat.length - 1; i >= 0; i--) {\n      let node = this.visibleNodesFlat[i];\n      let result = this._applyFiltersForNodeRec(node, true, animated);\n      if (result.newlyHidden.length) {\n        if (!node.isFilterAccepted()) {\n          newlyHidden.push(...result.newlyHidden);\n        }\n        this.viewRangeDirty = true;\n      }\n    }\n    newlyHidden.forEach(h => this._removeFromFlatList(h, animated));\n    this._nodesFiltered(newlyHidden);\n  }\n  _nodesFiltered(hiddenNodes) {\n    // non visible nodes must be deselected\n    this.deselectNodes(hiddenNodes);\n  }\n  applyFiltersForNode(node) {\n    let applyNewHiddenShownNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let animated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let result = this._applyFiltersForNodeRec(node, true, animated);\n\n    // the result so far only includes the node and all its children.\n    // always include the parent nodes as well so that the filter has an effect\n    let parent = node.parentNode;\n    while (parent) {\n      let parentResult = this._applyFiltersForNodeRec(parent, false, animated);\n      result.newlyHidden.unshift(...parentResult.newlyHidden);\n      result.newlyShown.unshift(...parentResult.newlyShown);\n      parent = parent.parentNode;\n    }\n    this._nodesFiltered(result.newlyHidden);\n    if (applyNewHiddenShownNodes) {\n      result.newlyShown.forEach(node => this._addToVisibleFlatList(node, animated));\n      result.newlyHidden.forEach(node => this._removeFromFlatList(node, animated));\n    }\n    return result;\n  }\n  _applyFiltersForNodeRec(node, recursive) {\n    let animated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let newlyHidden = [],\n      newlyShown = [];\n    animated = animated && this.filterAnimated;\n    let changed = this._applyFiltersForNode(node);\n    let hasChildrenWithFilterAccepted = false;\n    if (node.level < 32 /* see org.eclipse.scout.rt.client.ui.basic.tree.AbstractTree.expandAllRec */) {\n      if (recursive) {\n        node.childNodes.forEach(childNode => {\n          let result = this._applyFiltersForNodeRec(childNode, true, animated);\n          newlyHidden.push(...result.newlyHidden);\n          newlyShown.push(...result.newlyShown);\n          hasChildrenWithFilterAccepted = hasChildrenWithFilterAccepted || childNode.filterAccepted;\n        });\n      } else if (!node.filterAccepted) {\n        // Check children only if filterAccepted is false because only then hasChildrenWithFilterAccepted is used (see below).\n        // This has great impact on performance when there are many nodes\n        hasChildrenWithFilterAccepted = node.childNodes.some(childNode => childNode.filterAccepted);\n      }\n    }\n\n    // set filter accepted on this node if it has children with filter accepted (so that the children are visible)\n    if (!node.filterAccepted && hasChildrenWithFilterAccepted) {\n      node.setFilterAccepted(true);\n      changed = !changed;\n    }\n\n    // remember changed node\n    if (changed) {\n      let pushTo = node.filterAccepted ? newlyShown : newlyHidden;\n      pushTo.unshift(node);\n      if (this.rendered) {\n        this.viewRangeDirty = true;\n      }\n    }\n    return {\n      newlyHidden: newlyHidden,\n      newlyShown: newlyShown\n    };\n  }\n\n  /**\n   * @returns {Boolean} true if node state has changed, false if not\n   */\n  _applyFiltersForNode(node) {\n    let changed = this.filterSupport.applyFiltersForElement(node);\n    if (changed || node.filterDirty) {\n      node.filterDirty = false;\n      node.childNodes.forEach(childNode => {\n        childNode.filterDirty = true;\n      });\n    }\n    return changed;\n  }\n\n  /**\n   * @returns {FilterSupport}\n   */\n  _createFilterSupport() {\n    return new FilterSupport({\n      widget: this,\n      $container: () => this.$container,\n      filterElements: this._filter.bind(this),\n      getElementText: node => node.text\n    });\n  }\n  setTextFilterEnabled(textFilterEnabled) {\n    this.setProperty('textFilterEnabled', textFilterEnabled);\n  }\n  isTextFilterFieldVisible() {\n    return this.textFilterEnabled;\n  }\n  _renderTextFilterEnabled() {\n    this.filterSupport.renderFilterField();\n  }\n\n  /**\n   * Just insert node in DOM. NO check if in viewRange\n   */\n  _insertNodesInDOM(nodes, indexHint) {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    nodes = nodes.filter(function (node) {\n      let index = indexHint === undefined ? this.visibleNodesFlat.indexOf(node) : indexHint;\n      if (index === -1 || !(this.viewRangeRendered.from + this.viewRangeSize >= index && this.viewRangeRendered.from <= index && this.viewRangeSize > 0) || node.attached) {\n        // node is not visible\n        return false;\n      }\n      if (!node.rendered) {\n        this._renderNode(node);\n      }\n      node._decorate();\n      this._insertNodeInDOMAtPlace(node, index);\n      if (this.prevSelectedNode === node) {\n        this._highlightPrevSelectedNode();\n      }\n      node.rendered = true;\n      node.attached = true;\n      return true;\n    }, this);\n    this._installNodes(nodes);\n  }\n  _installNodes(nodes) {\n    // The measuring is separated into 3 blocks for performance reasons -> separates reading and setting of styles\n    // 1. Prepare style for measuring\n    if (this.isHorizontalScrollingEnabled()) {\n      nodes.forEach(node => {\n        node.$node.css('width', 'auto');\n        node.$node.css('display', 'inline-block');\n      }, this);\n    }\n\n    // 2. Measure\n    nodes.forEach(function (node) {\n      node.height = node.$node.outerHeight(true);\n      if (!this.isHorizontalScrollingEnabled()) {\n        return;\n      }\n      let newWidth = node.$node.outerWidth();\n      let oldWidth = node.width ? node.width : 0;\n      if (oldWidth === this.maxNodeWidth && newWidth < this.maxNodeWidth) {\n        this.maxNodeWidth = 0;\n        this.nodeWidthDirty = true;\n      } else if (newWidth > this.maxNodeWidth) {\n        this.maxNodeWidth = newWidth;\n        this.nodeWidthDirty = true;\n      } else if (newWidth === oldWidth && newWidth === 0) {\n        // newWidth and oldWidth are 0: this might be because the tree is invisible while a node is added:\n        // Mark as dirty to update the width later during layouting (when the tree gets visible and the width is available)\n        this.nodeWidthDirty = true;\n      }\n      node.width = newWidth;\n    }, this);\n\n    // 3. Reset style\n    if (this.isHorizontalScrollingEnabled()) {\n      nodes.forEach(function (node) {\n        if (!this.nodeWidthDirty) {\n          node.$node.css('width', this.maxNodeWidth);\n        }\n        node.$node.css('display', '');\n      }, this);\n    }\n  }\n\n  /**\n   * Attaches node to DOM, if it is visible and in view range\n   * */\n  _ensureNodeInDOM(node, useAnimation, indexHint) {\n    if (node && !node.attached && node === this.visibleNodesFlat[indexHint] && indexHint >= this.viewRangeRendered.from && indexHint < this.viewRangeRendered.to) {\n      this.showNode(node, useAnimation, indexHint);\n    }\n  }\n  _insertNodeInDOMAtPlace(node, index) {\n    let $node = node.$node;\n    if (index === 0) {\n      if (this.$fillBefore) {\n        $node.insertAfter(this.$fillBefore);\n      } else {\n        this.$data.prepend($node);\n      }\n      return;\n    }\n\n    // append after index\n    let nodeBefore = this.visibleNodesFlat[index - 1];\n    this._ensureNodeInDOM(nodeBefore, false, index - 1);\n    if (nodeBefore.attached) {\n      $node.insertAfter(nodeBefore.$node);\n      return;\n    }\n    if (index + 1 < this.visibleNodesFlat.length) {\n      let nodeAfter = this.visibleNodesFlat[index + 1];\n      if (nodeAfter.attached) {\n        $node.insertBefore(nodeAfter.$node);\n        return;\n      }\n    }\n\n    // used when the tree is scrolled\n    if (this.$fillBefore) {\n      $node.insertAfter(this.$fillBefore);\n    } else {\n      this.$data.prepend($node);\n    }\n  }\n  showNode(node, useAnimation, indexHint) {\n    if (!this.rendered || node.attached && !node.$node.hasClass('hiding')) {\n      return;\n    }\n    if (!node.attached) {\n      this._ensureNodeInDOM(node.parentNode, useAnimation, indexHint - 1);\n      this._insertNodesInDOM([node], indexHint);\n    }\n    if (!node.rendered) {\n      return;\n    }\n    let $node = node.$node;\n    if ($node.is('.showing')) {\n      return;\n    }\n    $node.removeClass('hiding');\n    let that = this;\n    if (useAnimation) {\n      $node.addClass('showing');\n      // hide node first and then make it appear using slideDown (setVisible(false) won't work because it would stay invisible during the animation)\n      $node.hide();\n      $node.stop(false, true).slideDown({\n        duration: 250,\n        start: that.startAnimationFunc,\n        complete: () => {\n          that.runningAnimationsFinishFunc();\n          $node.removeClass('showing');\n        }\n      });\n    }\n  }\n  hideNode(node, useAnimation, suppressDetachHandling) {\n    if (!this.rendered || !node.attached) {\n      return;\n    }\n    this.viewRangeDirty = true;\n    let that = this,\n      $node = node.$node;\n    if (!$node) {\n      // node is not rendered\n      return;\n    }\n    if ($node.is('.hiding')) {\n      return;\n    }\n    $node.removeClass('showing');\n    if (useAnimation) {\n      $node.addClass('hiding');\n      this._renderViewportBlocked = true;\n      $node.stop(false, true).slideUp({\n        duration: 250,\n        start: that.startAnimationFunc,\n        complete: () => {\n          that.runningAnimationsFinishFunc();\n          $node.removeClass('hiding');\n          if (!$node.hasClass('showing')) {\n            // JQuery sets display to none which we don't need because node will be detached.\n            // If node is added using another method than slideDown (used by show node), it would be invisible.\n            // Example: parent is collapsed while nodes are hiding -> remove filter, expand parent -> invisible nodes\n            $node.css('display', '');\n            $node.detach();\n            node.attached = false;\n          }\n        }\n      });\n    } else if (!suppressDetachHandling) {\n      $node.detach();\n      node.attached = false;\n      that.invalidateLayoutTree();\n    }\n  }\n  _nodesToIds(nodes) {\n    return nodes.map(node => node.id);\n  }\n  _nodesByIds(ids) {\n    return ids.map(id => this.nodesMap[id]);\n  }\n  _nodeById(id) {\n    return this.nodesMap[id];\n  }\n\n  /**\n   * Checks whether the given node is contained in the tree. Uses the id of the node for the lookup.\n   */\n  hasNode(node) {\n    return Boolean(this._nodeById(node.id));\n  }\n  _onNodeDoubleClick(event) {\n    if (this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    let $node = $(event.currentTarget);\n    let node = $node.data('node');\n    let expanded = !$node.hasClass('expanded');\n    this.doNodeAction(node, expanded);\n  }\n  doNodeAction(node, expanded) {\n    this.trigger('nodeAction', {\n      node: node\n    });\n\n    // For CheckableStyle.CHECKBOX_TREE_NODE expand on double click is only enabled for disabled nodes. Otherwise it would conflict with the \"check on node click\" behavior.\n    if (!(this.checkable === true && this.isTreeNodeCheckEnabled() && node.enabled)) {\n      this.setNodeExpanded(node, expanded, {\n        lazy: false // always show all nodes on node double click\n      });\n    }\n  }\n\n  _onNodeControlMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n    let $node = $(event.currentTarget).parent();\n    let node = $node.data('node');\n    let expanded = !$node.hasClass('expanded');\n    let expansionOpts = {\n      lazy: false // always show all nodes when the control gets clicked\n    };\n\n    // Click on \"show all\" control shows all nodes\n    if ($node.hasClass('lazy')) {\n      if (event.ctrlKey || event.shiftKey) {\n        // Collapse\n        expanded = false;\n        expansionOpts.collapseChildNodes = true;\n      } else {\n        // Show all nodes\n        this.expandNode(node, expansionOpts);\n        return false;\n      }\n    }\n    // Because we suppress handling by browser we have to set focus manually\n    if (this.requestFocusOnNodeControlMouseDown) {\n      this.focus();\n    }\n    this.selectNodes(node); // <---- ### 1\n    this.setNodeExpanded(node, expanded, expansionOpts); // <---- ### 2\n    // prevent bubbling to _onNodeMouseDown()\n    $.suppressEvent(event);\n\n    // ...but return true, so Outline.js can override this method and check if selection has been changed or not\n    return true;\n  }\n  _onNodeControlMouseUp(event) {\n    // prevent bubbling to _onNodeMouseUp()\n    return false;\n  }\n  _onNodeControlDoubleClick(event) {\n    // prevent bubbling to _onNodeDoubleClick()\n    return false;\n  }\n  _onContextMenu(event) {\n    event.preventDefault();\n    this._showContextMenu(event);\n  }\n  changeNode(node) {\n    this.applyFiltersForNode(node);\n    if (this.rendered) {\n      node._decorate();\n      // The padding size of a node depends on whether the node or the parent node has an icon, see _computeNodePaddingLeftForLevel\n      // Unfortunately, we cannot easily detect whether the icon has changed or not.\n      // However, the padding calculation only needs to be done if the node that toggles the icon is visible and expanded or has an expanded parent.\n      let paddingDirty = !!this.nodePaddingLevelDiffParentHasIcon && !!this.visibleNodesMap[node.id] && (node.expanded || !!node.parentNode);\n      if (paddingDirty && !this._changeNodeTaskScheduled) {\n        // Because the change node event is not batch capable, performance would slow down if many change node events are processed\n        // To mitigate this, the updating is done later\n        queueMicrotask(() => {\n          this._updateNodePaddingsLeft();\n          this._changeNodeTaskScheduled = false;\n        });\n        this._changeNodeTaskScheduled = true;\n      }\n    }\n    this.trigger('nodeChanged', {\n      node: node\n    });\n  }\n\n  // same as on Table.prototype._onDesktopPopupOpen\n  _onDesktopPopupOpen(event) {\n    let popup = event.popup;\n    if (!this.isFocusable(false)) {\n      return;\n    }\n    // Set tree style to focused if a context menu or a menu bar popup opens, so that it looks as it still has the focus\n    if (this.has(popup) && popup instanceof ContextMenuPopup) {\n      this.$container.addClass('focused');\n      popup.one('destroy', () => {\n        if (this.rendered) {\n          this.$container.removeClass('focused');\n        }\n      });\n    }\n  }\n  updateScrollbars() {\n    scrollbars.update(this.$data);\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * @memberOf Tree\n   */\n  static collectSubtree($rootNode, includeRootNodeInResult) {\n    if (!$rootNode) {\n      return $();\n    }\n    let rootLevel = parseFloat($rootNode.attr('data-level'));\n    // Find first node after the root element that has the same or a lower level\n    let $nextNode = $rootNode.next();\n    while ($nextNode.length > 0) {\n      let level = parseFloat($nextNode.attr('data-level'));\n      if (isNaN(level) || level <= rootLevel) {\n        break;\n      }\n      $nextNode = $nextNode.next();\n    }\n\n    // The result set consists of all nodes between the root node and the found node\n    let $result = $rootNode.nextUntil($nextNode);\n    if (includeRootNodeInResult === undefined || includeRootNodeInResult) {\n      $result = $result.add($rootNode);\n    }\n    return $result;\n  }\n\n  /**\n   * pre-order (top-down) traversal of the tree-nodes provided.<br>\n   * if func returns true the children of the visited node are not visited.\n   */\n  static visitNodes(func, nodes, parentNode) {\n    let i, node;\n    if (!nodes) {\n      return;\n    }\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      let doNotProcessChildren = func(node, parentNode);\n      if (!doNotProcessChildren && node.childNodes.length > 0) {\n        Tree.visitNodes(func, node.childNodes, node);\n      }\n    }\n  }\n}\n_defineProperty(Tree, \"DisplayStyle\", {\n  DEFAULT: 'default',\n  BREADCRUMB: 'breadcrumb'\n});\n_defineProperty(Tree, \"CheckableStyle\", {\n  /**\n   * Node check is only possible by checking the checkbox.\n   */\n  CHECKBOX: 'checkbox',\n  /**\n   * Node check is possible by clicking anywhere on the node.\n   */\n  CHECKBOX_TREE_NODE: 'checkbox_tree_node'\n});\n_defineProperty(Tree, \"VIEW_RANGE_DIVISOR\", 4);","map":{"version":3,"names":["arrays","ContextMenuPopup","defaultValues","Device","DoubleClickSupport","dragAndDrop","FilterSupport","graphics","HtmlComponent","KeyStrokeContext","keyStrokeModifier","LazyNodeFilter","MenuBar","MenuDestinations","MenuItemsOrder","menus","menus_1","objects","Range","scout","scrollbars","tooltips","TreeBreadcrumbFilter","TreeCollapseAllKeyStroke","TreeCollapseOrDrillUpKeyStroke","TreeExpandOrDrillDownKeyStroke","TreeLayout","TreeNavigationDownKeyStroke","TreeNavigationEndKeyStroke","TreeNavigationUpKeyStroke","TreeNode","TreeSpaceKeyStroke","Widget","$","Tree","constructor","toggleBreadcrumbStyleEnabled","breadcrumbTogglingThreshold","autoCheckChildren","checkable","checkableStyle","CheckableStyle","CHECKBOX_TREE_NODE","displayStyle","DisplayStyle","DEFAULT","dropType","dropMaximumSize","DEFAULT_DROP_MAXIMUM_SIZE","lazyExpandingEnabled","contextMenu","menuBar","keyStrokes","multiCheck","nodes","nodesMap","nodePaddingLevelCheckable","nodePaddingLevelNotCheckable","nodePaddingLevelDiffParentHasIcon","nodePaddingLeft","nodeCheckBoxPaddingLeft","nodeControlPaddingLeft","nodePaddingLevel","scrollToSelection","scrollTop","scrollTopHistory","selectedNodes","prevSelectedNode","filters","textFilterEnabled","filterSupport","_createFilterSupport","filteredElementsDirty","filterAnimated","checkedNodes","groupedNodes","visibleNodesFlat","visibleNodesMap","_addWidgetProperties","_additionalContainerClasses","_doubleClickSupport","_$animationWrapper","_$expandAnimationWrappers","_filterMenusHandler","_filterMenus","bind","_popupOpenHandler","_onDesktopPopupOpen","_inSelectionPathList","_changeNodeTaskScheduled","viewRangeRendered","viewRangeSize","startAnimationFunc","runningAnimations","runningAnimationsFinishFunc","_renderViewportBlocked","invalidateLayoutTree","nodeHeight","nodeWidth","maxNodeWidth","nodeWidthDirty","$data","_scrolldirections","requestFocusOnNodeControlMouseDown","_$mouseDownNode","_init","model","setFilters","addFilter","breadcrumbFilter","BREADCRUMB","initialTraversing","_setCheckable","_ensureTreeNodes","_initNodes","create","parent","position","Position","BOTTOM","menuOrder","session","menuFilter","cssClass","_updateItemPath","_setDisplayStyle","_setKeyStrokes","_setMenus","parentNode","visitNodes","_initTreeNode","_nodesByIds","_updateSelectionPath","forEach","node","applyFiltersForNode","_addToVisibleFlatList","i","length","childNodeIndex","nvl","_createTreeNode","nodeModel","_createKeyStrokeContext","_initKeyStrokeContext","_initTreeKeyStrokeContext","modifierBitMask","NONE","keyStrokeContext","registerKeyStroke","argMenus","updateKeyStrokes","_setProperty","_updateMenuBar","menuItems","MENU_BAR","setMenuItems","contextMenuItems","CONTEXT_MENU","updateMenuItems","_resetTreeNode","reset","isSelectedNode","indexOf","selectedNode","id","childNodes","child","level","checked","push","_initTreeNodeInternal","_updateMarkChildrenChecked","initialized","_applyNodeDefaultValues","applyTo","_destroy","_destroyTreeNode","_removeFromFlatList","destroy","_onNodeDeleted","func","_render","$container","$parent","appendDiv","addClass","layout","htmlComp","install","setLayout","_renderData","render","desktop","on","_renderCheckableStyle","_onContextMenu","_onNodeMouseDown","_onNodeMouseUp","_onNodeDoubleClick","_onNodeControlMouseDown","_onNodeControlMouseUp","_onNodeControlDoubleClick","isHorizontalScrollingEnabled","toggleClass","_installScrollbars","axis","_installNodeTooltipSupport","_updateNodeDimensions","_renderDisplayStyle","_renderViewport","_renderProperties","_renderTextFilterEnabled","_postRender","_renderSelection","_remove","off","remove","stop","uninstallDragAndDropHandler","_uninstallNodeTooltipSupport","$fillBefore","$fillAfter","isTreeNodeCheckEnabled","_onScroll","scrollToSelectionBackup","scrollLeft","rendered","setScrollTop","setProperty","_renderScrollTop","rendering","get$Scrollable","isEveryParentVisible","viewRange","_calculateCurrentViewRange","_renderViewRange","maxScrollTop","scrollHeight","clientHeight","_nodeAtScrollTop","_calculateViewRangeForNode","_rerenderViewport","_removeRenderedNodes","_renderFiller","_updateDomNodeWidth","$nodes","find","each","elem","$node","data","hasClass","_removeNode","_renderViewRangeForNode","_renderNodesInRange","range","prepend","maxRange","intersect","size","equals","Error","to","from","newRange","union","numNodesRendered","ensureRangeVisible","log","isTraceEnabled","trace","nodesToInsert","r","attached","_insertNodesInDOM","prependDiv","fillBeforeDimensions","_calculateFillerDimension","cssHeight","height","cssWidth","width","Math","max","fillAfterDimensions","dataWidth","dimension","_heightForNode","_widthForNode","_removeNodesInRange","fromNode","toNode","numNodesRemoved","subtract","detach","viewRangeDirty","rangesToRender","rangesToRemove","firstNode","lastNode","$nodesBeforeFirstNode","prevAll","$nodesAfterLastNode","nextAll","_cleanupNodes","debugOutput","Object","keys","_postRenderViewRange","_visibleNodesInViewRange","slice","reduce","aggr","eq","nodeTop","some","visibleNodesLength","quarterRange","floor","VIEW_RANGE_DIVISOR","diff","nodeIndex","min","calculateViewRangeSize","viewRangeMultiplier","ceil","outerHeight","setViewRangeSize","emptyNode","_renderNode","appendTo","oldNodeWidth","outerWidth","updateNodeHeights","removeAllNodes","_removeNodes","ensure","p","removeClass","paddingLeft","_computeNodePaddingLeft","_removeMenus","destination","onlyVisible","enableDisableKeyStroke","filterAccordingToSelection","_renderEnabled","_installOrUninstallDragAndDropHandler","enabled","enabledComputed","setEnabled","setTabbableOrFocusable","_renderDisabledStyle","_renderDisabledStyleInternal","setCheckable","_updateNodePaddingLevel","isBreadcrumbStyleActive","setCheckableStyle","_renderCheckable","isNodeRendered","Boolean","updateCheckableStateRec","$control","children","$checkbox","_updateControl","_renderCheckbox","cssPaddingLeft","filter","_updateNodePaddingsLeft","_renderExpansion","options","opts","expandLazyChanged","expansionChanged","extend","expanded","expandedLazy","childNode","select","_highlightPrevSelectedNode","revealSelection","prevSelectionAnimationDone","addClassForAnimation","oneAnimationEnd","_removeSelection","_removeNodeSelection","setDropType","_renderDropType","setDropMaximumSize","installOrUninstallDragAndDropHandler","target","doInstall","selector","onDrop","event","trigger","additionalDropProperties","$target","currentTarget","properties","nodeId","init","checkChildrenChecked","childrenFound","j","childrenChecked","stateChanged","hasCheckedSiblings","siblingNode","text","_nodeTooltipText","arrowPosition","arrowPositionUnit","nativeTooltip","get","isCustomEllipsisTooltipPossible","uninstall","tooltipText","_isTruncatedNodeTooltipEnabled","isContentTruncated","$text","setDisplayStyle","expandNode","filterVisibleNodes","removeFilter","index","element","isNullOrUndefined","setBreadcrumbStyleActive","active","isNodeInBreadcrumbVisible","undefined","setToggleBreadcrumbStyleEnabled","setBreadcrumbTogglingThreshold","setNodeExpanded","collapseNode","collapseAll","rebuildSuppressed","lazy","renderAnimated","collapseChildNodes","childOpts","valueCopy","renderExpansion","renderExpansionOpts","_rebuildParent","filterAccepted","ensureLoadChildren","done","_addChildrenToFlatList","_removeChildrenFromFlatList","ensureExpansionVisible","setNodeExpandedRecursive","animatedRemove","parentIndex","elementsToDelete","parentLevel","removedNodes","$wrapper","insertBefore","isDescendantOf","append","displayBackup","css","hideNode","splice","animate","start","complete","onAnimationComplete","step","revalidateLayoutTree","duration","queue","call","affectedNodes","renderingAnimated","_addToVisibleFlatListNoCheck","insertIndex","_findInsertPositionInFlatList","animatedRendering","insertBatch","forceFilter","isSubAdding","setInsertAt","newInsertBatch","isFilterAccepted","isAlreadyAdded","insertBatchInVisibleNodes","_showNodes","checkAndHandleBatchAnimationWrapper","nextBatchInsertIndex","_addChildrenToFlatListIfExpanded","insertNodes","checkAndHandleBatch","indexOffset","containsNode","insertAt","lastBatchInsertIndex","thatNode","siblings","_findPositionInFlatList","nodePos","prevSiblingNode","prevSiblingPos","checkNode","_isInSameSubTree","_isChildOfSelectedNodes","$animationWrapper","isEmpty","lastNodeIndex","nodeBefore","showNode","insertAfter","nodeAfter","animationCompleteFunc","replaceWith","contents","showNodes","indexHint","h","insert","scrollTo","layoutValidator","schedulePostValidateFunction","_expandAllParentNodes","$element","$scrollable","isExpanded","getChildren","defaultChildHeight","deselectAll","selectNodes","selectNode","debounceSend","equalsIgnoreOrder","_rememberScrollTopBeforeSelection","_setSelectedNodes","_updateScrollTopAfterSelection","currentLevel","scrollTopForLevel","_nodesSelectedInternal","_triggerNodesSelected","filterDirty","onRequestsDone","deselectNode","deselectNodes","collectChildren","concat","_collectNodesIfDescendants","removeAll","isNodeSelected","_computeNodePaddings","padding","_computeNodePaddingLeftForLevel","_computeNodeControlPaddingLeft","iconId","$dummyNode","$dummyNodeControl","cssPxValue","currNode","parentNodes","_updateChildNodeIndex","startIndex","insertNode","sort","a","b","entry","pushAll","updateNode","updateNodes","updatedNode","propertiesChanged","oldNode","_applyUpdatedNodeProperties","_decorate","leaf","deleteNode","deleteNodes","deleteAllNodes","deleteAllChildNodes","deletedNodes","parentNodesToReindex","topLevelNodesToReindex","uncheckNodes","nodesToCheck","result","nodeToCheck","isAncestorOf","updateNodeMap","updateNodeOrder","checkNodes","checkOnlyEnabled","checkChildren","triggerNodesChecked","updatedNodes","_renderChecked","uncheckNode","debounce","_showContextMenu","filteredMenus","$part","close","location","x","pageX","y","pageY","$anchor","open","mousedown","doubleClicked","hasNode","window","one","_isCheckboxClicked","loosesFocusIfPseudoElementIsRemoved","focusAndPreventDefault","is","selectionChanged","ultimate","_isGroupingEnd","addToGroup","$selectedNodes","applyFilter","_filter","newlyHidden","newlyShown","updateFilteredElements","textFilterText","it","animated","_applyFiltersForNodeRec","_nodesFiltered","hiddenNodes","applyNewHiddenShownNodes","parentResult","unshift","recursive","changed","_applyFiltersForNode","hasChildrenWithFilterAccepted","setFilterAccepted","pushTo","applyFiltersForElement","widget","filterElements","getElementText","setTextFilterEnabled","isTextFilterFieldVisible","renderFilterField","_insertNodeInDOMAtPlace","_installNodes","newWidth","oldWidth","_ensureNodeInDOM","useAnimation","that","hide","slideDown","suppressDetachHandling","slideUp","_nodesToIds","map","ids","_nodeById","doNodeAction","expansionOpts","ctrlKey","shiftKey","focus","suppressEvent","preventDefault","changeNode","paddingDirty","queueMicrotask","popup","isFocusable","has","updateScrollbars","update","collectSubtree","$rootNode","includeRootNodeInResult","rootLevel","parseFloat","attr","$nextNode","next","isNaN","$result","nextUntil","add","doNotProcessChildren","CHECKBOX"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/tree/Tree.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, ContextMenuPopup, defaultValues, Device, DoubleClickSupport, dragAndDrop, FilterSupport, graphics, HtmlComponent, KeyStrokeContext, keyStrokeModifier, LazyNodeFilter, MenuBar, MenuDestinations, MenuItemsOrder, menus as menus_1, objects, Range, scout, scrollbars, tooltips, TreeBreadcrumbFilter, TreeCollapseAllKeyStroke, TreeCollapseOrDrillUpKeyStroke, TreeExpandOrDrillDownKeyStroke, TreeLayout, TreeNavigationDownKeyStroke, TreeNavigationEndKeyStroke, TreeNavigationUpKeyStroke, TreeNode, TreeSpaceKeyStroke, Widget} from '../index';\nimport $ from 'jquery';\n\n/**\n * @class\n * @constructor\n */\nexport default class Tree extends Widget {\n  constructor() {\n    super();\n\n    this.toggleBreadcrumbStyleEnabled = false;\n    this.breadcrumbTogglingThreshold = null;\n    this.autoCheckChildren = false;\n    this.checkable = false;\n    this.checkableStyle = Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n    this.displayStyle = Tree.DisplayStyle.DEFAULT;\n    this.dropType = 0;\n    this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    this.lazyExpandingEnabled = true;\n    this.menus = [];\n    this.contextMenu = null;\n    this.menuBar = null;\n    this.keyStrokes = [];\n    this.multiCheck = true;\n    this.nodes = []; // top-level nodes\n    this.nodesMap = {}; // all nodes by id\n    this.nodePaddingLevelCheckable = 23; /* padding for one tree-level if the tree is checkable */\n    this.nodePaddingLevelNotCheckable = 18; /* padding for one tree-level if the tree is not checkable. this includes outline trees! */\n    this.nodePaddingLevelDiffParentHasIcon = null; /* is read from CSS */\n    this.nodePaddingLeft = null; /* is read from CSS */\n    this.nodeCheckBoxPaddingLeft = 29;\n    this.nodeControlPaddingLeft = null; /* is read from CSS */\n    this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n    this.scrollToSelection = false;\n    this.scrollTop = 0;\n    this.scrollTopHistory = []; // Only necessary for breadcrumb mode\n    this.selectedNodes = [];\n    this.prevSelectedNode = null; // The previously selected node, relevant for breadcrumb in compact mode\n\n    this.filters = [];\n    this.textFilterEnabled = true;\n    this.filterSupport = this._createFilterSupport();\n    this.filteredElementsDirty = false;\n    this.filterAnimated = true;\n\n    // performance optimization: E.g. rather than iterating over the whole tree when unchecking all nodes,\n    // we explicitly keep track of nodes to uncheck (useful e.g. for single-check mode in very large trees).\n    this.checkedNodes = [];\n\n    this.groupedNodes = {};\n    this.visibleNodesFlat = [];\n    this.visibleNodesMap = {};\n    this._addWidgetProperties(['menus', 'keyStrokes']);\n    this._additionalContainerClasses = ''; // may be used by subclasses to set additional CSS classes\n    this._doubleClickSupport = new DoubleClickSupport();\n    this._$animationWrapper = null; // used by _renderExpansion()\n    this._$expandAnimationWrappers = [];\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._popupOpenHandler = this._onDesktopPopupOpen.bind(this);\n\n    // contains all parents of a selected node, the selected node and the first level children\n    this._inSelectionPathList = {};\n    this._changeNodeTaskScheduled = false;\n    this.viewRangeRendered = new Range(0, 0);\n    this.viewRangeSize = 20;\n\n    this.startAnimationFunc = function() {\n      this.runningAnimations++;\n    }.bind(this);\n    this.runningAnimations = 0;\n    this.runningAnimationsFinishFunc = function() {\n      this.runningAnimations--;\n      if (this.runningAnimations <= 0) {\n        this.runningAnimations = 0;\n        this._renderViewportBlocked = false;\n        this.invalidateLayoutTree();\n      }\n    }.bind(this);\n\n    this.nodeHeight = 0;\n    this.nodeWidth = 0;\n    this.maxNodeWidth = 0;\n    this.nodeWidthDirty = false;\n    this.$data = null;\n    this._scrolldirections = 'both';\n    this.requestFocusOnNodeControlMouseDown = true;\n    this._$mouseDownNode = null;\n  }\n\n  static DisplayStyle = {\n    DEFAULT: 'default',\n    BREADCRUMB: 'breadcrumb'\n  };\n\n  static CheckableStyle = {\n    /**\n     * Node check is only possible by checking the checkbox.\n     */\n    CHECKBOX: 'checkbox',\n    /**\n     * Node check is possible by clicking anywhere on the node.\n     */\n    CHECKBOX_TREE_NODE: 'checkbox_tree_node'\n  };\n\n  /**\n   * Used to calculate the view range size. See {@link calculateViewRangeSize}.\n   */\n  static VIEW_RANGE_DIVISOR = 4;\n\n  _init(model) {\n    super._init(model);\n    this.setFilters(this.filters, false);\n    this.addFilter(new LazyNodeFilter(this), false);\n    this.breadcrumbFilter = new TreeBreadcrumbFilter(this);\n    if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n      this.addFilter(this.breadcrumbFilter, false);\n    }\n    this.initialTraversing = true;\n    this._setCheckable(this.checkable);\n    this._ensureTreeNodes(this.nodes);\n    this._initNodes(this.nodes);\n    this.initialTraversing = false;\n    this.menuBar = scout.create('MenuBar', {\n      parent: this,\n      position: MenuBar.Position.BOTTOM,\n      menuOrder: new MenuItemsOrder(this.session, 'Tree'),\n      menuFilter: this._filterMenusHandler,\n      cssClass: 'bounded'\n    });\n    this._updateItemPath(true);\n    this._setDisplayStyle(this.displayStyle);\n    this._setKeyStrokes(this.keyStrokes);\n    this._setMenus(this.menus);\n  }\n\n  /**\n   * Initialize nodes, applies filters and updates flat list\n   */\n  _initNodes(nodes, parentNode) {\n    if (!nodes) {\n      nodes = this.nodes;\n    }\n    Tree.visitNodes(this._initTreeNode.bind(this), nodes, parentNode);\n    if (typeof this.selectedNodes[0] === 'string') {\n      this.selectedNodes = this._nodesByIds(this.selectedNodes);\n    }\n    this._updateSelectionPath();\n    nodes.forEach(node => this.applyFiltersForNode(node));\n    Tree.visitNodes((node, parentNode) => this._addToVisibleFlatList(node, false), nodes, parentNode);\n  }\n\n  /**\n   * Iterates through the given array and converts node-models to instances of TreeNode (or a subclass).\n   * If the array element is already a TreeNode the function leaves the element untouched. This function also\n   * ensures that the attribute childNodeIndex is set. By default we use the order of the nodes array as index\n   * but only if childNodeIndex is undefined.\n   *\n   * @param nodes Array of node-models (plain object) or nodes (instance of TreeNode)\n   */\n  _ensureTreeNodes(nodes) {\n    let i, node;\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      node.childNodeIndex = scout.nvl(node.childNodeIndex, i);\n      if (node instanceof TreeNode) {\n        continue;\n      }\n      nodes[i] = this._createTreeNode(node);\n    }\n  }\n\n  _createTreeNode(nodeModel) {\n    nodeModel = scout.nvl(nodeModel, {});\n    nodeModel.parent = this;\n    return scout.create('TreeNode', nodeModel);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this._initTreeKeyStrokeContext();\n  }\n\n  _initTreeKeyStrokeContext() {\n    let modifierBitMask = keyStrokeModifier.NONE;\n\n    this.keyStrokeContext.registerKeyStroke([\n      new TreeSpaceKeyStroke(this),\n      new TreeNavigationUpKeyStroke(this, modifierBitMask),\n      new TreeNavigationDownKeyStroke(this, modifierBitMask),\n      new TreeCollapseAllKeyStroke(this, modifierBitMask),\n      new TreeCollapseOrDrillUpKeyStroke(this, modifierBitMask),\n      new TreeNavigationEndKeyStroke(this, modifierBitMask),\n      new TreeExpandOrDrillDownKeyStroke(this, modifierBitMask)\n    ]);\n  }\n\n  _setMenus(argMenus) {\n    this.updateKeyStrokes(argMenus, this.menus);\n    this._setProperty('menus', argMenus);\n    this._updateMenuBar();\n  }\n\n  _updateMenuBar() {\n    let menuItems = this._filterMenus(this.menus, MenuDestinations.MENU_BAR, false, true);\n    this.menuBar.setMenuItems(menuItems);\n    let contextMenuItems = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true);\n    if (this.contextMenu) {\n      this.contextMenu.updateMenuItems(contextMenuItems);\n    }\n  }\n\n  _setKeyStrokes(keyStrokes) {\n    this.updateKeyStrokes(keyStrokes, this.keyStrokes);\n    this._setProperty('keyStrokes', keyStrokes);\n  }\n\n  _resetTreeNode(node, parentNode) {\n    node.reset();\n  }\n\n  isSelectedNode(node) {\n    return this.selectedNodes.indexOf(node) > -1;\n  }\n\n  _updateSelectionPath() {\n    let selectedNode = this.selectedNodes[0];\n    if (!selectedNode) {\n      return;\n    }\n    this._inSelectionPathList[selectedNode.id] = true;\n\n    selectedNode.childNodes.forEach(child => {\n      this._inSelectionPathList[child.id] = true;\n    });\n\n    let parentNode = selectedNode.parentNode;\n    while (parentNode) {\n      this._inSelectionPathList[parentNode.id] = true;\n      parentNode = parentNode.parentNode;\n    }\n  }\n\n  _initTreeNode(node, parentNode) {\n    this.nodesMap[node.id] = node;\n    if (parentNode) {\n      node.parentNode = parentNode;\n      node.level = node.parentNode.level + 1;\n    }\n    if (node.checked) {\n      this.checkedNodes.push(node);\n    }\n    this._initTreeNodeInternal(node, parentNode);\n    this._updateMarkChildrenChecked(node, true, node.checked);\n    node.initialized = true;\n  }\n\n  _applyNodeDefaultValues(node) {\n    defaultValues.applyTo(node, 'TreeNode');\n  }\n\n  /**\n   * Override this function if you want a custom node init before filtering.\n   * The default impl. applies default values to the given node.\n   */\n  _initTreeNodeInternal(node, parentNode) {\n    this._applyNodeDefaultValues(node);\n  }\n\n  _destroy() {\n    super._destroy();\n    this.visitNodes(this._destroyTreeNode.bind(this));\n    this.nodes = []; // finally, clear array with root tree-nodes\n  }\n\n  _destroyTreeNode(node) {\n    delete this.nodesMap[node.id];\n    this._removeFromFlatList(node, false); // ensure node is not longer in visible nodes list.\n    node.destroy();\n\n    // noinspection JSUnresolvedVariable\n    if (this._onNodeDeleted) { // Necessary for subclasses\n      this._onNodeDeleted(node);\n    }\n  }\n\n  /**\n   * pre-order (top-down) traversal of the tree-nodes of this tree.<br>\n   * if func returns true the children of the visited node are not visited.\n   */\n  visitNodes(func, parentNode) {\n    return Tree.visitNodes(func, this.nodes, parentNode);\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('tree');\n    if (this._additionalContainerClasses) {\n      this.$container.addClass(this._additionalContainerClasses);\n    }\n    let layout = new TreeLayout(this);\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(layout);\n    this._renderData();\n    this.menuBar.render();\n    this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    this._renderCheckableStyle();\n  }\n\n  _renderData() {\n    this.$data = this.$container.appendDiv('tree-data')\n      .on('contextmenu', this._onContextMenu.bind(this))\n      .on('mousedown', '.tree-node', this._onNodeMouseDown.bind(this))\n      .on('mouseup', '.tree-node', this._onNodeMouseUp.bind(this))\n      .on('dblclick', '.tree-node', this._onNodeDoubleClick.bind(this))\n      .on('mousedown', '.tree-node-control', this._onNodeControlMouseDown.bind(this))\n      .on('mouseup', '.tree-node-control', this._onNodeControlMouseUp.bind(this))\n      .on('dblclick', '.tree-node-control', this._onNodeControlDoubleClick.bind(this));\n    HtmlComponent.install(this.$data, this.session);\n\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$data.toggleClass('scrollable-tree', true);\n    }\n\n    this._installScrollbars({\n      axis: this._scrolldirections\n    });\n    this._installNodeTooltipSupport();\n    this._updateNodeDimensions();\n    // render display style before viewport (not in renderProperties) to have a correct style from the beginning\n    this._renderDisplayStyle();\n    this._renderViewport();\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderTextFilterEnabled();\n  }\n\n  _postRender() {\n    super._postRender();\n    this._renderSelection();\n  }\n\n  _remove() {\n    this.session.desktop.off('popupOpen', this._popupOpenHandler);\n    this.filterSupport.remove();\n\n    // stop all animations\n    if (this._$animationWrapper) {\n      this._$animationWrapper.stop(false, true);\n    }\n    // Detach nodes from jQuery objects (because those will be removed)\n    this.visitNodes(this._resetTreeNode.bind(this));\n\n    dragAndDrop.uninstallDragAndDropHandler(this);\n    this._uninstallNodeTooltipSupport();\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.$data = null;\n    // reset rendered view range because no range is rendered\n    this.viewRangeRendered = new Range(0, 0);\n    super._remove();\n  }\n\n  isHorizontalScrollingEnabled() {\n    return this._scrolldirections === 'both' || this._scrolldirections === 'x';\n  }\n\n  isTreeNodeCheckEnabled() {\n    return this.checkableStyle === Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    let scrollToSelectionBackup = this.scrollToSelection;\n    this.scrollToSelection = false;\n    let scrollTop = this.$data[0].scrollTop;\n    let scrollLeft = this.$data[0].scrollLeft;\n    if (this.scrollTop !== scrollTop && this.rendered) {\n      this._renderViewport();\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n    this.scrollToSelection = scrollToSelectionBackup;\n  }\n\n  /**\n   * @override\n   */\n  setScrollTop(scrollTop) {\n    this.setProperty('scrollTop', scrollTop);\n    // call _renderViewport to make sure nodes are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed\n    if (this.rendered) {\n      this._renderViewport();\n      // Render scroll top again to make sure the data really is at the expected position\n      // This seems only to be necessary for Chrome and the tree, it seems to work for IE and table.\n      // It is not optimal, because actually it should be possible to modify the $data[0].scrollTop without using this function\n      // Some debugging showed that after reducing the height of the afterFiller in _renderFiller the scrollTop will be wrong.\n      // Updating the scrollTop in renderFiller or other view range relevant function is bad because it corrupts smooth scrolling (see also commit c14ce92e0a7bff568d4f2d715e3061a782e728c2)\n      this._renderScrollTop();\n    }\n  }\n\n  /**\n   * @override\n   */\n  _renderScrollTop() {\n    if (this.rendering) {\n      // Not necessary to do it while rendering since it will be done by the layout\n      return;\n    }\n    scrollbars.scrollTop(this.$data, this.scrollTop);\n  }\n\n  /**\n   * @override\n   */\n  get$Scrollable() {\n    return this.$data;\n  }\n\n  _renderViewport() {\n    if (this.runningAnimations > 0 || this._renderViewportBlocked) {\n      // animation pending do not render view port because finishing should rerenderViewport\n      return;\n    }\n    if (!this.$container.isEveryParentVisible()) {\n      // If the tree is invisible, the width and height of the nodes cannot be determined\n      // In that case, the tree won't be layouted either -> as soon as it will be layouted, renderViewport will be called again\n      return;\n    }\n    let viewRange = this._calculateCurrentViewRange();\n    this._renderViewRange(viewRange);\n  }\n\n  _calculateCurrentViewRange() {\n    let node,\n      scrollTop = this.$data[0].scrollTop,\n      maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;\n\n    if (maxScrollTop === 0 && this.visibleNodesFlat.length > 0) {\n      // no scrollbars visible\n      node = this.visibleNodesFlat[0];\n    } else {\n      node = this._nodeAtScrollTop(scrollTop);\n    }\n\n    return this._calculateViewRangeForNode(node);\n  }\n\n  _rerenderViewport() {\n    if (this._renderViewportBlocked) {\n      return;\n    }\n    this._removeRenderedNodes();\n    this._renderFiller();\n    this._updateDomNodeWidth();\n    this._renderViewport();\n  }\n\n  _removeRenderedNodes() {\n    let $nodes = this.$data.find('.tree-node');\n    $nodes.each((i, elem) => {\n      let $node = $(elem),\n        node = $node.data('node');\n      if ($node.hasClass('hiding')) {\n        // Do not remove nodes which are removed using an animation\n        return;\n      }\n      this._removeNode(node);\n    });\n    this.viewRangeRendered = new Range(0, 0);\n  }\n\n  _renderViewRangeForNode(node) {\n    let viewRange = this._calculateViewRangeForNode(node);\n    this._renderViewRange(viewRange);\n  }\n\n  _renderNodesInRange(range) {\n    let prepend = false;\n\n    let nodes = this.visibleNodesFlat;\n    if (nodes.length === 0) {\n      return;\n    }\n\n    let maxRange = new Range(0, nodes.length);\n    range = maxRange.intersect(range);\n    if (this.viewRangeRendered.size() > 0 && !range.intersect(this.viewRangeRendered).equals(new Range(0, 0))) {\n      throw new Error('New range must not intersect with existing.');\n    }\n    if (range.to <= this.viewRangeRendered.from) {\n      prepend = true;\n    }\n    let newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    let numNodesRendered = this.ensureRangeVisible(range);\n\n    $.log.isTraceEnabled() && $.log.trace(numNodesRendered + ' new nodes rendered from ' + range);\n  }\n\n  ensureRangeVisible(range) {\n    let nodes = this.visibleNodesFlat;\n    let nodesToInsert = [];\n    for (let r = range.from; r < range.to; r++) {\n      let node = nodes[r];\n      if (!node.attached) {\n        nodesToInsert.push(node);\n      }\n    }\n    this._insertNodesInDOM(nodesToInsert);\n    return nodesToInsert.length;\n  }\n\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$data.prependDiv('tree-data-fill');\n    }\n\n    let fillBeforeDimensions = this._calculateFillerDimension(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeDimensions.height);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$fillBefore.cssWidth(fillBeforeDimensions.width);\n      this.maxNodeWidth = Math.max(fillBeforeDimensions.width, this.maxNodeWidth);\n    }\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeDimensions.height);\n\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$data.appendDiv('tree-data-fill');\n    }\n\n    let fillAfterDimensions = {\n      height: 0,\n      width: 0\n    };\n    fillAfterDimensions = this._calculateFillerDimension(new Range(this.viewRangeRendered.to, this.visibleNodesFlat.length));\n    this.$fillAfter.cssHeight(fillAfterDimensions.height);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$fillAfter.cssWidth(fillAfterDimensions.width);\n      this.maxNodeWidth = Math.max(fillAfterDimensions.width, this.maxNodeWidth);\n    }\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterDimensions.height);\n  }\n\n  _calculateFillerDimension(range) {\n    let dataWidth = 0;\n    if (this.rendered) {\n      // the outer-width is only correct if this tree is already rendered. otherwise wrong values are returned.\n      dataWidth = this.$data.width();\n    }\n    let dimension = {\n      height: 0,\n      width: Math.max(dataWidth, this.maxNodeWidth)\n    };\n    for (let i = range.from; i < range.to; i++) {\n      let node = this.visibleNodesFlat[i];\n      dimension.height += this._heightForNode(node);\n      dimension.width = Math.max(dimension.width, this._widthForNode(node));\n    }\n    return dimension;\n  }\n\n  _removeNodesInRange(range) {\n    let fromNode, toNode, node, i,\n      numNodesRemoved = 0,\n      nodes = this.visibleNodesFlat;\n\n    let maxRange = new Range(0, nodes.length);\n    range = maxRange.intersect(range);\n    fromNode = nodes[range.from];\n    toNode = nodes[range.to];\n\n    let newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove nodes at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (i = range.from; i < range.to; i++) {\n      node = nodes[i];\n      this._removeNode(node);\n      numNodesRemoved++;\n    }\n\n    $.log.isTraceEnabled() && $.log.trace(numNodesRemoved + ' nodes removed from ' + range + '.');\n  }\n\n  /**\n   * Just removes the node, does NOT adjust this.viewRangeRendered\n   */\n  _removeNode(node) {\n    let $node = node.$node;\n    if (!$node) {\n      return;\n    }\n    if ($node.hasClass('hiding')) {\n      // Do not remove nodes which are removed using an animation\n      return;\n    }\n    // only remove node\n    $node.detach();\n    node.attached = false;\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {\n      // When node with has changed (because of changes in layout) we must at least\n      // update the internal node width even though the view-range has not changed.\n      if (this.nodeWidthDirty) {\n        this._renderFiller();\n        this._updateDomNodeWidth();\n      }\n\n      // Range already rendered -> do nothing\n      return;\n    }\n    if (!this.viewRangeDirty) {\n      let rangesToRender = viewRange.subtract(this.viewRangeRendered);\n      let rangesToRemove = this.viewRangeRendered.subtract(viewRange);\n      let maxRange = new Range(0, this.visibleNodesFlat.length);\n\n      rangesToRemove.forEach(range => {\n        this._removeNodesInRange(range);\n        if (maxRange.to < range.to) {\n          this.viewRangeRendered = viewRange;\n        }\n      });\n      rangesToRender.forEach(range => {\n        this._renderNodesInRange(range);\n      });\n    } else {\n      // expansion changed\n      this.viewRangeRendered = viewRange;\n      this.ensureRangeVisible(viewRange);\n    }\n\n    // check if at least last and first row in range got correctly rendered\n    if (this.viewRangeRendered.size() > 0) {\n      let nodes = this.visibleNodesFlat;\n      let firstNode = nodes[this.viewRangeRendered.from];\n      let lastNode = nodes[this.viewRangeRendered.to - 1];\n      if (this.viewRangeDirty) {\n        // cleanup nodes before range and after\n        let $nodesBeforeFirstNode = firstNode.$node.prevAll('.tree-node');\n        let $nodesAfterLastNode = lastNode.$node.nextAll('.tree-node');\n        this._cleanupNodes($nodesBeforeFirstNode);\n        this._cleanupNodes($nodesAfterLastNode);\n      }\n      if (!firstNode.attached || !lastNode.attached) {\n        throw new Error('Nodes not rendered as expected. ' + this.viewRangeRendered +\n          '. First: ' + graphics.debugOutput(firstNode.$node) +\n          '. Last: ' + graphics.debugOutput(lastNode.$node) +\n          '. Length: visibleNodesFlat=' + this.visibleNodesFlat.length + ' nodes=' + this.nodes.length + ' nodesMap=' + Object.keys(this.nodesMap).length);\n      }\n    }\n\n    this._postRenderViewRange();\n    this.viewRangeDirty = false;\n  }\n\n  _postRenderViewRange() {\n    this._renderFiller();\n    this._updateDomNodeWidth();\n    this._renderSelection();\n  }\n\n  _visibleNodesInViewRange() {\n    return this.visibleNodesFlat.slice(this.viewRangeRendered.from, this.viewRangeRendered.to);\n  }\n\n  _updateDomNodeWidth() {\n    if (!this.isHorizontalScrollingEnabled()) {\n      return;\n    }\n    if (!this.rendered || !this.nodeWidthDirty) {\n      return;\n    }\n    let nodes = this._visibleNodesInViewRange();\n    let maxNodeWidth = this.maxNodeWidth;\n    // find max-width\n    maxNodeWidth = nodes.reduce((aggr, node) => {\n      return Math.max(node.width, aggr);\n    }, scout.nvl(maxNodeWidth, 0));\n    // set max width on all nodes\n    nodes.forEach(node => {\n      node.$node.cssWidth(maxNodeWidth);\n    });\n    this.nodeWidthDirty = false;\n  }\n\n  _cleanupNodes($nodes) {\n    for (let i = 0; i < $nodes.length; i++) {\n      this._removeNode($nodes.eq(i).data('node'));\n    }\n  }\n\n  /**\n   * Returns the index of the node which is at position scrollTop.\n   */\n  _nodeAtScrollTop(scrollTop) {\n    let height = 0,\n      nodeTop;\n    this.visibleNodesFlat.some((node, i) => {\n      height += this._heightForNode(node);\n      if (scrollTop < height) {\n        nodeTop = node;\n        return true;\n      }\n      return false;\n    });\n    let visibleNodesLength = this.visibleNodesFlat.length;\n    if (!nodeTop && visibleNodesLength > 0) {\n      nodeTop = this.visibleNodesFlat[visibleNodesLength - 1];\n    }\n    return nodeTop;\n  }\n\n  _heightForNode(node) {\n    let height = 0;\n    if (node.height) {\n      height = node.height;\n    } else {\n      height = this.nodeHeight;\n    }\n    return height;\n  }\n\n  _widthForNode(node) {\n    let width = 0;\n    if (node.width) {\n      width = node.width;\n    } else {\n      width = this.nodeWidth;\n    }\n    return width;\n  }\n\n  /**\n   * Returns a range of size this.viewRangeSize. Start of range is nodeIndex - viewRangeSize / 4.\n   * -> 1/4 of the nodes are before the viewport 2/4 in the viewport 1/4 after the viewport,\n   * assuming viewRangeSize is 2*number of possible nodes in the viewport (see calculateViewRangeSize).\n   */\n  _calculateViewRangeForNode(node) {\n    let viewRange = new Range(),\n      quarterRange = Math.floor(this.viewRangeSize / Tree.VIEW_RANGE_DIVISOR),\n      diff;\n\n    let nodeIndex = this.visibleNodesFlat.indexOf(node);\n    viewRange.from = Math.max(nodeIndex - quarterRange, 0);\n    viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleNodesFlat.length);\n    if (!node || nodeIndex === -1) {\n      return viewRange;\n    }\n\n    // Try to use the whole viewRangeSize (extend from if necessary)\n    diff = this.viewRangeSize - viewRange.size();\n    if (diff > 0) {\n      viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n    }\n    return viewRange;\n  }\n\n  /**\n   * Calculates the optimal view range size (number of nodes to be rendered).\n   * It uses the default node height to estimate how many nodes fit in the view port.\n   * The view range size is this value * 2.\n   * <p>\n   * Note: the value calculated by this function is important for calculating the\n   * 'insertBatch'. When the value becomes smaller than 4 ({@link Tree.VIEW_RANGE_DIVISOR}) this\n   * will cause errors on inserting nodes at the right position. See #262890.\n   */\n  calculateViewRangeSize() {\n    // Make sure row height is up to date (row height may be different after zooming)\n    this._updateNodeDimensions();\n    if (this.nodeHeight === 0) {\n      throw new Error('Cannot calculate view range with nodeHeight = 0');\n    }\n    let viewRangeMultiplier = Tree.VIEW_RANGE_DIVISOR / 2; // See  _calculateViewRangeForNode\n    let viewRange = Math.ceil(this.$data.outerHeight() / this.nodeHeight) * viewRangeMultiplier;\n    return Math.max(Tree.VIEW_RANGE_DIVISOR, viewRange);\n  }\n\n  setViewRangeSize(viewRangeSize) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    if (this.rendered) {\n      this._renderViewport();\n    }\n  }\n\n  _updateNodeDimensions() {\n    let emptyNode = this._createTreeNode();\n    let $node = this._renderNode(emptyNode).appendTo(this.$data);\n    this.nodeHeight = $node.outerHeight(true);\n    if (this.isHorizontalScrollingEnabled()) {\n      let oldNodeWidth = this.nodeWidth;\n      this.nodeWidth = $node.outerWidth(true);\n      if (oldNodeWidth !== this.nodeWidth) {\n        this.viewRangeDirty = true;\n      }\n    }\n    emptyNode.reset();\n  }\n\n  /**\n   * Updates the node heights for every visible node and clears the height of the others\n   */\n  updateNodeHeights() {\n    this.visibleNodesFlat.forEach(node => {\n      if (!node.attached) {\n        node.height = null;\n      } else {\n        node.height = node.$node.outerHeight(true);\n      }\n    });\n  }\n\n  removeAllNodes() {\n    this._removeNodes(this.nodes);\n  }\n\n  /**\n   * @param parentNode\n   *          Optional. If provided, this node's state will be updated (e.g. it will be collapsed\n   *          if it does no longer have child nodes). Can also be an array, in which case all of\n   *          those nodes are updated.\n   */\n  _removeNodes(nodes, parentNode) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    nodes.forEach(function(node) {\n      this._removeFromFlatList(node, true);\n      if (node.childNodes.length > 0) {\n        this._removeNodes(node.childNodes, node);\n      }\n      if (node.$node) {\n        if (this._$animationWrapper && this._$animationWrapper.find(node.$node).length > 0) {\n          this._$animationWrapper.stop(false, true);\n        }\n        node.reset();\n      }\n    }, this);\n\n    // If every child node was deleted mark node as collapsed (independent of the model state)\n    // --> makes it consistent with addNodes and expand (expansion is not allowed if there are no child nodes)\n    arrays.ensure(parentNode).forEach(p => {\n      if (p && p.$node && p.childNodes.length === 0) {\n        p.$node.removeClass('expanded lazy');\n      }\n    });\n    if (this.rendered) {\n      this.viewRangeDirty = true;\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _renderNode(node) {\n    let paddingLeft = this._computeNodePaddingLeft(node);\n    node.render(this.$container, paddingLeft);\n    return node.$node;\n  }\n\n  _removeMenus() {\n    // menubar takes care about removal\n  }\n\n  _filterMenus(argMenus, destination, onlyVisible, enableDisableKeyStroke) {\n    return menus_1.filterAccordingToSelection('Tree', this.selectedNodes.length, argMenus, destination, onlyVisible, enableDisableKeyStroke);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n\n    this._installOrUninstallDragAndDropHandler();\n    let enabled = this.enabledComputed;\n    this.$data.setEnabled(enabled);\n    this.$container.setTabbableOrFocusable(enabled);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$data);\n  }\n\n  setCheckable(checkable) {\n    this.setProperty('checkable', checkable);\n  }\n\n  _setCheckable(checkable) {\n    this._setProperty('checkable', checkable);\n    this._updateNodePaddingLevel();\n  }\n\n  _updateNodePaddingLevel() {\n    if (this.isBreadcrumbStyleActive()) {\n      this.nodePaddingLevel = 0;\n    } else if (this.checkable) {\n      this.nodePaddingLevel = this.nodePaddingLevelCheckable;\n    } else {\n      this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n    }\n  }\n\n  setCheckableStyle(checkableStyle) {\n    this.setProperty('checkableStyle', checkableStyle);\n  }\n\n  _renderCheckable() {\n    // Define helper functions\n    let isNodeRendered = node => Boolean(node.$node);\n    let updateCheckableStateRec = node => {\n      let $node = node.$node;\n      let $control = $node.children('.tree-node-control');\n      let $checkbox = $node.children('.tree-node-checkbox');\n\n      node._updateControl($control);\n      if (this.checkable) {\n        if ($checkbox.length === 0) {\n          node._renderCheckbox();\n        }\n      } else {\n        $checkbox.remove();\n      }\n\n      $node.cssPaddingLeft(this._computeNodePaddingLeft(node));\n\n      // Recursion\n      if (node.childNodes) {\n        node.childNodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n      }\n    };\n\n    // Start recursion\n    this.nodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n  }\n\n  _renderDisplayStyle() {\n    this.$container.toggleClass('breadcrumb', this.isBreadcrumbStyleActive());\n    this.nodePaddingLeft = null;\n    this.nodeControlPaddingLeft = null;\n    this._updateNodePaddingsLeft();\n    // update scrollbar if mode has changed (from tree to bc or vice versa)\n    this.invalidateLayoutTree();\n  }\n\n  _renderExpansion(node, options) {\n    let opts = {\n      expandLazyChanged: false,\n      expansionChanged: false\n    };\n    $.extend(opts, options);\n\n    let $node = node.$node,\n      expanded = node.expanded;\n\n    // Only render if node is rendered to make it possible to expand/collapse currently hidden nodes (used by collapseAll).\n    if (!$node || $node.length === 0) {\n      return;\n    }\n\n    // Only expand / collapse if there are child nodes\n    if (node.childNodes.length === 0) {\n      return true;\n    }\n\n    $node.toggleClass('lazy', expanded && node.expandedLazy);\n    if (!opts.expansionChanged && !opts.expandLazyChanged) {\n      // Expansion state has not changed -> return\n      return;\n    }\n\n    if (expanded) {\n      $node.addClass('expanded');\n    } else {\n      $node.removeClass('expanded');\n    }\n  }\n\n  _renderSelection() {\n    // Add children class to root nodes if no nodes are selected\n    if (this.selectedNodes.length === 0) {\n      this.nodes.forEach(childNode => {\n        if (childNode.rendered) {\n          childNode.$node.addClass('child-of-selected');\n        }\n      }, this);\n    }\n\n    this.$container.toggleClass('no-nodes-selected', this.selectedNodes.length === 0);\n\n    this.selectedNodes.forEach(function(node) {\n      if (!this.visibleNodesMap[node.id]) {\n        return;\n      }\n\n      // Mark all ancestor nodes, especially necessary for bread crumb mode\n      let parentNode = node.parentNode;\n      if (parentNode && parentNode.rendered) {\n        parentNode.$node.addClass('parent-of-selected');\n      }\n      while (parentNode) {\n        if (parentNode.rendered) {\n          parentNode.$node.addClass('ancestor-of-selected');\n        }\n        parentNode = parentNode.parentNode;\n      }\n\n      // Mark all child nodes\n      if (node.expanded) {\n        node.childNodes.forEach(childNode => {\n          if (childNode.rendered) {\n            childNode.$node.addClass('child-of-selected');\n          }\n        }, this);\n      }\n\n      if (node.rendered) {\n        node.$node.select(true);\n      }\n    }, this);\n\n    // Update 'group' markers for all rendered nodes\n    for (let i = this.viewRangeRendered.from; i < this.viewRangeRendered.to; i++) {\n      if (i >= this.visibleNodesFlat.length) {\n        break;\n      }\n      let node = this.visibleNodesFlat[i];\n      if (node && node.rendered) {\n        node.$node.toggleClass('group', Boolean(this.groupedNodes[node.id]));\n      }\n    }\n\n    this._updateNodePaddingsLeft();\n    this._highlightPrevSelectedNode();\n\n    if (this.scrollToSelection) {\n      this.revealSelection();\n    }\n  }\n\n  _renderCheckableStyle() {\n    this.$data.toggleClass('checkable', this.isTreeNodeCheckEnabled());\n  }\n\n  _highlightPrevSelectedNode() {\n    if (!this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    if (!this.prevSelectedNode || !this.prevSelectedNode.rendered || this.prevSelectedNode.prevSelectionAnimationDone) {\n      return;\n    }\n    // Highlight previously selected node, but do it only once\n    if (this.prevSelectedNode.$node.hasClass('animate-prev-selected')) {\n      return this;\n    }\n    this.prevSelectedNode.$node.addClassForAnimation('animate-prev-selected').oneAnimationEnd(() => {\n      this.prevSelectedNode.prevSelectionAnimationDone = true;\n    });\n  }\n\n  _removeSelection() {\n    // Remove children class on root nodes if no nodes were selected\n    if (this.selectedNodes.length === 0) {\n      this.nodes.forEach(childNode => {\n        if (childNode.rendered) {\n          childNode.$node.removeClass('child-of-selected');\n        }\n      }, this);\n    }\n\n    // Ensure animate-prev-selected class is removed (in case animation did not start)\n    if (this.prevSelectedNode && this.prevSelectedNode.rendered) {\n      this.prevSelectedNode.$node.removeClass('animate-prev-selected');\n    }\n\n    this.selectedNodes.forEach(this._removeNodeSelection, this);\n  }\n\n  _removeNodeSelection(node) {\n    if (node.rendered) {\n      node.$node.select(false);\n    }\n\n    // remove ancestor and child classes\n    let parentNode = node.parentNode;\n    if (parentNode && parentNode.rendered) {\n      parentNode.$node.removeClass('parent-of-selected');\n    }\n    while (parentNode && parentNode.rendered) {\n      parentNode.$node.removeClass('ancestor-of-selected');\n      parentNode = parentNode.parentNode;\n    }\n    if (node.expanded) {\n      node.childNodes.forEach(childNode => {\n        if (childNode.rendered) {\n          childNode.$node.removeClass('child-of-selected');\n        }\n      }, this);\n    }\n  }\n\n  setDropType(dropType) {\n    this.setProperty('dropType', dropType);\n  }\n\n  _renderDropType() {\n    this._installOrUninstallDragAndDropHandler();\n  }\n\n  setDropMaximumSize(dropMaximumSize) {\n    this.setProperty('dropMaximumSize', dropMaximumSize);\n  }\n\n  _installOrUninstallDragAndDropHandler() {\n    dragAndDrop.installOrUninstallDragAndDropHandler(\n      {\n        target: this,\n        doInstall: () => this.dropType && this.enabledComputed,\n        selector: '.tree-data,.tree-node',\n        onDrop: event => this.trigger('drop', event),\n        dropType: () => this.dropType,\n        additionalDropProperties: event => {\n          let $target = $(event.currentTarget);\n          let properties = {\n            nodeId: ''\n          };\n          if ($target.hasClass('tree-node')) {\n            let node = $target.data('node');\n            properties.nodeId = node.id;\n          }\n          return properties;\n        }\n      });\n  }\n\n  _updateMarkChildrenChecked(node, init, checked, checkChildrenChecked) {\n    if (!this.checkable) {\n      return;\n    }\n\n    if (checkChildrenChecked) {\n      let childrenFound = false;\n      for (let j = 0; j < node.childNodes.length > 0; j++) {\n        let childNode = node.childNodes[j];\n        if (childNode.checked || childNode.childrenChecked) {\n          node.childrenChecked = true;\n          checked = true;\n          childrenFound = true;\n          if (this.rendered && node.$node) {\n            node.$node\n              .children('.tree-node-checkbox')\n              .children('.check-box')\n              .toggleClass('children-checked', true);\n          }\n          break;\n        }\n      }\n      if (!childrenFound) {\n        node.childrenChecked = false;\n        if (this.rendered && node.$node) {\n          node.$node.children('.tree-node-checkbox')\n            .children('.check-box')\n            .toggleClass('children-checked', false);\n        }\n      }\n    }\n\n    if (!node.parentNode || node.parentNode.checked) {\n      return;\n    }\n\n    let stateChanged = false;\n    if (!checked && !init) {\n      // node was unchecked check siblings\n      let hasCheckedSiblings = false;\n      for (let i = 0; i < node.parentNode.childNodes.length > 0; i++) {\n        let siblingNode = node.parentNode.childNodes[i];\n        if (siblingNode.checked || siblingNode.childrenChecked) {\n          hasCheckedSiblings = true;\n          break;\n        }\n      }\n      if (hasCheckedSiblings !== node.parentNode.childrenChecked) {\n        // parentNode.checked should be false\n        node.parentNode.childrenChecked = hasCheckedSiblings;\n        stateChanged = true;\n      }\n    }\n    if (checked && !node.parentNode.childrenChecked) {\n      node.parentNode.childrenChecked = true;\n      stateChanged = true;\n    }\n    if (stateChanged) {\n      this._updateMarkChildrenChecked(node.parentNode, init, checked);\n      if (this.rendered && node.parentNode.$node) {\n        if (checked) {\n          node.parentNode.$node.children('.tree-node-checkbox')\n            .children('.check-box')\n            .toggleClass('children-checked', true);\n        } else {\n          node.parentNode.$node.children('.tree-node-checkbox')\n            .children('.check-box')\n            .toggleClass('children-checked', false);\n        }\n      }\n    }\n  }\n\n  _installNodeTooltipSupport() {\n    tooltips.install(this.$data, {\n      parent: this,\n      selector: '.tree-node',\n      text: this._nodeTooltipText.bind(this),\n      arrowPosition: 50,\n      arrowPositionUnit: '%',\n      nativeTooltip: !Device.get().isCustomEllipsisTooltipPossible()\n    });\n  }\n\n  _uninstallNodeTooltipSupport() {\n    tooltips.uninstall(this.$data);\n  }\n\n  _nodeTooltipText($node) {\n    let node = $node.data('node');\n    if (node.tooltipText) {\n      return node.tooltipText;\n    } else if (this._isTruncatedNodeTooltipEnabled() && $node.isContentTruncated()) {\n      return node.$text.text();\n    }\n  }\n\n  _isTruncatedNodeTooltipEnabled() {\n    return true;\n  }\n\n  setDisplayStyle(displayStyle) {\n    if (this.displayStyle === displayStyle) {\n      return;\n    }\n    this._renderViewportBlocked = true;\n    this._setDisplayStyle(displayStyle);\n    if (this.rendered) {\n      this._renderDisplayStyle();\n    }\n    this._renderViewportBlocked = false;\n  }\n\n  _setDisplayStyle(displayStyle) {\n    this._setProperty('displayStyle', displayStyle);\n\n    if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n      if (this.selectedNodes.length > 0) {\n        let selectedNode = this.selectedNodes[0];\n        if (!selectedNode.expanded) {\n          this.expandNode(selectedNode);\n        }\n      }\n      this.filterAnimated = false;\n      this.addFilter(this.breadcrumbFilter, false);\n      this.filterVisibleNodes();\n    } else {\n      this.removeFilter(this.breadcrumbFilter);\n      this.filterAnimated = true;\n    }\n    this._updateNodePaddingLevel();\n  }\n\n  _updateNodePaddingsLeft() {\n    this.$nodes().each((index, element) => {\n      let $node = $(element);\n      let node = $node.data('node');\n      let paddingLeft = this._computeNodePaddingLeft(node);\n      $node.cssPaddingLeft(objects.isNullOrUndefined(paddingLeft) ? '' : paddingLeft);\n      node._updateControl($node.children('.tree-node-control'));\n    });\n  }\n\n  setBreadcrumbStyleActive(active) {\n    if (active) {\n      this.setDisplayStyle(Tree.DisplayStyle.BREADCRUMB);\n    } else {\n      this.setDisplayStyle(Tree.DisplayStyle.DEFAULT);\n    }\n  }\n\n  isNodeInBreadcrumbVisible(node) {\n    return this._inSelectionPathList[node.id] === undefined ? false : this._inSelectionPathList[node.id];\n  }\n\n  isBreadcrumbStyleActive() {\n    return this.displayStyle === Tree.DisplayStyle.BREADCRUMB;\n  }\n\n  setToggleBreadcrumbStyleEnabled(enabled) {\n    this.setProperty('toggleBreadcrumbStyleEnabled', enabled);\n  }\n\n  setBreadcrumbTogglingThreshold(width) {\n    this.setProperty('breadcrumbTogglingThreshold', width);\n  }\n\n  expandNode(node, opts) {\n    this.setNodeExpanded(node, true, opts);\n  }\n\n  collapseNode(node, opts) {\n    this.setNodeExpanded(node, false, opts);\n  }\n\n  collapseAll() {\n    this.rebuildSuppressed = true;\n    // Collapse all expanded child nodes (only model)\n    this.visitNodes(node => {\n      this.collapseNode(node);\n    });\n\n    if (this.rendered) {\n      // ensure correct rendering\n      this._rerenderViewport();\n    }\n\n    this.rebuildSuppressed = false;\n  }\n\n  setNodeExpanded(node, expanded, opts) {\n    opts = opts || {};\n    let lazy = opts.lazy;\n    if (objects.isNullOrUndefined(lazy)) {\n      if (node.expanded === expanded) {\n        // no state change: Keep the current \"expandedLazy\" state\n        lazy = node.expandedLazy;\n      } else if (expanded) {\n        // collapsed -> expanded: Set the \"expandedLazy\" state to the node's \"lazyExpandingEnabled\" flag\n        lazy = node.lazyExpandingEnabled;\n      } else {\n        // expanded -> collapsed: Set the \"expandedLazy\" state to false\n        lazy = false;\n      }\n    }\n    let renderAnimated = scout.nvl(opts.renderAnimated, true);\n\n    // Never do lazy expansion if it is disabled on the tree\n    if (!this.lazyExpandingEnabled) {\n      lazy = false;\n    }\n\n    if (this.isBreadcrumbStyleActive()) {\n      // Do not allow to collapse a selected node\n      if (!expanded && this.selectedNodes.indexOf(node) > -1) {\n        this.setNodeExpanded(node, true, opts);\n        return;\n      }\n    }\n\n    // Optionally collapse all children (recursively)\n    if (opts.collapseChildNodes) {\n      // Suppress render expansion\n      let childOpts = objects.valueCopy(opts);\n      childOpts.renderExpansion = false;\n\n      node.childNodes.forEach(childNode => {\n        if (childNode.expanded) {\n          this.collapseNode(childNode, childOpts);\n        }\n      });\n    }\n    let renderExpansionOpts = {\n      expansionChanged: false,\n      expandLazyChanged: false\n    };\n\n    // Set expansion state\n    if (node.expanded !== expanded || node.expandedLazy !== lazy) {\n      renderExpansionOpts.expansionChanged = node.expanded !== expanded;\n      renderExpansionOpts.expandLazyChanged = node.expandedLazy !== lazy;\n      node.expanded = expanded;\n      node.expandedLazy = lazy;\n\n      if (renderExpansionOpts.expansionChanged) {\n        if (node.parentNode) {\n          // ensure node is visible under the parent node if there is a parent.\n          this._rebuildParent(node.parentNode, opts);\n        } else if (node.filterAccepted) {\n          this._addToVisibleFlatList(node, false);\n        } else {\n          this._removeFromFlatList(node, false);\n        }\n      } else if (renderExpansionOpts.expandLazyChanged) {\n        this.applyFiltersForNode(node, false, renderAnimated);\n      }\n\n      if (this.groupedNodes[node.id]) {\n        this._updateItemPath(false, node);\n      }\n\n      if (node.expanded) {\n        node.ensureLoadChildren().done(this._addChildrenToFlatList.bind(this, node, null, renderAnimated, null, true /* required that ctrl+shift+add expands all rows of a table-page */));\n      } else {\n        this._removeChildrenFromFlatList(node, renderAnimated);\n      }\n      this.trigger('nodeExpanded', {\n        node: node,\n        expanded: expanded,\n        expandedLazy: lazy\n      });\n      this.viewRangeDirty = true;\n    }\n\n    // Render expansion\n    if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n      this._renderExpansion(node, renderExpansionOpts);\n    }\n\n    if (this.rendered) {\n      this.ensureExpansionVisible(node);\n    }\n  }\n\n  setNodeExpandedRecursive(nodes, expanded, opts) {\n    Tree.visitNodes(childNode => {\n      this.setNodeExpanded(childNode, expanded, opts);\n    }, nodes);\n  }\n\n  _rebuildParent(node, opts) {\n    if (this.rebuildSuppressed) {\n      return;\n    }\n    if (node.expanded || node.expandedLazy) {\n      this._addChildrenToFlatList(node, null, true, null, true /* required so that double clicking a table-page-row expands the clicked child row */);\n    } else {\n      this._removeChildrenFromFlatList(node, false);\n    }\n    // Render expansion\n    if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n      let renderExpansionOpts = {\n        expansionChanged: true\n      };\n      this._renderExpansion(node, renderExpansionOpts);\n    }\n  }\n\n  _removeChildrenFromFlatList(parentNode, animatedRemove) {\n    // Only if a parent is available the children are available.\n    if (this.visibleNodesMap[parentNode.id]) {\n      let parentIndex = this.visibleNodesFlat.indexOf(parentNode);\n      let elementsToDelete = 0;\n      let parentLevel = parentNode.level;\n      let removedNodes = [];\n      animatedRemove = animatedRemove && this.rendered;\n      if (this._$animationWrapper) {\n        // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n        // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n        // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n        // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n        this._$animationWrapper.stop(false, true);\n      }\n      this._$expandAnimationWrappers.forEach($wrapper => {\n        $wrapper.stop(false, true);\n      });\n      for (let i = parentIndex + 1; i < this.visibleNodesFlat.length; i++) {\n        if (this.visibleNodesFlat[i].level > parentLevel) {\n          let node = this.visibleNodesFlat[i];\n          if (this.isHorizontalScrollingEnabled()) {\n            // if node is the node which defines the widest width then recalculate width for render\n            if (node.width === this.maxNodeWidth) {\n              this.maxNodeWidth = 0;\n              this.nodeWidthDirty = true;\n            }\n          }\n          delete this.visibleNodesMap[this.visibleNodesFlat[i].id];\n          if (node.attached && animatedRemove) {\n            if (!this._$animationWrapper) {\n              this._$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(node.$node);\n              this._$animationWrapper.data('parentNode', parentNode);\n            }\n            if (node.isDescendantOf(this._$animationWrapper.data('parentNode'))) {\n              this._$animationWrapper.append(node.$node);\n            }\n            node.attached = false;\n            node.displayBackup = node.$node.css('display');\n            removedNodes.push(node);\n          } else if (node.attached && !animatedRemove) {\n            this.hideNode(node, false, false);\n          }\n          elementsToDelete++;\n        } else {\n          break;\n        }\n      }\n\n      this.visibleNodesFlat.splice(parentIndex + 1, elementsToDelete);\n      // animate closing\n      if (animatedRemove) { // don't animate while rendering (not necessary, or may even lead to timing issues)\n        this._renderViewportBlocked = true;\n        if (removedNodes.length > 0) {\n          this._$animationWrapper.animate({\n            height: 0\n          }, {\n            start: this.startAnimationFunc,\n            complete: onAnimationComplete.bind(this, removedNodes),\n            step: this.revalidateLayoutTree.bind(this),\n            duration: 200,\n            queue: false\n          });\n        } else if (this._$animationWrapper) {\n          this._$animationWrapper.remove();\n          this._$animationWrapper = null;\n          onAnimationComplete.call(this, removedNodes);\n        } else {\n          this._renderViewportBlocked = false;\n        }\n      }\n      return removedNodes;\n    }\n\n    // ----- Helper functions -----\n    function onAnimationComplete(affectedNodes) {\n      affectedNodes.forEach(node => {\n        node.$node.detach();\n        node.$node.css('display', node.displayBackup);\n        node.displayBackup = null;\n      });\n      if (this._$animationWrapper) {\n        this._$animationWrapper.remove();\n        this._$animationWrapper = null;\n      }\n      this.runningAnimationsFinishFunc();\n    }\n  }\n\n  _removeFromFlatList(node, animatedRemove) {\n    if (this.visibleNodesMap[node.id]) {\n      let index = this.visibleNodesFlat.indexOf(node);\n      this._removeChildrenFromFlatList(node, false);\n      if (this.isHorizontalScrollingEnabled()) {\n        // if node is the node which defines the widest width then recalculate width for render\n        if (node.width === this.maxNodeWidth) {\n          this.maxNodeWidth = 0;\n          this.nodeWidthDirty = true;\n        }\n      }\n      this.visibleNodesFlat.splice(index, 1);\n      delete this.visibleNodesMap[node.id];\n      this.hideNode(node, animatedRemove);\n    }\n  }\n\n  /**\n   * @returns {boolean} whether or not the function added a node to the flat list\n   */\n  _addToVisibleFlatList(node, renderingAnimated) {\n    // if node already is in visible list don't do anything. If no parentNode is available this node is on toplevel, if a parent is available\n    // it has to be in visible list and also be expanded\n    if (!this.visibleNodesMap[node.id] && node.filterAccepted\n      && (!node.parentNode || node.parentNode.expanded && this.visibleNodesMap[node.parentNode.id])) {\n      if (this.initialTraversing) {\n        // for faster index calculation\n        this._addToVisibleFlatListNoCheck(node, this.visibleNodesFlat.length, renderingAnimated);\n      } else {\n        let insertIndex = this._findInsertPositionInFlatList(node);\n        this._addToVisibleFlatListNoCheck(node, insertIndex, renderingAnimated);\n      }\n    }\n  }\n\n  // TODO [7.0] CGU applies to all the add/remove to/from flat list methods:\n  // Is it really necessary to update dom on every operation? why not just update the list and renderViewport at the end?\n  // The update of the flat list is currently implemented quite complicated -> it should be simplified.\n  // And: because add to flat list renders all the children the rendered node count is greater than the viewRangeSize until\n  // the layout renders the viewport again -> this must not happen (can be seen when a node gets expanded)\n  _addChildrenToFlatList(parentNode, parentIndex, animatedRendering, insertBatch, forceFilter) {\n    // add nodes recursively\n    if (!this.visibleNodesMap[parentNode.id]) {\n      return 0;\n    }\n\n    let isSubAdding = Boolean(insertBatch);\n    parentIndex = parentIndex ? parentIndex : this.visibleNodesFlat.indexOf(parentNode);\n    animatedRendering = animatedRendering && this.rendered; // don't animate while rendering (not necessary, or may even lead to timing issues)\n    if (this._$animationWrapper && !isSubAdding) {\n      // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n      // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n      // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n      // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n      this._$animationWrapper.stop(false, true);\n    }\n\n    if (insertBatch) {\n      insertBatch.setInsertAt(parentIndex);\n    } else {\n      insertBatch = this.newInsertBatch(parentIndex + 1);\n    }\n\n    parentNode.childNodes.forEach((node, index) => {\n      if (!node.initialized || !node.isFilterAccepted(forceFilter)) {\n        return;\n      }\n\n      let insertIndex, isAlreadyAdded = this.visibleNodesMap[node.id];\n      if (isAlreadyAdded) {\n        this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n        // Animate rendering is always false because it would generate a bunch of animation wrappers which stay forever without really starting an animation...\n        this.checkAndHandleBatchAnimationWrapper(parentNode, false, insertBatch);\n        insertBatch = this.newInsertBatch(insertBatch.nextBatchInsertIndex());\n        insertBatch = this._addChildrenToFlatListIfExpanded(1, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n      } else {\n        insertBatch.insertNodes.push(node);\n        this.visibleNodesMap[node.id] = true;\n        insertBatch = this.checkAndHandleBatch(insertBatch, parentNode, animatedRendering);\n        insertBatch = this._addChildrenToFlatListIfExpanded(0, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n      }\n    });\n\n    if (!isSubAdding) {\n      // animation is not done yet and all added nodes are in visible range\n      this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n      this.invalidateLayoutTree();\n    }\n\n    return insertBatch;\n  }\n\n  /**\n   * Checks if the given node is expanded, and if that's the case determine the insert index of the node and add its children to the flat list.\n   *\n   * @param {number} indexOffset either 0 or 1, offset is added to the insert index\n   */\n  _addChildrenToFlatListIfExpanded(indexOffset, node, insertIndex, animatedRendering, insertBatch, forceFilter) {\n    if (node.expanded && node.childNodes.length) {\n      if (insertBatch.containsNode(node.parentNode) || insertBatch.length() > 1) {\n        // if parent node is already in the batch, do not change the insertIndex,\n        // only append child nodes below that parent node\n        // Also, if the batch is not empty (i.e. contains more nodes than the current node),\n        // the insert index was already calculated previously and must not be changed.\n        insertIndex = insertBatch.insertAt();\n      } else {\n        insertIndex = this._findInsertPositionInFlatList(node);\n      }\n      insertIndex += indexOffset;\n      insertBatch = this._addChildrenToFlatList(node, insertIndex, animatedRendering, insertBatch, forceFilter);\n    }\n\n    return insertBatch;\n  }\n\n  _showNodes(insertBatch) {\n    return this.viewRangeRendered.from + this.viewRangeSize >= insertBatch.lastBatchInsertIndex() &&\n      this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex();\n  }\n\n  /**\n   * This function tries to find the correct insert position within the flat list for the given node.\n   * The function must consider the order of child nodes in the original tree structure and then check\n   * where in the flat list this position is.\n   */\n  _findInsertPositionInFlatList(node) {\n    let childNodes,\n      parentNode = node.parentNode;\n\n    // use root nodes as nodes when no other parent node is available (root case)\n    if (parentNode) {\n      childNodes = parentNode.childNodes;\n    } else {\n      childNodes = this.nodes;\n    }\n\n    // find all visible siblings for our node (incl. our own node, which is probably not yet\n    // in the visible nodes map)\n    let thatNode = node;\n    let siblings = childNodes.filter(node => {\n      return Boolean(this.visibleNodesMap[node.id]) || node === thatNode;\n    });\n\n    // when there are no visible siblings, insert below the parent node\n    if (siblings.length === 0) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    let nodePos = siblings.indexOf(node);\n\n    // when there are no prev. siblings in the flat list, insert below the parent node\n    if (nodePos === 0) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    let prevSiblingNode = siblings[nodePos - 1];\n    let prevSiblingPos = this._findPositionInFlatList(prevSiblingNode);\n\n    // when the prev. sibling is not in the flat list, insert below the parent node\n    if (prevSiblingPos === -1) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    // find the index of the last child element of our prev. sibling node\n    // that's where we want to insert the new node. We go down the flat list\n    // starting from the prev. sibling node, until we hit a node that does not\n    // belong to the sub tree of the prev. sibling node.\n    let i, checkNode;\n    for (i = prevSiblingPos; i < this.visibleNodesFlat.length; i++) {\n      checkNode = this.visibleNodesFlat[i];\n      if (!this._isInSameSubTree(prevSiblingNode, checkNode)) {\n        return i;\n      }\n    }\n\n    // insert at the end of the list\n    return this.visibleNodesFlat.length;\n  }\n\n  _findPositionInFlatList(node) {\n    return this.visibleNodesFlat.indexOf(node);\n  }\n\n  /**\n   * Checks whether the given checkNode belongs to the same sub tree (or is) the given node.\n   * The function goes up all parentNodes of the checkNode.\n   *\n   * @param {TreeNode} node which is used to for the sub tree comparison\n   * @param {TreeNode} checkNode node which is checked against the given node\n   * @returns {boolean}\n   */\n  _isInSameSubTree(node, checkNode) {\n    do {\n      if (checkNode === node || checkNode.parentNode === node) {\n        return true;\n      }\n      checkNode = checkNode.parentNode;\n    } while (checkNode);\n\n    return false;\n  }\n\n  /**\n   * Returns true if the given node is a child of one of the selected nodes.\n   * The functions goes up the parent node hierarchy.\n   *\n   * @param {TreeNode} node to check\n   * @returns {boolean}\n   */\n  _isChildOfSelectedNodes(node) {\n    while (node) {\n      if (this.selectedNodes.indexOf(node.parentNode) > -1) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * Info: the object created here is a bit weird: the array 'insertNodes' is used as function arguments to the Array#splice function at some point.\n   * The signature of that function is: array.splice(index, deleteCount[, element1[,  element2 [, ...]]])\n   * So the first two elements are numbers and all the following elements are TreeNodes or Pages.\n   * @returns {*}\n   */\n  newInsertBatch(insertIndex) {\n    return {\n      insertNodes: [insertIndex, 0], // second element is always 0 (used as argument for deleteCount in Array#splice)\n      $animationWrapper: null,\n      lastBatchInsertIndex: function() {\n        if (this.isEmpty()) {\n          return this.insertAt();\n        }\n        return this.insertAt() + this.insertNodes.length - 3;\n      },\n      nextBatchInsertIndex: function() {\n        // only NBU knows what this means\n        return this.lastBatchInsertIndex() + (this.isEmpty() ? 1 : 2);\n      },\n      isEmpty: function() {\n        return this.insertNodes.length === 2;\n      },\n      length: function() {\n        return this.insertNodes.length - 2;\n      },\n      insertAt: function() {\n        return this.insertNodes[0];\n      },\n      setInsertAt: function(insertAt) {\n        this.insertNodes[0] = insertAt;\n      },\n      containsNode: function(node) {\n        return this.insertNodes.indexOf(node) !== -1;\n      }\n    };\n  }\n\n  checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch) {\n    if (animatedRendering && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.to >= insertBatch.lastBatchInsertIndex() && !insertBatch.$animationWrapper) {\n      // we are in visible area so we need a animation wrapper\n      // if parent is in visible area insert after parent else insert before first node.\n      let lastNodeIndex = insertBatch.lastBatchInsertIndex() - 1,\n        nodeBefore = this.viewRangeRendered.from === insertBatch.lastBatchInsertIndex() ? null : this.visibleNodesFlat[lastNodeIndex];\n      if (nodeBefore && lastNodeIndex >= this.viewRangeRendered.from && lastNodeIndex < this.viewRangeRendered.to && !nodeBefore.attached) {\n        // ensure node before is visible\n        this.showNode(nodeBefore, false, lastNodeIndex);\n      }\n      if (nodeBefore && nodeBefore.attached) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(nodeBefore.$node);\n      } else if (parentNode.attached) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(parentNode.$node);\n      } else if (this.$fillBefore) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(this.$fillBefore);\n      } else {\n        let nodeAfter = this.visibleNodesFlat[insertBatch.lastBatchInsertIndex()];\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(nodeAfter.$node);\n      }\n      insertBatch.animationCompleteFunc = onAnimationComplete;\n      this._$expandAnimationWrappers.push(insertBatch.$animationWrapper);\n    }\n\n    // ----- Helper functions ----- //\n\n    function onAnimationComplete() {\n      insertBatch.$animationWrapper.replaceWith(insertBatch.$animationWrapper.contents());\n      arrays.remove(this._$expandAnimationWrappers, insertBatch.$animationWrapper);\n      insertBatch.$animationWrapper = null;\n      this.runningAnimationsFinishFunc();\n    }\n  }\n\n  checkAndHandleBatch(insertBatch, parentNode, animatedRendering) {\n    if (this.viewRangeRendered.from - 1 === insertBatch.lastBatchInsertIndex()) {\n      // do immediate rendering because list could be longer\n      this.insertBatchInVisibleNodes(insertBatch, false, false);\n      insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n    }\n    this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);\n\n    if (this.viewRangeRendered.from + this.viewRangeSize - 1 === insertBatch.lastBatchInsertIndex()) {\n      // do immediate rendering because list could be longer\n      this.insertBatchInVisibleNodes(insertBatch, true, animatedRendering);\n      insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n    }\n    return insertBatch;\n  }\n\n  insertBatchInVisibleNodes(insertBatch, showNodes, animate) {\n    if (insertBatch.isEmpty()) {\n      // nothing to add\n      return;\n    }\n    this.visibleNodesFlat.splice(...insertBatch.insertNodes);\n    if (showNodes) {\n      let indexHint = insertBatch.insertAt();\n      for (let i = 2; i < insertBatch.insertNodes.length; i++) {\n        let node = insertBatch.insertNodes[i];\n        this.showNode(node, false, indexHint);\n        if (insertBatch.$animationWrapper) {\n          insertBatch.$animationWrapper.append(node.$node);\n        }\n        indexHint++;\n      }\n      if (insertBatch.$animationWrapper) {\n        let h = insertBatch.$animationWrapper.outerHeight();\n        insertBatch.$animationWrapper\n          .css('height', 0)\n          .animate({\n            height: h\n          }, {\n            start: this.startAnimationFunc,\n            complete: insertBatch.animationCompleteFunc.bind(this),\n            step: this.revalidateLayoutTree.bind(this),\n            duration: 200,\n            queue: false\n          });\n      }\n    } else if (insertBatch.$animationWrapper && insertBatch.animationCompleteFunc) {\n      insertBatch.animationCompleteFunc.call(this);\n    }\n  }\n\n  _addToVisibleFlatListNoCheck(node, insertIndex, animatedRendering) {\n    arrays.insert(this.visibleNodesFlat, node, insertIndex);\n    this.visibleNodesMap[node.id] = true;\n    this.showNode(node, animatedRendering, insertIndex);\n  }\n\n  scrollTo(node, options) {\n    if (this.viewRangeRendered.size() === 0) {\n      // Cannot scroll to a node if no node is rendered\n      return;\n    }\n    if (!node.attached) {\n      this._renderViewRangeForNode(node);\n    }\n    if (!node.attached) {\n      // Node may not be visible due to the filter -> don't try to scroll because it would fail\n      return;\n    }\n    scrollbars.scrollTo(this.$data, node.$node, options);\n  }\n\n  revealSelection() {\n    if (!this.rendered) {\n      // Execute delayed because tree may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n\n    if (this.selectedNodes.length > 0) {\n      if (!this.visibleNodesMap[this.selectedNodes[0].id]) {\n        this._expandAllParentNodes(this.selectedNodes[0]);\n      }\n      this.scrollTo(this.selectedNodes[0]);\n      this.ensureExpansionVisible(this.selectedNodes[0]);\n    }\n  }\n\n  ensureExpansionVisible(node) {\n    // only scroll if treenode is in dom and the current node is selected (user triggered expansion change)\n    if (!node || !node.$node || this.selectedNodes[0] !== node) {\n      return;\n    }\n    scrollbars.ensureExpansionVisible({\n      element: node,\n      $element: node.$node,\n      $scrollable: this.get$Scrollable(),\n      isExpanded: element => element.expanded,\n      getChildren: parent => parent.childNodes,\n      nodePaddingLevel: this.nodePaddingLevel,\n      defaultChildHeight: this.nodeHeight\n    });\n  }\n\n  deselectAll() {\n    this.selectNodes([]);\n  }\n\n  selectNode(node, debounceSend) {\n    this.selectNodes(node, debounceSend);\n  }\n\n  selectNodes(nodes, debounceSend) {\n    nodes = arrays.ensure(nodes);\n\n    // TODO [8.0] CGU Actually, the nodes should be filtered here so that invisible nodes may not be selected\n    // But this is currently not possible because the LazyNodeFilter would not accept the nodes\n    // We would have to keep track of the clicked nodes and check them in the lazy node filter (e.g. selectedNode.parentNode.lazySelectedChildNodes[selectedNode.id] = selectedNode).\n    // But since this requires a change in setNodeExpanded as well we decided to not implement it until the TODO at _addChildrenToFlatList is solved\n\n    if (arrays.equalsIgnoreOrder(nodes, this.selectedNodes)) {\n      return;\n    }\n\n    if (this.rendered) {\n      this._rememberScrollTopBeforeSelection();\n      this._removeSelection();\n    }\n    if (this.prevSelectedNode) {\n      this.prevSelectedNode.prevSelectionAnimationDone = false;\n    }\n    this.prevSelectedNode = this.selectedNodes[0];\n    this._setSelectedNodes(nodes, debounceSend);\n    if (this.rendered) {\n      this._renderSelection();\n      this._updateScrollTopAfterSelection();\n    }\n  }\n\n  _rememberScrollTopBeforeSelection() {\n    if (this.isBreadcrumbStyleActive()) {\n      // Save the current scrollTop for future up navigation\n      if (this.selectedNodes.length > 0) {\n        this.scrollTopHistory[this.selectedNodes[0].level] = this.$data[0].scrollTop;\n      }\n    } else {\n      // Clear history if user now works with tree to not get confused when returning to bc mode\n      this.scrollTopHistory = [];\n    }\n  }\n\n  _updateScrollTopAfterSelection() {\n    if (!this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    let currentLevel = -1;\n    if (this.selectedNodes.length > 0) {\n      currentLevel = this.selectedNodes[0].level;\n    }\n    // Remove positions after the current level (no restore when going down, only when going up)\n    this.scrollTopHistory.splice(currentLevel + 1);\n    // Read the scroll top for the current level and use that one if it is set\n    let scrollTopForLevel = this.scrollTopHistory[currentLevel];\n    if (scrollTopForLevel >= 0) {\n      this.setScrollTop(scrollTopForLevel);\n    }\n  }\n\n  _setSelectedNodes(nodes, debounceSend) {\n    // Make a copy so that original array stays untouched\n    this.selectedNodes = nodes.slice();\n    this._nodesSelectedInternal();\n    this._triggerNodesSelected(debounceSend);\n\n    if (this.selectedNodes.length > 0 && !this.visibleNodesMap[this.selectedNodes[0].id]) {\n      this._expandAllParentNodes(this.selectedNodes[0]);\n    }\n\n    this._updateItemPath(true);\n    if (this.isBreadcrumbStyleActive()) {\n      // In breadcrumb mode selected node has to be expanded\n      if (this.selectedNodes.length > 0 && !this.selectedNodes[0].expanded) {\n        this.expandNode(this.selectedNodes[0]);\n        this.selectedNodes[0].filterDirty = true;\n      }\n      this.filter();\n    }\n    this.session.onRequestsDone(this._updateMenuBar.bind(this));\n  }\n\n  /**\n   * This method is overridden by subclasses of Tree. The default impl. does nothing.\n   */\n  _nodesSelectedInternal(node) {\n    // NOP\n  }\n\n  deselectNode(node) {\n    this.deselectNodes(node);\n  }\n\n  /**\n   * @param nodes the nodes to deselect\n   * @param options.collectChildren true to add the selected children to the list of nodes to deselect\n   */\n  deselectNodes(nodes, options) {\n    nodes = arrays.ensure(nodes);\n    options = options || {};\n    if (options.collectChildren) {\n      nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.selectedNodes));\n    }\n    let selectedNodes = this.selectedNodes.slice(); // copy\n    if (arrays.removeAll(selectedNodes, nodes)) {\n      this.selectNodes(selectedNodes);\n    }\n  }\n\n  isNodeSelected(node) {\n    return this.selectedNodes.indexOf(node) > -1;\n  }\n\n  _computeNodePaddingLeft(node) {\n    this._computeNodePaddings();\n    if (this.isBreadcrumbStyleActive()) {\n      return this.nodePaddingLeft;\n    }\n    let padding = this.nodePaddingLeft + this._computeNodePaddingLeftForLevel(node);\n    if (this.checkable) {\n      padding += this.nodeCheckBoxPaddingLeft;\n    }\n    return padding;\n  }\n\n  _computeNodeControlPaddingLeft(node) {\n    return this.nodeControlPaddingLeft + this._computeNodePaddingLeftForLevel(node);\n  }\n\n  _computeNodePaddingLeftForLevel(node) {\n    if (this.checkable || !this.nodePaddingLevelDiffParentHasIcon) {\n      return node.level * this.nodePaddingLevel;\n    }\n    let padding = 0;\n    let parentNode = node.parentNode;\n    while (parentNode) {\n      padding += this.nodePaddingLevel;\n      // Increase the padding if the parent node has an icon to make the hierarchy more clear\n      // This is not necessary if the child nodes have icons as well, the padding even looks too big, as it is the case for checkable trees.\n      // We only check the first child node for an icon because that one has the biggest impact on the hierarchy visualization. It also increases performance a little.\n      if (parentNode.iconId && !parentNode.childNodes[0].iconId) {\n        padding += this.nodePaddingLevelDiffParentHasIcon;\n      }\n      parentNode = parentNode.parentNode;\n    }\n    return padding;\n  }\n\n  /**\n   * Reads the paddings from CSS and stores them in nodePaddingLeft and nodeControlPaddingLeft\n   */\n  _computeNodePaddings() {\n    if (this.nodePaddingLeft !== null && this.nodeControlPaddingLeft !== null && this.nodePaddingLevelDiffParentHasIcon !== null) {\n      return;\n    }\n    let $dummyNode = this.$data.appendDiv('tree-node');\n    let $dummyNodeControl = $dummyNode.appendDiv('tree-node-control');\n    if (this.nodePaddingLeft === null) {\n      this.nodePaddingLeft = $dummyNode.cssPaddingLeft();\n    }\n    if (this.nodeControlPaddingLeft === null) {\n      this.nodeControlPaddingLeft = $dummyNodeControl.cssPaddingLeft();\n    }\n    if (this.nodePaddingLevelDiffParentHasIcon === null) {\n      this.nodePaddingLevelDiffParentHasIcon = this.$container.cssPxValue('--node-padding-level-diff-parent-has-icon');\n    }\n    $dummyNode.remove();\n  }\n\n  _expandAllParentNodes(node) {\n    let i, currNode = node,\n      parentNodes = [];\n\n    currNode = node;\n    let nodesToInsert = [];\n    while (currNode.parentNode) {\n      parentNodes.push(currNode.parentNode);\n      if (!this.visibleNodesMap[currNode.id]) {\n        nodesToInsert.push(currNode);\n      }\n      currNode = currNode.parentNode;\n    }\n\n    for (i = parentNodes.length - 1; i >= 0; i--) {\n      if (nodesToInsert.indexOf(parentNodes[i]) !== -1) {\n        this._addToVisibleFlatList(parentNodes[i], false);\n      }\n      if (!parentNodes[i].expanded) {\n        this.expandNode(parentNodes[i], {\n          renderExpansion: false,\n          renderAnimated: false\n        });\n      }\n    }\n    if (this.rendered && nodesToInsert.length > 0) {\n      this._rerenderViewport();\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _updateChildNodeIndex(nodes, startIndex) {\n    if (!nodes || !nodes.length) {\n      return;\n    }\n    for (let i = scout.nvl(startIndex, 0); i < nodes.length; i++) {\n      nodes[i].childNodeIndex = i;\n    }\n  }\n\n  /**\n   * @param {TreeNode} [parentNode]\n   */\n  insertNode(node, parentNode) {\n    this.insertNodes([node], parentNode);\n  }\n\n  /**\n   * @param {TreeNode} [parentNode]\n   */\n  insertNodes(nodes, parentNode) {\n    nodes = arrays.ensure(nodes).slice();\n    if (nodes.length === 0) {\n      return;\n    }\n    this._ensureTreeNodes(nodes);\n    if (parentNode && !(parentNode instanceof TreeNode)) {\n      throw new Error('parent has to be a tree node: ' + parentNode);\n    }\n\n    // Append continuous node blocks\n    nodes.sort((a, b) => {\n      return a.childNodeIndex - b.childNodeIndex;\n    });\n\n    // Update parent with new child nodes\n    if (parentNode) {\n      if (parentNode.childNodes && parentNode.childNodes.length > 0) {\n        nodes.forEach(entry => {\n          // only insert node if not already existing\n          if (parentNode.childNodes.indexOf(entry) < 0) {\n            arrays.insert(parentNode.childNodes, entry, entry.childNodeIndex);\n          }\n        });\n        this._updateChildNodeIndex(parentNode.childNodes, nodes[0].childNodeIndex);\n      } else {\n        nodes.forEach(entry => {\n          parentNode.childNodes.push(entry);\n        });\n      }\n      this._initNodes(nodes, parentNode);\n      if (this.groupedNodes[parentNode.id]) {\n        this._updateItemPath(false, parentNode);\n      }\n      if (this.rendered) {\n        let opts = {\n          expansionChanged: true\n        };\n        this._renderExpansion(parentNode, opts);\n        this.ensureExpansionVisible(parentNode);\n      }\n    } else {\n      if (this.nodes && this.nodes.length > 0) {\n        nodes.forEach(entry => {\n          // only insert node if not already existing\n          if (this.nodes.indexOf(entry) < 0) {\n            arrays.insert(this.nodes, entry, entry.childNodeIndex);\n          }\n        });\n        this._updateChildNodeIndex(this.nodes, nodes[0].childNodeIndex);\n      } else {\n        arrays.pushAll(this.nodes, nodes);\n      }\n      this._initNodes(nodes, parentNode);\n    }\n    if (this.rendered) {\n      this.viewRangeDirty = true;\n      this.invalidateLayoutTree();\n    }\n    this.trigger('nodesInserted', {\n      nodes: nodes,\n      parentNode: parentNode\n    });\n  }\n\n  updateNode(node) {\n    this.updateNodes([node]);\n  }\n\n  updateNodes(nodes) {\n    nodes = arrays.ensure(nodes);\n    if (nodes.length === 0) {\n      return;\n    }\n    nodes.forEach(function(updatedNode) {\n      let propertiesChanged,\n        oldNode = this.nodesMap[updatedNode.id];\n\n      // if same instance has been updated we must set the flag always to true\n      // because we cannot compare against an \"old\" node\n      if (updatedNode === oldNode) {\n        propertiesChanged = true;\n      } else {\n        this._applyNodeDefaultValues(updatedNode);\n        propertiesChanged = this._applyUpdatedNodeProperties(oldNode, updatedNode);\n      }\n\n      if (propertiesChanged) {\n        this.applyFiltersForNode(oldNode);\n        this._updateItemPath(false, oldNode.parentNode);\n        if (this.rendered) {\n          oldNode._decorate();\n        }\n      }\n    }, this);\n\n    this.trigger('nodesUpdated', {\n      nodes: nodes\n    });\n  }\n\n  /**\n   * Called by _onNodesUpdated for every updated node. The function is expected to apply\n   * all updated properties from the updatedNode to the oldNode. May be overridden by\n   * subclasses so update their specific node properties.\n   *\n   * @param oldNode\n   *          The target node to be updated\n   * @param updatedNode\n   *          The new node with potentially updated properties. Default values are already applied!\n   * @returns {boolean}\n   *          true if at least one property has changed, false otherwise. This value is used to\n   *          determine if the node has to be rendered again.\n   */\n  _applyUpdatedNodeProperties(oldNode, updatedNode) {\n    // Note: We only update _some_ of the properties, because everything else will be handled\n    // with separate events. --> See also: JsonTree.java/handleModelNodesUpdated()\n    let propertiesChanged = false;\n    if (oldNode.leaf !== updatedNode.leaf) {\n      oldNode.leaf = updatedNode.leaf;\n      propertiesChanged = true;\n    }\n    if (oldNode.enabled !== updatedNode.enabled) {\n      oldNode.enabled = updatedNode.enabled;\n      propertiesChanged = true;\n    }\n    if (oldNode.lazyExpandingEnabled !== updatedNode.lazyExpandingEnabled) {\n      oldNode.lazyExpandingEnabled = updatedNode.lazyExpandingEnabled;\n      // Also make sure expandedLazy is reset to false when lazyExpanding is disabled (same code as in AbstractTreeNode.setLazyExpandingEnabled)\n      if (!updatedNode.lazyExpandingEnabled || !this.lazyExpandingEnabled) {\n        oldNode.expandedLazy = false;\n      }\n      propertiesChanged = true;\n    }\n    return propertiesChanged;\n  }\n\n  deleteNode(node, parentNode) {\n    this.deleteNodes([node], parentNode);\n  }\n\n  deleteAllNodes() {\n    this.deleteAllChildNodes();\n  }\n\n  deleteNodes(nodes, parentNode) {\n    let deletedNodes = [];\n    let parentNodesToReindex = [];\n    let topLevelNodesToReindex = [];\n    nodes = arrays.ensure(nodes).slice(); // copy\n    if (nodes.length === 0) {\n      return;\n    }\n\n    nodes.forEach(function(node) {\n      let p = parentNode || node.parentNode;\n      if (p) {\n        if (node.parentNode !== p) {\n          throw new Error('Unexpected parent. Node.parent: ' + node.parentNode + ', parentNode: ' + parentNode);\n        }\n        arrays.remove(p.childNodes, node);\n        if (parentNodesToReindex.indexOf(p) === -1) {\n          parentNodesToReindex.push(p);\n        }\n      } else {\n        arrays.remove(this.nodes, node);\n        topLevelNodesToReindex = this.nodes;\n      }\n      this._destroyTreeNode(node);\n      deletedNodes.push(node);\n      this._updateMarkChildrenChecked(node, false, false);\n\n      // remove children from node map\n      Tree.visitNodes(this._destroyTreeNode.bind(this), node.childNodes);\n    }, this);\n\n    // update child node indices\n    parentNodesToReindex.forEach(p => this._updateChildNodeIndex(p.childNodes));\n    this._updateChildNodeIndex(topLevelNodesToReindex);\n\n    this.deselectNodes(deletedNodes, {collectChildren: true});\n    this.uncheckNodes(deletedNodes, {collectChildren: true});\n\n    // remove node from html document\n    if (this.rendered) {\n      this._removeNodes(deletedNodes, parentNode || parentNodesToReindex);\n    }\n\n    this.trigger('nodesDeleted', {\n      nodes: nodes,\n      parentNode: parentNode\n    });\n  }\n\n  _collectNodesIfDescendants(nodes, nodesToCheck) {\n    let result = [];\n    nodesToCheck.forEach(nodeToCheck => {\n      if (nodes.some(node => {\n        return node.isAncestorOf(nodeToCheck);\n      })) {\n        result.push(nodeToCheck);\n      }\n    });\n    return result;\n  }\n\n  deleteAllChildNodes(parentNode) {\n    let nodes;\n    if (parentNode) {\n      nodes = parentNode.childNodes;\n      parentNode.childNodes = [];\n    } else {\n      nodes = this.nodes;\n      this.nodes = [];\n    }\n    Tree.visitNodes(updateNodeMap.bind(this), nodes);\n\n    this.deselectNodes(nodes, {collectChildren: true});\n    this.uncheckNodes(nodes, {collectChildren: true});\n\n    // remove node from html document\n    if (this.rendered) {\n      this._removeNodes(nodes, parentNode);\n    }\n\n    this.trigger('allChildNodesDeleted', {\n      parentNode: parentNode\n    });\n\n    // --- Helper functions ---\n\n    // Update model and nodemap\n    function updateNodeMap(node) {\n      this._destroyTreeNode(node);\n      this._updateMarkChildrenChecked(node, false, false);\n    }\n  }\n\n  updateNodeOrder(childNodes, parentNode) {\n    childNodes = arrays.ensure(childNodes);\n\n    this._updateChildNodeIndex(childNodes);\n    if (parentNode) {\n      if (parentNode.childNodes.length !== childNodes.length) {\n        throw new Error('Node order may not be updated because lengths of the arrays differ.');\n      }\n      // Make a copy so that original array stays untouched\n      parentNode.childNodes = childNodes.slice();\n      this._removeChildrenFromFlatList(parentNode, false);\n      if (parentNode.expanded) {\n        this._addChildrenToFlatList(parentNode, null, false);\n      }\n    } else {\n      if (this.nodes.length !== childNodes.length) {\n        throw new Error('Node order may not be updated because lengths of the arrays differ.');\n      }\n      // Make a copy so that original array stays untouched\n      this.nodes = childNodes.slice();\n      this.nodes.forEach(function(node) {\n        this._removeFromFlatList(node, false);\n        this._addToVisibleFlatList(node, false);\n        if (node.expanded) {\n          this._addChildrenToFlatList(node, null, false);\n        }\n      }, this);\n    }\n\n    this.trigger('childNodeOrderChanged', {\n      parentNode: parentNode\n    });\n  }\n\n  checkNode(node, checked, options) {\n    let opts = $.extend(options, {\n      checked: checked\n    });\n    this.checkNodes([node], opts);\n  }\n\n  checkNodes(nodes, options) {\n    let opts = {\n      checked: true,\n      checkOnlyEnabled: true,\n      checkChildren: this.autoCheckChildren,\n      triggerNodesChecked: true\n    };\n    $.extend(opts, options);\n    let updatedNodes = [];\n    // use enabled computed because when the parent of the table is disabled, it should not be allowed to check rows\n    if (!this.checkable || !this.enabledComputed && opts.checkOnlyEnabled) {\n      return;\n    }\n    nodes = arrays.ensure(nodes);\n    nodes.forEach(function(node) {\n      if (!node.enabled && opts.checkOnlyEnabled || node.checked === opts.checked || !node.filterAccepted) {\n        if (opts.checkChildren) {\n          this.checkNodes(node.childNodes, opts);\n        }\n        return;\n      }\n      if (!this.multiCheck && opts.checked) {\n        for (let i = 0; i < this.checkedNodes.length; i++) {\n          this.checkedNodes[i].checked = false;\n          this._updateMarkChildrenChecked(this.checkedNodes[i], false, false, true);\n          updatedNodes.push(this.checkedNodes[i]);\n        }\n        this.checkedNodes = [];\n      }\n      node.checked = opts.checked;\n      if (node.checked) {\n        this.checkedNodes.push(node);\n      } else {\n        arrays.remove(this.checkedNodes, node);\n      }\n      updatedNodes.push(node);\n      this._updateMarkChildrenChecked(node, false, opts.checked, true);\n      if (opts.checkChildren) {\n        let childOpts = $.extend({}, opts, {\n          triggerNodesChecked: false\n        });\n        this.checkNodes(node.childNodes, childOpts);\n      }\n    }, this);\n\n    if (opts.triggerNodesChecked && updatedNodes.length > 0) {\n      this.trigger('nodesChecked', {\n        nodes: updatedNodes\n      });\n    }\n    if (this.rendered) {\n      updatedNodes.forEach(node => {\n        node._renderChecked();\n      });\n    }\n  }\n\n  uncheckNode(node, options) {\n    let opts = $.extend({\n      checkOnlyEnabled: true\n    }, options);\n    this.uncheckNodes([node], opts);\n  }\n\n  /**\n   * @param nodes the nodes to uncheck\n   * @param options.collectChildren true to add the checked children to the list of nodes to uncheck\n   */\n  uncheckNodes(nodes, options) {\n    let opts = {\n      checked: false\n    };\n    $.extend(opts, options);\n    if (opts.collectChildren) {\n      nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.checkedNodes));\n    }\n    this.checkNodes(nodes, opts);\n  }\n\n  _triggerNodesSelected(debounce) {\n    this.trigger('nodesSelected', {\n      debounce: debounce\n    });\n  }\n\n  _showContextMenu(event) {\n    let func = function(event) {\n      if (!this.rendered) { // check needed because function is called asynchronously\n        return;\n      }\n      let filteredMenus = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true),\n        $part = $(event.currentTarget);\n      if (filteredMenus.length === 0) {\n        return; // at least one menu item must be visible\n      }\n      // Prevent firing of 'onClose'-handler during contextMenu.open()\n      // (Can lead to null-access when adding a new handler to this.contextMenu)\n      if (this.contextMenu) {\n        this.contextMenu.close();\n      }\n      this.contextMenu = scout.create('ContextMenuPopup', {\n        parent: this,\n        menuItems: filteredMenus,\n        location: {\n          x: event.pageX,\n          y: event.pageY\n        },\n        $anchor: $part,\n        menuFilter: this._filterMenusHandler\n      });\n      this.contextMenu.open();\n    };\n\n    this.session.onRequestsDone(func.bind(this), event);\n  }\n\n  _onNodeMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n\n    let $node = $(event.currentTarget);\n    let node = $node.data('node');\n    if (!this.hasNode(node)) {\n      // if node does not belong to this tree, do nothing (may happen if another tree is embedded inside the node)\n      return;\n    }\n    this._$mouseDownNode = $node;\n    $node.window().one('mouseup', () => {\n      this._$mouseDownNode = null;\n    });\n\n    this.selectNodes(node);\n\n    if (this.checkable && node.enabled && this._isCheckboxClicked(event)) {\n      if (Device.get().loosesFocusIfPseudoElementIsRemoved()) {\n        this.focusAndPreventDefault(event);\n      }\n      this.checkNode(node, !node.checked);\n    }\n    return true;\n  }\n\n  _onNodeMouseUp(event) {\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n\n    let $node = $(event.currentTarget);\n    let node = $node.data('node');\n    if (!this._$mouseDownNode || this._$mouseDownNode[0] !== $node[0]) {\n      // Don't accept if mouse up happens on another node than mouse down, or mousedown didn't happen on a node at all\n      return;\n    }\n\n    this.trigger('nodeClick', {\n      node: node\n    });\n    return true;\n  }\n\n  _isCheckboxClicked(event) {\n    // with CheckableStyle.CHECKBOX_TREE_NODE a click anywhere on the node should trigger the check\n    if (this.isTreeNodeCheckEnabled()) {\n      return true;\n    }\n    return $(event.target).is('.check-box');\n  }\n\n  _updateItemPath(selectionChanged, ultimate) {\n    let selectedNodes, node, level;\n    if (selectionChanged) {\n      // first remove and select selected\n      this.groupedNodes = {};\n\n      this._inSelectionPathList = {};\n    }\n\n    if (!ultimate) {\n      // find direct children\n      selectedNodes = this.selectedNodes;\n      if (selectedNodes.length === 0) {\n        return;\n      }\n      node = selectedNodes[0];\n\n      if (selectionChanged) {\n        this._inSelectionPathList[node.id] = true;\n        if (node.childNodes) {\n          node.childNodes.forEach(child => {\n            this._inSelectionPathList[child.id] = true;\n          });\n        }\n      }\n      level = node.level;\n\n      // find grouping end (ultimate parent)\n      while (node.parentNode) {\n        let parent = node.parentNode;\n        if (this._isGroupingEnd(parent) && !ultimate) {\n          ultimate = node;\n          if (!selectionChanged) {\n            break;\n          }\n        }\n        if (selectionChanged) {\n          this._inSelectionPathList[parent.id] = true;\n        }\n        node = parent;\n      }\n      // find group with same ultimate parent\n      ultimate = ultimate || selectedNodes[0];\n      this.groupedNodes[ultimate.id] = true;\n    }\n    node = ultimate;\n    if (node && node.expanded && this.groupedNodes[node.id]) {\n      addToGroup.call(this, node.childNodes);\n    }\n\n    // ------ helper function ------//\n\n    function addToGroup(nodes) {\n      nodes.forEach(node => {\n        this.groupedNodes[node.id] = true;\n        node._decorate();\n        if (node.expanded && node.isFilterAccepted()) {\n          addToGroup.call(this, node.childNodes);\n        }\n      });\n    }\n  }\n\n  _isGroupingEnd(node) {\n    // May be implemented by subclasses, default tree has no grouping parent\n    return false;\n  }\n\n  /**\n   * @returns {TreeNode} the first selected node or null when no node is selected.\n   */\n  selectedNode() {\n    if (this.selectedNodes.length === 0) {\n      return null;\n    }\n    return this.selectedNodes[0];\n  }\n\n  $selectedNodes() {\n    return this.$data.find('.selected');\n  }\n\n  $nodes() {\n    return this.$data.find('.tree-node');\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to add.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  addFilter(filter, applyFilter = true) {\n    this.filterSupport.addFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to remove.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  removeFilter(filter, applyFilter = true) {\n    this.filterSupport.removeFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The new filters.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  setFilters(filters, applyFilter = true) {\n    this.filterSupport.setFilters(filters, applyFilter);\n  }\n\n  filter() {\n    this.filterSupport.filter();\n  }\n\n  _filter() {\n    let newlyHidden = [],\n      newlyShown = [];\n    // Filter nodes\n    this.nodes.forEach(node => {\n      let result = this.applyFiltersForNode(node, false, this.filterAnimated);\n      newlyHidden.push(...result.newlyHidden);\n      newlyShown.push(...result.newlyShown);\n    });\n    return {\n      newlyHidden: newlyHidden,\n      newlyShown: newlyShown\n    };\n  }\n\n  updateFilteredElements(result, opts) {\n    if (!this.filteredElementsDirty) {\n      return;\n    }\n    if (opts.textFilterText) {\n      this._nodesByIds(Object.keys(this.nodesMap))\n        .filter(it => it.filterAccepted)\n        .forEach(node => this._expandAllParentNodes(node));\n    }\n    result.newlyShown.forEach(node => this._addToVisibleFlatList(node, this.filterAnimated));\n    result.newlyHidden.forEach(node => this._removeFromFlatList(node, this.filterAnimated));\n    this.filteredElementsDirty = false;\n  }\n\n  filterVisibleNodes(animated) {\n    // Filter nodes\n    let newlyHidden = [];\n    // iterate from end to beginning (child nodes first) so that the state of the children has already been updated\n    for (let i = this.visibleNodesFlat.length - 1; i >= 0; i--) {\n      let node = this.visibleNodesFlat[i];\n      let result = this._applyFiltersForNodeRec(node, true, animated);\n      if (result.newlyHidden.length) {\n        if (!node.isFilterAccepted()) {\n          newlyHidden.push(...result.newlyHidden);\n        }\n        this.viewRangeDirty = true;\n      }\n    }\n    newlyHidden.forEach(h => this._removeFromFlatList(h, animated));\n    this._nodesFiltered(newlyHidden);\n  }\n\n  _nodesFiltered(hiddenNodes) {\n    // non visible nodes must be deselected\n    this.deselectNodes(hiddenNodes);\n  }\n\n  applyFiltersForNode(node, applyNewHiddenShownNodes = true, animated = false) {\n    let result = this._applyFiltersForNodeRec(node, true, animated);\n\n    // the result so far only includes the node and all its children.\n    // always include the parent nodes as well so that the filter has an effect\n    let parent = node.parentNode;\n    while (parent) {\n      let parentResult = this._applyFiltersForNodeRec(parent, false, animated);\n      result.newlyHidden.unshift(...parentResult.newlyHidden);\n      result.newlyShown.unshift(...parentResult.newlyShown);\n      parent = parent.parentNode;\n    }\n    this._nodesFiltered(result.newlyHidden);\n\n    if (applyNewHiddenShownNodes) {\n      result.newlyShown.forEach(node => this._addToVisibleFlatList(node, animated));\n      result.newlyHidden.forEach(node => this._removeFromFlatList(node, animated));\n    }\n    return result;\n  }\n\n  _applyFiltersForNodeRec(node, recursive, animated = false) {\n    let newlyHidden = [], newlyShown = [];\n    animated = animated && this.filterAnimated;\n\n    let changed = this._applyFiltersForNode(node);\n    let hasChildrenWithFilterAccepted = false;\n    if (node.level < 32 /* see org.eclipse.scout.rt.client.ui.basic.tree.AbstractTree.expandAllRec */) {\n      if (recursive) {\n        node.childNodes.forEach(childNode => {\n          let result = this._applyFiltersForNodeRec(childNode, true, animated);\n          newlyHidden.push(...result.newlyHidden);\n          newlyShown.push(...result.newlyShown);\n          hasChildrenWithFilterAccepted = hasChildrenWithFilterAccepted || childNode.filterAccepted;\n        });\n      } else if (!node.filterAccepted) {\n        // Check children only if filterAccepted is false because only then hasChildrenWithFilterAccepted is used (see below).\n        // This has great impact on performance when there are many nodes\n        hasChildrenWithFilterAccepted = node.childNodes.some(childNode => childNode.filterAccepted);\n      }\n    }\n\n    // set filter accepted on this node if it has children with filter accepted (so that the children are visible)\n    if (!node.filterAccepted && hasChildrenWithFilterAccepted) {\n      node.setFilterAccepted(true);\n      changed = !changed;\n    }\n\n    // remember changed node\n    if (changed) {\n      let pushTo = node.filterAccepted ? newlyShown : newlyHidden;\n      pushTo.unshift(node);\n\n      if (this.rendered) {\n        this.viewRangeDirty = true;\n      }\n    }\n\n    return {newlyHidden: newlyHidden, newlyShown: newlyShown};\n  }\n\n  /**\n   * @returns {Boolean} true if node state has changed, false if not\n   */\n  _applyFiltersForNode(node) {\n    let changed = this.filterSupport.applyFiltersForElement(node);\n    if (changed || node.filterDirty) {\n      node.filterDirty = false;\n      node.childNodes.forEach(childNode => {\n        childNode.filterDirty = true;\n      });\n    }\n    return changed;\n  }\n\n  /**\n   * @returns {FilterSupport}\n   */\n  _createFilterSupport() {\n    return new FilterSupport({\n      widget: this,\n      $container: () => this.$container,\n      filterElements: this._filter.bind(this),\n      getElementText: node => node.text\n    });\n  }\n\n  setTextFilterEnabled(textFilterEnabled) {\n    this.setProperty('textFilterEnabled', textFilterEnabled);\n  }\n\n  isTextFilterFieldVisible() {\n    return this.textFilterEnabled;\n  }\n\n  _renderTextFilterEnabled() {\n    this.filterSupport.renderFilterField();\n  }\n\n  /**\n   * Just insert node in DOM. NO check if in viewRange\n   */\n  _insertNodesInDOM(nodes, indexHint) {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    nodes = nodes.filter(function(node) {\n      let index = indexHint === undefined ? this.visibleNodesFlat.indexOf(node) : indexHint;\n      if (index === -1 || !(this.viewRangeRendered.from + this.viewRangeSize >= index && this.viewRangeRendered.from <= index && this.viewRangeSize > 0) || node.attached) {\n        // node is not visible\n        return false;\n      }\n      if (!node.rendered) {\n        this._renderNode(node);\n      }\n      node._decorate();\n      this._insertNodeInDOMAtPlace(node, index);\n      if (this.prevSelectedNode === node) {\n        this._highlightPrevSelectedNode();\n      }\n      node.rendered = true;\n      node.attached = true;\n      return true;\n    }, this);\n    this._installNodes(nodes);\n  }\n\n  _installNodes(nodes) {\n    // The measuring is separated into 3 blocks for performance reasons -> separates reading and setting of styles\n    // 1. Prepare style for measuring\n    if (this.isHorizontalScrollingEnabled()) {\n      nodes.forEach(node => {\n        node.$node.css('width', 'auto');\n        node.$node.css('display', 'inline-block');\n      }, this);\n    }\n\n    // 2. Measure\n    nodes.forEach(function(node) {\n      node.height = node.$node.outerHeight(true);\n      if (!this.isHorizontalScrollingEnabled()) {\n        return;\n      }\n      let newWidth = node.$node.outerWidth();\n      let oldWidth = node.width ? node.width : 0;\n      if (oldWidth === this.maxNodeWidth && newWidth < this.maxNodeWidth) {\n        this.maxNodeWidth = 0;\n        this.nodeWidthDirty = true;\n      } else if (newWidth > this.maxNodeWidth) {\n        this.maxNodeWidth = newWidth;\n        this.nodeWidthDirty = true;\n      } else if (newWidth === oldWidth && newWidth === 0) {\n        // newWidth and oldWidth are 0: this might be because the tree is invisible while a node is added:\n        // Mark as dirty to update the width later during layouting (when the tree gets visible and the width is available)\n        this.nodeWidthDirty = true;\n      }\n      node.width = newWidth;\n    }, this);\n\n    // 3. Reset style\n    if (this.isHorizontalScrollingEnabled()) {\n      nodes.forEach(function(node) {\n        if (!this.nodeWidthDirty) {\n          node.$node.css('width', this.maxNodeWidth);\n        }\n        node.$node.css('display', '');\n      }, this);\n    }\n  }\n\n  /**\n   * Attaches node to DOM, if it is visible and in view range\n   * */\n  _ensureNodeInDOM(node, useAnimation, indexHint) {\n    if (node && !node.attached && node === this.visibleNodesFlat[indexHint] && indexHint >= this.viewRangeRendered.from && indexHint < this.viewRangeRendered.to) {\n      this.showNode(node, useAnimation, indexHint);\n    }\n  }\n\n  _insertNodeInDOMAtPlace(node, index) {\n    let $node = node.$node;\n\n    if (index === 0) {\n      if (this.$fillBefore) {\n        $node.insertAfter(this.$fillBefore);\n      } else {\n        this.$data.prepend($node);\n      }\n      return;\n    }\n\n    // append after index\n    let nodeBefore = this.visibleNodesFlat[index - 1];\n    this._ensureNodeInDOM(nodeBefore, false, index - 1);\n    if (nodeBefore.attached) {\n      $node.insertAfter(nodeBefore.$node);\n      return;\n    }\n\n    if (index + 1 < this.visibleNodesFlat.length) {\n      let nodeAfter = this.visibleNodesFlat[index + 1];\n      if (nodeAfter.attached) {\n        $node.insertBefore(nodeAfter.$node);\n        return;\n      }\n    }\n\n    // used when the tree is scrolled\n    if (this.$fillBefore) {\n      $node.insertAfter(this.$fillBefore);\n    } else {\n      this.$data.prepend($node);\n    }\n  }\n\n  showNode(node, useAnimation, indexHint) {\n    if (!this.rendered || (node.attached && !node.$node.hasClass('hiding'))) {\n      return;\n    }\n    if (!node.attached) {\n      this._ensureNodeInDOM(node.parentNode, useAnimation, indexHint - 1);\n      this._insertNodesInDOM([node], indexHint);\n    }\n    if (!node.rendered) {\n      return;\n    }\n    let $node = node.$node;\n    if ($node.is('.showing')) {\n      return;\n    }\n    $node.removeClass('hiding');\n    let that = this;\n    if (useAnimation) {\n      $node.addClass('showing');\n      // hide node first and then make it appear using slideDown (setVisible(false) won't work because it would stay invisible during the animation)\n      $node.hide();\n      $node.stop(false, true).slideDown({\n        duration: 250,\n        start: that.startAnimationFunc,\n        complete: () => {\n          that.runningAnimationsFinishFunc();\n          $node.removeClass('showing');\n        }\n      });\n    }\n  }\n\n  hideNode(node, useAnimation, suppressDetachHandling) {\n    if (!this.rendered || !node.attached) {\n      return;\n    }\n    this.viewRangeDirty = true;\n    let that = this,\n      $node = node.$node;\n    if (!$node) {\n      // node is not rendered\n      return;\n    }\n\n    if ($node.is('.hiding')) {\n      return;\n    }\n    $node.removeClass('showing');\n    if (useAnimation) {\n      $node.addClass('hiding');\n      this._renderViewportBlocked = true;\n      $node.stop(false, true).slideUp({\n        duration: 250,\n        start: that.startAnimationFunc,\n        complete: () => {\n          that.runningAnimationsFinishFunc();\n          $node.removeClass('hiding');\n          if (!$node.hasClass('showing')) {\n            // JQuery sets display to none which we don't need because node will be detached.\n            // If node is added using another method than slideDown (used by show node), it would be invisible.\n            // Example: parent is collapsed while nodes are hiding -> remove filter, expand parent -> invisible nodes\n            $node.css('display', '');\n            $node.detach();\n            node.attached = false;\n          }\n        }\n      });\n    } else if (!suppressDetachHandling) {\n      $node.detach();\n      node.attached = false;\n      that.invalidateLayoutTree();\n    }\n  }\n\n  _nodesToIds(nodes) {\n    return nodes.map(node => node.id);\n  }\n\n  _nodesByIds(ids) {\n    return ids.map(id => this.nodesMap[id]);\n  }\n\n  _nodeById(id) {\n    return this.nodesMap[id];\n  }\n\n  /**\n   * Checks whether the given node is contained in the tree. Uses the id of the node for the lookup.\n   */\n  hasNode(node) {\n    return Boolean(this._nodeById(node.id));\n  }\n\n  _onNodeDoubleClick(event) {\n    if (this.isBreadcrumbStyleActive()) {\n      return;\n    }\n\n    let $node = $(event.currentTarget);\n    let node = $node.data('node');\n    let expanded = !$node.hasClass('expanded');\n    this.doNodeAction(node, expanded);\n  }\n\n  doNodeAction(node, expanded) {\n    this.trigger('nodeAction', {\n      node: node\n    });\n\n    // For CheckableStyle.CHECKBOX_TREE_NODE expand on double click is only enabled for disabled nodes. Otherwise it would conflict with the \"check on node click\" behavior.\n    if (!(this.checkable === true && this.isTreeNodeCheckEnabled() && node.enabled)) {\n      this.setNodeExpanded(node, expanded, {\n        lazy: false // always show all nodes on node double click\n      });\n    }\n  }\n\n  _onNodeControlMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n\n    let $node = $(event.currentTarget).parent();\n    let node = $node.data('node');\n    let expanded = !$node.hasClass('expanded');\n    let expansionOpts = {\n      lazy: false // always show all nodes when the control gets clicked\n    };\n\n    // Click on \"show all\" control shows all nodes\n    if ($node.hasClass('lazy')) {\n      if (event.ctrlKey || event.shiftKey) {\n        // Collapse\n        expanded = false;\n        expansionOpts.collapseChildNodes = true;\n      } else {\n        // Show all nodes\n        this.expandNode(node, expansionOpts);\n        return false;\n      }\n    }\n    // Because we suppress handling by browser we have to set focus manually\n    if (this.requestFocusOnNodeControlMouseDown) {\n      this.focus();\n    }\n    this.selectNodes(node); // <---- ### 1\n    this.setNodeExpanded(node, expanded, expansionOpts); // <---- ### 2\n    // prevent bubbling to _onNodeMouseDown()\n    $.suppressEvent(event);\n\n    // ...but return true, so Outline.js can override this method and check if selection has been changed or not\n    return true;\n  }\n\n  _onNodeControlMouseUp(event) {\n    // prevent bubbling to _onNodeMouseUp()\n    return false;\n  }\n\n  _onNodeControlDoubleClick(event) {\n    // prevent bubbling to _onNodeDoubleClick()\n    return false;\n  }\n\n  _onContextMenu(event) {\n    event.preventDefault();\n    this._showContextMenu(event);\n  }\n\n  changeNode(node) {\n    this.applyFiltersForNode(node);\n    if (this.rendered) {\n      node._decorate();\n      // The padding size of a node depends on whether the node or the parent node has an icon, see _computeNodePaddingLeftForLevel\n      // Unfortunately, we cannot easily detect whether the icon has changed or not.\n      // However, the padding calculation only needs to be done if the node that toggles the icon is visible and expanded or has an expanded parent.\n      let paddingDirty = !!this.nodePaddingLevelDiffParentHasIcon && !!this.visibleNodesMap[node.id] && (node.expanded || !!node.parentNode);\n      if (paddingDirty && !this._changeNodeTaskScheduled) {\n        // Because the change node event is not batch capable, performance would slow down if many change node events are processed\n        // To mitigate this, the updating is done later\n        queueMicrotask(() => {\n          this._updateNodePaddingsLeft();\n          this._changeNodeTaskScheduled = false;\n        });\n        this._changeNodeTaskScheduled = true;\n      }\n    }\n    this.trigger('nodeChanged', {\n      node: node\n    });\n  }\n\n  // same as on Table.prototype._onDesktopPopupOpen\n  _onDesktopPopupOpen(event) {\n    let popup = event.popup;\n    if (!this.isFocusable(false)) {\n      return;\n    }\n    // Set tree style to focused if a context menu or a menu bar popup opens, so that it looks as it still has the focus\n    if (this.has(popup) && popup instanceof ContextMenuPopup) {\n      this.$container.addClass('focused');\n      popup.one('destroy', () => {\n        if (this.rendered) {\n          this.$container.removeClass('focused');\n        }\n      });\n    }\n  }\n\n  updateScrollbars() {\n    scrollbars.update(this.$data);\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * @memberOf Tree\n   */\n  static collectSubtree($rootNode, includeRootNodeInResult) {\n    if (!$rootNode) {\n      return $();\n    }\n    let rootLevel = parseFloat($rootNode.attr('data-level'));\n    // Find first node after the root element that has the same or a lower level\n    let $nextNode = $rootNode.next();\n    while ($nextNode.length > 0) {\n      let level = parseFloat($nextNode.attr('data-level'));\n      if (isNaN(level) || level <= rootLevel) {\n        break;\n      }\n      $nextNode = $nextNode.next();\n    }\n\n    // The result set consists of all nodes between the root node and the found node\n    let $result = $rootNode.nextUntil($nextNode);\n    if (includeRootNodeInResult === undefined || includeRootNodeInResult) {\n      $result = $result.add($rootNode);\n    }\n    return $result;\n  }\n\n  /**\n   * pre-order (top-down) traversal of the tree-nodes provided.<br>\n   * if func returns true the children of the visited node are not visited.\n   */\n  static visitNodes(func, nodes, parentNode) {\n    let i, node;\n    if (!nodes) {\n      return;\n    }\n\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      let doNotProcessChildren = func(node, parentNode);\n      if (!doNotProcessChildren && node.childNodes.length > 0) {\n        Tree.visitNodes(func, node.childNodes, node);\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}