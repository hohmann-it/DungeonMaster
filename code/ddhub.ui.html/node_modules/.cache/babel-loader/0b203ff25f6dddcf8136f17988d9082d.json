{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, HAlign, Key, keys, scout, Widget } from '../index';\nimport $ from 'jquery';\nexport default class KeyStroke {\n  constructor() {\n    this.field = null; // optional model field\n\n    this.which = []; // keys which this keystroke is bound to. Typically, this is a single key, but may be multiple keys if handling the same action (e.g. ENTER and SPACE on a button).\n    this.ctrl = false;\n    this.inheritAccessibility = true;\n    this.alt = false;\n    this.shift = false;\n    this.preventDefault = true;\n    this.stopPropagation = false;\n    this.stopImmediatePropagation = false;\n    this.keyStrokeMode = KeyStroke.Mode.DOWN;\n    this.repeatable = false; // whether or not the handle method is called multiple times while a key is pressed\n    this._handleExecuted = false; // internal flag to remember whether or not the handle method has been executed (reset on keyup)\n    this.keyStrokeFirePolicy = Action.KeyStrokeFirePolicy.ACCESSIBLE_ONLY;\n    this.enabledByFilter = true;\n\n    // Hints to control rendering of the key(s).\n    this.renderingHints = {\n      render: () => {\n        if (this.field && this.field.rendered !== undefined) {\n          return this.field.rendered; // only render key if associated field is visible.\n        }\n\n        return true; // by default, keystrokes are rendered\n      },\n\n      gap: 4,\n      offset: 4,\n      hAlign: HAlign.LEFT,\n      text: null,\n      $drawingArea: ($drawingArea, event) => $drawingArea\n    };\n\n    /**\n     * Indicates whether to invoke 'acceptInput' on a currently focused value field prior handling the keystroke.\n     */\n    this.invokeAcceptInputOnActiveValueField = false;\n\n    /**\n     * Indicates whether to prevent the invoke of 'acceptInput' on a currently focused value field prior handling the keystroke,\n     * either triggered by previous property or by KeyStrokeContext\n     */\n    this.preventInvokeAcceptInputOnActiveValueField = false;\n  }\n\n  /**\n   * Parses the given keystroke name into the key parts like 'ctrl', 'shift', 'alt' and 'which'.\n   */\n  parseAndSetKeyStroke(keyStrokeName) {\n    this.alt = false;\n    this.ctrl = false;\n    this.shift = false;\n    this.which = [];\n    if (keyStrokeName) {\n      $.extend(this, KeyStroke.parseKeyStroke(keyStrokeName));\n    }\n  }\n\n  /**\n   * Returns true if this event is handled by this keystroke, and if so sets the propagation flags accordingly.\n   */\n  accept(event) {\n    if (!this._isEnabled()) {\n      return false;\n    }\n\n    // Check whether this event is accepted for execution.\n    if (!this._accept(event)) {\n      return false;\n    }\n\n    // Apply propagation flags to the event.\n    this._applyPropagationFlags(event);\n    // only accept on correct event type -> keyup or keydown. But propagation flags should be set to prevent execution of upper keyStrokes.\n    return event.type === this.keyStrokeMode;\n  }\n\n  /**\n   * Method invoked to handle the given keystroke event, and is only called if the event was accepted by 'KeyStroke.accept(event)'.\n   */\n  handle(event) {\n    throw new Error('keystroke event not handled: ' + event);\n  }\n  invokeHandle(event) {\n    // if key stroke is repeatable, handle is called each time the key event occurs\n    // which means it is executed multiple times while a key is pressed.\n    if (this.repeatable) {\n      this.handle(event);\n      return;\n    }\n\n    // if key stroke is not repeatable it should only call execute once until\n    // we receive a key up event for that key\n    if (!this._handleExecuted) {\n      this.handle(event);\n      if (event.type === KeyStroke.Mode.DOWN) {\n        this._handleExecuted = true;\n\n        // Reset handleExecuted on the next key up event\n        // (use capturing phase to execute even if event.stopPropagation has been called)\n        let $target = $(event.target);\n        let $window = $target.window();\n        let keyStroke = this;\n        let keyUpHandler = {\n          handleEvent: function (event) {\n            keyStroke._handleExecuted = false;\n            $window[0].removeEventListener('keyup', this, true);\n          }\n        };\n        $window[0].addEventListener('keyup', keyUpHandler, true);\n      }\n    }\n  }\n\n  /**\n   * Method invoked in the context of accepting a keystroke, and returns true if the keystroke is accessible to the user.\n   */\n  _isEnabled() {\n    // Hint: do not check for which.length because there are keystrokes without a which, e.g. RangeKeyStroke.js\n\n    if (!this.field) {\n      return true;\n    }\n    if (this.field instanceof Widget && this.field.isRemovalPending()) {\n      // Prevent possible exceptions or unexpected behavior if a keystroke is executed while a widget is being removed.\n      return false;\n    }\n    // Check visibility\n    if (this.field.visible !== undefined && !this.field.visible) {\n      return false;\n    }\n    // Check enabled state (if inheritAccessibility is true)\n    if (!this.inheritAccessibility) {\n      return true;\n    }\n    if (this.field.enabledComputed !== undefined) {\n      return this.field.enabledComputed;\n    }\n    if (this.field.enabled !== undefined) {\n      // This should actually not happen because this.field should always be a widget\n      return this.field.enabled;\n    }\n    return false;\n  }\n\n  /**\n   * Method invoked in the context of accepting a keystroke, and returns true if the event matches this keystroke.\n   */\n  _accept(event) {\n    return KeyStroke.acceptEvent(this, event);\n  }\n\n  /**\n   * Method invoked in the context of accepting a keystroke, and sets the propagation flags accordingly.\n   */\n  _applyPropagationFlags(event) {\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n    if (this.stopImmediatePropagation) {\n      event.stopImmediatePropagation();\n    }\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Returns the key(s) associated with this keystroke. Typically, this is a single key, but may be multiple if this keystroke is associated with multiple keys, e.g. ENTER and SPACE on a button.\n   */\n  keys() {\n    return this.which.map(function (which) {\n      return new Key(this, which);\n    }, this);\n  }\n\n  /**\n   * Renders the visual representation of this keystroke, with the 'which' as given by the event.\n   *\n   * @return $drawingArea on which the key was finally rendered.\n   */\n  renderKeyBox($drawingArea, event) {\n    $drawingArea = this.renderingHints.$drawingArea($drawingArea, event);\n    if (!$drawingArea || !$drawingArea.length) {\n      return null;\n    }\n    let $keyBox = this._renderKeyBox($drawingArea, event.which);\n    this._postRenderKeyBox($drawingArea, $keyBox);\n    return $drawingArea;\n  }\n  _renderKeyBox($parent, keyCode) {\n    let $existingKeyBoxes = $('.key-box', $parent);\n    let text = this.renderingHints.text || keys.codesToKeys[keys.fromBrowser(keyCode)];\n    let align = this.renderingHints.hAlign === HAlign.RIGHT ? 'right' : 'left';\n    let offset = this.renderingHints.offset;\n    $existingKeyBoxes = $existingKeyBoxes.filter(function () {\n      if (align === 'right') {\n        return $(this).hasClass('right');\n      }\n      return !$(this).hasClass('right');\n    });\n    if ($existingKeyBoxes.length > 0) {\n      let $boxLastAdded = $existingKeyBoxes.first();\n      if (this.renderingHints.hAlign === HAlign.RIGHT) {\n        offset = $parent.outerWidth() - $boxLastAdded.position().left + this.renderingHints.gap;\n      } else {\n        offset = $boxLastAdded.position().left + this.renderingHints.gap + $boxLastAdded.outerWidth();\n      }\n    }\n    if (this.shift) {\n      text = 'Shift ' + text;\n    }\n    if (this.alt) {\n      text = 'Alt ' + text;\n    }\n    if (this.ctrl) {\n      text = 'Ctrl ' + text;\n    }\n    let position = $parent.css('position');\n    if (position === 'absolute' || position === 'relative' || position === 'static' && $existingKeyBoxes.length > 0) {\n      return prependKeyBox.call(this, offset);\n    }\n    let pos = $parent.position();\n    if (pos) {\n      return prependKeyBox.call(this, pos.left + offset);\n    }\n    $.log.warn('(keys#drawSingleKeyBoxItem) pos is undefined. $parent=' + $parent);\n    function prependKeyBox(alignValue) {\n      return $parent.prependDiv('key-box', text).css(align, alignValue + 'px').toggleClass('disabled', !this.enabledByFilter).addClass(align);\n    }\n  }\n\n  /**\n   * Method invoked after this keystroke was rendered, and is typically overwritten to reposition the visual representation.\n   */\n  _postRenderKeyBox($drawingArea) {}\n\n  /**\n   * Removes the visual representation of this keystroke.\n   */\n  removeKeyBox($drawingArea) {\n    if ($drawingArea) {\n      $('.key-box', $drawingArea).remove();\n      $('.key-box-additional', $drawingArea).remove();\n    }\n  }\n  // --- Static helpers --- //\n\n  /**\n   * Parses the given keystroke name into the key parts like 'ctrl', 'shift', 'alt' and 'which'.\n   *\n   * @returns a plain object with properties ctrl, shift, alt and which - may be used as input\n   *     for Key.js and KeyStroke.js\n   * @see \"org.eclipse.scout.rt.client.ui.action.keystroke.KeyStrokeNormalizer\"\n   */\n  static parseKeyStroke(keyStrokeName) {\n    if (!keyStrokeName) {\n      return null;\n    }\n    let keyStrokeObj = {\n      alt: false,\n      ctrl: false,\n      shift: false,\n      which: []\n    };\n    keyStrokeName.split('-').forEach(part => {\n      if (part === 'alternate' || part === 'alt') {\n        keyStrokeObj.alt = true;\n      } else if (part === 'control' || part === 'ctrl') {\n        keyStrokeObj.ctrl = true;\n      } else if (part === 'shift') {\n        keyStrokeObj.shift = true;\n      } else {\n        let key = keys[part.toUpperCase()];\n        keyStrokeObj.which = key && [key];\n      }\n    });\n    return keyStrokeObj;\n  }\n  static acceptEvent(keyStroke, event) {\n    if (!keyStroke) {\n      return false;\n    }\n    // event.ctrlKey||event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx use in this cases command key\n    return KeyStroke.acceptModifiers(keyStroke, event) && scout.isOneOf(event.which, keyStroke.which);\n  }\n  static acceptModifiers(keyStroke, event) {\n    return KeyStroke._acceptModifier(keyStroke.ctrl, event.ctrlKey || event.metaKey) && KeyStroke._acceptModifier(keyStroke.alt, event.altKey) && KeyStroke._acceptModifier(keyStroke.shift, event.shiftKey);\n  }\n  static _acceptModifier(modifier, eventModifier) {\n    return modifier === undefined || eventModifier === undefined || modifier === eventModifier;\n  }\n}\n_defineProperty(KeyStroke, \"Mode\", {\n  UP: 'keyup',\n  DOWN: 'keydown'\n});","map":{"version":3,"names":["Action","HAlign","Key","keys","scout","Widget","$","KeyStroke","constructor","field","which","ctrl","inheritAccessibility","alt","shift","preventDefault","stopPropagation","stopImmediatePropagation","keyStrokeMode","Mode","DOWN","repeatable","_handleExecuted","keyStrokeFirePolicy","KeyStrokeFirePolicy","ACCESSIBLE_ONLY","enabledByFilter","renderingHints","render","rendered","undefined","gap","offset","hAlign","LEFT","text","$drawingArea","event","invokeAcceptInputOnActiveValueField","preventInvokeAcceptInputOnActiveValueField","parseAndSetKeyStroke","keyStrokeName","extend","parseKeyStroke","accept","_isEnabled","_accept","_applyPropagationFlags","type","handle","Error","invokeHandle","$target","target","$window","window","keyStroke","keyUpHandler","handleEvent","removeEventListener","addEventListener","isRemovalPending","visible","enabledComputed","enabled","acceptEvent","map","renderKeyBox","length","$keyBox","_renderKeyBox","_postRenderKeyBox","$parent","keyCode","$existingKeyBoxes","codesToKeys","fromBrowser","align","RIGHT","filter","hasClass","$boxLastAdded","first","outerWidth","position","left","css","prependKeyBox","call","pos","log","warn","alignValue","prependDiv","toggleClass","addClass","removeKeyBox","remove","keyStrokeObj","split","forEach","part","key","toUpperCase","acceptModifiers","isOneOf","_acceptModifier","ctrlKey","metaKey","altKey","shiftKey","modifier","eventModifier","UP"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/keystroke/KeyStroke.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, HAlign, Key, keys, scout, Widget} from '../index';\nimport $ from 'jquery';\n\nexport default class KeyStroke {\n\n  constructor() {\n    this.field = null; // optional model field\n\n    this.which = []; // keys which this keystroke is bound to. Typically, this is a single key, but may be multiple keys if handling the same action (e.g. ENTER and SPACE on a button).\n    this.ctrl = false;\n    this.inheritAccessibility = true;\n    this.alt = false;\n    this.shift = false;\n    this.preventDefault = true;\n    this.stopPropagation = false;\n    this.stopImmediatePropagation = false;\n    this.keyStrokeMode = KeyStroke.Mode.DOWN;\n    this.repeatable = false; // whether or not the handle method is called multiple times while a key is pressed\n    this._handleExecuted = false; // internal flag to remember whether or not the handle method has been executed (reset on keyup)\n    this.keyStrokeFirePolicy = Action.KeyStrokeFirePolicy.ACCESSIBLE_ONLY;\n    this.enabledByFilter = true;\n\n    // Hints to control rendering of the key(s).\n    this.renderingHints = {\n      render: () => {\n        if (this.field && this.field.rendered !== undefined) {\n          return this.field.rendered; // only render key if associated field is visible.\n        }\n        return true; // by default, keystrokes are rendered\n      },\n      gap: 4,\n      offset: 4,\n      hAlign: HAlign.LEFT,\n      text: null,\n      $drawingArea: ($drawingArea, event) => $drawingArea\n    };\n\n    /**\n     * Indicates whether to invoke 'acceptInput' on a currently focused value field prior handling the keystroke.\n     */\n    this.invokeAcceptInputOnActiveValueField = false;\n\n    /**\n     * Indicates whether to prevent the invoke of 'acceptInput' on a currently focused value field prior handling the keystroke,\n     * either triggered by previous property or by KeyStrokeContext\n     */\n    this.preventInvokeAcceptInputOnActiveValueField = false;\n  }\n\n  /**\n   * Parses the given keystroke name into the key parts like 'ctrl', 'shift', 'alt' and 'which'.\n   */\n  parseAndSetKeyStroke(keyStrokeName) {\n    this.alt = false;\n    this.ctrl = false;\n    this.shift = false;\n    this.which = [];\n    if (keyStrokeName) {\n      $.extend(this, KeyStroke.parseKeyStroke(keyStrokeName));\n    }\n  }\n\n  /**\n   * Returns true if this event is handled by this keystroke, and if so sets the propagation flags accordingly.\n   */\n  accept(event) {\n    if (!this._isEnabled()) {\n      return false;\n    }\n\n    // Check whether this event is accepted for execution.\n    if (!this._accept(event)) {\n      return false;\n    }\n\n    // Apply propagation flags to the event.\n    this._applyPropagationFlags(event);\n    // only accept on correct event type -> keyup or keydown. But propagation flags should be set to prevent execution of upper keyStrokes.\n    return event.type === this.keyStrokeMode;\n  }\n\n  /**\n   * Method invoked to handle the given keystroke event, and is only called if the event was accepted by 'KeyStroke.accept(event)'.\n   */\n  handle(event) {\n    throw new Error('keystroke event not handled: ' + event);\n  }\n\n  invokeHandle(event) {\n    // if key stroke is repeatable, handle is called each time the key event occurs\n    // which means it is executed multiple times while a key is pressed.\n    if (this.repeatable) {\n      this.handle(event);\n      return;\n    }\n\n    // if key stroke is not repeatable it should only call execute once until\n    // we receive a key up event for that key\n    if (!this._handleExecuted) {\n      this.handle(event);\n\n      if (event.type === KeyStroke.Mode.DOWN) {\n        this._handleExecuted = true;\n\n        // Reset handleExecuted on the next key up event\n        // (use capturing phase to execute even if event.stopPropagation has been called)\n        let $target = $(event.target);\n        let $window = $target.window();\n        let keyStroke = this;\n        let keyUpHandler = {\n          handleEvent: function(event) {\n            keyStroke._handleExecuted = false;\n            $window[0].removeEventListener('keyup', this, true);\n          }\n        };\n        $window[0].addEventListener('keyup', keyUpHandler, true);\n      }\n    }\n  }\n\n  /**\n   * Method invoked in the context of accepting a keystroke, and returns true if the keystroke is accessible to the user.\n   */\n  _isEnabled() {\n    // Hint: do not check for which.length because there are keystrokes without a which, e.g. RangeKeyStroke.js\n\n    if (!this.field) {\n      return true;\n    }\n    if (this.field instanceof Widget && this.field.isRemovalPending()) {\n      // Prevent possible exceptions or unexpected behavior if a keystroke is executed while a widget is being removed.\n      return false;\n    }\n    // Check visibility\n    if (this.field.visible !== undefined && !this.field.visible) {\n      return false;\n    }\n    // Check enabled state (if inheritAccessibility is true)\n    if (!this.inheritAccessibility) {\n      return true;\n    }\n    if (this.field.enabledComputed !== undefined) {\n      return this.field.enabledComputed;\n    }\n    if (this.field.enabled !== undefined) {\n      // This should actually not happen because this.field should always be a widget\n      return this.field.enabled;\n    }\n    return false;\n  }\n\n  /**\n   * Method invoked in the context of accepting a keystroke, and returns true if the event matches this keystroke.\n   */\n  _accept(event) {\n    return KeyStroke.acceptEvent(this, event);\n  }\n\n  /**\n   * Method invoked in the context of accepting a keystroke, and sets the propagation flags accordingly.\n   */\n  _applyPropagationFlags(event) {\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n    if (this.stopImmediatePropagation) {\n      event.stopImmediatePropagation();\n    }\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Returns the key(s) associated with this keystroke. Typically, this is a single key, but may be multiple if this keystroke is associated with multiple keys, e.g. ENTER and SPACE on a button.\n   */\n  keys() {\n    return this.which.map(function(which) {\n      return new Key(this, which);\n    }, this);\n  }\n\n  /**\n   * Renders the visual representation of this keystroke, with the 'which' as given by the event.\n   *\n   * @return $drawingArea on which the key was finally rendered.\n   */\n  renderKeyBox($drawingArea, event) {\n    $drawingArea = this.renderingHints.$drawingArea($drawingArea, event);\n    if (!$drawingArea || !$drawingArea.length) {\n      return null;\n    }\n\n    let $keyBox = this._renderKeyBox($drawingArea, event.which);\n    this._postRenderKeyBox($drawingArea, $keyBox);\n    return $drawingArea;\n  }\n\n  _renderKeyBox($parent, keyCode) {\n    let $existingKeyBoxes = $('.key-box', $parent);\n    let text = this.renderingHints.text || keys.codesToKeys[keys.fromBrowser(keyCode)];\n    let align = this.renderingHints.hAlign === HAlign.RIGHT ? 'right' : 'left';\n    let offset = this.renderingHints.offset;\n    $existingKeyBoxes = $existingKeyBoxes.filter(function() {\n      if (align === 'right') {\n        return $(this).hasClass('right');\n      }\n      return !$(this).hasClass('right');\n    });\n    if ($existingKeyBoxes.length > 0) {\n      let $boxLastAdded = $existingKeyBoxes.first();\n      if (this.renderingHints.hAlign === HAlign.RIGHT) {\n        offset = $parent.outerWidth() - $boxLastAdded.position().left + this.renderingHints.gap;\n      } else {\n        offset = $boxLastAdded.position().left + this.renderingHints.gap + $boxLastAdded.outerWidth();\n      }\n    }\n    if (this.shift) {\n      text = 'Shift ' + text;\n    }\n    if (this.alt) {\n      text = 'Alt ' + text;\n    }\n    if (this.ctrl) {\n      text = 'Ctrl ' + text;\n    }\n    let position = $parent.css('position');\n    if (position === 'absolute' || position === 'relative' || (position === 'static' && $existingKeyBoxes.length > 0)) {\n      return prependKeyBox.call(this, offset);\n    }\n    let pos = $parent.position();\n    if (pos) {\n      return prependKeyBox.call(this, pos.left + offset);\n    }\n    $.log.warn('(keys#drawSingleKeyBoxItem) pos is undefined. $parent=' + $parent);\n\n    function prependKeyBox(alignValue) {\n      return $parent.prependDiv('key-box', text)\n        .css(align, alignValue + 'px')\n        .toggleClass('disabled', !this.enabledByFilter)\n        .addClass(align);\n    }\n  }\n\n  /**\n   * Method invoked after this keystroke was rendered, and is typically overwritten to reposition the visual representation.\n   */\n  _postRenderKeyBox($drawingArea) {\n  }\n\n  /**\n   * Removes the visual representation of this keystroke.\n   */\n  removeKeyBox($drawingArea) {\n    if ($drawingArea) {\n      $('.key-box', $drawingArea).remove();\n      $('.key-box-additional', $drawingArea).remove();\n    }\n  }\n\n  static Mode = {\n    UP: 'keyup',\n    DOWN: 'keydown'\n  };\n\n  // --- Static helpers --- //\n\n  /**\n   * Parses the given keystroke name into the key parts like 'ctrl', 'shift', 'alt' and 'which'.\n   *\n   * @returns a plain object with properties ctrl, shift, alt and which - may be used as input\n   *     for Key.js and KeyStroke.js\n   * @see \"org.eclipse.scout.rt.client.ui.action.keystroke.KeyStrokeNormalizer\"\n   */\n  static parseKeyStroke(keyStrokeName) {\n    if (!keyStrokeName) {\n      return null;\n    }\n\n    let keyStrokeObj = {\n      alt: false,\n      ctrl: false,\n      shift: false,\n      which: []\n    };\n\n    keyStrokeName.split('-').forEach(part => {\n      if (part === 'alternate' || part === 'alt') {\n        keyStrokeObj.alt = true;\n      } else if (part === 'control' || part === 'ctrl') {\n        keyStrokeObj.ctrl = true;\n      } else if (part === 'shift') {\n        keyStrokeObj.shift = true;\n      } else {\n        let key = keys[part.toUpperCase()];\n        keyStrokeObj.which = key && [key];\n      }\n    });\n\n    return keyStrokeObj;\n  }\n\n  static acceptEvent(keyStroke, event) {\n    if (!keyStroke) {\n      return false;\n    }\n    // event.ctrlKey||event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx use in this cases command key\n    return KeyStroke.acceptModifiers(keyStroke, event) &&\n      scout.isOneOf(event.which, keyStroke.which);\n  }\n\n  static acceptModifiers(keyStroke, event) {\n    return KeyStroke._acceptModifier(keyStroke.ctrl, (event.ctrlKey || event.metaKey)) &&\n      KeyStroke._acceptModifier(keyStroke.alt, event.altKey) &&\n      KeyStroke._acceptModifier(keyStroke.shift, event.shiftKey);\n  }\n\n  static _acceptModifier(modifier, eventModifier) {\n    return modifier === undefined || eventModifier === undefined || modifier === eventModifier;\n  }\n}\n"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,MAAM,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAEC,KAAK,EAAEC,MAAM,QAAO,UAAU;AACjE,OAAOC,CAAC,MAAM,QAAQ;AAEtB,eAAe,MAAMC,SAAS,CAAC;EAE7BC,WAAW,GAAG;IACZ,IAAI,CAACC,KAAK,GAAG,IAAI,CAAC,CAAC;;IAEnB,IAAI,CAACC,KAAK,GAAG,EAAE,CAAC,CAAC;IACjB,IAAI,CAACC,IAAI,GAAG,KAAK;IACjB,IAAI,CAACC,oBAAoB,GAAG,IAAI;IAChC,IAAI,CAACC,GAAG,GAAG,KAAK;IAChB,IAAI,CAACC,KAAK,GAAG,KAAK;IAClB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,wBAAwB,GAAG,KAAK;IACrC,IAAI,CAACC,aAAa,GAAGX,SAAS,CAACY,IAAI,CAACC,IAAI;IACxC,IAAI,CAACC,UAAU,GAAG,KAAK,CAAC,CAAC;IACzB,IAAI,CAACC,eAAe,GAAG,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACC,mBAAmB,GAAGvB,MAAM,CAACwB,mBAAmB,CAACC,eAAe;IACrE,IAAI,CAACC,eAAe,GAAG,IAAI;;IAE3B;IACA,IAAI,CAACC,cAAc,GAAG;MACpBC,MAAM,EAAE,MAAM;QACZ,IAAI,IAAI,CAACnB,KAAK,IAAI,IAAI,CAACA,KAAK,CAACoB,QAAQ,KAAKC,SAAS,EAAE;UACnD,OAAO,IAAI,CAACrB,KAAK,CAACoB,QAAQ,CAAC,CAAC;QAC9B;;QACA,OAAO,IAAI,CAAC,CAAC;MACf,CAAC;;MACDE,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,CAAC;MACTC,MAAM,EAAEhC,MAAM,CAACiC,IAAI;MACnBC,IAAI,EAAE,IAAI;MACVC,YAAY,EAAE,CAACA,YAAY,EAAEC,KAAK,KAAKD;IACzC,CAAC;;IAED;AACJ;AACA;IACI,IAAI,CAACE,mCAAmC,GAAG,KAAK;;IAEhD;AACJ;AACA;AACA;IACI,IAAI,CAACC,0CAA0C,GAAG,KAAK;EACzD;;EAEA;AACF;AACA;EACEC,oBAAoB,CAACC,aAAa,EAAE;IAClC,IAAI,CAAC5B,GAAG,GAAG,KAAK;IAChB,IAAI,CAACF,IAAI,GAAG,KAAK;IACjB,IAAI,CAACG,KAAK,GAAG,KAAK;IAClB,IAAI,CAACJ,KAAK,GAAG,EAAE;IACf,IAAI+B,aAAa,EAAE;MACjBnC,CAAC,CAACoC,MAAM,CAAC,IAAI,EAAEnC,SAAS,CAACoC,cAAc,CAACF,aAAa,CAAC,CAAC;IACzD;EACF;;EAEA;AACF;AACA;EACEG,MAAM,CAACP,KAAK,EAAE;IACZ,IAAI,CAAC,IAAI,CAACQ,UAAU,EAAE,EAAE;MACtB,OAAO,KAAK;IACd;;IAEA;IACA,IAAI,CAAC,IAAI,CAACC,OAAO,CAACT,KAAK,CAAC,EAAE;MACxB,OAAO,KAAK;IACd;;IAEA;IACA,IAAI,CAACU,sBAAsB,CAACV,KAAK,CAAC;IAClC;IACA,OAAOA,KAAK,CAACW,IAAI,KAAK,IAAI,CAAC9B,aAAa;EAC1C;;EAEA;AACF;AACA;EACE+B,MAAM,CAACZ,KAAK,EAAE;IACZ,MAAM,IAAIa,KAAK,CAAC,+BAA+B,GAAGb,KAAK,CAAC;EAC1D;EAEAc,YAAY,CAACd,KAAK,EAAE;IAClB;IACA;IACA,IAAI,IAAI,CAAChB,UAAU,EAAE;MACnB,IAAI,CAAC4B,MAAM,CAACZ,KAAK,CAAC;MAClB;IACF;;IAEA;IACA;IACA,IAAI,CAAC,IAAI,CAACf,eAAe,EAAE;MACzB,IAAI,CAAC2B,MAAM,CAACZ,KAAK,CAAC;MAElB,IAAIA,KAAK,CAACW,IAAI,KAAKzC,SAAS,CAACY,IAAI,CAACC,IAAI,EAAE;QACtC,IAAI,CAACE,eAAe,GAAG,IAAI;;QAE3B;QACA;QACA,IAAI8B,OAAO,GAAG9C,CAAC,CAAC+B,KAAK,CAACgB,MAAM,CAAC;QAC7B,IAAIC,OAAO,GAAGF,OAAO,CAACG,MAAM,EAAE;QAC9B,IAAIC,SAAS,GAAG,IAAI;QACpB,IAAIC,YAAY,GAAG;UACjBC,WAAW,EAAE,UAASrB,KAAK,EAAE;YAC3BmB,SAAS,CAAClC,eAAe,GAAG,KAAK;YACjCgC,OAAO,CAAC,CAAC,CAAC,CAACK,mBAAmB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC;UACrD;QACF,CAAC;QACDL,OAAO,CAAC,CAAC,CAAC,CAACM,gBAAgB,CAAC,OAAO,EAAEH,YAAY,EAAE,IAAI,CAAC;MAC1D;IACF;EACF;;EAEA;AACF;AACA;EACEZ,UAAU,GAAG;IACX;;IAEA,IAAI,CAAC,IAAI,CAACpC,KAAK,EAAE;MACf,OAAO,IAAI;IACb;IACA,IAAI,IAAI,CAACA,KAAK,YAAYJ,MAAM,IAAI,IAAI,CAACI,KAAK,CAACoD,gBAAgB,EAAE,EAAE;MACjE;MACA,OAAO,KAAK;IACd;IACA;IACA,IAAI,IAAI,CAACpD,KAAK,CAACqD,OAAO,KAAKhC,SAAS,IAAI,CAAC,IAAI,CAACrB,KAAK,CAACqD,OAAO,EAAE;MAC3D,OAAO,KAAK;IACd;IACA;IACA,IAAI,CAAC,IAAI,CAAClD,oBAAoB,EAAE;MAC9B,OAAO,IAAI;IACb;IACA,IAAI,IAAI,CAACH,KAAK,CAACsD,eAAe,KAAKjC,SAAS,EAAE;MAC5C,OAAO,IAAI,CAACrB,KAAK,CAACsD,eAAe;IACnC;IACA,IAAI,IAAI,CAACtD,KAAK,CAACuD,OAAO,KAAKlC,SAAS,EAAE;MACpC;MACA,OAAO,IAAI,CAACrB,KAAK,CAACuD,OAAO;IAC3B;IACA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;EACElB,OAAO,CAACT,KAAK,EAAE;IACb,OAAO9B,SAAS,CAAC0D,WAAW,CAAC,IAAI,EAAE5B,KAAK,CAAC;EAC3C;;EAEA;AACF;AACA;EACEU,sBAAsB,CAACV,KAAK,EAAE;IAC5B,IAAI,IAAI,CAACrB,eAAe,EAAE;MACxBqB,KAAK,CAACrB,eAAe,EAAE;IACzB;IACA,IAAI,IAAI,CAACC,wBAAwB,EAAE;MACjCoB,KAAK,CAACpB,wBAAwB,EAAE;IAClC;IACA,IAAI,IAAI,CAACF,cAAc,EAAE;MACvBsB,KAAK,CAACtB,cAAc,EAAE;IACxB;EACF;;EAEA;AACF;AACA;EACEZ,IAAI,GAAG;IACL,OAAO,IAAI,CAACO,KAAK,CAACwD,GAAG,CAAC,UAASxD,KAAK,EAAE;MACpC,OAAO,IAAIR,GAAG,CAAC,IAAI,EAAEQ,KAAK,CAAC;IAC7B,CAAC,EAAE,IAAI,CAAC;EACV;;EAEA;AACF;AACA;AACA;AACA;EACEyD,YAAY,CAAC/B,YAAY,EAAEC,KAAK,EAAE;IAChCD,YAAY,GAAG,IAAI,CAACT,cAAc,CAACS,YAAY,CAACA,YAAY,EAAEC,KAAK,CAAC;IACpE,IAAI,CAACD,YAAY,IAAI,CAACA,YAAY,CAACgC,MAAM,EAAE;MACzC,OAAO,IAAI;IACb;IAEA,IAAIC,OAAO,GAAG,IAAI,CAACC,aAAa,CAAClC,YAAY,EAAEC,KAAK,CAAC3B,KAAK,CAAC;IAC3D,IAAI,CAAC6D,iBAAiB,CAACnC,YAAY,EAAEiC,OAAO,CAAC;IAC7C,OAAOjC,YAAY;EACrB;EAEAkC,aAAa,CAACE,OAAO,EAAEC,OAAO,EAAE;IAC9B,IAAIC,iBAAiB,GAAGpE,CAAC,CAAC,UAAU,EAAEkE,OAAO,CAAC;IAC9C,IAAIrC,IAAI,GAAG,IAAI,CAACR,cAAc,CAACQ,IAAI,IAAIhC,IAAI,CAACwE,WAAW,CAACxE,IAAI,CAACyE,WAAW,CAACH,OAAO,CAAC,CAAC;IAClF,IAAII,KAAK,GAAG,IAAI,CAAClD,cAAc,CAACM,MAAM,KAAKhC,MAAM,CAAC6E,KAAK,GAAG,OAAO,GAAG,MAAM;IAC1E,IAAI9C,MAAM,GAAG,IAAI,CAACL,cAAc,CAACK,MAAM;IACvC0C,iBAAiB,GAAGA,iBAAiB,CAACK,MAAM,CAAC,YAAW;MACtD,IAAIF,KAAK,KAAK,OAAO,EAAE;QACrB,OAAOvE,CAAC,CAAC,IAAI,CAAC,CAAC0E,QAAQ,CAAC,OAAO,CAAC;MAClC;MACA,OAAO,CAAC1E,CAAC,CAAC,IAAI,CAAC,CAAC0E,QAAQ,CAAC,OAAO,CAAC;IACnC,CAAC,CAAC;IACF,IAAIN,iBAAiB,CAACN,MAAM,GAAG,CAAC,EAAE;MAChC,IAAIa,aAAa,GAAGP,iBAAiB,CAACQ,KAAK,EAAE;MAC7C,IAAI,IAAI,CAACvD,cAAc,CAACM,MAAM,KAAKhC,MAAM,CAAC6E,KAAK,EAAE;QAC/C9C,MAAM,GAAGwC,OAAO,CAACW,UAAU,EAAE,GAAGF,aAAa,CAACG,QAAQ,EAAE,CAACC,IAAI,GAAG,IAAI,CAAC1D,cAAc,CAACI,GAAG;MACzF,CAAC,MAAM;QACLC,MAAM,GAAGiD,aAAa,CAACG,QAAQ,EAAE,CAACC,IAAI,GAAG,IAAI,CAAC1D,cAAc,CAACI,GAAG,GAAGkD,aAAa,CAACE,UAAU,EAAE;MAC/F;IACF;IACA,IAAI,IAAI,CAACrE,KAAK,EAAE;MACdqB,IAAI,GAAG,QAAQ,GAAGA,IAAI;IACxB;IACA,IAAI,IAAI,CAACtB,GAAG,EAAE;MACZsB,IAAI,GAAG,MAAM,GAAGA,IAAI;IACtB;IACA,IAAI,IAAI,CAACxB,IAAI,EAAE;MACbwB,IAAI,GAAG,OAAO,GAAGA,IAAI;IACvB;IACA,IAAIiD,QAAQ,GAAGZ,OAAO,CAACc,GAAG,CAAC,UAAU,CAAC;IACtC,IAAIF,QAAQ,KAAK,UAAU,IAAIA,QAAQ,KAAK,UAAU,IAAKA,QAAQ,KAAK,QAAQ,IAAIV,iBAAiB,CAACN,MAAM,GAAG,CAAE,EAAE;MACjH,OAAOmB,aAAa,CAACC,IAAI,CAAC,IAAI,EAAExD,MAAM,CAAC;IACzC;IACA,IAAIyD,GAAG,GAAGjB,OAAO,CAACY,QAAQ,EAAE;IAC5B,IAAIK,GAAG,EAAE;MACP,OAAOF,aAAa,CAACC,IAAI,CAAC,IAAI,EAAEC,GAAG,CAACJ,IAAI,GAAGrD,MAAM,CAAC;IACpD;IACA1B,CAAC,CAACoF,GAAG,CAACC,IAAI,CAAC,wDAAwD,GAAGnB,OAAO,CAAC;IAE9E,SAASe,aAAa,CAACK,UAAU,EAAE;MACjC,OAAOpB,OAAO,CAACqB,UAAU,CAAC,SAAS,EAAE1D,IAAI,CAAC,CACvCmD,GAAG,CAACT,KAAK,EAAEe,UAAU,GAAG,IAAI,CAAC,CAC7BE,WAAW,CAAC,UAAU,EAAE,CAAC,IAAI,CAACpE,eAAe,CAAC,CAC9CqE,QAAQ,CAAClB,KAAK,CAAC;IACpB;EACF;;EAEA;AACF;AACA;EACEN,iBAAiB,CAACnC,YAAY,EAAE,CAChC;;EAEA;AACF;AACA;EACE4D,YAAY,CAAC5D,YAAY,EAAE;IACzB,IAAIA,YAAY,EAAE;MAChB9B,CAAC,CAAC,UAAU,EAAE8B,YAAY,CAAC,CAAC6D,MAAM,EAAE;MACpC3F,CAAC,CAAC,qBAAqB,EAAE8B,YAAY,CAAC,CAAC6D,MAAM,EAAE;IACjD;EACF;EAOA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOtD,cAAc,CAACF,aAAa,EAAE;IACnC,IAAI,CAACA,aAAa,EAAE;MAClB,OAAO,IAAI;IACb;IAEA,IAAIyD,YAAY,GAAG;MACjBrF,GAAG,EAAE,KAAK;MACVF,IAAI,EAAE,KAAK;MACXG,KAAK,EAAE,KAAK;MACZJ,KAAK,EAAE;IACT,CAAC;IAED+B,aAAa,CAAC0D,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,CAACC,IAAI,IAAI;MACvC,IAAIA,IAAI,KAAK,WAAW,IAAIA,IAAI,KAAK,KAAK,EAAE;QAC1CH,YAAY,CAACrF,GAAG,GAAG,IAAI;MACzB,CAAC,MAAM,IAAIwF,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,MAAM,EAAE;QAChDH,YAAY,CAACvF,IAAI,GAAG,IAAI;MAC1B,CAAC,MAAM,IAAI0F,IAAI,KAAK,OAAO,EAAE;QAC3BH,YAAY,CAACpF,KAAK,GAAG,IAAI;MAC3B,CAAC,MAAM;QACL,IAAIwF,GAAG,GAAGnG,IAAI,CAACkG,IAAI,CAACE,WAAW,EAAE,CAAC;QAClCL,YAAY,CAACxF,KAAK,GAAG4F,GAAG,IAAI,CAACA,GAAG,CAAC;MACnC;IACF,CAAC,CAAC;IAEF,OAAOJ,YAAY;EACrB;EAEA,OAAOjC,WAAW,CAACT,SAAS,EAAEnB,KAAK,EAAE;IACnC,IAAI,CAACmB,SAAS,EAAE;MACd,OAAO,KAAK;IACd;IACA;IACA,OAAOjD,SAAS,CAACiG,eAAe,CAAChD,SAAS,EAAEnB,KAAK,CAAC,IAChDjC,KAAK,CAACqG,OAAO,CAACpE,KAAK,CAAC3B,KAAK,EAAE8C,SAAS,CAAC9C,KAAK,CAAC;EAC/C;EAEA,OAAO8F,eAAe,CAAChD,SAAS,EAAEnB,KAAK,EAAE;IACvC,OAAO9B,SAAS,CAACmG,eAAe,CAAClD,SAAS,CAAC7C,IAAI,EAAG0B,KAAK,CAACsE,OAAO,IAAItE,KAAK,CAACuE,OAAO,CAAE,IAChFrG,SAAS,CAACmG,eAAe,CAAClD,SAAS,CAAC3C,GAAG,EAAEwB,KAAK,CAACwE,MAAM,CAAC,IACtDtG,SAAS,CAACmG,eAAe,CAAClD,SAAS,CAAC1C,KAAK,EAAEuB,KAAK,CAACyE,QAAQ,CAAC;EAC9D;EAEA,OAAOJ,eAAe,CAACK,QAAQ,EAAEC,aAAa,EAAE;IAC9C,OAAOD,QAAQ,KAAKjF,SAAS,IAAIkF,aAAa,KAAKlF,SAAS,IAAIiF,QAAQ,KAAKC,aAAa;EAC5F;AACF;AAAC,gBA7ToBzG,SAAS,UAiQd;EACZ0G,EAAE,EAAE,OAAO;EACX7F,IAAI,EAAE;AACR,CAAC"},"metadata":{},"sourceType":"module"}