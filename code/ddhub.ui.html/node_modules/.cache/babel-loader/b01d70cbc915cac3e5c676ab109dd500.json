{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { LookupFieldAdapter, scout, strings } from '../../../index';\nexport default class SmartFieldAdapter extends LookupFieldAdapter {\n  constructor() {\n    super();\n    this._addRemoteProperties(['activeFilter']);\n  }\n\n  /**\n   * Property lookup-row must be handled before value, since the smart-field has either a lookup-row\n   * or a value but never both (when we only have a value, the smart-field must perform a lookup by key\n   * in order to resolve the display name for that value).\n   * <br>\n   * Intentionally don't re-use properties from super-classes.\n   */\n\n  _postCreateWidget() {\n    super._postCreateWidget();\n    this.widget.lookupCall = scout.create('RemoteLookupCall', this);\n  }\n  _syncResult(result) {\n    let executedLookupCall = this.widget._currentLookupCall;\n    if (!executedLookupCall && this.widget.touchMode && this.widget.popup && this.widget.popup._field) {\n      // in case lookupCall is executed from within the popup (touch):\n      executedLookupCall = this.widget.popup._field._currentLookupCall;\n    }\n    if (executedLookupCall) {\n      executedLookupCall.resolveLookup(result);\n    }\n  }\n\n  // When displayText comes from the server we must not call parseAndSetValue here.\n  _syncDisplayText(displayText) {\n    this.widget.setDisplayText(displayText);\n  }\n  _orderPropertyNamesOnSync(newProperties) {\n    return Object.keys(newProperties).sort(this._createPropertySortFunc(SmartFieldAdapter.PROPERTIES_ORDER));\n  }\n  _onWidgetEvent(event) {\n    if (event.type === 'acceptByText') {\n      this._onWidgetAcceptByText(event);\n    } else {\n      super._onWidgetEvent(event);\n    }\n  }\n  _onWidgetAcceptByText(event) {\n    this._sendProperty('errorStatus', event.errorStatus);\n  }\n  _onWidgetAcceptInput(event) {\n    let eventData = {\n      displayText: event.displayText,\n      errorStatus: event.errorStatus\n    };\n    if (event.errorStatus) {\n      // 'clear' case\n      if (strings.empty(event.displayText)) {\n        eventData.value = null;\n      }\n    } else {\n      eventData.value = event.value;\n      if (event.acceptByLookupRow) {\n        eventData.lookupRow = event.lookupRow;\n      }\n    }\n    this._send('acceptInput', eventData, {\n      showBusyIndicator: !event.whileTyping,\n      coalesce: function (previous) {\n        return this.target === previous.target && this.type === previous.type && this.whileTyping === previous.whileTyping;\n      }\n    });\n  }\n}\n_defineProperty(SmartFieldAdapter, \"PROPERTIES_ORDER\", ['lookupRow', 'value', 'errorStatus', 'displayText']);","map":{"version":3,"names":["LookupFieldAdapter","scout","strings","SmartFieldAdapter","constructor","_addRemoteProperties","_postCreateWidget","widget","lookupCall","create","_syncResult","result","executedLookupCall","_currentLookupCall","touchMode","popup","_field","resolveLookup","_syncDisplayText","displayText","setDisplayText","_orderPropertyNamesOnSync","newProperties","Object","keys","sort","_createPropertySortFunc","PROPERTIES_ORDER","_onWidgetEvent","event","type","_onWidgetAcceptByText","_sendProperty","errorStatus","_onWidgetAcceptInput","eventData","empty","value","acceptByLookupRow","lookupRow","_send","showBusyIndicator","whileTyping","coalesce","previous","target"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/smartfield/SmartFieldAdapter.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {LookupFieldAdapter, scout, strings} from '../../../index';\n\nexport default class SmartFieldAdapter extends LookupFieldAdapter {\n\n  constructor() {\n    super();\n\n    this._addRemoteProperties(['activeFilter']);\n  }\n\n  /**\n   * Property lookup-row must be handled before value, since the smart-field has either a lookup-row\n   * or a value but never both (when we only have a value, the smart-field must perform a lookup by key\n   * in order to resolve the display name for that value).\n   * <br>\n   * Intentionally don't re-use properties from super-classes.\n   */\n  static PROPERTIES_ORDER = ['lookupRow', 'value', 'errorStatus', 'displayText'];\n\n  _postCreateWidget() {\n    super._postCreateWidget();\n    this.widget.lookupCall = scout.create('RemoteLookupCall', this);\n  }\n\n  _syncResult(result) {\n    let executedLookupCall = this.widget._currentLookupCall;\n    if (!executedLookupCall && this.widget.touchMode && this.widget.popup && this.widget.popup._field) {\n      // in case lookupCall is executed from within the popup (touch):\n      executedLookupCall = this.widget.popup._field._currentLookupCall;\n    }\n    if (executedLookupCall) {\n      executedLookupCall.resolveLookup(result);\n    }\n  }\n\n  // When displayText comes from the server we must not call parseAndSetValue here.\n  _syncDisplayText(displayText) {\n    this.widget.setDisplayText(displayText);\n  }\n\n  _orderPropertyNamesOnSync(newProperties) {\n    return Object.keys(newProperties).sort(this._createPropertySortFunc(SmartFieldAdapter.PROPERTIES_ORDER));\n  }\n\n  _onWidgetEvent(event) {\n    if (event.type === 'acceptByText') {\n      this._onWidgetAcceptByText(event);\n    } else {\n      super._onWidgetEvent(event);\n    }\n  }\n\n  _onWidgetAcceptByText(event) {\n    this._sendProperty('errorStatus', event.errorStatus);\n  }\n\n  _onWidgetAcceptInput(event) {\n    let eventData = {\n      displayText: event.displayText,\n      errorStatus: event.errorStatus\n    };\n\n    if (event.errorStatus) {\n      // 'clear' case\n      if (strings.empty(event.displayText)) {\n        eventData.value = null;\n      }\n    } else {\n      eventData.value = event.value;\n      if (event.acceptByLookupRow) {\n        eventData.lookupRow = event.lookupRow;\n      }\n    }\n\n    this._send('acceptInput', eventData, {\n      showBusyIndicator: !event.whileTyping,\n      coalesce: function(previous) {\n        return this.target === previous.target && this.type === previous.type && this.whileTyping === previous.whileTyping;\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}