{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays } from '../index';\nexport default class Range {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n  equals(other) {\n    return this.from === other.from && this.to === other.to;\n  }\n\n  /**\n   * Subtracts the given range and returns an array of the remaining ranges.\n   */\n  subtract(other) {\n    // other is empty\n    if (other.size() === 0) {\n      return [new Range(this.from, this.to)];\n    }\n    // other is greater\n    if (this.from >= other.from && this.to <= other.to) {\n      return [new Range(0, 0)];\n    }\n    // other is contained completely\n    if (other.from >= this.from && other.to <= this.to) {\n      let range1 = new Range(this.from, other.from);\n      let range2 = new Range(other.to, this.to);\n      if (range1.size() === 0) {\n        return [range2];\n      }\n      if (range2.size() === 0) {\n        return [range1];\n      }\n      return [range1, range2];\n    }\n    // other overlaps on the bottom\n    if (other.from > this.from && other.from < this.to) {\n      return [new Range(this.from, other.from)];\n    }\n    // other overlaps on the top\n    if (this.from > other.from && this.from < other.to) {\n      return [new Range(other.to, this.to)];\n    }\n    // other is outside\n    return [new Range(this.from, this.to)];\n  }\n\n  /**\n   * Subtracts every given range and returns an array of the remaining ranges.\n   */\n  subtractAll(others) {\n    let other = others.shift();\n    let remains = [this];\n    let newRemains = [];\n    // Subtract every other element from the remains of every subtraction\n    while (other) {\n      remains.forEach(subtract.bind(other));\n      remains = newRemains;\n      newRemains = [];\n      other = others.shift();\n    }\n    // Remove empty ranges\n    remains = remains.filter(remainingElem => {\n      return remainingElem.size() > 0;\n    });\n    // If nothing is left add one empty range to be consistent with .subtract()\n    if (remains.length === 0) {\n      remains.push(new Range(0, 0));\n    }\n    function subtract(remainingElem) {\n      arrays.pushAll(newRemains, remainingElem.subtract(other));\n    }\n    return remains;\n  }\n  shrink(other) {\n    // other is empty\n    if (other.size() === 0) {\n      return new Range(this.from, this.to);\n    }\n    // other is greater\n    if (this.from >= other.from && this.to <= other.to) {\n      return new Range(0, 0);\n    }\n    // other is contained completely\n    if (other.from >= this.from && other.to <= this.to) {\n      return new Range(this.from, other.to);\n    }\n    // other overlaps on the bottom\n    if (other.from >= this.from && other.from < this.to) {\n      return new Range(this.from, other.from);\n    }\n    // other overlaps on the top\n    if (this.from > other.from && this.from < other.to) {\n      return new Range(other.to, this.to);\n    }\n    if (other.to < this.from) {\n      return new Range(this.from - other.size() - 1, this.to - other.size() - 1);\n    }\n    // other is outside\n    return new Range(this.from, this.to);\n  }\n  union(other) {\n    if (this.to < other.from || other.to < this.from) {\n      let range1 = new Range(this.from, this.to);\n      let range2 = new Range(other.from, other.to);\n      if (range1.size() === 0) {\n        return [range2];\n      }\n      if (range2.size() === 0) {\n        return [range1];\n      }\n      return [range1, range2];\n    }\n    return [new Range(Math.min(this.from, other.from), Math.max(this.to, other.to))];\n  }\n  add(other) {\n    if (this.to < other.from || other.to < this.from) {\n      let range1 = new Range(this.from, this.to);\n      let range2 = new Range(other.from, other.to);\n      if (range1.size() === 0) {\n        return range2;\n      }\n      if (range2.size() === 0) {\n        return range1;\n      }\n      throw new Error('Range to add has to border on the existing range. ' + this + ', ' + other);\n    }\n    return new Range(Math.min(this.from, other.from), Math.max(this.to, other.to));\n  }\n  intersect(other) {\n    if (this.to <= other.from || other.to <= this.from) {\n      return new Range(0, 0);\n    }\n    return new Range(Math.max(this.from, other.from), Math.min(this.to, other.to));\n  }\n  size() {\n    return this.to - this.from;\n  }\n  contains(value) {\n    return this.from <= value && value < this.to;\n  }\n  toString() {\n    return 'scout.Range[' + 'from=' + (this.from === null ? 'null' : this.from) + ' to=' + (this.to === null ? 'null' : this.to) + ']';\n  }\n}","map":{"version":3,"names":["arrays","Range","constructor","from","to","equals","other","subtract","size","range1","range2","subtractAll","others","shift","remains","newRemains","forEach","bind","filter","remainingElem","length","push","pushAll","shrink","union","Math","min","max","add","Error","intersect","contains","value","toString"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/Range.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays} from '../index';\n\nexport default class Range {\n\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n\n  equals(other) {\n    return this.from === other.from && this.to === other.to;\n  }\n\n  /**\n   * Subtracts the given range and returns an array of the remaining ranges.\n   */\n  subtract(other) {\n    // other is empty\n    if (other.size() === 0) {\n      return [new Range(this.from, this.to)];\n    }\n    // other is greater\n    if (this.from >= other.from && this.to <= other.to) {\n      return [new Range(0, 0)];\n    }\n    // other is contained completely\n    if (other.from >= this.from && other.to <= this.to) {\n      let range1 = new Range(this.from, other.from);\n      let range2 = new Range(other.to, this.to);\n      if (range1.size() === 0) {\n        return [range2];\n      }\n      if (range2.size() === 0) {\n        return [range1];\n      }\n      return [range1, range2];\n    }\n    // other overlaps on the bottom\n    if (other.from > this.from && other.from < this.to) {\n      return [new Range(this.from, other.from)];\n    }\n    // other overlaps on the top\n    if (this.from > other.from && this.from < other.to) {\n      return [new Range(other.to, this.to)];\n    }\n    // other is outside\n    return [new Range(this.from, this.to)];\n  }\n\n  /**\n   * Subtracts every given range and returns an array of the remaining ranges.\n   */\n  subtractAll(others) {\n    let other = others.shift();\n    let remains = [this];\n    let newRemains = [];\n    // Subtract every other element from the remains of every subtraction\n    while (other) {\n      remains.forEach(subtract.bind(other));\n      remains = newRemains;\n      newRemains = [];\n      other = others.shift();\n    }\n    // Remove empty ranges\n    remains = remains.filter(remainingElem => {\n      return remainingElem.size() > 0;\n    });\n    // If nothing is left add one empty range to be consistent with .subtract()\n    if (remains.length === 0) {\n      remains.push(new Range(0, 0));\n    }\n\n    function subtract(remainingElem) {\n      arrays.pushAll(newRemains, remainingElem.subtract(other));\n    }\n\n    return remains;\n  }\n\n  shrink(other) {\n    // other is empty\n    if (other.size() === 0) {\n      return new Range(this.from, this.to);\n    }\n    // other is greater\n    if (this.from >= other.from && this.to <= other.to) {\n      return new Range(0, 0);\n    }\n    // other is contained completely\n    if (other.from >= this.from && other.to <= this.to) {\n      return new Range(this.from, other.to);\n    }\n    // other overlaps on the bottom\n    if (other.from >= this.from && other.from < this.to) {\n      return new Range(this.from, other.from);\n    }\n    // other overlaps on the top\n    if (this.from > other.from && this.from < other.to) {\n      return new Range(other.to, this.to);\n    }\n    if (other.to < this.from) {\n      return new Range(this.from - other.size() - 1, this.to - other.size() - 1);\n    }\n    // other is outside\n    return new Range(this.from, this.to);\n  }\n\n  union(other) {\n    if (this.to < other.from || other.to < this.from) {\n      let range1 = new Range(this.from, this.to);\n      let range2 = new Range(other.from, other.to);\n      if (range1.size() === 0) {\n        return [range2];\n      }\n      if (range2.size() === 0) {\n        return [range1];\n      }\n      return [range1, range2];\n    }\n    return [new Range(Math.min(this.from, other.from), Math.max(this.to, other.to))];\n  }\n\n  add(other) {\n    if (this.to < other.from || other.to < this.from) {\n      let range1 = new Range(this.from, this.to);\n      let range2 = new Range(other.from, other.to);\n      if (range1.size() === 0) {\n        return range2;\n      }\n      if (range2.size() === 0) {\n        return range1;\n      }\n      throw new Error('Range to add has to border on the existing range. ' + this + ', ' + other);\n    }\n    return new Range(Math.min(this.from, other.from), Math.max(this.to, other.to));\n  }\n\n  intersect(other) {\n    if (this.to <= other.from || other.to <= this.from) {\n      return new Range(0, 0);\n    }\n    return new Range(Math.max(this.from, other.from), Math.min(this.to, other.to));\n  }\n\n  size() {\n    return this.to - this.from;\n  }\n\n  contains(value) {\n    return this.from <= value && value < this.to;\n  }\n\n  toString() {\n    return 'scout.Range[' +\n      'from=' + (this.from === null ? 'null' : this.from) +\n      ' to=' + (this.to === null ? 'null' : this.to) + ']';\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}