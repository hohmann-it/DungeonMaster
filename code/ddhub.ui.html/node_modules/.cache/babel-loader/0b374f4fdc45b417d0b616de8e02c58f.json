{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { graphics } from '../../index';\nimport $ from 'jquery';\nexport default class ColumnOptimalWidthMeasurer {\n  constructor(column) {\n    this.column = column;\n    this.table = null;\n    this.$measurement = null;\n    this.deferred = null;\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n    this._imageLoadOrErrorHandler = this._onImageLoadOrError.bind(this);\n    this._columnCellContents = {};\n  }\n  measure(promise) {\n    $.log.isDebugEnabled() && $.log.debug('Optimal width measuring started for column ' + this.column.id);\n\n    // Table is not yet available on the column in the constructor -> set it here\n    this.table = this.column.table;\n    if (this.$measurement) {\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring aborted for column ' + this.column.id);\n\n      // If measurement is still in progress, abort it and start a new measurement\n      this._resolve(-1);\n    }\n\n    // Prepare a temporary container that is not (yet) part of the DOM to prevent\n    // expensive \"forced reflow\" while adding the cell divs. Only after all cells\n    // are rendered, the container is added to the DOM.\n    this.$measurement = this.table.$data.makeDiv('hidden');\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n\n    // Create divs for all relevant cells of the column\n    this._appendElements();\n\n    // Add to DOM\n    this.table.$data.append(this.$measurement);\n    if (this.completeImageCount >= this.imageCount) {\n      // Measure now\n      let optimalWidth = this._measure();\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (sync) for column ' + this.column.id + ': ' + optimalWidth);\n      this.remove();\n      return optimalWidth;\n    }\n\n    // Measure later as soon as every image has been loaded\n    $.log.isDebugEnabled() && $.log.debug('Not all images loaded, deferring measurement for column ' + this.column.id + '. Images complete: ' + this.completeImageCount + '/' + this.imageCount);\n    this.$measurement[0].addEventListener('load', this._imageLoadOrErrorHandler, true);\n    this.$measurement[0].addEventListener('error', this._imageLoadOrErrorHandler, true);\n    this.deferred = $.Deferred();\n    return this.deferred.promise();\n  }\n  remove() {\n    if (!this.$measurement) {\n      return;\n    }\n    this.$measurement[0].removeEventListener('load', this._imageLoadOrErrorHandler, true);\n    this.$measurement[0].removeEventListener('error', this._imageLoadOrErrorHandler, true);\n    this.$measurement.remove();\n    this.$measurement = null;\n  }\n  _measure() {\n    let maxWidth = this.column.minWidth;\n    let maxOverlap = 0;\n    // Since the measurement may be async due to image loading, the $measurement is hidden (=display: none) until the real measurement starts.\n    // Otherwise it would influence the scroll width of the real table data\n    this.$measurement.addClass('invisible').removeClass('hidden').children().each(function () {\n      if (this.dataset.overlap) {\n        maxOverlap = Math.max(maxOverlap, parseInt(this.dataset.overlap, 10));\n      }\n      maxWidth = Math.max(maxWidth, graphics.size($(this), true).width);\n    });\n    return maxWidth + maxOverlap;\n  }\n  _resolve(optimalWidth) {\n    this.remove();\n    if (this.deferred) {\n      this.deferred.resolve(optimalWidth);\n      this.deferred = null;\n    }\n  }\n  _appendElements() {\n    this._appendHeader();\n    this._appendRows();\n    this._appendAggregateRows();\n  }\n  _appendHeader() {\n    if (this.column.$header) {\n      this._appendToMeasurement(this.column.$header.clone());\n    }\n  }\n  _appendRows() {\n    this.table.rows.forEach(this._appendRow.bind(this));\n    this._columnCellContents = {};\n  }\n  _appendRow(row) {\n    let columnContent = this.column.buildCellForRow(row);\n    if (this._columnCellContents[columnContent]) {\n      return;\n    }\n    this._columnCellContents[columnContent] = true;\n    this._appendToMeasurement($(columnContent));\n  }\n  _appendAggregateRows() {\n    this.table._aggregateRows.forEach(this._appendAggregateRow.bind(this));\n  }\n  _appendAggregateRow(row) {\n    this._appendToMeasurement(this._build$CellForAggregateRow(row));\n  }\n\n  /**\n   * For aggregate rows the text of neighbour cells may overlap into the own cell.\n   * To ensure there is enough space for the content of this cell, the overlap of the neighbour must be included.\n   * To have access to neighbour cells and to measure its sizes the whole aggregate row must be constructed.\n   *\n   * @returns {$} The created cell\n   */\n  _build$CellForAggregateRow(row) {\n    let columns = this.table.visibleColumns();\n    let colIndex = columns.indexOf(this.column);\n    let $row = this.table._build$AggregateRow(row);\n    $row.appendTo(this.table.$data);\n    columns.map(c => c.buildCellForAggregateRow(row)).forEach(c => $(c).appendTo($row));\n    let $cell = $row.children().eq(colIndex);\n    let aggregateOverlap = this._getAggregateOverlap($cell); // compute the overlap\n    if (aggregateOverlap > 0) {\n      $cell[0].dataset.overlap = aggregateOverlap + '';\n    }\n    $row.detach();\n    return $cell;\n  }\n\n  /**\n   * Compute how much the neighbour cell overlaps into the given cell.\n   * @param {$} $cell The cell for which the overlap should be computed\n   * @returns {number} The overlap in pixels.\n   */\n  _getAggregateOverlap($cell) {\n    if (!$cell || !$cell.length || $cell.hasClass('empty')) {\n      return 0;\n    }\n    let cellRange = this.table._getAggrCellRange($cell);\n    if (cellRange.length < 2) {\n      return 0;\n    }\n    let $neighbour = cellRange[cellRange.length - 1];\n    if ($neighbour.hasClass('empty') || $cell.hasClass('halign-right') === $neighbour.hasClass('halign-right')) {\n      return 0;\n    }\n    let $neighbourText = $neighbour.children('.text');\n    if (!$neighbourText || !$neighbourText.length) {\n      return 0;\n    }\n    let overlap = graphics.size($neighbourText).width - $neighbour.cssMaxWidth() + $neighbour.cssPaddingLeft();\n    if (overlap <= 0) {\n      return 0;\n    }\n    for (let i = cellRange.length - 1; i > 0; i--) {\n      let $aggrCell = cellRange[i];\n      if ($aggrCell.hasClass('empty')) {\n        overlap -= $aggrCell.cssMaxWidth();\n      }\n    }\n    return Math.max(0, overlap);\n  }\n  _appendToMeasurement($calc) {\n    // Count images\n    let $calcImgs = $calc.find('img');\n    $calcImgs.each((index, elem) => {\n      let $img = $(elem);\n      $img.data('measure', 'in-progress');\n      if (elem.complete) {\n        $img.data('complete', elem.complete);\n        this.completeImageCount++;\n      }\n      this.imageCount++;\n    });\n\n    // Append to measurement element\n    $calc.css({\n      minWidth: '',\n      maxWidth: ''\n    }).appendTo(this.$measurement);\n  }\n  _onImageLoadOrError(event) {\n    let $img = $(event.target);\n    if ($img.data('complete')) {\n      // Ignore images which were already complete and therefore already incremented the _imageCompleteCount\n      return;\n    }\n    this.completeImageCount++;\n    $.log.isTraceEnabled() && $.log.trace('Images complete (async) ' + this.completeImageCount + '/' + this.imageCount, event.target.src);\n    if (this.completeImageCount >= this.imageCount) {\n      let optimalWidth = this._measure();\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (async) for column ' + this.column.id + ': ' + optimalWidth);\n      this._resolve(optimalWidth);\n    }\n  }\n}","map":{"version":3,"names":["graphics","$","ColumnOptimalWidthMeasurer","constructor","column","table","$measurement","deferred","imageCount","completeImageCount","_imageLoadOrErrorHandler","_onImageLoadOrError","bind","_columnCellContents","measure","promise","log","isDebugEnabled","debug","id","_resolve","$data","makeDiv","_appendElements","append","optimalWidth","_measure","remove","addEventListener","Deferred","removeEventListener","maxWidth","minWidth","maxOverlap","addClass","removeClass","children","each","dataset","overlap","Math","max","parseInt","size","width","resolve","_appendHeader","_appendRows","_appendAggregateRows","$header","_appendToMeasurement","clone","rows","forEach","_appendRow","row","columnContent","buildCellForRow","_aggregateRows","_appendAggregateRow","_build$CellForAggregateRow","columns","visibleColumns","colIndex","indexOf","$row","_build$AggregateRow","appendTo","map","c","buildCellForAggregateRow","$cell","eq","aggregateOverlap","_getAggregateOverlap","detach","length","hasClass","cellRange","_getAggrCellRange","$neighbour","$neighbourText","cssMaxWidth","cssPaddingLeft","i","$aggrCell","$calc","$calcImgs","find","index","elem","$img","data","complete","css","event","target","isTraceEnabled","trace","src"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/columns/ColumnOptimalWidthMeasurer.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {graphics} from '../../index';\nimport $ from 'jquery';\n\nexport default class ColumnOptimalWidthMeasurer {\n\n  constructor(column) {\n    this.column = column;\n    this.table = null;\n    this.$measurement = null;\n    this.deferred = null;\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n    this._imageLoadOrErrorHandler = this._onImageLoadOrError.bind(this);\n    this._columnCellContents = {};\n  }\n\n  measure(promise) {\n    $.log.isDebugEnabled() && $.log.debug('Optimal width measuring started for column ' + this.column.id);\n\n    // Table is not yet available on the column in the constructor -> set it here\n    this.table = this.column.table;\n\n    if (this.$measurement) {\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring aborted for column ' + this.column.id);\n\n      // If measurement is still in progress, abort it and start a new measurement\n      this._resolve(-1);\n    }\n\n    // Prepare a temporary container that is not (yet) part of the DOM to prevent\n    // expensive \"forced reflow\" while adding the cell divs. Only after all cells\n    // are rendered, the container is added to the DOM.\n    this.$measurement = this.table.$data.makeDiv('hidden');\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n\n    // Create divs for all relevant cells of the column\n    this._appendElements();\n\n    // Add to DOM\n    this.table.$data.append(this.$measurement);\n\n    if (this.completeImageCount >= this.imageCount) {\n      // Measure now\n      let optimalWidth = this._measure();\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (sync) for column ' + this.column.id + ': ' + optimalWidth);\n      this.remove();\n      return optimalWidth;\n    }\n\n    // Measure later as soon as every image has been loaded\n    $.log.isDebugEnabled() && $.log.debug('Not all images loaded, deferring measurement for column ' + this.column.id + '. Images complete: ' + this.completeImageCount + '/' + this.imageCount);\n    this.$measurement[0].addEventListener('load', this._imageLoadOrErrorHandler, true);\n    this.$measurement[0].addEventListener('error', this._imageLoadOrErrorHandler, true);\n    this.deferred = $.Deferred();\n    return this.deferred.promise();\n  }\n\n  remove() {\n    if (!this.$measurement) {\n      return;\n    }\n    this.$measurement[0].removeEventListener('load', this._imageLoadOrErrorHandler, true);\n    this.$measurement[0].removeEventListener('error', this._imageLoadOrErrorHandler, true);\n    this.$measurement.remove();\n    this.$measurement = null;\n  }\n\n  _measure() {\n    let maxWidth = this.column.minWidth;\n    let maxOverlap = 0;\n    // Since the measurement may be async due to image loading, the $measurement is hidden (=display: none) until the real measurement starts.\n    // Otherwise it would influence the scroll width of the real table data\n    this.$measurement\n      .addClass('invisible')\n      .removeClass('hidden')\n      .children()\n      .each(function() {\n        if (this.dataset.overlap) {\n          maxOverlap = Math.max(maxOverlap, parseInt(this.dataset.overlap, 10));\n        }\n        maxWidth = Math.max(maxWidth, graphics.size($(this), true).width);\n      });\n    return maxWidth + maxOverlap;\n  }\n\n  _resolve(optimalWidth) {\n    this.remove();\n    if (this.deferred) {\n      this.deferred.resolve(optimalWidth);\n      this.deferred = null;\n    }\n  }\n\n  _appendElements() {\n    this._appendHeader();\n    this._appendRows();\n    this._appendAggregateRows();\n  }\n\n  _appendHeader() {\n    if (this.column.$header) {\n      this._appendToMeasurement(this.column.$header.clone());\n    }\n  }\n\n  _appendRows() {\n    this.table.rows.forEach(this._appendRow.bind(this));\n    this._columnCellContents = {};\n  }\n\n  _appendRow(row) {\n    let columnContent = this.column.buildCellForRow(row);\n    if (this._columnCellContents[columnContent]) {\n      return;\n    }\n    this._columnCellContents[columnContent] = true;\n\n    this._appendToMeasurement($(columnContent));\n  }\n\n  _appendAggregateRows() {\n    this.table._aggregateRows.forEach(this._appendAggregateRow.bind(this));\n  }\n\n  _appendAggregateRow(row) {\n    this._appendToMeasurement(this._build$CellForAggregateRow(row));\n  }\n\n  /**\n   * For aggregate rows the text of neighbour cells may overlap into the own cell.\n   * To ensure there is enough space for the content of this cell, the overlap of the neighbour must be included.\n   * To have access to neighbour cells and to measure its sizes the whole aggregate row must be constructed.\n   *\n   * @returns {$} The created cell\n   */\n  _build$CellForAggregateRow(row) {\n    let columns = this.table.visibleColumns();\n    let colIndex = columns.indexOf(this.column);\n    let $row = this.table._build$AggregateRow(row);\n\n    $row.appendTo(this.table.$data);\n    columns\n      .map(c => c.buildCellForAggregateRow(row))\n      .forEach(c => $(c).appendTo($row));\n    let $cell = $row.children().eq(colIndex);\n\n    let aggregateOverlap = this._getAggregateOverlap($cell); // compute the overlap\n    if (aggregateOverlap > 0) {\n      $cell[0].dataset.overlap = aggregateOverlap + '';\n    }\n    $row.detach();\n\n    return $cell;\n  }\n\n  /**\n   * Compute how much the neighbour cell overlaps into the given cell.\n   * @param {$} $cell The cell for which the overlap should be computed\n   * @returns {number} The overlap in pixels.\n   */\n  _getAggregateOverlap($cell) {\n    if (!$cell || !$cell.length || $cell.hasClass('empty')) {\n      return 0;\n    }\n    let cellRange = this.table._getAggrCellRange($cell);\n    if (cellRange.length < 2) {\n      return 0;\n    }\n    let $neighbour = cellRange[cellRange.length - 1];\n    if ($neighbour.hasClass('empty') || $cell.hasClass('halign-right') === $neighbour.hasClass('halign-right')) {\n      return 0;\n    }\n    let $neighbourText = $neighbour.children('.text');\n    if (!$neighbourText || !$neighbourText.length) {\n      return 0;\n    }\n    let overlap = graphics.size($neighbourText).width - $neighbour.cssMaxWidth() + $neighbour.cssPaddingLeft();\n    if (overlap <= 0) {\n      return 0;\n    }\n    for (let i = cellRange.length - 1; i > 0; i--) {\n      let $aggrCell = cellRange[i];\n      if ($aggrCell.hasClass('empty')) {\n        overlap -= $aggrCell.cssMaxWidth();\n      }\n    }\n    return Math.max(0, overlap);\n  }\n\n  _appendToMeasurement($calc) {\n    // Count images\n    let $calcImgs = $calc.find('img');\n    $calcImgs.each((index, elem) => {\n      let $img = $(elem);\n      $img.data('measure', 'in-progress');\n      if (elem.complete) {\n        $img.data('complete', elem.complete);\n        this.completeImageCount++;\n      }\n      this.imageCount++;\n    });\n\n    // Append to measurement element\n    $calc.css({\n      minWidth: '',\n      maxWidth: ''\n    }).appendTo(this.$measurement);\n  }\n\n  _onImageLoadOrError(event) {\n    let $img = $(event.target);\n    if ($img.data('complete')) {\n      // Ignore images which were already complete and therefore already incremented the _imageCompleteCount\n      return;\n    }\n\n    this.completeImageCount++;\n    $.log.isTraceEnabled() && $.log.trace('Images complete (async) ' + this.completeImageCount + '/' + this.imageCount, event.target.src);\n    if (this.completeImageCount >= this.imageCount) {\n      let optimalWidth = this._measure();\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (async) for column ' + this.column.id + ': ' + optimalWidth);\n      this._resolve(optimalWidth);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}