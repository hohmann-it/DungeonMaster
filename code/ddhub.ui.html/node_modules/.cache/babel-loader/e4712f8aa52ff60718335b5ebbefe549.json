{"ast":null,"code":"/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, dragAndDrop, DragAndDropHandler } from '../index';\nconst SCOUT_TYPES = {\n  FILE_TRANSFER: 1 << 0,\n  // IDNDSupport.TYPE_FILE_TRANSFER (NOSONAR)\n  JAVA_ELEMENT_TRANSFER: 1 << 1,\n  // IDNDSupport.TYPE_JAVA_ELEMENT_TRANSFER (NOSONAR)\n  TEXT_TRANSFER: 1 << 2,\n  // IDNDSupport.TYPE_TEXT_TRANSFER (NOSONAR)\n  IMAGE_TRANSFER: 1 << 3 // IDNDSupport.TYPE_IMAGE_TRANSFER (NOSONAR)\n};\n\nconst DEFAULT_DROP_MAXIMUM_SIZE = 50 * 1024 * 1024; // 50 MB\n\n/**\n * Mapping function from scout drag types to browser drag types.\n *\n * @param scoutTypesArray array of SCOUT_TYPES\n * @returns {Array} return array\n */\nexport function scoutTypeToDragTypeMapping(scoutTypesArray) {\n  scoutTypesArray = arrays.ensure(scoutTypesArray);\n  let ret = [];\n  if (scoutTypesArray.indexOf(SCOUT_TYPES.FILE_TRANSFER) >= 0) {\n    ret.push('Files');\n  }\n  return ret;\n}\n\n/**\n * Check if specific scout type is supported by dataTransfer, if event is not handled by this field (desktop might handle it)\n *\n * @param event including event.originalEvent.dataTransfer\n * @param fieldAllowedTypes allowed types on field (integer, bitwise comparison used)\n * @param scoutTypeArray e.g. FILE_TRANSFER\n */\nexport function verifyDataTransferTypesScoutTypes(event, scoutTypeArray, fieldAllowedTypes) {\n  scoutTypeArray = arrays.ensure(scoutTypeArray);\n  let dragTypeArray = [];\n\n  // check if any scout type is allowed for field allowed types (or no field allowed types defined)\n  if (fieldAllowedTypes !== undefined) {\n    scoutTypeArray.forEach(scoutType => {\n      if ((fieldAllowedTypes & scoutType) === scoutType) {\n        // NOSONAR\n        arrays.pushAll(dragTypeArray, scoutTypeToDragTypeMapping(scoutTypeArray));\n      }\n    });\n  } else {\n    dragTypeArray = scoutTypeToDragTypeMapping(scoutTypeArray);\n  }\n  if (Array.isArray(dragTypeArray) && dragTypeArray.length > 0) {\n    verifyDataTransferTypes(event, dragTypeArray);\n  }\n}\n\n/**\n * Check if specific type is supported by dataTransfer, if event is not handled by this field (upstream field might handle it, at the latest desktop)\n *\n * @param dataTransfer dataTransfer object (not dataTransfer.types)\n * @param needleArray e.g. 'Files'\n */\nexport function verifyDataTransferTypes(event, needleArray) {\n  let dataTransfer = event.originalEvent.dataTransfer;\n  if (dataTransferTypesContains(dataTransfer, needleArray)) {\n    event.stopPropagation();\n    event.preventDefault();\n    return true;\n  }\n  return false;\n}\n\n/**\n * dataTransfer.types might be an array (Chrome, IE) or a DOMStringList.\n *\n * Unfortunately there is no intersecting contains method for both types.\n *\n * @param dataTransfer dataTransfer object (not dataTransfer.types)\n * @param scoutTypesArray e.g. FILE_TRANSFER\n */\nexport function dataTransferTypesContainsScoutTypes(dataTransfer, scoutTypesArray) {\n  scoutTypesArray = arrays.ensure(scoutTypesArray);\n  let dragTypesArray = scoutTypeToDragTypeMapping(scoutTypesArray);\n  return dataTransferTypesContains(dataTransfer, dragTypesArray);\n}\n\n/**\n * dataTransfer.types might be an array (Chrome, IE) or a DOMStringList.\n *\n * Unfortunately there is no intersecting contains method for both types.\n *\n * @param dataTransfer dataTransfer object (not dataTransfer.types)\n * @param needleArray e.g. 'Files'\n */\nexport function dataTransferTypesContains(dataTransfer, needleArray) {\n  needleArray = arrays.ensure(needleArray);\n  if (dataTransfer && dataTransfer.types) {\n    if (Array.isArray(dataTransfer.types) && arrays.containsAny(dataTransfer.types, needleArray)) {\n      // Array: indexOf function\n      return true;\n    } else if (dataTransfer.types.contains) {\n      // DOMStringList: contains function\n      return needleArray.some(element => {\n        return dataTransfer.types.contains(element);\n      });\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {DragAndDropOptions} options\n * @return {null|DragAndDropHandler}\n */\nexport function handler(options) {\n  if (!options || !options.target) {\n    return null;\n  }\n  return new DragAndDropHandler(options);\n}\n\n/**\n * installs or uninstalls a {@link DragAndDropHandler} on the target.\n *\n * @param {DragAndDropOptions} options\n */\nexport function installOrUninstallDragAndDropHandler(options) {\n  if (!options.target) {\n    return;\n  }\n  options = $.extend({}, _createDragAndDropHandlerOptions(options.target), options);\n  if (options.doInstall()) {\n    _installDragAndDropHandler(options);\n  } else {\n    uninstallDragAndDropHandler(options.target);\n  }\n}\n\n/**\n *\n * @param {DragAndDropOptions} options\n * @private\n */\nexport function _installDragAndDropHandler(options) {\n  if (options.target.dragAndDropHandler) {\n    return;\n  }\n  options.target.dragAndDropHandler = handler(options);\n  if (!options.target.dragAndDropHandler) {\n    return;\n  }\n  let $container = options.container();\n  if (!$container) {\n    return;\n  }\n  options.target.dragAndDropHandler.install($container, options.selector);\n}\n\n/**\n *\n * @param {DragAndDropTarget} target\n * @private\n */\nexport function _createDragAndDropHandlerOptions(target) {\n  return {\n    target: target,\n    supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n    validateFiles: (files, defaultValidator) => defaultValidator(files),\n    onDrop: files => {},\n    dropType: () => dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n    dropMaximumSize: () => target.dropMaximumSize,\n    doInstall: () => target.enabledComputed,\n    container: () => target.$container,\n    additionalDropProperties: event => {}\n  };\n}\n\n/**\n * uninstalls a {@link DragAndDropHandler} from the target. If no handler is installed, this function does nothing.\n * @param {DragAndDropTarget} target the target widget.\n */\nexport function uninstallDragAndDropHandler(target) {\n  if (!target || !target.dragAndDropHandler) {\n    return;\n  }\n  target.dragAndDropHandler.uninstall();\n  target.dragAndDropHandler = null;\n}\nexport default {\n  DEFAULT_DROP_MAXIMUM_SIZE,\n  SCOUT_TYPES,\n  dataTransferTypesContains,\n  dataTransferTypesContainsScoutTypes,\n  handler,\n  installOrUninstallDragAndDropHandler,\n  scoutTypeToDragTypeMapping,\n  uninstallDragAndDropHandler,\n  verifyDataTransferTypes,\n  verifyDataTransferTypesScoutTypes\n};\n\n// ----------------- TYPEDEF -----------------\n\n/**\n * @typedef {Widget} DragAndDropTarget\n * @property {number} [dropMaximumSize] default drop maximum size used in {@link DragAndDropOptions.dropMaximumSize}. If the target object contains a different field or function to retrieve this value override the supplier.\n * @property {boolean} [enabledComputed]  default install/uninstall criteria used in {@link DragAndDropOptions.doInstall}. If the target object contains a different field or function to retrieve this value override the supplier.\n * @property {$} [$container] default container used in {@link DragAndDropOptions.container}. If the target object contains a different field or function to retrieve this value override the supplier.\n * @property {DragAndDropHandler} [dragAndDropHandler] installed drag & drop handler. Will be managed through {@link DragAndDropHandler}\n */\n\n/**\n * @callback validateFiles\n * @param {File[]} files\n * @param {DragAndDropHandler._validateFiles} defaultValidator\n * @throws {dropValidationErrorMessage} validationErrorMessage\n */\n\n/**\n * @callback onDrop\n * @param {File[]} files\n */\n\n/**\n * @callback additionalDropProperties\n * @param {Event} event\n * @returns {Object}\n */\n\n/**\n * @callback doInstall\n * @returns {boolean}\n */\n\n/**\n * @callback container\n * @returns {$}\n */\n\n/**\n * @callback dropType\n * @returns {dragAndDrop.SCOUT_TYPES.FILE_TRANSFER | number}\n */\n\n/**\n * @callback dropMaximumSize\n * @returns {number}\n */\n\n/**\n * @typedef {Object} DragAndDropOptions\n * @property {DragAndDropTarget} target the target object where the handler shall be installed.\n * @property {onDrop} onDrop Will be called when a valid element has been dropped.\n * @property {doInstall} [doInstall] Determines if the drag & drop handler should be installed or uninstalled. Default implementation is checking {@link DragAndDropTarget.enabledComputed}\n * @property {container} [container] Returns the dom container providing the necessary drag & drop events. Default is {@link DragAndDropTarget.$container}\n * @property {SCOUT_TYPES} [supportedScoutTypes] The scout type which will be allowed to drop into the target. Default is {@link dragAndDrop.SCOUT_TYPES.FILE_TRANSFER}\n * @property {String} [selector] CSS selector which will be added to the event source.\n * @property {dropType} [dropType] Returns the allowed drop type during a drop event. Default is {@link dragAndDrop.SCOUT_TYPES.FILE_TRANSFER}\n * @property {dropMaximumSize} [dropMaximumSize] Returns the maximum allowed size of a dropped object. Default is {@link DragAndDropTarget.dropMaximumSize}\n * @property {validateFiles} [validateFiles] An optional function to add a custom file validation logic. Throw a {@link dropValidationErrorMessage} to indicate a failed validation.\n *           If no custom validator is installed, the default maximum file size validator is invoked.\n * @property {additionalDropProperties} [additionalDropProperties] Returns additional drop properties to be used in {@link DragAndDropHandler.uploadFiles} as uploadProperties\n */","map":{"version":3,"names":["arrays","dragAndDrop","DragAndDropHandler","SCOUT_TYPES","FILE_TRANSFER","JAVA_ELEMENT_TRANSFER","TEXT_TRANSFER","IMAGE_TRANSFER","DEFAULT_DROP_MAXIMUM_SIZE","scoutTypeToDragTypeMapping","scoutTypesArray","ensure","ret","indexOf","push","verifyDataTransferTypesScoutTypes","event","scoutTypeArray","fieldAllowedTypes","dragTypeArray","undefined","forEach","scoutType","pushAll","Array","isArray","length","verifyDataTransferTypes","needleArray","dataTransfer","originalEvent","dataTransferTypesContains","stopPropagation","preventDefault","dataTransferTypesContainsScoutTypes","dragTypesArray","types","containsAny","contains","some","element","handler","options","target","installOrUninstallDragAndDropHandler","$","extend","_createDragAndDropHandlerOptions","doInstall","_installDragAndDropHandler","uninstallDragAndDropHandler","dragAndDropHandler","$container","container","install","selector","supportedScoutTypes","validateFiles","files","defaultValidator","onDrop","dropType","dropMaximumSize","enabledComputed","additionalDropProperties","uninstall"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/dragAndDrop.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, dragAndDrop, DragAndDropHandler} from '../index';\n\nconst SCOUT_TYPES = {\n  FILE_TRANSFER: 1 << 0, // IDNDSupport.TYPE_FILE_TRANSFER (NOSONAR)\n  JAVA_ELEMENT_TRANSFER: 1 << 1, // IDNDSupport.TYPE_JAVA_ELEMENT_TRANSFER (NOSONAR)\n  TEXT_TRANSFER: 1 << 2, // IDNDSupport.TYPE_TEXT_TRANSFER (NOSONAR)\n  IMAGE_TRANSFER: 1 << 3 // IDNDSupport.TYPE_IMAGE_TRANSFER (NOSONAR)\n};\n\nconst DEFAULT_DROP_MAXIMUM_SIZE = 50 * 1024 * 1024; // 50 MB\n\n/**\n * Mapping function from scout drag types to browser drag types.\n *\n * @param scoutTypesArray array of SCOUT_TYPES\n * @returns {Array} return array\n */\nexport function scoutTypeToDragTypeMapping(scoutTypesArray) {\n  scoutTypesArray = arrays.ensure(scoutTypesArray);\n  let ret = [];\n  if (scoutTypesArray.indexOf(SCOUT_TYPES.FILE_TRANSFER) >= 0) {\n    ret.push('Files');\n  }\n  return ret;\n}\n\n/**\n * Check if specific scout type is supported by dataTransfer, if event is not handled by this field (desktop might handle it)\n *\n * @param event including event.originalEvent.dataTransfer\n * @param fieldAllowedTypes allowed types on field (integer, bitwise comparison used)\n * @param scoutTypeArray e.g. FILE_TRANSFER\n */\nexport function verifyDataTransferTypesScoutTypes(event, scoutTypeArray, fieldAllowedTypes) {\n  scoutTypeArray = arrays.ensure(scoutTypeArray);\n  let dragTypeArray = [];\n\n  // check if any scout type is allowed for field allowed types (or no field allowed types defined)\n  if (fieldAllowedTypes !== undefined) {\n    scoutTypeArray.forEach(scoutType => {\n      if ((fieldAllowedTypes & scoutType) === scoutType) { // NOSONAR\n        arrays.pushAll(dragTypeArray, scoutTypeToDragTypeMapping(scoutTypeArray));\n      }\n    });\n  } else {\n    dragTypeArray = scoutTypeToDragTypeMapping(scoutTypeArray);\n  }\n\n  if (Array.isArray(dragTypeArray) && dragTypeArray.length > 0) {\n    verifyDataTransferTypes(event, dragTypeArray);\n  }\n}\n\n/**\n * Check if specific type is supported by dataTransfer, if event is not handled by this field (upstream field might handle it, at the latest desktop)\n *\n * @param dataTransfer dataTransfer object (not dataTransfer.types)\n * @param needleArray e.g. 'Files'\n */\nexport function verifyDataTransferTypes(event, needleArray) {\n  let dataTransfer = event.originalEvent.dataTransfer;\n\n  if (dataTransferTypesContains(dataTransfer, needleArray)) {\n    event.stopPropagation();\n    event.preventDefault();\n    return true;\n  }\n  return false;\n}\n\n/**\n * dataTransfer.types might be an array (Chrome, IE) or a DOMStringList.\n *\n * Unfortunately there is no intersecting contains method for both types.\n *\n * @param dataTransfer dataTransfer object (not dataTransfer.types)\n * @param scoutTypesArray e.g. FILE_TRANSFER\n */\nexport function dataTransferTypesContainsScoutTypes(dataTransfer, scoutTypesArray) {\n  scoutTypesArray = arrays.ensure(scoutTypesArray);\n  let dragTypesArray = scoutTypeToDragTypeMapping(scoutTypesArray);\n  return dataTransferTypesContains(dataTransfer, dragTypesArray);\n}\n\n/**\n * dataTransfer.types might be an array (Chrome, IE) or a DOMStringList.\n *\n * Unfortunately there is no intersecting contains method for both types.\n *\n * @param dataTransfer dataTransfer object (not dataTransfer.types)\n * @param needleArray e.g. 'Files'\n */\nexport function dataTransferTypesContains(dataTransfer, needleArray) {\n  needleArray = arrays.ensure(needleArray);\n  if (dataTransfer && dataTransfer.types) {\n    if (Array.isArray(dataTransfer.types) && arrays.containsAny(dataTransfer.types, needleArray)) {\n      // Array: indexOf function\n      return true;\n    } else if (dataTransfer.types.contains) {\n      // DOMStringList: contains function\n      return needleArray.some(element => {\n        return dataTransfer.types.contains(element);\n      });\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {DragAndDropOptions} options\n * @return {null|DragAndDropHandler}\n */\nexport function handler(options) {\n  if (!options || !options.target) {\n    return null;\n  }\n  return new DragAndDropHandler(options);\n}\n\n/**\n * installs or uninstalls a {@link DragAndDropHandler} on the target.\n *\n * @param {DragAndDropOptions} options\n */\nexport function installOrUninstallDragAndDropHandler(options) {\n  if (!options.target) {\n    return;\n  }\n  options = $.extend({}, _createDragAndDropHandlerOptions(options.target), options);\n  if (options.doInstall()) {\n    _installDragAndDropHandler(options);\n  } else {\n    uninstallDragAndDropHandler(options.target);\n  }\n}\n\n/**\n *\n * @param {DragAndDropOptions} options\n * @private\n */\nexport function _installDragAndDropHandler(options) {\n  if (options.target.dragAndDropHandler) {\n    return;\n  }\n  options.target.dragAndDropHandler = handler(options);\n  if (!options.target.dragAndDropHandler) {\n    return;\n  }\n  let $container = options.container();\n  if (!$container) {\n    return;\n  }\n  options.target.dragAndDropHandler.install($container, options.selector);\n}\n\n/**\n *\n * @param {DragAndDropTarget} target\n * @private\n */\nexport function _createDragAndDropHandlerOptions(target) {\n  return {\n    target: target,\n    supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n    validateFiles: (files, defaultValidator) => defaultValidator(files),\n    onDrop: files => {\n    },\n    dropType: () => dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n    dropMaximumSize: () => target.dropMaximumSize,\n    doInstall: () => target.enabledComputed,\n    container: () => target.$container,\n    additionalDropProperties: event => {\n    }\n  };\n}\n\n/**\n * uninstalls a {@link DragAndDropHandler} from the target. If no handler is installed, this function does nothing.\n * @param {DragAndDropTarget} target the target widget.\n */\nexport function uninstallDragAndDropHandler(target) {\n  if (!target || !target.dragAndDropHandler) {\n    return;\n  }\n  target.dragAndDropHandler.uninstall();\n  target.dragAndDropHandler = null;\n}\n\nexport default {\n  DEFAULT_DROP_MAXIMUM_SIZE,\n  SCOUT_TYPES,\n  dataTransferTypesContains,\n  dataTransferTypesContainsScoutTypes,\n  handler,\n  installOrUninstallDragAndDropHandler,\n  scoutTypeToDragTypeMapping,\n  uninstallDragAndDropHandler,\n  verifyDataTransferTypes,\n  verifyDataTransferTypesScoutTypes\n};\n\n// ----------------- TYPEDEF -----------------\n\n/**\n * @typedef {Widget} DragAndDropTarget\n * @property {number} [dropMaximumSize] default drop maximum size used in {@link DragAndDropOptions.dropMaximumSize}. If the target object contains a different field or function to retrieve this value override the supplier.\n * @property {boolean} [enabledComputed]  default install/uninstall criteria used in {@link DragAndDropOptions.doInstall}. If the target object contains a different field or function to retrieve this value override the supplier.\n * @property {$} [$container] default container used in {@link DragAndDropOptions.container}. If the target object contains a different field or function to retrieve this value override the supplier.\n * @property {DragAndDropHandler} [dragAndDropHandler] installed drag & drop handler. Will be managed through {@link DragAndDropHandler}\n */\n\n/**\n * @callback validateFiles\n * @param {File[]} files\n * @param {DragAndDropHandler._validateFiles} defaultValidator\n * @throws {dropValidationErrorMessage} validationErrorMessage\n */\n\n/**\n * @callback onDrop\n * @param {File[]} files\n */\n\n/**\n * @callback additionalDropProperties\n * @param {Event} event\n * @returns {Object}\n */\n\n/**\n * @callback doInstall\n * @returns {boolean}\n */\n\n/**\n * @callback container\n * @returns {$}\n */\n\n/**\n * @callback dropType\n * @returns {dragAndDrop.SCOUT_TYPES.FILE_TRANSFER | number}\n */\n\n/**\n * @callback dropMaximumSize\n * @returns {number}\n */\n\n/**\n * @typedef {Object} DragAndDropOptions\n * @property {DragAndDropTarget} target the target object where the handler shall be installed.\n * @property {onDrop} onDrop Will be called when a valid element has been dropped.\n * @property {doInstall} [doInstall] Determines if the drag & drop handler should be installed or uninstalled. Default implementation is checking {@link DragAndDropTarget.enabledComputed}\n * @property {container} [container] Returns the dom container providing the necessary drag & drop events. Default is {@link DragAndDropTarget.$container}\n * @property {SCOUT_TYPES} [supportedScoutTypes] The scout type which will be allowed to drop into the target. Default is {@link dragAndDrop.SCOUT_TYPES.FILE_TRANSFER}\n * @property {String} [selector] CSS selector which will be added to the event source.\n * @property {dropType} [dropType] Returns the allowed drop type during a drop event. Default is {@link dragAndDrop.SCOUT_TYPES.FILE_TRANSFER}\n * @property {dropMaximumSize} [dropMaximumSize] Returns the maximum allowed size of a dropped object. Default is {@link DragAndDropTarget.dropMaximumSize}\n * @property {validateFiles} [validateFiles] An optional function to add a custom file validation logic. Throw a {@link dropValidationErrorMessage} to indicate a failed validation.\n *           If no custom validator is installed, the default maximum file size validator is invoked.\n * @property {additionalDropProperties} [additionalDropProperties] Returns additional drop properties to be used in {@link DragAndDropHandler.uploadFiles} as uploadProperties\n */\n"],"mappings":"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ML,MAAM,CAACoB,eAAe;IACvCV,SAAS,EAAE,MAAMV,MAAM,CAACS,UAAU;IAClCY,wBAAwB,EAAEhD,KAAK,IAAI,CACnC;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASkC,2BAA2B,CAACP,MAAM,EAAE;EAClD,IAAI,CAACA,MAAM,IAAI,CAACA,MAAM,CAACQ,kBAAkB,EAAE;IACzC;EACF;EACAR,MAAM,CAACQ,kBAAkB,CAACc,SAAS,EAAE;EACrCtB,MAAM,CAACQ,kBAAkB,GAAG,IAAI;AAClC;AAEA,eAAe;EACb3C,yBAAyB;EACzBL,WAAW;EACX4B,yBAAyB;EACzBG,mCAAmC;EACnCO,OAAO;EACPG,oCAAoC;EACpCnC,0BAA0B;EAC1ByC,2BAA2B;EAC3BvB,uBAAuB;EACvBZ;AACF,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}