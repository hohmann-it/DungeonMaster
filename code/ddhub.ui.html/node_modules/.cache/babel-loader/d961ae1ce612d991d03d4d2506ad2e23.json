{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AjaxCall, App, arrays, BackgroundJobPollingStatus, BackgroundJobPollingSupport, Device, EventSupport, FileInput, files as fileUtil, FocusManager, fonts, icons, LayoutValidator, Locale, logging, MessageBox, ModelAdapter, NullWidget, ObjectFactory, objects, Reconnector, RemoteEvent, ResponseQueue, scout, Status, strings, TextMap, texts, TypeDescriptor, URL, UserAgent, webstorage } from '../index';\nimport $ from 'jquery';\nexport default class Session {\n  constructor() {\n    this.$entryPoint = null;\n    this.partId = 0;\n    this.url = new URL();\n    this.userAgent = new UserAgent({\n      deviceType: Device.get().type,\n      touch: Device.get().supportsOnlyTouch(),\n      standalone: Device.get().isStandalone()\n    });\n    this.locale = new Locale(); // Ensure there is always a locale even if not passed and startup request fails\n    this.textMap = new TextMap();\n    this.ready = false; // true after desktop has been completely rendered\n    this.unloading = false; // true when 'beforeOnload' event has been triggered\n    this.unloaded = false; // true after unload event has been received from the window\n    this.loggedOut = false;\n    this.inspector = false;\n    this.persistent = false;\n    this.inDevelopmentMode = false;\n    this.desktop = null;\n    this.layoutValidator = new LayoutValidator();\n    this.focusManager = null;\n    this.keyStrokeManager = null;\n    this.uiSessionId = null; // assigned by server on session startup (OWASP recommendation, see https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern).\n    this.clientSessionId = this._getClientSessionIdFromStorage();\n    this.forceNewClientSession = false;\n    this.remoteUrl = 'json';\n    this.unloadUrl = 'unload';\n    this.modelAdapterRegistry = {};\n    this.ajaxCalls = [];\n    this.asyncEvents = [];\n    this.responseQueue = new ResponseQueue(this);\n    this.requestsPendingCounter = 0;\n    this.suppressErrors = false;\n    this.requestTimeoutCancel = 5000; // ms\n    this.requestTimeoutPoll = 75000; // ms, depends on polling interval, will therefore be initialized on startup\n    this.requestTimeoutPing = 5000; // ms\n    this.backgroundJobPollingSupport = new BackgroundJobPollingSupport(true);\n    this.reconnector = new Reconnector(this);\n    this.processingEvents = false;\n\n    // This property is enabled by URL parameter &adapterExportEnabled=1. Default is false\n    this.adapterExportEnabled = false;\n    this._adapterDataCache = {};\n    this._busy = false;\n    this._busyIndicator = null;\n    this._busyIndicatorTimeoutId = null;\n    this._deferred = null;\n    this._fatalMessagesOnScreen = {};\n    this._retryRequest = null;\n    this._queuedRequest = null;\n    this.requestSequenceNo = 0;\n    this.rootAdapter = new ModelAdapter();\n    this.rootAdapter.init({\n      session: this,\n      id: '1',\n      objectType: 'RootAdapter'\n    });\n    let rootParent = new NullWidget();\n    rootParent.session = this;\n    rootParent.initialized = true;\n    this.root = this.rootAdapter.createWidget({\n      session: this,\n      id: '1',\n      objectType: 'NullWidget'\n    }, rootParent);\n    this.events = this._createEventSupport();\n  }\n\n  // Corresponds to constants in JsonResponse\n\n  /**\n   * @param {$} model.$entryPoint\n   *     The HTML element that is used by the {@link Desktop} to render its content.\n   * @param {string} [model.portletPartId]\n   *     Necessary when multiple UI sessions are managed by the same window (portlet support).\n   *     Each session's partId must be unique. Default is 0.\n   * @param {string} [model.clientSessionId]\n   *     Identifies the 'client instance' on the UI server. If the property is not set\n   *     (which is the default case), the clientSessionId is taken from the browser's\n   *     session storage (per browser window, survives F5 refresh of page). If no\n   *     clientSessionId can be found, a new one is generated on the server.\n   * @param {boolean} [model.forceNewClientSession]\n   *     If set to true, the stored or passed clientSessionId will be ignored\n   *     and a new one generated by the server.\n   * @param {UserAgent} [model.userAgent]\n   *     By default the user agent for the running platform is used. Use this option if you want to set a custom one.\n   * @param {Locale|object} [model.locale]\n   *     If not specified, {@link Locale.DEFAULT} is used.\n   * @param {boolean} [model.backgroundJobPollingEnabled]\n   *     Unless websockets is used, this property turns on (default) or off background\n   *     polling using an async ajax call together with setTimeout()\n   * @param {boolean} [model.suppressErrors]\n   *     Basically added because of Jasmine-tests. When working with async tests that\n   *     use setTimeout(), sometimes the Jasmine-Maven plug-in fails and aborts the\n   *     build because there were console errors. These errors always happen in this\n   *     class. That's why we can skip suppress error handling with this flag.\n   * @param {boolean} [model.focusManagerActive]\n   *     Forces the focus manager to be active or not. If undefined, the value is\n   *     auto detected by Device.js.\n   * @param {object} [model.reconnectorOptions]\n   *     Properties of this object are copied to the Session's reconnector\n   *     instance (see {@link Reconnector}).\n   * @param {object} [model.ajaxCallOptions]\n   *     Properties of this object are copied to all instances of {@link AjaxCall}.\n   */\n  init(model) {\n    let options = model || {};\n    if (!options.$entryPoint) {\n      throw new Error('$entryPoint is not defined');\n    }\n    this.$entryPoint = options.$entryPoint;\n    this.partId = scout.nvl(options.portletPartId, this.partId);\n    this.forceNewClientSession = scout.nvl(this.url.getParameter('forceNewClientSession'), options.forceNewClientSession);\n    if (this.forceNewClientSession) {\n      this.clientSessionId = null;\n    } else {\n      this.clientSessionId = scout.nvl(options.clientSessionId, this.clientSessionId);\n    }\n    this.userAgent = scout.nvl(options.userAgent, this.userAgent);\n    this.suppressErrors = scout.nvl(options.suppressErrors, this.suppressErrors);\n    if (options.locale) {\n      this.locale = Locale.ensure(options.locale);\n      this.textMap = texts.get(this.locale.languageTag);\n    }\n    if (options.backgroundJobPollingEnabled === false) {\n      this.backgroundJobPollingSupport.enabled = false;\n    }\n    $.extend(this.reconnector, options.reconnectorOptions);\n    this.ajaxCallOptions = options.ajaxCallOptions;\n\n    // Set inspector flag by looking at URL params. This is required when running in offline mode.\n    // In online mode, the server may override this flag again, see _processStartupResponse().\n    if (this.url.getParameter('debug') === 'true' || this.url.getParameter('inspector') === 'true') {\n      this.inspector = true;\n    }\n    if (this.url.getParameter('adapterExportEnabled') === 'true') {\n      this.adapterExportEnabled = true;\n    }\n\n    // Install focus management for this session (cannot be created in constructor, because this.$entryPoint is required)\n    this.focusManager = new FocusManager({\n      session: this,\n      active: options.focusManagerActive\n    });\n    this.keyStrokeManager = scout.create('KeyStrokeManager', {\n      session: this\n    });\n  }\n  _throwError(message) {\n    if (!this.suppressErrors) {\n      throw new Error(message);\n    }\n  }\n  unregisterModelAdapter(modelAdapter) {\n    delete this.modelAdapterRegistry[modelAdapter.id];\n  }\n  registerModelAdapter(modelAdapter) {\n    if (modelAdapter.id === undefined) {\n      throw new Error('modelAdapter.id must be defined');\n    }\n    this.modelAdapterRegistry[modelAdapter.id] = modelAdapter;\n  }\n  getModelAdapter(id) {\n    return this.modelAdapterRegistry[id];\n  }\n  getWidget(adapterId) {\n    if (!adapterId) {\n      return null;\n    }\n    if (typeof adapterId !== 'string') {\n      throw new Error('typeof adapterId must be string');\n    }\n    let adapter = this.getModelAdapter(adapterId);\n    if (!adapter) {\n      return null;\n    }\n    return adapter.widget;\n  }\n  getOrCreateWidget(adapterId, parent, strict) {\n    if (!adapterId) {\n      return null;\n    }\n    if (typeof adapterId !== 'string') {\n      throw new Error('typeof adapterId must be string');\n    }\n    let widget = this.getWidget(adapterId);\n    if (widget) {\n      return widget;\n    }\n    let adapterData = this._getAdapterData(adapterId);\n    if (!adapterData) {\n      if (scout.nvl(strict, true)) {\n        throw new Error('no adapterData found for adapterId=' + adapterId);\n      }\n      return null;\n    }\n    let adapter = this.createModelAdapter(adapterData);\n    return adapter.createWidget(adapterData, parent);\n  }\n  createModelAdapter(adapterData) {\n    let objectType = adapterData.objectType;\n    let createOpts = {};\n    let objectInfo = TypeDescriptor.parse(objectType);\n    if (objectInfo.modelVariant) {\n      objectType = objectInfo.objectType.toString() + 'Adapter' + ObjectFactory.MODEL_VARIANT_SEPARATOR + objectInfo.modelVariant.toString();\n      // If no adapter exists for the given variant then create an adapter without variant.\n      // Mostly variant is only essential for the widget, not the adapter\n      createOpts.variantLenient = true;\n    } else {\n      objectType = objectInfo.objectType.toString() + 'Adapter';\n    }\n\n    // TODO [7.0] bsh, cgu: Add classId/modelClass? Think about if IDs should be different for widgets (maybe prefix with 'w')\n    let adapterModel = {\n      id: adapterData.id,\n      session: this\n    };\n    let adapter = scout.create(objectType, adapterModel, createOpts);\n    $.log.isTraceEnabled() && $.log.trace('created new adapter ' + adapter);\n    return adapter;\n  }\n\n  /**\n   * Sends the request asynchronously and processes the response later.<br>\n   * Furthermore, the request is sent delayed. If send is called multiple times\n   * during the same user interaction, the events are collected and sent in one\n   * request at the end of the user interaction\n   */\n  sendEvent(event, delay) {\n    delay = delay || 0;\n    this.asyncEvents = this._coalesceEvents(this.asyncEvents, event);\n    this.asyncEvents.push(event);\n    // Use the specified delay, except another event is already scheduled. In that case, use the minimal delay.\n    // This ensures that an event with a long delay doesn't hold back another event with a short delay.\n    this._asyncDelay = Math.min(delay, scout.nvl(this._asyncDelay, delay));\n    clearTimeout(this._sendTimeoutId);\n    this._sendTimeoutId = setTimeout(() => {\n      this._sendTimeoutId = null;\n      this._asyncDelay = null;\n      if (this.areRequestsPending()) {\n        // do not send if there are any requests pending because the order matters -> prevents race conditions\n        return;\n      }\n      this._sendNow();\n    }, this._asyncDelay);\n  }\n  _sendStartupRequest() {\n    // Build startup request (see JavaDoc for JsonStartupRequest.java for details)\n    let request = this._newRequest({\n      startup: true\n    });\n    if (this.partId) {\n      request.partId = this.partId;\n    }\n    if (this.clientSessionId) {\n      request.clientSessionId = this.clientSessionId;\n    }\n    if (App.get().version) {\n      request.version = App.get().version;\n    }\n    request.userAgent = this.userAgent;\n    request.sessionStartupParams = this._createSessionStartupParams();\n\n    // Send request\n    let ajaxOptions = this.defaultAjaxOptions(request);\n    return $.ajax(ajaxOptions).catch(onAjaxFail.bind(this)).then(onAjaxDone.bind(this));\n\n    // ----- Helper methods -----\n\n    function onAjaxDone(data) {\n      this._processStartupResponse(data);\n      if (data.error) {\n        return $.rejectedPromise(data);\n      }\n    }\n    function onAjaxFail(jqXHR, textStatus, errorThrown) {\n      this._processErrorResponse(jqXHR, textStatus, errorThrown, request);\n      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n      return $.rejectedPromise(jqXHR, textStatus, errorThrown, ...args);\n    }\n  }\n\n  /**\n   * Creates an object to send to the server as \"startupParams\".\n   *\n   * Default params:\n   * \"url\":\n   *   browser URL (without query and hash part)\n   * \"geolocationServiceAvailable\":\n   *   true if browser supports geo location services\n   *\n   * Additionally, all query parameters from the URL are put in the resulting object.\n   */\n  _createSessionStartupParams() {\n    let params = {\n      url: this.url.baseUrlRaw,\n      geolocationServiceAvailable: Device.get().supportsGeolocation()\n    };\n\n    // Extract query parameters from URL and put them in the resulting object\n    let urlParameterMap = this.url.parameterMap;\n    for (let prop in urlParameterMap) {\n      params[prop] = urlParameterMap[prop];\n    }\n    return params;\n  }\n\n  /**\n   * @param {[]} data.adapterData\n   * @param {[]} data.events\n   * @param data.startupData\n   * @param data.startupData.clientSession\n   * @param data.startupData.clientSessionId\n   * @param data.startupData.pollingInterval\n   * @param data.startupData.persistent\n   * @param data.startupData.inDevelopmentMode\n   * @param data.error\n   * @param data.sessionTerminated\n   */\n  _processStartupResponse(data) {\n    // Handle errors from server\n    if (data.error) {\n      this._processErrorJsonResponse(data.error);\n      return;\n    }\n    webstorage.removeItemFromSessionStorage('scout:versionMismatch');\n    if (!data.startupData) {\n      throw new Error('Missing startupData');\n    }\n\n    // Mark session as persistent (means a persistent session cookie is used and the client session will be restored after a browser restart)\n    this.persistent = data.startupData.persistent;\n\n    // true if the UiServer runs in development mode (see Platform.get().inDevelopmentMode())\n    this.inDevelopmentMode = !!data.startupData.inDevelopmentMode; // may be undefined\n\n    // Store clientSessionId in sessionStorage (to send the same ID again on page reload)\n    this.clientSessionId = data.startupData.clientSessionId;\n    this._storeClientSessionIdInStorage(this.clientSessionId);\n\n    // Assign server generated uiSessionId. It must be sent along with all further requests.\n    this.uiSessionId = data.startupData.uiSessionId;\n\n    // Destroy UI session on server when page is closed or reloaded\n    $(window).on('beforeunload.' + this.uiSessionId, this._onWindowBeforeUnload.bind(this)).on('unload.' + this.uiSessionId, this._onWindowUnload.bind(this));\n\n    // Special case: Page must be reloaded on startup (e.g. theme changed)\n    if (data.startupData.reloadPage) {\n      scout.reloadPage();\n      return;\n    }\n\n    // Enable inspector mode if server requests it (e.g. when server is running in development mode)\n    if (data.startupData.inspector) {\n      this.inspector = true;\n    }\n\n    // Init request timeout for poller\n    this.requestTimeoutPoll = (data.startupData.pollingInterval + 15) * 1000;\n\n    // Register UI session\n    this.modelAdapterRegistry[this.uiSessionId] = this; // TODO [7.0] cgu: maybe better separate session object from event processing, create ClientSession.js?. If yes, desktop should not have rootadapter as parent, see 406\n\n    // Store adapters to adapter data cache\n    if (data.adapterData) {\n      this._copyAdapterData(data.adapterData);\n    }\n    this.locale = new Locale(data.startupData.locale);\n    this.textMap = texts.get(this.locale.languageTag);\n    this.textMap.addAll(data.startupData.textMap);\n\n    // Create the desktop\n    // Extract client session data without creating a model adapter for it. It is (currently) only used to transport the desktop's adapterId.\n    let clientSessionData = this._getAdapterData(data.startupData.clientSession);\n    this.desktop = this.getOrCreateWidget(clientSessionData.desktop, this.rootAdapter.widget);\n    App.get()._triggerDesktopReady(this.desktop);\n    let renderDesktopImpl = function () {\n      this._renderDesktop();\n\n      // In case the server sent additional events, process them\n      if (data.events) {\n        this.processingEvents = true;\n        try {\n          this._processEvents(data.events);\n        } finally {\n          this.processingEvents = false;\n        }\n      }\n\n      // Ensure layout is valid (explicitly layout immediately and don't wait for setTimeout to run to make layouting invisible to the user)\n      this.layoutValidator.validate();\n      this.focusManager.validateFocus();\n\n      // Start poller\n      this._resumeBackgroundJobPolling();\n      this.ready = true;\n      App.get()._triggerSessionReady(this);\n      $.log.isInfoEnabled() && $.log.info('Session initialized. Detected ' + Device.get());\n      if ($.log.isDebugEnabled()) {\n        $.log.isDebugEnabled() && $.log.debug('size of _adapterDataCache after session has been initialized: ' + objects.countOwnProperties(this._adapterDataCache));\n        $.log.isDebugEnabled() && $.log.debug('size of modelAdapterRegistry after session has been initialized: ' + objects.countOwnProperties(this.modelAdapterRegistry));\n      }\n    }.bind(this);\n    this.render(renderDesktopImpl);\n  }\n  _storeClientSessionIdInStorage(clientSessionId) {\n    let key = 'scout:clientSessionId';\n    webstorage.removeItemFromSessionStorage(key);\n    webstorage.removeItemFromLocalStorage(key);\n    if (this.persistent) {\n      webstorage.setItemToLocalStorage(key, clientSessionId);\n    } else {\n      webstorage.setItemToSessionStorage(key, clientSessionId);\n    }\n  }\n  _getClientSessionIdFromStorage() {\n    let key = 'scout:clientSessionId';\n    let id = webstorage.getItemFromSessionStorage(key);\n    if (!id) {\n      // If the session is persistent it was stored in the local storage (cannot check for this.persistent here because it is not known yet)\n      id = webstorage.getItemFromLocalStorage(key);\n    }\n    return id;\n  }\n  render(renderFunc) {\n    // Render desktop after fonts have been preloaded (this fixes initial layouting issues when font icons are not yet ready)\n    if (fonts.loadingComplete) {\n      renderFunc();\n    } else {\n      fonts.preloader().then(renderFunc);\n    }\n  }\n  _sendUnloadRequest() {\n    let request = this._newRequest({\n      unload: true,\n      showBusyIndicator: false\n    });\n    // Send request\n    this._sendRequest(request);\n  }\n  _sendNow() {\n    if (this.asyncEvents.length === 0) {\n      // Nothing to send -> return\n      return;\n    }\n    // If an event requires a new request, only the previous events are sent now.\n    // The next requests are send the next time _sendNow is called (-> when the response to the current request arrives)\n    let events = [];\n    this.asyncEvents.some((event, i) => {\n      if (event.newRequest && events.length > 0) {\n        return true;\n      }\n      events.push(event);\n      return false;\n    });\n    let request = this._newRequest({\n      events: events\n    });\n    // Busy indicator required when at least one event requests it\n    request.showBusyIndicator = request.events.some(event => {\n      return scout.nvl(event.showBusyIndicator, true);\n    });\n    this.responseQueue.prepareRequest(request);\n    // Send request\n    this._sendRequest(request);\n    // Remove the events which are sent now from the list, keep the ones which are sent later\n    this.asyncEvents = this.asyncEvents.slice(events.length);\n  }\n  _coalesceEvents(previousEvents, event) {\n    if (!event.coalesce) {\n      return previousEvents;\n    }\n    let filter = $.negate(event.coalesce).bind(event);\n    return previousEvents.filter(filter);\n  }\n  _sendRequest(request) {\n    if (!request) {\n      return; // nothing to send\n    }\n\n    if (this.loggedOut) {\n      // Don't send any JSON requests when we are logged out. They would fail since the UI session\n      // no longer exists. This could happen when views are open and the client session is stopped.\n      // Destroying the form adapters makes the Desktop send an \"activeForm = null\" event.\n      return;\n    }\n    if (this.offline && !request.unload) {\n      // In Firefox, \"offline\" is already true when page is unloaded\n      this._handleSendWhenOffline(request);\n      return;\n    }\n    if (request.unload && navigator.sendBeacon) {\n      // The unload request must _not_ be sent asynchronously, because the browser would cancel\n      // it when the page unload is completed. Because the support for synchronous AJAX request\n      // will apparently be dropped eventually, we use the \"sendBeacon\" method to send the unload\n      // request to the server (we don't expect an answer). Not all browsers support this method,\n      // therefore we check for its existence and fall back to (legacy) synchronous AJAX call\n      // when it is missing. More information:\n      // - http://stackoverflow.com/questions/15479103/can-beforeunload-unload-be-used-to-send-xmlhttprequests-reliably\n      // - https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/7nKMdg_ALcc\n      // - https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon\n      navigator.sendBeacon(this.unloadUrl + '/' + this.uiSessionId, '');\n      return;\n    }\n    let ajaxOptions = this.defaultAjaxOptions(request);\n    let busyHandling = scout.nvl(request.showBusyIndicator, true);\n    if (request.unload) {\n      ajaxOptions.async = false;\n    }\n    this._performUserAjaxRequest(ajaxOptions, busyHandling, request);\n  }\n  _handleSendWhenOffline(request) {\n    // No need to queue the request when request does not contain events (e.g. log request, unload request)\n    if (!request.events) {\n      return;\n    }\n\n    // Merge request with queued event\n    if (this._queuedRequest) {\n      if (this._queuedRequest.events) {\n        // 1. Remove request events from queued events\n        request.events.forEach(event => {\n          this._queuedRequest.events = this._coalesceEvents(this._queuedRequest.events, event);\n        });\n        // 2. Add request events to end of queued events\n        this._queuedRequest.events = this._queuedRequest.events.concat(request.events);\n      } else {\n        this._queuedRequest.events = request.events;\n      }\n    } else {\n      this._queuedRequest = request;\n    }\n    this.layoutValidator.validate();\n  }\n  defaultAjaxOptions(request) {\n    request = request || this._newRequest();\n    let url = this._decorateUrl(this.remoteUrl, request);\n    let ajaxOptions = {\n      type: 'POST',\n      dataType: 'json',\n      contentType: 'application/json; charset=UTF-8',\n      cache: false,\n      url: url,\n      data: this._requestToJson(request)\n    };\n\n    // Ensure that certain request don't run forever. When a timeout occurs, the session\n    // is put into offline mode. Note that normal requests should NOT be limited, because\n    // the server processing might take very long (e.g. long running database query).\n    ajaxOptions.timeout = 0; // \"infinite\"\n    if (request.cancel) {\n      ajaxOptions.timeout = this.requestTimeoutCancel;\n    }\n    if (request.ping) {\n      ajaxOptions.timeout = this.requestTimeoutPing;\n    }\n    if (request.pollForBackgroundJobs) {\n      ajaxOptions.timeout = this.requestTimeoutPoll;\n    }\n    return ajaxOptions;\n  }\n  _decorateUrl(url, request) {\n    let urlHint = null;\n    // Add dummy URL parameter as marker (for debugging purposes)\n    if (request.unload) {\n      urlHint = 'unload';\n    } else if (request.pollForBackgroundJobs) {\n      urlHint = 'poll';\n    } else if (request.ping) {\n      urlHint = 'ping';\n    } else if (request.cancel) {\n      urlHint = 'cancel';\n    } else if (request.log) {\n      urlHint = 'log';\n    } else if (request.syncResponseQueue) {\n      urlHint = 'sync';\n    }\n    if (urlHint) {\n      url = new URL(url).addParameter(urlHint).toString();\n    }\n    return url;\n  }\n  _getRequestName(request, defaultName) {\n    if (request) {\n      if (request.unload) {\n        return 'unload';\n      } else if (request.pollForBackgroundJobs) {\n        return 'pollForBackgroundJobs';\n      } else if (request.ping) {\n        return 'ping';\n      } else if (request.cancel) {\n        return 'cancel';\n      } else if (request.log) {\n        return 'log';\n      } else if (request.syncResponseQueue) {\n        return 'syncResponseQueue';\n      }\n    }\n    return defaultName;\n  }\n  _requestToJson(request) {\n    return JSON.stringify(request, function (key, value) {\n      // Replacer function that filter certain properties from the resulting JSON string.\n      // See https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n      let ignore = this === request && key === 'showBusyIndicator' || this instanceof RemoteEvent && scout.isOneOf(key, 'showBusyIndicator', 'coalesce', 'newRequest');\n      return ignore ? undefined : value;\n    });\n  }\n  _callAjax(callOptions) {\n    let defaultOptions = {\n      retryIntervals: [100, 500, 500, 500]\n    };\n    let ajaxCall = scout.create('AjaxCall', $.extend(defaultOptions, callOptions, this.ajaxCallOptions), {\n      ensureUniqueId: false\n    });\n    this.registerAjaxCall(ajaxCall);\n    return ajaxCall.call().always(this.unregisterAjaxCall.bind(this, ajaxCall));\n  }\n  _performUserAjaxRequest(ajaxOptions, busyHandling, request) {\n    if (busyHandling) {\n      this.setBusy(true);\n    }\n    this.setRequestPending(true);\n    let jsError = null,\n      success = false;\n    this._callAjax({\n      ajaxOptions: ajaxOptions,\n      request: request,\n      name: this._getRequestName(request, 'user request')\n    }).done(onAjaxDone.bind(this)).fail(onAjaxFail.bind(this)).always(onAjaxAlways.bind(this));\n\n    // ----- Helper methods -----\n\n    function onAjaxDone(data) {\n      try {\n        // Busy handling is remove _before_ processing the response, otherwise the focus cannot be set\n        // correctly, because the glasspane of the busy indicator is still visible.\n        // The second check prevents flickering of the busy indicator if there is a scheduled request\n        // that will be sent immediately afterwards (see onAjaxAlways).\n        if (busyHandling && !this.areBusyIndicatedEventsQueued()) {\n          this.setBusy(false);\n        }\n        success = this.responseQueue.process(data);\n      } catch (err) {\n        jsError = jsError || err;\n      }\n    }\n    function onAjaxFail(ajaxError) {\n      try {\n        if (busyHandling) {\n          this.setBusy(false);\n        }\n        this._processErrorResponse(ajaxError.jqXHR, ajaxError.textStatus, ajaxError.errorThrown, request);\n      } catch (err) {\n        jsError = jsError || err;\n      }\n    }\n\n    // Variable arguments:\n    // \"done\" --> data, textStatus, jqXHR\n    // \"fail\" --> jqXHR, textStatus, errorThrown\n    function onAjaxAlways(data, textStatus, errorThrown) {\n      this.setRequestPending(false);\n\n      // \"success\" is false when either\n      // a) an HTTP error occurred or\n      // b) a JSON response with the error flag set (UI processing error) was returned\n      if (success) {\n        this._resumeBackgroundJobPolling();\n        this._fireRequestFinished(data);\n        if (this._retryRequest) {\n          // Send retry request first\n          let retryRequest = this._retryRequest;\n          this._retryRequest = null;\n          this.responseQueue.prepareRequest(retryRequest);\n          this._sendRequest(retryRequest);\n        } else if (this._queuedRequest) {\n          // Send events that happened while being offline\n          let queuedRequest = this._queuedRequest;\n          this._queuedRequest = null;\n          this.responseQueue.prepareRequest(queuedRequest);\n          this._sendRequest(queuedRequest);\n        }\n\n        // If there already is a another request pending, send it now\n        // But only if it should not be sent delayed\n        if (!this._sendTimeoutId) {\n          this._sendNow();\n        }\n      } else {\n        // Ensure busy is false when an error occurred an we won't be sending more requests.\n        // It could still be true when here were more busy indicated events in the queue when\n        // the error response was received (e.g. when selecting some table rows just when the\n        // server is restarted).\n        this.setBusy(false);\n      }\n      this.layoutValidator.validate();\n\n      // Throw previously caught error\n      if (jsError) {\n        throw jsError;\n      }\n    }\n  }\n  registerAjaxCall(ajaxCall) {\n    this.ajaxCalls.push(ajaxCall);\n  }\n  unregisterAjaxCall(ajaxCall) {\n    arrays.remove(this.ajaxCalls, ajaxCall);\n  }\n  interruptAllAjaxCalls() {\n    // Because the error handlers alter the \"this.ajaxCalls\" array,\n    // the loop must operate on a copy of the original array!\n    this.ajaxCalls.slice().forEach(ajaxCall => {\n      ajaxCall.pendingCall && ajaxCall.pendingCall.abort();\n    });\n  }\n  abortAllAjaxCalls() {\n    // Because the error handlers alter the \"this.ajaxCalls\" array,\n    // the loop must operate on a copy of the original array!\n    this.ajaxCalls.slice().forEach(ajaxCall => {\n      ajaxCall.abort();\n    });\n  }\n\n  /**\n   * (Re-)starts background job polling when not started yet or when an error occurred while polling.\n   * In the latter case, polling is resumed when a user-initiated request has been successful.\n   */\n  _resumeBackgroundJobPolling() {\n    if (this.backgroundJobPollingSupport.enabled && this.backgroundJobPollingSupport.status !== BackgroundJobPollingStatus.RUNNING) {\n      $.log.isInfoEnabled() && $.log.info('Resume background jobs polling request, status was=' + this.backgroundJobPollingSupport.status);\n      this._pollForBackgroundJobs();\n    }\n  }\n\n  /**\n   * Polls the results of jobs running in the background. Note: we cannot use the _sendRequest method here\n   * since we don't want any busy handling in case of background jobs. The request may take a while, since\n   * the server doesn't return until either a time-out occurs or there's something in the response when\n   * a model job is done and no request initiated by a user is running.\n   */\n  _pollForBackgroundJobs() {\n    this.backgroundJobPollingSupport.setRunning();\n    let request = this._newRequest({\n      pollForBackgroundJobs: true\n    });\n    this.responseQueue.prepareRequest(request);\n    let ajaxOptions = this.defaultAjaxOptions(request);\n    this._callAjax({\n      ajaxOptions: ajaxOptions,\n      request: request,\n      name: this._getRequestName(request, 'request')\n    }).done(onAjaxDone.bind(this)).fail(onAjaxFail.bind(this));\n\n    // --- Helper methods ---\n\n    function onAjaxDone(data) {\n      if (data.error) {\n        // Don't schedule a new polling request, when an error occurs\n        // when the next user-initiated request succeeds, we re-enable polling\n        // otherwise the polling would ping the server to death in case of an error\n        $.log.warn('Polling request failed. Interrupt polling until the next user-initiated request succeeds');\n        this.backgroundJobPollingSupport.setFailed();\n        if (this.areRequestsPending()) {\n          // Add response to queue, handle later by _performUserAjaxRequest()\n          this.responseQueue.add(data);\n        } else {\n          // No user request pending, handle immediately\n          this.responseQueue.process(data);\n        }\n      } else if (data.sessionTerminated) {\n        $.log.info('Session terminated, stopped polling for background jobs');\n        this.backgroundJobPollingSupport.setStopped();\n        // If were are not yet logged out, redirect to the logout URL (the session that initiated the\n        // session invalidation will receive a dedicated logout event, redirect is handled there).\n        if (!this.loggedOut && data.redirectUrl) {\n          this.logout(data.redirectUrl);\n        }\n      } else {\n        try {\n          // No need to change backgroundJobPollingSupport state, it should still be RUNNING\n          if (this.areRequestsPending()) {\n            // Add response to queue, handle later by _performUserAjaxRequest()\n            this.responseQueue.add(data);\n          } else {\n            // No user request pending, handle immediately\n            this.responseQueue.process(data);\n            this.layoutValidator.validate();\n          }\n          setTimeout(this._pollForBackgroundJobs.bind(this));\n        } catch (error) {\n          this.backgroundJobPollingSupport.setFailed();\n          throw error;\n        }\n      }\n    }\n    function onAjaxFail(ajaxError) {\n      this.backgroundJobPollingSupport.setFailed();\n      this._processErrorResponse(ajaxError.jqXHR, ajaxError.textStatus, ajaxError.errorThrown, request);\n    }\n  }\n\n  /**\n   * Do NOT call this method directly, always use the response queue:\n   *\n   *   session.responseQueue.process(data);\n   *\n   * Otherwise, the response queue's expected sequence number will get out of sync.\n   */\n  processJsonResponseInternal(data) {\n    let success = false;\n    if (data.error) {\n      this._processErrorJsonResponse(data.error);\n    } else {\n      this._processSuccessResponse(data);\n      success = true;\n    }\n    return success;\n  }\n  _processSuccessResponse(message) {\n    if (message.adapterData) {\n      this._copyAdapterData(message.adapterData);\n    }\n    if (message.events) {\n      this.processingEvents = true;\n      try {\n        this._processEvents(message.events);\n      } finally {\n        this.processingEvents = false;\n      }\n    }\n    if ($.log.isDebugEnabled()) {\n      let cacheSize = objects.countOwnProperties(this._adapterDataCache);\n      $.log.trace('size of _adapterDataCache after response has been processed: ' + cacheSize);\n      cacheSize = objects.countOwnProperties(this.modelAdapterRegistry);\n      $.log.trace('size of modelAdapterRegistry after response has been processed: ' + cacheSize);\n    }\n  }\n  _copyAdapterData(adapterData) {\n    let count = 0;\n    let prop;\n    for (prop in adapterData) {\n      this._adapterDataCache[prop] = adapterData[prop];\n      count++;\n    }\n    if (count > 0) {\n      $.log.isTraceEnabled() && $.log.trace('Stored ' + count + ' properties in adapterDataCache');\n    }\n  }\n\n  /**\n   * @param textStatus 'timeout', 'abort', 'error' or 'parseerror' (see http://api.jquery.com/jquery.ajax/)\n   */\n  _processErrorResponse(jqXHR, textStatus, errorThrown, request) {\n    $.log.error('errorResponse: status=' + jqXHR.status + ', textStatus=' + textStatus + ', errorThrown=' + errorThrown);\n    let offlineError = AjaxCall.isOfflineError(jqXHR, textStatus, errorThrown, request);\n    if (offlineError) {\n      if (this.ready) {\n        this.goOffline();\n        if (request && !request.pollForBackgroundJobs && !this._retryRequest) {\n          this._retryRequest = request;\n        }\n        return;\n      }\n      // Not ready yet (startup request)\n      errorThrown = errorThrown || this.optText('ui.ConnectionInterrupted', 'Connection interrupted');\n    }\n\n    // Show error message\n    let boxOptions = {\n      header: this.optText('ui.NetworkError', 'Network error'),\n      body: strings.join(' ', jqXHR.status || '', errorThrown),\n      yesButtonText: this.optText('ui.Reload', 'Reload'),\n      yesButtonAction: () => scout.reloadPage(),\n      iconId: icons.SLIPPERY\n    };\n    this.showFatalMessage(boxOptions, jqXHR.status + '.net');\n  }\n  _processErrorJsonResponse(jsonError) {\n    if (jsonError.code === Session.JsonResponseError.VERSION_MISMATCH) {\n      let loopDetection = webstorage.getItemFromSessionStorage('scout:versionMismatch');\n      if (!loopDetection) {\n        webstorage.setItemToSessionStorage('scout:versionMismatch', 'yes');\n        // Reload page -> everything should then be up to date\n        scout.reloadPage();\n        return;\n      }\n      webstorage.removeItemFromSessionStorage('scout:versionMismatch');\n    }\n    if (this.loggedOut) {\n      // When the session is terminated via user request (logout button), the poller might return\n      // with a code 20. If we are already logged out, there is no need to show a message box.\n      return;\n    }\n\n    // Default values for fatal message boxes\n    let boxOptions = {\n      header: this.optText('ui.ServerError', 'Server error') + ' (' + this.optText('ui.ErrorCodeX', 'Code ' + jsonError.code, jsonError.code) + ')',\n      body: jsonError.message,\n      yesButtonText: this.optText('ui.Reload', 'Reload'),\n      yesButtonAction: () => {\n        scout.reloadPage();\n      }\n    };\n\n    // Customize for specific error codes\n    if (jsonError.code === Session.JsonResponseError.STARTUP_FAILED) {\n      // there are no texts yet if session startup failed\n      boxOptions.header = jsonError.message;\n      boxOptions.body = null;\n      boxOptions.yesButtonText = 'Retry';\n      boxOptions.iconId = icons.SLIPPERY;\n    } else if (jsonError.code === Session.JsonResponseError.SESSION_TIMEOUT) {\n      boxOptions.header = this.optText('ui.SessionTimeout', boxOptions.header);\n      boxOptions.body = this.optText('ui.SessionExpiredMsg', boxOptions.body);\n      boxOptions.iconId = icons.HOURGLASS;\n    } else if (jsonError.code === Session.JsonResponseError.UI_PROCESSING) {\n      boxOptions.header = this.optText('ui.UnexpectedProblem', boxOptions.header);\n      boxOptions.body = strings.join('\\n\\n', this.optText('ui.InternalProcessingErrorMsg', boxOptions.body, ' (' + this.optText('ui.ErrorCodeX', 'Code 20', '20') + ')'), this.optText('ui.UiInconsistentMsg', ''));\n      boxOptions.iconId = icons.SLIPPERY;\n      if (this.inDevelopmentMode) {\n        boxOptions.noButtonText = this.optText('ui.Ignore', 'Ignore');\n      }\n    } else if (jsonError.code === Session.JsonResponseError.UNSAFE_UPLOAD) {\n      boxOptions.header = this.optText('ui.UnsafeUpload', boxOptions.header);\n      boxOptions.body = this.optText('ui.UnsafeUploadMsg', boxOptions.body);\n      boxOptions.yesButtonText = this.optText('ui.Ok', 'Ok');\n      boxOptions.yesButtonAction = () => {};\n    } else if (jsonError.code === Session.JsonResponseError.REJECTED_UPLOAD) {\n      boxOptions.header = this.optText('ui.RejectedUpload', boxOptions.header);\n      boxOptions.body = this.optText('ui.RejectedUploadMsg', boxOptions.body);\n      boxOptions.yesButtonText = this.optText('ui.Ok', 'Ok');\n      boxOptions.yesButtonAction = () => {};\n    }\n    this.showFatalMessage(boxOptions, jsonError.code);\n  }\n  _fireRequestFinished(message) {\n    if (!this._deferred) {\n      return;\n    }\n    if (message.events) {\n      for (let i = 0; i < message.events.length; i++) {\n        this._deferredEventTypes.push(message.events[i].type);\n      }\n    }\n    if (this.requestsPendingCounter === 0) {\n      this._deferred.resolve(this._deferredEventTypes);\n      this._deferred = null;\n      this._deferredEventTypes = null;\n    }\n  }\n\n  /**\n   * Shows a UI-only message box.\n   *\n   * @param options\n   *          Options for the message box, see MessageBox\n   * @param errorCode\n   *          If defined, a second call to this method with the same errorCode will\n   *          do nothing. Can be used to prevent double messages for the same error.\n   */\n  showFatalMessage(options, errorCode) {\n    if (!errorCode) {\n      errorCode = App.get().errorHandler.getJsErrorCode();\n    }\n    if (this._fatalMessagesOnScreen[errorCode]) {\n      return;\n    }\n    this._fatalMessagesOnScreen[errorCode] = true;\n    options = options || {};\n    let model = {\n        session: this,\n        parent: this.desktop || new NullWidget(),\n        iconId: options.iconId,\n        severity: scout.nvl(options.severity, Status.Severity.ERROR),\n        header: options.header,\n        body: options.body,\n        hiddenText: options.hiddenText,\n        yesButtonText: options.yesButtonText,\n        noButtonText: options.noButtonText,\n        cancelButtonText: options.cancelButtonText\n      },\n      messageBox = scout.create('MessageBox', model),\n      $entryPoint = options.entryPoint || this.$entryPoint;\n    messageBox.on('action', event => {\n      delete this._fatalMessagesOnScreen[errorCode];\n      messageBox.destroy();\n      let option = event.option;\n      if (option === 'yes' && options.yesButtonAction) {\n        options.yesButtonAction.apply(this);\n      } else if (option === 'no' && options.noButtonAction) {\n        options.noButtonAction.apply(this);\n      } else if (option === 'cancel' && options.cancelButtonAction) {\n        options.cancelButtonAction.apply(this);\n      }\n    });\n    messageBox.render($entryPoint);\n  }\n  isFatalMessageShown() {\n    return Object.keys(this._fatalMessagesOnScreen).length > 0;\n  }\n  uploadFiles(target, files, uploadProperties, maxTotalSize, allowedTypes) {\n    let formData = new FormData(),\n      acceptedFiles = [];\n    if (uploadProperties) {\n      $.each(uploadProperties, (key, value) => {\n        formData.append(key, value);\n      });\n    }\n    $.each(files, (index, value) => {\n      if (!allowedTypes || allowedTypes.length === 0 || scout.isOneOf(value.type, allowedTypes)) {\n        /*\n         * - see ClipboardField for comments on \"scoutName\"\n         * - Some Browsers (e.g. Edge) handle an empty string as filename as if the filename is not set and therefore introduce a default filename like 'blob'.\n         *   To counter this, we introduce a empty filename string. The string consists of characters that can not occur in regular filenames, to prevent collisions.\n         */\n        let filename = scout.nvl(value.scoutName, value.name, Session.EMPTY_UPLOAD_FILENAME);\n        formData.append('files', value, filename);\n        acceptedFiles.push(value);\n      }\n    });\n\n    // 50 MB as default maximum size\n    maxTotalSize = scout.nvl(maxTotalSize, FileInput.DEFAULT_MAXIMUM_UPLOAD_SIZE);\n\n    // very large files must not be sent to server otherwise the whole system might crash (for all users).\n    if (!fileUtil.validateMaximumUploadSize(acceptedFiles, maxTotalSize)) {\n      let boxOptions = {\n        header: this.text('ui.FileSizeLimitTitle'),\n        body: this.text('ui.FileSizeLimit', maxTotalSize / 1024 / 1024),\n        yesButtonText: this.optText('Ok', 'Ok')\n      };\n      this.showFatalMessage(boxOptions);\n      return false;\n    }\n    let uploadAjaxOptions = {\n      type: 'POST',\n      url: 'upload/' + this.uiSessionId + '/' + target.id,\n      cache: false,\n      // Don't touch the data (do not convert it to string)\n      processData: false,\n      // Do not automatically add content type (otherwise, multipart boundary would be missing)\n      contentType: false,\n      data: formData\n    };\n    // Special handling for FormData polyfill\n    if (formData.polyfill) {\n      formData.applyToAjaxOptions(uploadAjaxOptions);\n    }\n    this.responseQueue.prepareHttpRequest(uploadAjaxOptions);\n    let busyHandling = !this.areRequestsPending();\n    this._performUserAjaxRequest(uploadAjaxOptions, busyHandling);\n    return true;\n  }\n  goOffline() {\n    if (this.offline) {\n      return; // already offline\n    }\n\n    this.offline = true;\n\n    // Abort pending ajax requests.\n    this.abortAllAjaxCalls();\n\n    // In Firefox, the current async polling request is interrupted immediately when the page is unloaded. Therefore,\n    // an offline message would appear at once on the desktop. When reloading the page, all elements are cleared anyway,\n    // thus we wait some short period of time before displaying the message and starting the reconnector. If\n    // we find that goOffline() was called because of request unloading, we skip the unnecessary part. Note that\n    // FF doesn't guarantee that _onWindowUnload() is called before this setTimeout() function is called. Therefore,\n    // we have to look at another property \"unloading\" that is set earlier in _onWindowBeforeUnload().\n    setTimeout(() => {\n      if (this.unloading || this.unloaded) {\n        return;\n      }\n      this.rootAdapter.goOffline();\n      this.reconnector.start();\n    }, 100);\n  }\n  goOnline() {\n    this.offline = false;\n    this.rootAdapter.goOnline();\n    let request = this._newRequest({\n      syncResponseQueue: true\n    });\n    this.responseQueue.prepareRequest(request);\n    this._sendRequest(request); // implies \"_resumeBackgroundJobPolling\", and also sends queued request\n  }\n\n  onReconnecting() {\n    if (this.desktop) {\n      this.desktop.onReconnecting();\n    }\n  }\n  onReconnectingSucceeded() {\n    if (this.desktop) {\n      this.desktop.onReconnectingSucceeded();\n    }\n    this.goOnline();\n  }\n  onReconnectingFailed() {\n    if (this.desktop) {\n      this.desktop.onReconnectingFailed();\n    }\n  }\n  listen() {\n    if (!this._deferred) {\n      this._deferred = $.Deferred();\n      this._deferredEventTypes = [];\n    }\n    return this._deferred;\n  }\n\n  /**\n   * Executes the given callback when pending requests are finished, or immediately if there are no requests pending.\n   * @param func callback function\n   * @param vararg arguments to pass to the callback function\n   */\n  onRequestsDone(func) {\n    for (var _len2 = arguments.length, vararg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      vararg[_key2 - 1] = arguments[_key2];\n    }\n    if (this.areRequestsPending() || this.areEventsQueued()) {\n      this.listen().done(onEventsProcessed);\n    } else {\n      func.apply(this, vararg);\n    }\n    function onEventsProcessed() {\n      func.apply(this, vararg);\n    }\n  }\n\n  /**\n   * Executes the given callback when all events of the current response are processed. Executes it immediately if no events are being processed.\n   * @param func callback function\n   * @param vararg arguments to pass to the callback function\n   */\n  onEventsProcessed(func) {\n    for (var _len3 = arguments.length, vararg = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      vararg[_key3 - 1] = arguments[_key3];\n    }\n    if (this.processingEvents) {\n      this.one('eventsProcessed', execFunc);\n    } else {\n      execFunc();\n    }\n    function execFunc() {\n      func.apply(this, vararg);\n    }\n  }\n  areEventsQueued() {\n    return this.asyncEvents.length > 0;\n  }\n  areBusyIndicatedEventsQueued() {\n    return this.asyncEvents.some(event => {\n      return scout.nvl(event.showBusyIndicator, true);\n    });\n  }\n  areResponsesQueued() {\n    return this.responseQueue.size() > 0;\n  }\n  areRequestsPending() {\n    return this.requestsPendingCounter > 0;\n  }\n  setRequestPending(pending) {\n    if (pending) {\n      this.requestsPendingCounter++;\n    } else {\n      this.requestsPendingCounter--;\n    }\n\n    // In \"inspector\" mode, add/remove a marker attribute to the $entryPoint that\n    // can be used to detect pending server calls by UI testing tools, e.g. Selenium\n    if (this.inspector) {\n      this.$entryPoint.toggleAttr('data-request-pending', pending, 'true');\n    }\n  }\n  setBusy(busy) {\n    if (busy) {\n      if (!this._busy) {\n        this._renderBusy();\n      }\n      this._busy = true;\n    } else {\n      if (this._busy) {\n        this._removeBusy();\n      }\n      this._busy = false;\n    }\n  }\n  _renderBusy() {\n    if (this._busyIndicatorTimeoutId !== null && this._busyIndicatorTimeoutId !== undefined) {\n      // Do not schedule it twice\n      return;\n    }\n    // Don't show the busy indicator immediately. Set a short timer instead (which may be\n    // cancelled again if the busy state returns to false in the meantime).\n    this._busyIndicatorTimeoutId = setTimeout(() => {\n      if (this._busyIndicator) {\n        // busy indicator is already showing\n        return;\n      }\n      if (!this.desktop || !this.desktop.rendered) {\n        return; // No busy indicator without desktop (e.g. during shutdown)\n      }\n\n      this._busyIndicator = scout.create('BusyIndicator', {\n        parent: this.desktop\n      });\n      this._busyIndicator.on('cancel', this._onCancelProcessing.bind(this));\n      this._busyIndicator.render(this.$entryPoint);\n    }, 500);\n  }\n  _removeBusy() {\n    // Clear pending timer\n    clearTimeout(this._busyIndicatorTimeoutId);\n    this._busyIndicatorTimeoutId = null;\n\n    // Remove busy indicator (if it was already created)\n    if (this._busyIndicator) {\n      this._busyIndicator.destroy();\n      this._busyIndicator = null;\n    }\n  }\n  _onCancelProcessing(event) {\n    let busyIndicator = this._busyIndicator;\n    if (!busyIndicator) {\n      return; // removed in the mean time\n    }\n\n    busyIndicator.off('cancel');\n\n    // Set \"canceling\" state in busy indicator (after 100ms, would not look good otherwise)\n    setTimeout(() => {\n      busyIndicator.cancelled();\n    }, 100);\n    this._sendCancelRequest();\n  }\n  _sendCancelRequest() {\n    let request = this._newRequest({\n      cancel: true,\n      showBusyIndicator: false\n    });\n    this._sendRequest(request);\n  }\n\n  /**\n   * Sends a request containing the log message for logging purpose.\n   * The request is sent immediately (does not await pending requests).\n   * @param {string} message the log message\n   * @param {logging.Level} [level] the log level used to log the message. Default is {@link logging.Level.ERROR}.\n   */\n  sendLogRequest(message, level) {\n    let request = this._newRequest({\n      log: true,\n      message: message,\n      level: scout.nvl(level, logging.Level.ERROR)\n    });\n    if (this.currentEvent) {\n      request.event = {\n        target: this.currentEvent.target,\n        type: this.currentEvent.type\n      };\n    }\n\n    // Do not use _sendRequest to make sure a log request has no side effects and will be sent only once\n    $.ajax(this.defaultAjaxOptions(request));\n  }\n  _newRequest(requestData) {\n    let request = $.extend({\n      uiSessionId: this.uiSessionId\n    }, requestData);\n\n    // Certain requests do not require a sequence number\n    if (!request.log && !request.syncResponseQueue) {\n      request['#'] = this.requestSequenceNo++;\n    }\n    return request;\n  }\n  _processEvents(events) {\n    let i = 0;\n    while (i < events.length) {\n      let event = events[i];\n      this.currentEvent = event;\n      let adapter = this.getModelAdapter(event.target);\n      if (!adapter) {\n        // Sometimes events seem to happen \"too early\", e.g. when a \"requestFocus\" event for a field is\n        // encountered before the \"showForm\" event has been processed. If the target adapter cannot be\n        // resolved, we try the other events first, expecting them to trigger the creation of the event\n        // adapter. As soon as a event could be processed successfully, we try our postponed event again.\n        $.log.isDebugEnabled() && $.log.debug('Postponing \\'' + event.type + '\\' for adapter with ID ' + event.target);\n        i++;\n        continue;\n      }\n      // Remove the successful event and reset the pointer to the start of the remaining events (to\n      // retry previously postponed events).\n      events.splice(i, 1);\n      i = 0;\n      $.log.isDebugEnabled() && $.log.debug('Processing event \\'' + event.type + '\\' for adapter with ID ' + event.target);\n      adapter.onModelEvent(event);\n      adapter.resetEventFilters();\n    }\n    this.currentEvent = null;\n\n    // If there are still events whose target could not be resolved, throw an error\n    if (events.length) {\n      throw new Error('Could not resolve event targets: [' + events.map(event => {\n        let msg = 'target: ' + event.target + ', type: ' + event.type;\n        if (event.properties) {\n          msg += ', properties: ' + Object.keys(event.properties);\n        }\n        return '\"' + msg + '\"';\n      }, this).join(', ') + ']');\n    }\n    this.trigger('eventsProcessed');\n  }\n  start() {\n    $.log.isInfoEnabled() && $.log.info('Session starting...');\n\n    // Send startup request\n    return this._sendStartupRequest();\n  }\n  onModelEvent(event) {\n    if (event.type === 'localeChanged') {\n      this._onLocaleChanged(event);\n    } else if (event.type === 'logout') {\n      this._onLogout(event);\n    } else if (event.type === 'disposeAdapter') {\n      this._onDisposeAdapter(event);\n    } else if (event.type === 'reloadPage') {\n      this._onReloadPage(event);\n    } else {\n      $.log.warn('Model action \"' + event.type + '\" is not supported by UI session');\n    }\n  }\n  resetEventFilters() {\n    // NOP\n  }\n  _onLocaleChanged(event) {\n    let locale = new Locale(event.locale);\n    let textMap = new TextMap(event.textMap);\n    this.switchLocale(locale, textMap);\n  }\n\n  /**\n   * @param {Locale} the new locale\n   * @param {TextMap} [textMap] the new textMap. If not defined, the corresponding textMap for the new locale is used.\n   */\n  switchLocale(locale, textMap) {\n    scout.assertParameter('locale', locale, Locale);\n    this.locale = locale;\n    this.textMap = texts.get(locale.languageTag);\n    if (textMap) {\n      objects.copyOwnProperties(textMap, this.textMap);\n    }\n    // TODO [7.0] bsh: inform components to reformat display text? also check Collator in comparators.TEXT\n\n    this.trigger('localeSwitch', {\n      locale: this.locale\n    });\n  }\n  _renderDesktop() {\n    this.desktop.render(this.$entryPoint);\n    this.desktop.invalidateLayoutTree(false);\n  }\n  _onLogout(event) {\n    this.logout(event.redirectUrl);\n  }\n  logout(logoutUrl) {\n    this.loggedOut = true;\n    // TODO [7.0] bsh: Check if there is a better solution (e.g. send a flag from server \"action\" = [ \"redirect\" | \"closeWindow\" ])\n    if (this.forceNewClientSession) {\n      this.desktop.$container.window(true).close();\n    } else {\n      // remember current url to not lose query parameters (such as debug; however, ignore deeplinks)\n      let url = new URL();\n      url.removeParameter('dl'); // deeplink\n      url.removeParameter('i'); // deeplink info\n      webstorage.setItemToSessionStorage('scout:loginUrl', url.toString());\n      // Clear everything and reload the page. We wrap that in setTimeout() to allow other events to be executed normally before.\n      setTimeout(() => {\n        scout.reloadPage({\n          redirectUrl: logoutUrl\n        });\n      });\n    }\n  }\n  _onDisposeAdapter(event) {\n    // Model adapter was disposed on server -> dispose it on the UI, too\n    let adapter = this.getModelAdapter(event.adapter);\n    if (adapter) {\n      // adapter may be null if it was never sent to the UI, e.g. a form that was opened and closed in the same request\n      adapter.destroy();\n    }\n  }\n  _onReloadPage(event) {\n    // Don't clear the body, because other events might be processed before the reload and\n    // it could cause errors when all DOM elements are already removed.\n    scout.reloadPage({\n      clearBody: false\n    });\n  }\n  _onWindowBeforeUnload() {\n    $.log.isInfoEnabled() && $.log.info('Session before unloading...');\n    // TODO [7.0] bsh: Cancel pending requests\n\n    // Set a flag that indicates unloading before _onWindowUnload() is called.\n    // See goOffline() why this is necessary.\n    this.unloading = true;\n    setTimeout(() => {\n      // Because there is no callback when the unloading was cancelled, we always\n      // reset the flag after a short period of time.\n      this.unloading = false;\n    }, 200);\n  }\n  _onWindowUnload() {\n    $.log.isInfoEnabled() && $.log.info('Session unloading...');\n    this.unloaded = true;\n\n    // Close popup windows\n    if (this.desktop && this.desktop.formController) {\n      this.desktop.formController.closePopupWindows();\n    }\n\n    // Destroy UI session on server (only when the server did not not initiate the logout,\n    // otherwise the UI session would already be disposed)\n    if (!this.loggedOut) {\n      this._sendUnloadRequest();\n    }\n    if (this.loggedOut && this.persistent) {\n      webstorage.removeItemFromLocalStorage('scout:clientSessionId');\n    }\n  }\n\n  /**\n   * Returns the adapter-data sent with the JSON response from the adapter-data cache. Note that this operation\n   * removes the requested element from the cache, thus you cannot request the same ID twice. Typically once\n   * you've requested an element from this cache an adapter for that ID is created and stored in the adapter\n   * registry which too exists on this session object.\n   */\n  _getAdapterData(id) {\n    let adapterData = this._adapterDataCache[id];\n    let deleteAdapterData = !this.adapterExportEnabled;\n    if (deleteAdapterData) {\n      delete this._adapterDataCache[id];\n    }\n    return adapterData;\n  }\n  getAdapterData(id) {\n    return this._adapterDataCache[id];\n  }\n\n  /**\n   * Returns the text for the given key.\n   *\n   * @param textKey key to lookup the text\n   * @param args texts to replace the placeholders specified by {0}, {1}, etc.\n   * @returns {string}\n   */\n  text(textKey) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    return this.textMap.get(textKey, ...args);\n  }\n\n  /**\n   * Returns the text for the given key.\n   *\n   * @param textKey key to lookup the text\n   * @param defaultValue the text to return if the key has not been found.\n   * @param args texts to replace the placeholders specified by {0}, {1}, etc.\n   * @returns {string}\n   */\n  optText(textKey, defaultValue) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    }\n    return this.textMap.optGet(textKey, defaultValue, ...args);\n  }\n  textExists(textKey) {\n    return this.textMap.exists(textKey);\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n  one(type, func) {\n    this.events.one(type, func);\n  }\n  on(type, func) {\n    return this.events.on(type, func);\n  }\n  off(type, func) {\n    this.events.off(type, func);\n  }\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n  when(type) {\n    return this.events.when(type);\n  }\n}\n_defineProperty(Session, \"JsonResponseError\", {\n  STARTUP_FAILED: 5,\n  SESSION_TIMEOUT: 10,\n  UI_PROCESSING: 20,\n  UNSAFE_UPLOAD: 30,\n  REJECTED_UPLOAD: 31,\n  VERSION_MISMATCH: 40\n});\n_defineProperty(Session, \"EMPTY_UPLOAD_FILENAME\", '*empty*');","map":{"version":3,"names":["AjaxCall","App","arrays","BackgroundJobPollingStatus","BackgroundJobPollingSupport","Device","EventSupport","FileInput","files","fileUtil","FocusManager","fonts","icons","LayoutValidator","Locale","logging","MessageBox","ModelAdapter","NullWidget","ObjectFactory","objects","Reconnector","RemoteEvent","ResponseQueue","scout","Status","strings","TextMap","texts","TypeDescriptor","URL","UserAgent","webstorage","$","Session","constructor","$entryPoint","partId","url","userAgent","deviceType","get","type","touch","supportsOnlyTouch","standalone","isStandalone","locale","textMap","ready","unloading","unloaded","loggedOut","inspector","persistent","inDevelopmentMode","desktop","layoutValidator","focusManager","keyStrokeManager","uiSessionId","clientSessionId","_getClientSessionIdFromStorage","forceNewClientSession","remoteUrl","unloadUrl","modelAdapterRegistry","ajaxCalls","asyncEvents","responseQueue","requestsPendingCounter","suppressErrors","requestTimeoutCancel","requestTimeoutPoll","requestTimeoutPing","backgroundJobPollingSupport","reconnector","processingEvents","adapterExportEnabled","_adapterDataCache","_busy","_busyIndicator","_busyIndicatorTimeoutId","_deferred","_fatalMessagesOnScreen","_retryRequest","_queuedRequest","requestSequenceNo","rootAdapter","init","session","id","objectType","rootParent","initialized","root","createWidget","events","_createEventSupport","model","options","Error","nvl","portletPartId","getParameter","ensure","languageTag","backgroundJobPollingEnabled","enabled","extend","reconnectorOptions","ajaxCallOptions","active","focusManagerActive","create","_throwError","message","unregisterModelAdapter","modelAdapter","registerModelAdapter","undefined","getModelAdapter","getWidget","adapterId","adapter","widget","getOrCreateWidget","parent","strict","adapterData","_getAdapterData","createModelAdapter","createOpts","objectInfo","parse","modelVariant","toString","MODEL_VARIANT_SEPARATOR","variantLenient","adapterModel","log","isTraceEnabled","trace","sendEvent","event","delay","_coalesceEvents","push","_asyncDelay","Math","min","clearTimeout","_sendTimeoutId","setTimeout","areRequestsPending","_sendNow","_sendStartupRequest","request","_newRequest","startup","version","sessionStartupParams","_createSessionStartupParams","ajaxOptions","defaultAjaxOptions","ajax","catch","onAjaxFail","bind","then","onAjaxDone","data","_processStartupResponse","error","rejectedPromise","jqXHR","textStatus","errorThrown","_processErrorResponse","args","params","baseUrlRaw","geolocationServiceAvailable","supportsGeolocation","urlParameterMap","parameterMap","prop","_processErrorJsonResponse","removeItemFromSessionStorage","startupData","_storeClientSessionIdInStorage","window","on","_onWindowBeforeUnload","_onWindowUnload","reloadPage","pollingInterval","_copyAdapterData","addAll","clientSessionData","clientSession","_triggerDesktopReady","renderDesktopImpl","_renderDesktop","_processEvents","validate","validateFocus","_resumeBackgroundJobPolling","_triggerSessionReady","isInfoEnabled","info","isDebugEnabled","debug","countOwnProperties","render","key","removeItemFromLocalStorage","setItemToLocalStorage","setItemToSessionStorage","getItemFromSessionStorage","getItemFromLocalStorage","renderFunc","loadingComplete","preloader","_sendUnloadRequest","unload","showBusyIndicator","_sendRequest","length","some","i","newRequest","prepareRequest","slice","previousEvents","coalesce","filter","negate","offline","_handleSendWhenOffline","navigator","sendBeacon","busyHandling","async","_performUserAjaxRequest","forEach","concat","_decorateUrl","dataType","contentType","cache","_requestToJson","timeout","cancel","ping","pollForBackgroundJobs","urlHint","syncResponseQueue","addParameter","_getRequestName","defaultName","JSON","stringify","value","ignore","isOneOf","_callAjax","callOptions","defaultOptions","retryIntervals","ajaxCall","ensureUniqueId","registerAjaxCall","call","always","unregisterAjaxCall","setBusy","setRequestPending","jsError","success","name","done","fail","onAjaxAlways","areBusyIndicatedEventsQueued","process","err","ajaxError","_fireRequestFinished","retryRequest","queuedRequest","remove","interruptAllAjaxCalls","pendingCall","abort","abortAllAjaxCalls","status","RUNNING","_pollForBackgroundJobs","setRunning","warn","setFailed","add","sessionTerminated","setStopped","redirectUrl","logout","processJsonResponseInternal","_processSuccessResponse","cacheSize","count","offlineError","isOfflineError","goOffline","optText","boxOptions","header","body","join","yesButtonText","yesButtonAction","iconId","SLIPPERY","showFatalMessage","jsonError","code","JsonResponseError","VERSION_MISMATCH","loopDetection","STARTUP_FAILED","SESSION_TIMEOUT","HOURGLASS","UI_PROCESSING","noButtonText","UNSAFE_UPLOAD","REJECTED_UPLOAD","_deferredEventTypes","resolve","errorCode","errorHandler","getJsErrorCode","severity","Severity","ERROR","hiddenText","cancelButtonText","messageBox","entryPoint","destroy","option","apply","noButtonAction","cancelButtonAction","isFatalMessageShown","Object","keys","uploadFiles","target","uploadProperties","maxTotalSize","allowedTypes","formData","FormData","acceptedFiles","each","append","index","filename","scoutName","EMPTY_UPLOAD_FILENAME","DEFAULT_MAXIMUM_UPLOAD_SIZE","validateMaximumUploadSize","text","uploadAjaxOptions","processData","polyfill","applyToAjaxOptions","prepareHttpRequest","start","goOnline","onReconnecting","onReconnectingSucceeded","onReconnectingFailed","listen","Deferred","onRequestsDone","func","vararg","areEventsQueued","onEventsProcessed","one","execFunc","areResponsesQueued","size","pending","toggleAttr","busy","_renderBusy","_removeBusy","rendered","_onCancelProcessing","busyIndicator","off","cancelled","_sendCancelRequest","sendLogRequest","level","Level","currentEvent","requestData","splice","onModelEvent","resetEventFilters","map","msg","properties","trigger","_onLocaleChanged","_onLogout","_onDisposeAdapter","_onReloadPage","switchLocale","assertParameter","copyOwnProperties","invalidateLayoutTree","logoutUrl","$container","close","removeParameter","clearBody","formController","closePopupWindows","deleteAdapterData","getAdapterData","textKey","defaultValue","optGet","textExists","exists","source","addListener","listener","removeListener","when"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/session/Session.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {AjaxCall, App, arrays, BackgroundJobPollingStatus, BackgroundJobPollingSupport, Device, EventSupport, FileInput, files as fileUtil, FocusManager, fonts, icons, LayoutValidator, Locale, logging, MessageBox, ModelAdapter, NullWidget, ObjectFactory, objects, Reconnector, RemoteEvent, ResponseQueue, scout, Status, strings, TextMap, texts, TypeDescriptor, URL, UserAgent, webstorage} from '../index';\nimport $ from 'jquery';\n\nexport default class Session {\n  constructor() {\n    this.$entryPoint = null;\n    this.partId = 0;\n\n    this.url = new URL();\n    this.userAgent = new UserAgent({\n      deviceType: Device.get().type,\n      touch: Device.get().supportsOnlyTouch(),\n      standalone: Device.get().isStandalone()\n    });\n    this.locale = new Locale(); // Ensure there is always a locale even if not passed and startup request fails\n    this.textMap = new TextMap();\n\n    this.ready = false; // true after desktop has been completely rendered\n    this.unloading = false; // true when 'beforeOnload' event has been triggered\n    this.unloaded = false; // true after unload event has been received from the window\n    this.loggedOut = false;\n    this.inspector = false;\n    this.persistent = false;\n    this.inDevelopmentMode = false;\n    this.desktop = null;\n    this.layoutValidator = new LayoutValidator();\n    this.focusManager = null;\n    this.keyStrokeManager = null;\n\n    this.uiSessionId = null; // assigned by server on session startup (OWASP recommendation, see https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern).\n    this.clientSessionId = this._getClientSessionIdFromStorage();\n    this.forceNewClientSession = false;\n    this.remoteUrl = 'json';\n    this.unloadUrl = 'unload';\n    this.modelAdapterRegistry = {};\n    this.ajaxCalls = [];\n    this.asyncEvents = [];\n    this.responseQueue = new ResponseQueue(this);\n    this.requestsPendingCounter = 0;\n    this.suppressErrors = false;\n    this.requestTimeoutCancel = 5000; // ms\n    this.requestTimeoutPoll = 75000; // ms, depends on polling interval, will therefore be initialized on startup\n    this.requestTimeoutPing = 5000; // ms\n    this.backgroundJobPollingSupport = new BackgroundJobPollingSupport(true);\n    this.reconnector = new Reconnector(this);\n    this.processingEvents = false;\n\n    // This property is enabled by URL parameter &adapterExportEnabled=1. Default is false\n    this.adapterExportEnabled = false;\n    this._adapterDataCache = {};\n    this._busy = false;\n    this._busyIndicator = null;\n    this._busyIndicatorTimeoutId = null;\n    this._deferred = null;\n    this._fatalMessagesOnScreen = {};\n    this._retryRequest = null;\n    this._queuedRequest = null;\n    this.requestSequenceNo = 0;\n\n    this.rootAdapter = new ModelAdapter();\n    this.rootAdapter.init({\n      session: this,\n      id: '1',\n      objectType: 'RootAdapter'\n    });\n\n    let rootParent = new NullWidget();\n    rootParent.session = this;\n    rootParent.initialized = true;\n\n    this.root = this.rootAdapter.createWidget({\n      session: this,\n      id: '1',\n      objectType: 'NullWidget'\n    }, rootParent);\n    this.events = this._createEventSupport();\n  }\n\n  // Corresponds to constants in JsonResponse\n  static JsonResponseError = {\n    STARTUP_FAILED: 5,\n    SESSION_TIMEOUT: 10,\n    UI_PROCESSING: 20,\n    UNSAFE_UPLOAD: 30,\n    REJECTED_UPLOAD: 31,\n    VERSION_MISMATCH: 40\n  };\n\n  // Placeholder string for an empty filename\n  static EMPTY_UPLOAD_FILENAME = '*empty*';\n\n  /**\n   * @param {$} model.$entryPoint\n   *     The HTML element that is used by the {@link Desktop} to render its content.\n   * @param {string} [model.portletPartId]\n   *     Necessary when multiple UI sessions are managed by the same window (portlet support).\n   *     Each session's partId must be unique. Default is 0.\n   * @param {string} [model.clientSessionId]\n   *     Identifies the 'client instance' on the UI server. If the property is not set\n   *     (which is the default case), the clientSessionId is taken from the browser's\n   *     session storage (per browser window, survives F5 refresh of page). If no\n   *     clientSessionId can be found, a new one is generated on the server.\n   * @param {boolean} [model.forceNewClientSession]\n   *     If set to true, the stored or passed clientSessionId will be ignored\n   *     and a new one generated by the server.\n   * @param {UserAgent} [model.userAgent]\n   *     By default the user agent for the running platform is used. Use this option if you want to set a custom one.\n   * @param {Locale|object} [model.locale]\n   *     If not specified, {@link Locale.DEFAULT} is used.\n   * @param {boolean} [model.backgroundJobPollingEnabled]\n   *     Unless websockets is used, this property turns on (default) or off background\n   *     polling using an async ajax call together with setTimeout()\n   * @param {boolean} [model.suppressErrors]\n   *     Basically added because of Jasmine-tests. When working with async tests that\n   *     use setTimeout(), sometimes the Jasmine-Maven plug-in fails and aborts the\n   *     build because there were console errors. These errors always happen in this\n   *     class. That's why we can skip suppress error handling with this flag.\n   * @param {boolean} [model.focusManagerActive]\n   *     Forces the focus manager to be active or not. If undefined, the value is\n   *     auto detected by Device.js.\n   * @param {object} [model.reconnectorOptions]\n   *     Properties of this object are copied to the Session's reconnector\n   *     instance (see {@link Reconnector}).\n   * @param {object} [model.ajaxCallOptions]\n   *     Properties of this object are copied to all instances of {@link AjaxCall}.\n   */\n  init(model) {\n    let options = model || {};\n\n    if (!options.$entryPoint) {\n      throw new Error('$entryPoint is not defined');\n    }\n    this.$entryPoint = options.$entryPoint;\n    this.partId = scout.nvl(options.portletPartId, this.partId);\n    this.forceNewClientSession = scout.nvl(this.url.getParameter('forceNewClientSession'), options.forceNewClientSession);\n    if (this.forceNewClientSession) {\n      this.clientSessionId = null;\n    } else {\n      this.clientSessionId = scout.nvl(options.clientSessionId, this.clientSessionId);\n    }\n    this.userAgent = scout.nvl(options.userAgent, this.userAgent);\n    this.suppressErrors = scout.nvl(options.suppressErrors, this.suppressErrors);\n    if (options.locale) {\n      this.locale = Locale.ensure(options.locale);\n      this.textMap = texts.get(this.locale.languageTag);\n    }\n    if (options.backgroundJobPollingEnabled === false) {\n      this.backgroundJobPollingSupport.enabled = false;\n    }\n    $.extend(this.reconnector, options.reconnectorOptions);\n    this.ajaxCallOptions = options.ajaxCallOptions;\n\n    // Set inspector flag by looking at URL params. This is required when running in offline mode.\n    // In online mode, the server may override this flag again, see _processStartupResponse().\n    if (this.url.getParameter('debug') === 'true' || this.url.getParameter('inspector') === 'true') {\n      this.inspector = true;\n    }\n\n    if (this.url.getParameter('adapterExportEnabled') === 'true') {\n      this.adapterExportEnabled = true;\n    }\n\n    // Install focus management for this session (cannot be created in constructor, because this.$entryPoint is required)\n    this.focusManager = new FocusManager({\n      session: this,\n      active: options.focusManagerActive\n    });\n    this.keyStrokeManager = scout.create('KeyStrokeManager', {\n      session: this\n    });\n  }\n\n  _throwError(message) {\n    if (!this.suppressErrors) {\n      throw new Error(message);\n    }\n  }\n\n  unregisterModelAdapter(modelAdapter) {\n    delete this.modelAdapterRegistry[modelAdapter.id];\n  }\n\n  registerModelAdapter(modelAdapter) {\n    if (modelAdapter.id === undefined) {\n      throw new Error('modelAdapter.id must be defined');\n    }\n    this.modelAdapterRegistry[modelAdapter.id] = modelAdapter;\n  }\n\n  getModelAdapter(id) {\n    return this.modelAdapterRegistry[id];\n  }\n\n  getWidget(adapterId) {\n    if (!adapterId) {\n      return null;\n    }\n    if (typeof adapterId !== 'string') {\n      throw new Error('typeof adapterId must be string');\n    }\n    let adapter = this.getModelAdapter(adapterId);\n    if (!adapter) {\n      return null;\n    }\n    return adapter.widget;\n  }\n\n  getOrCreateWidget(adapterId, parent, strict) {\n    if (!adapterId) {\n      return null;\n    }\n    if (typeof adapterId !== 'string') {\n      throw new Error('typeof adapterId must be string');\n    }\n    let widget = this.getWidget(adapterId);\n    if (widget) {\n      return widget;\n    }\n    let adapterData = this._getAdapterData(adapterId);\n    if (!adapterData) {\n      if (scout.nvl(strict, true)) {\n        throw new Error('no adapterData found for adapterId=' + adapterId);\n      }\n      return null;\n    }\n    let adapter = this.createModelAdapter(adapterData);\n    return adapter.createWidget(adapterData, parent);\n  }\n\n  createModelAdapter(adapterData) {\n    let objectType = adapterData.objectType;\n    let createOpts = {};\n\n    let objectInfo = TypeDescriptor.parse(objectType);\n    if (objectInfo.modelVariant) {\n      objectType = objectInfo.objectType.toString() + 'Adapter' + ObjectFactory.MODEL_VARIANT_SEPARATOR + objectInfo.modelVariant.toString();\n      // If no adapter exists for the given variant then create an adapter without variant.\n      // Mostly variant is only essential for the widget, not the adapter\n      createOpts.variantLenient = true;\n    } else {\n      objectType = objectInfo.objectType.toString() + 'Adapter';\n    }\n\n    // TODO [7.0] bsh, cgu: Add classId/modelClass? Think about if IDs should be different for widgets (maybe prefix with 'w')\n    let adapterModel = {\n      id: adapterData.id,\n      session: this\n    };\n    let adapter = scout.create(objectType, adapterModel, createOpts);\n    $.log.isTraceEnabled() && $.log.trace('created new adapter ' + adapter);\n    return adapter;\n  }\n\n  /**\n   * Sends the request asynchronously and processes the response later.<br>\n   * Furthermore, the request is sent delayed. If send is called multiple times\n   * during the same user interaction, the events are collected and sent in one\n   * request at the end of the user interaction\n   */\n  sendEvent(event, delay) {\n    delay = delay || 0;\n\n    this.asyncEvents = this._coalesceEvents(this.asyncEvents, event);\n    this.asyncEvents.push(event);\n    // Use the specified delay, except another event is already scheduled. In that case, use the minimal delay.\n    // This ensures that an event with a long delay doesn't hold back another event with a short delay.\n    this._asyncDelay = Math.min(delay, scout.nvl(this._asyncDelay, delay));\n\n    clearTimeout(this._sendTimeoutId);\n    this._sendTimeoutId = setTimeout(() => {\n      this._sendTimeoutId = null;\n      this._asyncDelay = null;\n      if (this.areRequestsPending()) {\n        // do not send if there are any requests pending because the order matters -> prevents race conditions\n        return;\n      }\n      this._sendNow();\n    }, this._asyncDelay);\n  }\n\n  _sendStartupRequest() {\n    // Build startup request (see JavaDoc for JsonStartupRequest.java for details)\n    let request = this._newRequest({\n      startup: true\n    });\n    if (this.partId) {\n      request.partId = this.partId;\n    }\n    if (this.clientSessionId) {\n      request.clientSessionId = this.clientSessionId;\n    }\n    if (App.get().version) {\n      request.version = App.get().version;\n    }\n    request.userAgent = this.userAgent;\n    request.sessionStartupParams = this._createSessionStartupParams();\n\n    // Send request\n    let ajaxOptions = this.defaultAjaxOptions(request);\n\n    return $.ajax(ajaxOptions)\n      .catch(onAjaxFail.bind(this))\n      .then(onAjaxDone.bind(this));\n\n    // ----- Helper methods -----\n\n    function onAjaxDone(data) {\n      this._processStartupResponse(data);\n      if (data.error) {\n        return $.rejectedPromise(data);\n      }\n    }\n\n    function onAjaxFail(jqXHR, textStatus, errorThrown, ...args) {\n      this._processErrorResponse(jqXHR, textStatus, errorThrown, request);\n      return $.rejectedPromise(jqXHR, textStatus, errorThrown, ...args);\n    }\n  }\n\n  /**\n   * Creates an object to send to the server as \"startupParams\".\n   *\n   * Default params:\n   * \"url\":\n   *   browser URL (without query and hash part)\n   * \"geolocationServiceAvailable\":\n   *   true if browser supports geo location services\n   *\n   * Additionally, all query parameters from the URL are put in the resulting object.\n   */\n  _createSessionStartupParams() {\n    let params = {\n      url: this.url.baseUrlRaw,\n      geolocationServiceAvailable: Device.get().supportsGeolocation()\n    };\n\n    // Extract query parameters from URL and put them in the resulting object\n    let urlParameterMap = this.url.parameterMap;\n    for (let prop in urlParameterMap) {\n      params[prop] = urlParameterMap[prop];\n    }\n    return params;\n  }\n\n  /**\n   * @param {[]} data.adapterData\n   * @param {[]} data.events\n   * @param data.startupData\n   * @param data.startupData.clientSession\n   * @param data.startupData.clientSessionId\n   * @param data.startupData.pollingInterval\n   * @param data.startupData.persistent\n   * @param data.startupData.inDevelopmentMode\n   * @param data.error\n   * @param data.sessionTerminated\n   */\n  _processStartupResponse(data) {\n    // Handle errors from server\n    if (data.error) {\n      this._processErrorJsonResponse(data.error);\n      return;\n    }\n\n    webstorage.removeItemFromSessionStorage('scout:versionMismatch');\n\n    if (!data.startupData) {\n      throw new Error('Missing startupData');\n    }\n\n    // Mark session as persistent (means a persistent session cookie is used and the client session will be restored after a browser restart)\n    this.persistent = data.startupData.persistent;\n\n    // true if the UiServer runs in development mode (see Platform.get().inDevelopmentMode())\n    this.inDevelopmentMode = !!data.startupData.inDevelopmentMode; // may be undefined\n\n    // Store clientSessionId in sessionStorage (to send the same ID again on page reload)\n    this.clientSessionId = data.startupData.clientSessionId;\n    this._storeClientSessionIdInStorage(this.clientSessionId);\n\n    // Assign server generated uiSessionId. It must be sent along with all further requests.\n    this.uiSessionId = data.startupData.uiSessionId;\n\n    // Destroy UI session on server when page is closed or reloaded\n    $(window)\n      .on('beforeunload.' + this.uiSessionId, this._onWindowBeforeUnload.bind(this))\n      .on('unload.' + this.uiSessionId, this._onWindowUnload.bind(this));\n\n    // Special case: Page must be reloaded on startup (e.g. theme changed)\n    if (data.startupData.reloadPage) {\n      scout.reloadPage();\n      return;\n    }\n\n    // Enable inspector mode if server requests it (e.g. when server is running in development mode)\n    if (data.startupData.inspector) {\n      this.inspector = true;\n    }\n\n    // Init request timeout for poller\n    this.requestTimeoutPoll = (data.startupData.pollingInterval + 15) * 1000;\n\n    // Register UI session\n    this.modelAdapterRegistry[this.uiSessionId] = this; // TODO [7.0] cgu: maybe better separate session object from event processing, create ClientSession.js?. If yes, desktop should not have rootadapter as parent, see 406\n\n    // Store adapters to adapter data cache\n    if (data.adapterData) {\n      this._copyAdapterData(data.adapterData);\n    }\n\n    this.locale = new Locale(data.startupData.locale);\n    this.textMap = texts.get(this.locale.languageTag);\n    this.textMap.addAll(data.startupData.textMap);\n\n    // Create the desktop\n    // Extract client session data without creating a model adapter for it. It is (currently) only used to transport the desktop's adapterId.\n    let clientSessionData = this._getAdapterData(data.startupData.clientSession);\n    this.desktop = this.getOrCreateWidget(clientSessionData.desktop, this.rootAdapter.widget);\n    App.get()._triggerDesktopReady(this.desktop);\n\n    let renderDesktopImpl = function() {\n      this._renderDesktop();\n\n      // In case the server sent additional events, process them\n      if (data.events) {\n        this.processingEvents = true;\n        try {\n          this._processEvents(data.events);\n        } finally {\n          this.processingEvents = false;\n        }\n      }\n\n      // Ensure layout is valid (explicitly layout immediately and don't wait for setTimeout to run to make layouting invisible to the user)\n      this.layoutValidator.validate();\n      this.focusManager.validateFocus();\n\n      // Start poller\n      this._resumeBackgroundJobPolling();\n\n      this.ready = true;\n      App.get()._triggerSessionReady(this);\n\n      $.log.isInfoEnabled() && $.log.info('Session initialized. Detected ' + Device.get());\n      if ($.log.isDebugEnabled()) {\n        $.log.isDebugEnabled() && $.log.debug('size of _adapterDataCache after session has been initialized: ' + objects.countOwnProperties(this._adapterDataCache));\n        $.log.isDebugEnabled() && $.log.debug('size of modelAdapterRegistry after session has been initialized: ' + objects.countOwnProperties(this.modelAdapterRegistry));\n      }\n    }.bind(this);\n\n    this.render(renderDesktopImpl);\n  }\n\n  _storeClientSessionIdInStorage(clientSessionId) {\n    let key = 'scout:clientSessionId';\n    webstorage.removeItemFromSessionStorage(key);\n    webstorage.removeItemFromLocalStorage(key);\n    if (this.persistent) {\n      webstorage.setItemToLocalStorage(key, clientSessionId);\n    } else {\n      webstorage.setItemToSessionStorage(key, clientSessionId);\n    }\n  }\n\n  _getClientSessionIdFromStorage() {\n    let key = 'scout:clientSessionId';\n    let id = webstorage.getItemFromSessionStorage(key);\n    if (!id) {\n      // If the session is persistent it was stored in the local storage (cannot check for this.persistent here because it is not known yet)\n      id = webstorage.getItemFromLocalStorage(key);\n    }\n    return id;\n  }\n\n  render(renderFunc) {\n    // Render desktop after fonts have been preloaded (this fixes initial layouting issues when font icons are not yet ready)\n    if (fonts.loadingComplete) {\n      renderFunc();\n    } else {\n      fonts.preloader().then(renderFunc);\n    }\n  }\n\n  _sendUnloadRequest() {\n    let request = this._newRequest({\n      unload: true,\n      showBusyIndicator: false\n    });\n    // Send request\n    this._sendRequest(request);\n  }\n\n  _sendNow() {\n    if (this.asyncEvents.length === 0) {\n      // Nothing to send -> return\n      return;\n    }\n    // If an event requires a new request, only the previous events are sent now.\n    // The next requests are send the next time _sendNow is called (-> when the response to the current request arrives)\n    let events = [];\n    this.asyncEvents.some((event, i) => {\n      if (event.newRequest && events.length > 0) {\n        return true;\n      }\n      events.push(event);\n      return false;\n    });\n    let request = this._newRequest({\n      events: events\n    });\n    // Busy indicator required when at least one event requests it\n    request.showBusyIndicator = request.events.some(event => {\n      return scout.nvl(event.showBusyIndicator, true);\n    });\n    this.responseQueue.prepareRequest(request);\n    // Send request\n    this._sendRequest(request);\n    // Remove the events which are sent now from the list, keep the ones which are sent later\n    this.asyncEvents = this.asyncEvents.slice(events.length);\n  }\n\n  _coalesceEvents(previousEvents, event) {\n    if (!event.coalesce) {\n      return previousEvents;\n    }\n    let filter = $.negate(event.coalesce).bind(event);\n    return previousEvents.filter(filter);\n  }\n\n  _sendRequest(request) {\n    if (!request) {\n      return; // nothing to send\n    }\n\n    if (this.loggedOut) {\n      // Don't send any JSON requests when we are logged out. They would fail since the UI session\n      // no longer exists. This could happen when views are open and the client session is stopped.\n      // Destroying the form adapters makes the Desktop send an \"activeForm = null\" event.\n      return;\n    }\n\n    if (this.offline && !request.unload) { // In Firefox, \"offline\" is already true when page is unloaded\n      this._handleSendWhenOffline(request);\n      return;\n    }\n\n    if (request.unload && navigator.sendBeacon) {\n      // The unload request must _not_ be sent asynchronously, because the browser would cancel\n      // it when the page unload is completed. Because the support for synchronous AJAX request\n      // will apparently be dropped eventually, we use the \"sendBeacon\" method to send the unload\n      // request to the server (we don't expect an answer). Not all browsers support this method,\n      // therefore we check for its existence and fall back to (legacy) synchronous AJAX call\n      // when it is missing. More information:\n      // - http://stackoverflow.com/questions/15479103/can-beforeunload-unload-be-used-to-send-xmlhttprequests-reliably\n      // - https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/7nKMdg_ALcc\n      // - https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon\n      navigator.sendBeacon(this.unloadUrl + '/' + this.uiSessionId, '');\n      return;\n    }\n\n    let ajaxOptions = this.defaultAjaxOptions(request);\n\n    let busyHandling = scout.nvl(request.showBusyIndicator, true);\n    if (request.unload) {\n      ajaxOptions.async = false;\n    }\n    this._performUserAjaxRequest(ajaxOptions, busyHandling, request);\n  }\n\n  _handleSendWhenOffline(request) {\n    // No need to queue the request when request does not contain events (e.g. log request, unload request)\n    if (!request.events) {\n      return;\n    }\n\n    // Merge request with queued event\n    if (this._queuedRequest) {\n      if (this._queuedRequest.events) {\n        // 1. Remove request events from queued events\n        request.events.forEach(event => {\n          this._queuedRequest.events = this._coalesceEvents(this._queuedRequest.events, event);\n        });\n        // 2. Add request events to end of queued events\n        this._queuedRequest.events = this._queuedRequest.events.concat(request.events);\n      } else {\n        this._queuedRequest.events = request.events;\n      }\n    } else {\n      this._queuedRequest = request;\n    }\n    this.layoutValidator.validate();\n  }\n\n  defaultAjaxOptions(request) {\n    request = request || this._newRequest();\n    let url = this._decorateUrl(this.remoteUrl, request);\n\n    let ajaxOptions = {\n      type: 'POST',\n      dataType: 'json',\n      contentType: 'application/json; charset=UTF-8',\n      cache: false,\n      url: url,\n      data: this._requestToJson(request)\n    };\n\n    // Ensure that certain request don't run forever. When a timeout occurs, the session\n    // is put into offline mode. Note that normal requests should NOT be limited, because\n    // the server processing might take very long (e.g. long running database query).\n    ajaxOptions.timeout = 0; // \"infinite\"\n    if (request.cancel) {\n      ajaxOptions.timeout = this.requestTimeoutCancel;\n    }\n    if (request.ping) {\n      ajaxOptions.timeout = this.requestTimeoutPing;\n    }\n    if (request.pollForBackgroundJobs) {\n      ajaxOptions.timeout = this.requestTimeoutPoll;\n    }\n    return ajaxOptions;\n  }\n\n  _decorateUrl(url, request) {\n    let urlHint = null;\n    // Add dummy URL parameter as marker (for debugging purposes)\n    if (request.unload) {\n      urlHint = 'unload';\n    } else if (request.pollForBackgroundJobs) {\n      urlHint = 'poll';\n    } else if (request.ping) {\n      urlHint = 'ping';\n    } else if (request.cancel) {\n      urlHint = 'cancel';\n    } else if (request.log) {\n      urlHint = 'log';\n    } else if (request.syncResponseQueue) {\n      urlHint = 'sync';\n    }\n    if (urlHint) {\n      url = new URL(url).addParameter(urlHint)\n        .toString();\n    }\n    return url;\n  }\n\n  _getRequestName(request, defaultName) {\n    if (request) {\n      if (request.unload) {\n        return 'unload';\n      } else if (request.pollForBackgroundJobs) {\n        return 'pollForBackgroundJobs';\n      } else if (request.ping) {\n        return 'ping';\n      } else if (request.cancel) {\n        return 'cancel';\n      } else if (request.log) {\n        return 'log';\n      } else if (request.syncResponseQueue) {\n        return 'syncResponseQueue';\n      }\n    }\n    return defaultName;\n  }\n\n  _requestToJson(request) {\n    return JSON.stringify(request, function(key, value) {\n      // Replacer function that filter certain properties from the resulting JSON string.\n      // See https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n      let ignore =\n        this === request && key === 'showBusyIndicator' ||\n        this instanceof RemoteEvent && scout.isOneOf(key, 'showBusyIndicator', 'coalesce', 'newRequest');\n      return ignore ? undefined : value;\n    });\n  }\n\n  _callAjax(callOptions) {\n    let defaultOptions = {\n      retryIntervals: [100, 500, 500, 500]\n    };\n    let ajaxCall = scout.create('AjaxCall', $.extend(defaultOptions, callOptions, this.ajaxCallOptions), {\n      ensureUniqueId: false\n    });\n    this.registerAjaxCall(ajaxCall);\n    return ajaxCall.call()\n      .always(this.unregisterAjaxCall.bind(this, ajaxCall));\n  }\n\n  _performUserAjaxRequest(ajaxOptions, busyHandling, request) {\n    if (busyHandling) {\n      this.setBusy(true);\n    }\n    this.setRequestPending(true);\n\n    let jsError = null,\n      success = false;\n\n    this._callAjax({\n      ajaxOptions: ajaxOptions,\n      request: request,\n      name: this._getRequestName(request, 'user request')\n    })\n      .done(onAjaxDone.bind(this))\n      .fail(onAjaxFail.bind(this))\n      .always(onAjaxAlways.bind(this));\n\n    // ----- Helper methods -----\n\n    function onAjaxDone(data) {\n      try {\n        // Busy handling is remove _before_ processing the response, otherwise the focus cannot be set\n        // correctly, because the glasspane of the busy indicator is still visible.\n        // The second check prevents flickering of the busy indicator if there is a scheduled request\n        // that will be sent immediately afterwards (see onAjaxAlways).\n        if (busyHandling && !this.areBusyIndicatedEventsQueued()) {\n          this.setBusy(false);\n        }\n        success = this.responseQueue.process(data);\n      } catch (err) {\n        jsError = jsError || err;\n      }\n    }\n\n    function onAjaxFail(ajaxError) {\n      try {\n        if (busyHandling) {\n          this.setBusy(false);\n        }\n        this._processErrorResponse(ajaxError.jqXHR, ajaxError.textStatus, ajaxError.errorThrown, request);\n      } catch (err) {\n        jsError = jsError || err;\n      }\n    }\n\n    // Variable arguments:\n    // \"done\" --> data, textStatus, jqXHR\n    // \"fail\" --> jqXHR, textStatus, errorThrown\n    function onAjaxAlways(data, textStatus, errorThrown) {\n      this.setRequestPending(false);\n\n      // \"success\" is false when either\n      // a) an HTTP error occurred or\n      // b) a JSON response with the error flag set (UI processing error) was returned\n      if (success) {\n        this._resumeBackgroundJobPolling();\n        this._fireRequestFinished(data);\n\n        if (this._retryRequest) {\n          // Send retry request first\n          let retryRequest = this._retryRequest;\n          this._retryRequest = null;\n          this.responseQueue.prepareRequest(retryRequest);\n          this._sendRequest(retryRequest);\n        } else if (this._queuedRequest) {\n          // Send events that happened while being offline\n          let queuedRequest = this._queuedRequest;\n          this._queuedRequest = null;\n          this.responseQueue.prepareRequest(queuedRequest);\n          this._sendRequest(queuedRequest);\n        }\n\n        // If there already is a another request pending, send it now\n        // But only if it should not be sent delayed\n        if (!this._sendTimeoutId) {\n          this._sendNow();\n        }\n      } else {\n        // Ensure busy is false when an error occurred an we won't be sending more requests.\n        // It could still be true when here were more busy indicated events in the queue when\n        // the error response was received (e.g. when selecting some table rows just when the\n        // server is restarted).\n        this.setBusy(false);\n      }\n      this.layoutValidator.validate();\n\n      // Throw previously caught error\n      if (jsError) {\n        throw jsError;\n      }\n    }\n  }\n\n  registerAjaxCall(ajaxCall) {\n    this.ajaxCalls.push(ajaxCall);\n  }\n\n  unregisterAjaxCall(ajaxCall) {\n    arrays.remove(this.ajaxCalls, ajaxCall);\n  }\n\n  interruptAllAjaxCalls() {\n    // Because the error handlers alter the \"this.ajaxCalls\" array,\n    // the loop must operate on a copy of the original array!\n    this.ajaxCalls.slice().forEach(ajaxCall => {\n      ajaxCall.pendingCall && ajaxCall.pendingCall.abort();\n    });\n  }\n\n  abortAllAjaxCalls() {\n    // Because the error handlers alter the \"this.ajaxCalls\" array,\n    // the loop must operate on a copy of the original array!\n    this.ajaxCalls.slice().forEach(ajaxCall => {\n      ajaxCall.abort();\n    });\n  }\n\n  /**\n   * (Re-)starts background job polling when not started yet or when an error occurred while polling.\n   * In the latter case, polling is resumed when a user-initiated request has been successful.\n   */\n  _resumeBackgroundJobPolling() {\n    if (this.backgroundJobPollingSupport.enabled && this.backgroundJobPollingSupport.status !== BackgroundJobPollingStatus.RUNNING) {\n      $.log.isInfoEnabled() && $.log.info('Resume background jobs polling request, status was=' + this.backgroundJobPollingSupport.status);\n      this._pollForBackgroundJobs();\n    }\n  }\n\n  /**\n   * Polls the results of jobs running in the background. Note: we cannot use the _sendRequest method here\n   * since we don't want any busy handling in case of background jobs. The request may take a while, since\n   * the server doesn't return until either a time-out occurs or there's something in the response when\n   * a model job is done and no request initiated by a user is running.\n   */\n  _pollForBackgroundJobs() {\n    this.backgroundJobPollingSupport.setRunning();\n\n    let request = this._newRequest({\n      pollForBackgroundJobs: true\n    });\n    this.responseQueue.prepareRequest(request);\n\n    let ajaxOptions = this.defaultAjaxOptions(request);\n\n    this._callAjax({\n      ajaxOptions: ajaxOptions,\n      request: request,\n      name: this._getRequestName(request, 'request')\n    })\n      .done(onAjaxDone.bind(this))\n      .fail(onAjaxFail.bind(this));\n\n    // --- Helper methods ---\n\n    function onAjaxDone(data) {\n      if (data.error) {\n        // Don't schedule a new polling request, when an error occurs\n        // when the next user-initiated request succeeds, we re-enable polling\n        // otherwise the polling would ping the server to death in case of an error\n        $.log.warn('Polling request failed. Interrupt polling until the next user-initiated request succeeds');\n        this.backgroundJobPollingSupport.setFailed();\n        if (this.areRequestsPending()) {\n          // Add response to queue, handle later by _performUserAjaxRequest()\n          this.responseQueue.add(data);\n        } else {\n          // No user request pending, handle immediately\n          this.responseQueue.process(data);\n        }\n      } else if (data.sessionTerminated) {\n        $.log.info('Session terminated, stopped polling for background jobs');\n        this.backgroundJobPollingSupport.setStopped();\n        // If were are not yet logged out, redirect to the logout URL (the session that initiated the\n        // session invalidation will receive a dedicated logout event, redirect is handled there).\n        if (!this.loggedOut && data.redirectUrl) {\n          this.logout(data.redirectUrl);\n        }\n      } else {\n        try {\n          // No need to change backgroundJobPollingSupport state, it should still be RUNNING\n          if (this.areRequestsPending()) {\n            // Add response to queue, handle later by _performUserAjaxRequest()\n            this.responseQueue.add(data);\n          } else {\n            // No user request pending, handle immediately\n            this.responseQueue.process(data);\n            this.layoutValidator.validate();\n          }\n          setTimeout(this._pollForBackgroundJobs.bind(this));\n        } catch (error) {\n          this.backgroundJobPollingSupport.setFailed();\n          throw error;\n        }\n      }\n    }\n\n    function onAjaxFail(ajaxError) {\n      this.backgroundJobPollingSupport.setFailed();\n      this._processErrorResponse(ajaxError.jqXHR, ajaxError.textStatus, ajaxError.errorThrown, request);\n    }\n  }\n\n  /**\n   * Do NOT call this method directly, always use the response queue:\n   *\n   *   session.responseQueue.process(data);\n   *\n   * Otherwise, the response queue's expected sequence number will get out of sync.\n   */\n  processJsonResponseInternal(data) {\n    let success = false;\n    if (data.error) {\n      this._processErrorJsonResponse(data.error);\n    } else {\n      this._processSuccessResponse(data);\n      success = true;\n    }\n    return success;\n  }\n\n  _processSuccessResponse(message) {\n    if (message.adapterData) {\n      this._copyAdapterData(message.adapterData);\n    }\n\n    if (message.events) {\n      this.processingEvents = true;\n      try {\n        this._processEvents(message.events);\n      } finally {\n        this.processingEvents = false;\n      }\n    }\n\n    if ($.log.isDebugEnabled()) {\n      let cacheSize = objects.countOwnProperties(this._adapterDataCache);\n      $.log.trace('size of _adapterDataCache after response has been processed: ' + cacheSize);\n      cacheSize = objects.countOwnProperties(this.modelAdapterRegistry);\n      $.log.trace('size of modelAdapterRegistry after response has been processed: ' + cacheSize);\n    }\n  }\n\n  _copyAdapterData(adapterData) {\n    let count = 0;\n    let prop;\n\n    for (prop in adapterData) {\n      this._adapterDataCache[prop] = adapterData[prop];\n      count++;\n    }\n    if (count > 0) {\n      $.log.isTraceEnabled() && $.log.trace('Stored ' + count + ' properties in adapterDataCache');\n    }\n  }\n\n  /**\n   * @param textStatus 'timeout', 'abort', 'error' or 'parseerror' (see http://api.jquery.com/jquery.ajax/)\n   */\n  _processErrorResponse(jqXHR, textStatus, errorThrown, request) {\n    $.log.error('errorResponse: status=' + jqXHR.status + ', textStatus=' + textStatus + ', errorThrown=' + errorThrown);\n\n    let offlineError = AjaxCall.isOfflineError(jqXHR, textStatus, errorThrown, request);\n    if (offlineError) {\n      if (this.ready) {\n        this.goOffline();\n        if (request && !request.pollForBackgroundJobs && !this._retryRequest) {\n          this._retryRequest = request;\n        }\n        return;\n      }\n      // Not ready yet (startup request)\n      errorThrown = errorThrown || this.optText('ui.ConnectionInterrupted', 'Connection interrupted');\n    }\n\n    // Show error message\n    let boxOptions = {\n      header: this.optText('ui.NetworkError', 'Network error'),\n      body: strings.join(' ', jqXHR.status || '', errorThrown),\n      yesButtonText: this.optText('ui.Reload', 'Reload'),\n      yesButtonAction: () => scout.reloadPage(),\n      iconId: icons.SLIPPERY\n    };\n    this.showFatalMessage(boxOptions, jqXHR.status + '.net');\n  }\n\n  _processErrorJsonResponse(jsonError) {\n    if (jsonError.code === Session.JsonResponseError.VERSION_MISMATCH) {\n      let loopDetection = webstorage.getItemFromSessionStorage('scout:versionMismatch');\n      if (!loopDetection) {\n        webstorage.setItemToSessionStorage('scout:versionMismatch', 'yes');\n        // Reload page -> everything should then be up to date\n        scout.reloadPage();\n        return;\n      }\n      webstorage.removeItemFromSessionStorage('scout:versionMismatch');\n    }\n\n    if (this.loggedOut) {\n      // When the session is terminated via user request (logout button), the poller might return\n      // with a code 20. If we are already logged out, there is no need to show a message box.\n      return;\n    }\n\n    // Default values for fatal message boxes\n    let boxOptions = {\n      header: this.optText('ui.ServerError', 'Server error') + ' (' + this.optText('ui.ErrorCodeX', 'Code ' + jsonError.code, jsonError.code) + ')',\n      body: jsonError.message,\n      yesButtonText: this.optText('ui.Reload', 'Reload'),\n      yesButtonAction: () => {\n        scout.reloadPage();\n      }\n    };\n\n    // Customize for specific error codes\n    if (jsonError.code === Session.JsonResponseError.STARTUP_FAILED) {\n      // there are no texts yet if session startup failed\n      boxOptions.header = jsonError.message;\n      boxOptions.body = null;\n      boxOptions.yesButtonText = 'Retry';\n      boxOptions.iconId = icons.SLIPPERY;\n    } else if (jsonError.code === Session.JsonResponseError.SESSION_TIMEOUT) {\n      boxOptions.header = this.optText('ui.SessionTimeout', boxOptions.header);\n      boxOptions.body = this.optText('ui.SessionExpiredMsg', boxOptions.body);\n      boxOptions.iconId = icons.HOURGLASS;\n    } else if (jsonError.code === Session.JsonResponseError.UI_PROCESSING) {\n      boxOptions.header = this.optText('ui.UnexpectedProblem', boxOptions.header);\n      boxOptions.body = strings.join('\\n\\n',\n        this.optText('ui.InternalProcessingErrorMsg', boxOptions.body, ' (' + this.optText('ui.ErrorCodeX', 'Code 20', '20') + ')'),\n        this.optText('ui.UiInconsistentMsg', ''));\n      boxOptions.iconId = icons.SLIPPERY;\n      if (this.inDevelopmentMode) {\n        boxOptions.noButtonText = this.optText('ui.Ignore', 'Ignore');\n      }\n    } else if (jsonError.code === Session.JsonResponseError.UNSAFE_UPLOAD) {\n      boxOptions.header = this.optText('ui.UnsafeUpload', boxOptions.header);\n      boxOptions.body = this.optText('ui.UnsafeUploadMsg', boxOptions.body);\n      boxOptions.yesButtonText = this.optText('ui.Ok', 'Ok');\n      boxOptions.yesButtonAction = () => {\n      };\n    } else if (jsonError.code === Session.JsonResponseError.REJECTED_UPLOAD) {\n      boxOptions.header = this.optText('ui.RejectedUpload', boxOptions.header);\n      boxOptions.body = this.optText('ui.RejectedUploadMsg', boxOptions.body);\n      boxOptions.yesButtonText = this.optText('ui.Ok', 'Ok');\n      boxOptions.yesButtonAction = () => {\n      };\n    }\n    this.showFatalMessage(boxOptions, jsonError.code);\n  }\n\n  _fireRequestFinished(message) {\n    if (!this._deferred) {\n      return;\n    }\n    if (message.events) {\n      for (let i = 0; i < message.events.length; i++) {\n        this._deferredEventTypes.push(message.events[i].type);\n      }\n    }\n    if (this.requestsPendingCounter === 0) {\n      this._deferred.resolve(this._deferredEventTypes);\n      this._deferred = null;\n      this._deferredEventTypes = null;\n    }\n  }\n\n  /**\n   * Shows a UI-only message box.\n   *\n   * @param options\n   *          Options for the message box, see MessageBox\n   * @param errorCode\n   *          If defined, a second call to this method with the same errorCode will\n   *          do nothing. Can be used to prevent double messages for the same error.\n   */\n  showFatalMessage(options, errorCode) {\n    if (!errorCode) {\n      errorCode = App.get().errorHandler.getJsErrorCode();\n    }\n    if (this._fatalMessagesOnScreen[errorCode]) {\n      return;\n    }\n    this._fatalMessagesOnScreen[errorCode] = true;\n\n    options = options || {};\n    let model = {\n        session: this,\n        parent: this.desktop || new NullWidget(),\n        iconId: options.iconId,\n        severity: scout.nvl(options.severity, Status.Severity.ERROR),\n        header: options.header,\n        body: options.body,\n        hiddenText: options.hiddenText,\n        yesButtonText: options.yesButtonText,\n        noButtonText: options.noButtonText,\n        cancelButtonText: options.cancelButtonText\n      },\n      messageBox = scout.create('MessageBox', model),\n      $entryPoint = options.entryPoint || this.$entryPoint;\n\n    messageBox.on('action', event => {\n      delete this._fatalMessagesOnScreen[errorCode];\n      messageBox.destroy();\n      let option = event.option;\n      if (option === 'yes' && options.yesButtonAction) {\n        options.yesButtonAction.apply(this);\n      } else if (option === 'no' && options.noButtonAction) {\n        options.noButtonAction.apply(this);\n      } else if (option === 'cancel' && options.cancelButtonAction) {\n        options.cancelButtonAction.apply(this);\n      }\n    });\n    messageBox.render($entryPoint);\n  }\n\n  isFatalMessageShown() {\n    return Object.keys(this._fatalMessagesOnScreen).length > 0;\n  }\n\n  uploadFiles(target, files, uploadProperties, maxTotalSize, allowedTypes) {\n    let formData = new FormData(),\n      acceptedFiles = [];\n\n    if (uploadProperties) {\n      $.each(uploadProperties, (key, value) => {\n        formData.append(key, value);\n      });\n    }\n\n    $.each(files, (index, value) => {\n      if (!allowedTypes || allowedTypes.length === 0 || scout.isOneOf(value.type, allowedTypes)) {\n        /*\n         * - see ClipboardField for comments on \"scoutName\"\n         * - Some Browsers (e.g. Edge) handle an empty string as filename as if the filename is not set and therefore introduce a default filename like 'blob'.\n         *   To counter this, we introduce a empty filename string. The string consists of characters that can not occur in regular filenames, to prevent collisions.\n         */\n        let filename = scout.nvl(value.scoutName, value.name, Session.EMPTY_UPLOAD_FILENAME);\n        formData.append('files', value, filename);\n        acceptedFiles.push(value);\n      }\n    });\n\n    // 50 MB as default maximum size\n    maxTotalSize = scout.nvl(maxTotalSize, FileInput.DEFAULT_MAXIMUM_UPLOAD_SIZE);\n\n    // very large files must not be sent to server otherwise the whole system might crash (for all users).\n    if (!fileUtil.validateMaximumUploadSize(acceptedFiles, maxTotalSize)) {\n      let boxOptions = {\n        header: this.text('ui.FileSizeLimitTitle'),\n        body: this.text('ui.FileSizeLimit', maxTotalSize / 1024 / 1024),\n        yesButtonText: this.optText('Ok', 'Ok')\n      };\n\n      this.showFatalMessage(boxOptions);\n      return false;\n    }\n\n    let uploadAjaxOptions = {\n      type: 'POST',\n      url: 'upload/' + this.uiSessionId + '/' + target.id,\n      cache: false,\n      // Don't touch the data (do not convert it to string)\n      processData: false,\n      // Do not automatically add content type (otherwise, multipart boundary would be missing)\n      contentType: false,\n      data: formData\n    };\n    // Special handling for FormData polyfill\n    if (formData.polyfill) {\n      formData.applyToAjaxOptions(uploadAjaxOptions);\n    }\n    this.responseQueue.prepareHttpRequest(uploadAjaxOptions);\n\n    let busyHandling = !this.areRequestsPending();\n    this._performUserAjaxRequest(uploadAjaxOptions, busyHandling);\n    return true;\n  }\n\n  goOffline() {\n    if (this.offline) {\n      return; // already offline\n    }\n    this.offline = true;\n\n    // Abort pending ajax requests.\n    this.abortAllAjaxCalls();\n\n    // In Firefox, the current async polling request is interrupted immediately when the page is unloaded. Therefore,\n    // an offline message would appear at once on the desktop. When reloading the page, all elements are cleared anyway,\n    // thus we wait some short period of time before displaying the message and starting the reconnector. If\n    // we find that goOffline() was called because of request unloading, we skip the unnecessary part. Note that\n    // FF doesn't guarantee that _onWindowUnload() is called before this setTimeout() function is called. Therefore,\n    // we have to look at another property \"unloading\" that is set earlier in _onWindowBeforeUnload().\n    setTimeout(() => {\n      if (this.unloading || this.unloaded) {\n        return;\n      }\n      this.rootAdapter.goOffline();\n      this.reconnector.start();\n    }, 100);\n  }\n\n  goOnline() {\n    this.offline = false;\n    this.rootAdapter.goOnline();\n\n    let request = this._newRequest({\n      syncResponseQueue: true\n    });\n    this.responseQueue.prepareRequest(request);\n    this._sendRequest(request); // implies \"_resumeBackgroundJobPolling\", and also sends queued request\n  }\n\n  onReconnecting() {\n    if (this.desktop) {\n      this.desktop.onReconnecting();\n    }\n  }\n\n  onReconnectingSucceeded() {\n    if (this.desktop) {\n      this.desktop.onReconnectingSucceeded();\n    }\n    this.goOnline();\n  }\n\n  onReconnectingFailed() {\n    if (this.desktop) {\n      this.desktop.onReconnectingFailed();\n    }\n  }\n\n  listen() {\n    if (!this._deferred) {\n      this._deferred = $.Deferred();\n      this._deferredEventTypes = [];\n    }\n    return this._deferred;\n  }\n\n  /**\n   * Executes the given callback when pending requests are finished, or immediately if there are no requests pending.\n   * @param func callback function\n   * @param vararg arguments to pass to the callback function\n   */\n  onRequestsDone(func, ...vararg) {\n    if (this.areRequestsPending() || this.areEventsQueued()) {\n      this.listen().done(onEventsProcessed);\n    } else {\n      func.apply(this, vararg);\n    }\n\n    function onEventsProcessed() {\n      func.apply(this, vararg);\n    }\n  }\n\n  /**\n   * Executes the given callback when all events of the current response are processed. Executes it immediately if no events are being processed.\n   * @param func callback function\n   * @param vararg arguments to pass to the callback function\n   */\n  onEventsProcessed(func, ...vararg) {\n    if (this.processingEvents) {\n      this.one('eventsProcessed', execFunc);\n    } else {\n      execFunc();\n    }\n\n    function execFunc() {\n      func.apply(this, vararg);\n    }\n  }\n\n  areEventsQueued() {\n    return this.asyncEvents.length > 0;\n  }\n\n  areBusyIndicatedEventsQueued() {\n    return this.asyncEvents.some(event => {\n      return scout.nvl(event.showBusyIndicator, true);\n    });\n  }\n\n  areResponsesQueued() {\n    return this.responseQueue.size() > 0;\n  }\n\n  areRequestsPending() {\n    return this.requestsPendingCounter > 0;\n  }\n\n  setRequestPending(pending) {\n    if (pending) {\n      this.requestsPendingCounter++;\n    } else {\n      this.requestsPendingCounter--;\n    }\n\n    // In \"inspector\" mode, add/remove a marker attribute to the $entryPoint that\n    // can be used to detect pending server calls by UI testing tools, e.g. Selenium\n    if (this.inspector) {\n      this.$entryPoint.toggleAttr('data-request-pending', pending, 'true');\n    }\n  }\n\n  setBusy(busy) {\n    if (busy) {\n      if (!this._busy) {\n        this._renderBusy();\n      }\n      this._busy = true;\n    } else {\n      if (this._busy) {\n        this._removeBusy();\n      }\n      this._busy = false;\n    }\n  }\n\n  _renderBusy() {\n    if (this._busyIndicatorTimeoutId !== null && this._busyIndicatorTimeoutId !== undefined) {\n      // Do not schedule it twice\n      return;\n    }\n    // Don't show the busy indicator immediately. Set a short timer instead (which may be\n    // cancelled again if the busy state returns to false in the meantime).\n    this._busyIndicatorTimeoutId = setTimeout(() => {\n      if (this._busyIndicator) {\n        // busy indicator is already showing\n        return;\n      }\n      if (!this.desktop || !this.desktop.rendered) {\n        return; // No busy indicator without desktop (e.g. during shutdown)\n      }\n      this._busyIndicator = scout.create('BusyIndicator', {\n        parent: this.desktop\n      });\n      this._busyIndicator.on('cancel', this._onCancelProcessing.bind(this));\n      this._busyIndicator.render(this.$entryPoint);\n    }, 500);\n  }\n\n  _removeBusy() {\n    // Clear pending timer\n    clearTimeout(this._busyIndicatorTimeoutId);\n    this._busyIndicatorTimeoutId = null;\n\n    // Remove busy indicator (if it was already created)\n    if (this._busyIndicator) {\n      this._busyIndicator.destroy();\n      this._busyIndicator = null;\n    }\n  }\n\n  _onCancelProcessing(event) {\n    let busyIndicator = this._busyIndicator;\n    if (!busyIndicator) {\n      return; // removed in the mean time\n    }\n    busyIndicator.off('cancel');\n\n    // Set \"canceling\" state in busy indicator (after 100ms, would not look good otherwise)\n    setTimeout(() => {\n      busyIndicator.cancelled();\n    }, 100);\n\n    this._sendCancelRequest();\n  }\n\n  _sendCancelRequest() {\n    let request = this._newRequest({\n      cancel: true,\n      showBusyIndicator: false\n    });\n    this._sendRequest(request);\n  }\n\n  /**\n   * Sends a request containing the log message for logging purpose.\n   * The request is sent immediately (does not await pending requests).\n   * @param {string} message the log message\n   * @param {logging.Level} [level] the log level used to log the message. Default is {@link logging.Level.ERROR}.\n   */\n  sendLogRequest(message, level) {\n    let request = this._newRequest({\n      log: true,\n      message: message,\n      level: scout.nvl(level, logging.Level.ERROR)\n    });\n    if (this.currentEvent) {\n      request.event = {\n        target: this.currentEvent.target,\n        type: this.currentEvent.type\n      };\n    }\n\n    // Do not use _sendRequest to make sure a log request has no side effects and will be sent only once\n    $.ajax(this.defaultAjaxOptions(request));\n  }\n\n  _newRequest(requestData) {\n    let request = $.extend({\n      uiSessionId: this.uiSessionId\n    }, requestData);\n\n    // Certain requests do not require a sequence number\n    if (!request.log && !request.syncResponseQueue) {\n      request['#'] = this.requestSequenceNo++;\n    }\n    return request;\n  }\n\n  _processEvents(events) {\n    let i = 0;\n    while (i < events.length) {\n      let event = events[i];\n      this.currentEvent = event;\n\n      let adapter = this.getModelAdapter(event.target);\n      if (!adapter) {\n        // Sometimes events seem to happen \"too early\", e.g. when a \"requestFocus\" event for a field is\n        // encountered before the \"showForm\" event has been processed. If the target adapter cannot be\n        // resolved, we try the other events first, expecting them to trigger the creation of the event\n        // adapter. As soon as a event could be processed successfully, we try our postponed event again.\n        $.log.isDebugEnabled() && $.log.debug('Postponing \\'' + event.type + '\\' for adapter with ID ' + event.target);\n        i++;\n        continue;\n      }\n      // Remove the successful event and reset the pointer to the start of the remaining events (to\n      // retry previously postponed events).\n      events.splice(i, 1);\n      i = 0;\n\n      $.log.isDebugEnabled() && $.log.debug('Processing event \\'' + event.type + '\\' for adapter with ID ' + event.target);\n      adapter.onModelEvent(event);\n      adapter.resetEventFilters();\n    }\n    this.currentEvent = null;\n\n    // If there are still events whose target could not be resolved, throw an error\n    if (events.length) {\n      throw new Error('Could not resolve event targets: [' + events.map(event => {\n        let msg = 'target: ' + event.target + ', type: ' + event.type;\n        if (event.properties) {\n          msg += ', properties: ' + Object.keys(event.properties);\n        }\n        return '\"' + msg + '\"';\n      }, this).join(', ') + ']');\n    }\n    this.trigger('eventsProcessed');\n  }\n\n  start() {\n    $.log.isInfoEnabled() && $.log.info('Session starting...');\n\n    // Send startup request\n    return this._sendStartupRequest();\n  }\n\n  onModelEvent(event) {\n    if (event.type === 'localeChanged') {\n      this._onLocaleChanged(event);\n    } else if (event.type === 'logout') {\n      this._onLogout(event);\n    } else if (event.type === 'disposeAdapter') {\n      this._onDisposeAdapter(event);\n    } else if (event.type === 'reloadPage') {\n      this._onReloadPage(event);\n    } else {\n      $.log.warn('Model action \"' + event.type + '\" is not supported by UI session');\n    }\n  }\n\n  resetEventFilters() {\n    // NOP\n  }\n\n  _onLocaleChanged(event) {\n    let locale = new Locale(event.locale);\n    let textMap = new TextMap(event.textMap);\n    this.switchLocale(locale, textMap);\n  }\n\n  /**\n   * @param {Locale} the new locale\n   * @param {TextMap} [textMap] the new textMap. If not defined, the corresponding textMap for the new locale is used.\n   */\n  switchLocale(locale, textMap) {\n    scout.assertParameter('locale', locale, Locale);\n    this.locale = locale;\n    this.textMap = texts.get(locale.languageTag);\n    if (textMap) {\n      objects.copyOwnProperties(textMap, this.textMap);\n    }\n    // TODO [7.0] bsh: inform components to reformat display text? also check Collator in comparators.TEXT\n\n    this.trigger('localeSwitch', {\n      locale: this.locale\n    });\n  }\n\n  _renderDesktop() {\n    this.desktop.render(this.$entryPoint);\n    this.desktop.invalidateLayoutTree(false);\n  }\n\n  _onLogout(event) {\n    this.logout(event.redirectUrl);\n  }\n\n  logout(logoutUrl) {\n    this.loggedOut = true;\n    // TODO [7.0] bsh: Check if there is a better solution (e.g. send a flag from server \"action\" = [ \"redirect\" | \"closeWindow\" ])\n    if (this.forceNewClientSession) {\n      this.desktop.$container.window(true).close();\n    } else {\n      // remember current url to not lose query parameters (such as debug; however, ignore deeplinks)\n      let url = new URL();\n      url.removeParameter('dl'); // deeplink\n      url.removeParameter('i'); // deeplink info\n      webstorage.setItemToSessionStorage('scout:loginUrl', url.toString());\n      // Clear everything and reload the page. We wrap that in setTimeout() to allow other events to be executed normally before.\n      setTimeout(() => {\n        scout.reloadPage({\n          redirectUrl: logoutUrl\n        });\n      });\n    }\n  }\n\n  _onDisposeAdapter(event) {\n    // Model adapter was disposed on server -> dispose it on the UI, too\n    let adapter = this.getModelAdapter(event.adapter);\n    if (adapter) { // adapter may be null if it was never sent to the UI, e.g. a form that was opened and closed in the same request\n      adapter.destroy();\n    }\n  }\n\n  _onReloadPage(event) {\n    // Don't clear the body, because other events might be processed before the reload and\n    // it could cause errors when all DOM elements are already removed.\n    scout.reloadPage({\n      clearBody: false\n    });\n  }\n\n  _onWindowBeforeUnload() {\n    $.log.isInfoEnabled() && $.log.info('Session before unloading...');\n    // TODO [7.0] bsh: Cancel pending requests\n\n    // Set a flag that indicates unloading before _onWindowUnload() is called.\n    // See goOffline() why this is necessary.\n    this.unloading = true;\n    setTimeout(() => {\n      // Because there is no callback when the unloading was cancelled, we always\n      // reset the flag after a short period of time.\n      this.unloading = false;\n    }, 200);\n  }\n\n  _onWindowUnload() {\n    $.log.isInfoEnabled() && $.log.info('Session unloading...');\n    this.unloaded = true;\n\n    // Close popup windows\n    if (this.desktop && this.desktop.formController) {\n      this.desktop.formController.closePopupWindows();\n    }\n\n    // Destroy UI session on server (only when the server did not not initiate the logout,\n    // otherwise the UI session would already be disposed)\n    if (!this.loggedOut) {\n      this._sendUnloadRequest();\n    }\n    if (this.loggedOut && this.persistent) {\n      webstorage.removeItemFromLocalStorage('scout:clientSessionId');\n    }\n  }\n\n  /**\n   * Returns the adapter-data sent with the JSON response from the adapter-data cache. Note that this operation\n   * removes the requested element from the cache, thus you cannot request the same ID twice. Typically once\n   * you've requested an element from this cache an adapter for that ID is created and stored in the adapter\n   * registry which too exists on this session object.\n   */\n  _getAdapterData(id) {\n    let adapterData = this._adapterDataCache[id];\n    let deleteAdapterData = !this.adapterExportEnabled;\n    if (deleteAdapterData) {\n      delete this._adapterDataCache[id];\n    }\n    return adapterData;\n  }\n\n  getAdapterData(id) {\n    return this._adapterDataCache[id];\n  }\n\n  /**\n   * Returns the text for the given key.\n   *\n   * @param textKey key to lookup the text\n   * @param args texts to replace the placeholders specified by {0}, {1}, etc.\n   * @returns {string}\n   */\n  text(textKey, ...args) {\n    return this.textMap.get(textKey, ...args);\n  }\n\n  /**\n   * Returns the text for the given key.\n   *\n   * @param textKey key to lookup the text\n   * @param defaultValue the text to return if the key has not been found.\n   * @param args texts to replace the placeholders specified by {0}, {1}, etc.\n   * @returns {string}\n   */\n  optText(textKey, defaultValue, ...args) {\n    return this.textMap.optGet(textKey, defaultValue, ...args);\n  }\n\n  textExists(textKey) {\n    return this.textMap.exists(textKey);\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n\n  one(type, func) {\n    this.events.one(type, func);\n  }\n\n  on(type, func) {\n    return this.events.on(type, func);\n  }\n\n  off(type, func) {\n    this.events.off(type, func);\n  }\n\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n\n  when(type) {\n    return this.events.when(type);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}