{"ast":null,"code":"/*\n * Copyright (c) 2010-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { objects, strings } from '../index';\n\n/**\n * Ensures the given parameter is an array\n *\n * @template T\n * @param {T[]|T|null} array\n * @return T[]\n */\nexport function ensure(array) {\n  if (array === undefined || array === null) {\n    return [];\n  }\n  if (!Array.isArray(array)) {\n    return [array];\n  }\n  return array;\n}\n\n/**\n * Creates an array with the given length and initializes each value with the given initValue.\n */\nexport function init(length, initValue) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array[i] = initValue;\n  }\n  return array;\n}\n\n/**\n * Removes the first occurrence of the specified element from the array,\n * if it is present (optional operation).  If the array does not contain\n * the element, it is unchanged.\n *\n * @return {boolean} true if the array contained the specified element\n */\nexport function remove(arr, element) {\n  if (arr) {\n    let index = arr.indexOf(element);\n    if (index !== -1) {\n      arr.splice(index, 1);\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Removes every given element from the array\n *\n * @return {boolean} true if the array contained at least one of the specified elements\n */\nexport function removeAll(arr, elements) {\n  let modified = false;\n  if (!elements || elements.length === 0) {\n    return false;\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (elements.indexOf(arr[i]) > -1) {\n      arr.splice(i, 1);\n      modified = true;\n    }\n  }\n  return modified;\n}\n\n/**\n * @return {number} the index of the replaced element\n */\nexport function replace(arr, element, replacement) {\n  let index = arr.indexOf(element);\n  if (index !== -1) {\n    arr[index] = replacement;\n  }\n  return index;\n}\n\n/**\n * Inserts the given element at the specified index.\n * <p>\n * This function uses insertAll() which relies on Array.prototype.splice(). Check its js-doc for details.\n */\nexport function insert(arr, element, index) {\n  insertAll(arr, [element], index);\n}\n\n/**\n * Inserts all elements of the given array at the specified index.\n * <p>\n * This function is based on Array.prototype.splice().\n * Thus, if the 'index' is greater than the length of the array, 'elements' will be added to the end of the array 'arr'.\n * This may cause unexpected behavior on accessing arr[index] after insertion.\n *\n * The caller must ensure the size of the array.\n */\nexport function insertAll(arr, elements, index) {\n  elements = ensure(elements);\n  arr.splice(...[index, 0].concat(elements));\n}\n\n/**\n * Inserts the given element into the array according to the sort order indicated by the given comparison function.\n *\n * All arguments are mandatory.\n */\nexport function insertSorted(arr, element, compareFunc) {\n  // https://en.wikipedia.org/wiki/Binary_search_algorithm\n  let left = 0;\n  let right = arr.length - 1;\n  while (left <= right) {\n    let middle = left + Math.floor((right - left) / 2);\n    let c = compareFunc(arr[middle], element);\n    if (c < 0) {\n      // Search in right half\n      left = middle + 1;\n    } else if (c > 0) {\n      // Search in left half\n      right = middle - 1;\n    } else {\n      // Found an exact match.\n      // The insertion point index is equal to the last index starting from \"middle\" that matches\n      // the element. This ensures a stable insertion order (because of the device-and-conquer\n      // method, \"middle\" might be any of the elements with the same value).\n      left = middle + 1;\n      while (left < arr.length && compareFunc(arr[left], element) === 0) {\n        left++;\n      }\n      break;\n    }\n  }\n  // \"left\" now contains the index to insert the element\n  arr.splice(left, 0, element);\n}\n\n/**\n * Inserts to given element into the array directly BEFORE the first array element that matches the given predicate.\n * If no such element can be found, the new element is inserted at the BEGIN of the array.\n *\n * @template T\n * @param {T[]} arr\n * @param {T} elementToInsert\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg] optional \"this\" binding for predicate function\n */\nexport function insertBefore(arr, elementToInsert, predicate, thisArg) {\n  let index = findIndex(arr, predicate, thisArg);\n  if (index === -1) {\n    arr.unshift(elementToInsert);\n  } else {\n    insert(arr, elementToInsert, index);\n  }\n}\n\n/**\n * Inserts to given element into the array directly AFTER the first array element that matches the given predicate.\n * If no such element can be found, the new element is inserted at the END of the array.\n *\n * @template T\n * @param {T[]} arr\n * @param {T} elementToInsert\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg] optional \"this\" binding for predicate function\n */\nexport function insertAfter(arr, elementToInsert, predicate) {\n  let index = findIndex(arr, predicate);\n  if (index === -1) {\n    arr.push(elementToInsert);\n  } else {\n    insert(arr, elementToInsert, index + 1);\n  }\n}\n\n/**\n * This function uses insert() which relies on Array.prototype.splice(). Check its js-doc for details.\n */\nexport function move(arr, fromIndex, toIndex) {\n  let element = arr.splice(fromIndex, 1)[0];\n  insert(arr, element, toIndex);\n}\nexport function contains(haystack, needle) {\n  haystack = ensure(haystack);\n  return haystack.indexOf(needle) !== -1;\n}\nexport function containsAny(haystack, needles) {\n  haystack = ensure(haystack);\n  needles = ensure(needles);\n  return needles.some(element => {\n    return haystack.indexOf(element) >= 0;\n  });\n}\nexport function containsAll(haystack, needles) {\n  haystack = ensure(haystack);\n  needles = ensure(needles);\n  return needles.every(element => {\n    return haystack.indexOf(element) >= 0;\n  });\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @return {T}\n */\nexport function first(arr) {\n  if (Array.isArray(arr)) {\n    return arr[0];\n  }\n  return arr;\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @return {T}\n */\nexport function last(arr) {\n  if (Array.isArray(arr)) {\n    return arr[arr.length - 1];\n  }\n  return arr;\n}\n\n/**\n * @returns {boolean} true if the given argument is an array and has a length > 0, false in any other case.\n */\nexport function hasElements(arr) {\n  return !empty(arr);\n}\n\n/**\n * @returns {boolean} true if the given argument is not an array or the length of the array is 0, false in any other case.\n */\nexport function empty(arr) {\n  if (Array.isArray(arr)) {\n    return arr.length === 0;\n  }\n  return true;\n}\n\n/**\n * @returns {number} the size of the array, or 0 if the argument is not an array\n */\nexport function length(arr) {\n  if (Array.isArray(arr)) {\n    return arr.length;\n  }\n  return 0;\n}\nexport function pushAll(arr, arr2) {\n  arr2 = ensure(arr2);\n  arr.push(...arr2);\n}\n\n/**\n * Merges the two given arrays and removes duplicate entries in O(n).\n * If the arrays contain objects instead of primitives, it uses their id to check for equality.\n */\nexport function union(array1, array2) {\n  let result = [];\n  let map = {};\n  array1 = ensure(array1);\n  array2 = ensure(array2);\n  array1.forEach(entry => {\n    let key = entry;\n    if (typeof entry === 'object') {\n      key = entry.id;\n    }\n    map[key] = entry;\n    result.push(entry);\n  });\n  array2.forEach(entry => {\n    let key = entry;\n    if (typeof entry === 'object') {\n      key = entry.id;\n    }\n    if (!(key in map)) {\n      result.push(entry);\n    }\n  });\n  return result;\n}\nexport function equalsIgnoreOrder(arr, arr2) {\n  // noinspection DuplicatedCode\n  if (arr === arr2) {\n    return true;\n  }\n  if ((!arr || arr.length === 0) && (!arr2 || arr2.length === 0)) {\n    return true;\n  }\n  if (!arr || !arr2) {\n    return false;\n  }\n  if (arr.length !== arr2.length) {\n    return false;\n  }\n  return containsAll(arr, arr2);\n}\nexport function equals(arr, arr2) {\n  // noinspection DuplicatedCode\n  if (arr === arr2) {\n    return true;\n  }\n  if ((!arr || arr.length === 0) && (!arr2 || arr2.length === 0)) {\n    return true;\n  }\n  if (!arr || !arr2) {\n    return false;\n  }\n  if (arr.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function greater(arr, arr2) {\n  let arrLength = 0,\n    arr2Length = 0;\n  if (arr) {\n    arrLength = arr.length;\n  }\n  if (arr2) {\n    arr2Length = arr2.length;\n  }\n  return arrLength > arr2Length;\n}\nexport function eachSibling(arr, element, func) {\n  if (!arr || !func) {\n    return;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    let elementAtI = arr[i];\n    if (elementAtI !== element) {\n      func(elementAtI, i);\n    }\n  }\n}\n\n/**\n * Alternative implementation of Array.findIndex(callback [, thisArg]), which is supported by most browsers.\n * See Array.findIndex for a detailed description.\n *\n * @template T\n * @param {T[]} arr\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg] optional \"this\" binding for predicate function\n * @returns {number}\n */\nexport function findIndex(arr, predicate, thisArg) {\n  if (!arr || !predicate) {\n    return -1;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate.call(thisArg, arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg]\n * @returns {T|null}\n */\nexport function find(arr, predicate, thisArg) {\n  let index = findIndex(arr, predicate, thisArg);\n  if (index === -1) {\n    return null;\n  }\n  return arr[index];\n}\nexport function findFrom(arr, startIndex, predicate, reverse) {\n  if (reverse) {\n    return findFromReverse(arr, startIndex, predicate);\n  }\n  return findFromForward(arr, startIndex, predicate);\n}\nexport function findIndexFrom(arr, startIndex, predicate, reverse) {\n  if (reverse) {\n    return findIndexFromReverse(arr, startIndex, predicate);\n  }\n  return findIndexFromForward(arr, startIndex, predicate);\n}\nexport function findFromForward(arr, startIndex, predicate) {\n  let index = findIndexFromForward(arr, startIndex, predicate);\n  if (index === -1) {\n    return null;\n  }\n  return arr[index];\n}\nexport function findIndexFromForward(arr, startIndex, predicate) {\n  if (!arr || !predicate || startIndex >= arr.length) {\n    return -1;\n  }\n  if (startIndex < 0) {\n    startIndex = 0;\n  }\n  for (let i = startIndex; i < arr.length; i++) {\n    let element = arr[i];\n    if (predicate(element, i)) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport function findFromReverse(arr, startIndex, predicate) {\n  let index = findIndexFromReverse(arr, startIndex, predicate);\n  if (index === -1) {\n    return null;\n  }\n  return arr[index];\n}\nexport function findIndexFromReverse(arr, startIndex, predicate) {\n  if (!arr || !predicate || startIndex < 0) {\n    return -1;\n  }\n  if (startIndex >= arr.length) {\n    startIndex = arr.length - 1;\n  }\n  for (let i = startIndex; i >= 0; i--) {\n    let element = arr[i];\n    if (predicate(element, i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Pushes all elements to the given array that are not null or undefined.\n */\nexport function pushIfDefined(arr) {\n  if (arr) {\n    for (var _len = arguments.length, elements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      elements[_key - 1] = arguments[_key];\n    }\n    pushAll(arr, elements.filter(element => element !== null && element !== undefined));\n  }\n}\n\n/**\n * Pushes the given element if it does not already exist in the array and the element is truthy. Thus the array is like a Set where every element\n * can only be added once to the collection. Note: the comparison is done with the === operator.\n */\nexport function pushSet(arr, element) {\n  if (element && arr.indexOf(element) === -1) {\n    arr.push(element);\n  }\n}\n\n/**\n * Creates a string containing all elements in the array separated by the given delimiter.\n * @param {[]} arr\n * @param {string} [delimiter=null]\n * @param {boolean} [encodeHtml=false] true to encode the elements, false if not\n */\nexport function format(arr, delimiter, encodeHtml) {\n  if (!arr || arr.length === 0) {\n    return '';\n  }\n  let output = '';\n  for (let i = 0; i < arr.length; i++) {\n    let element = arr[i];\n    if (delimiter && i > 0 && i < arr.length) {\n      output += delimiter;\n    }\n    if (encodeHtml) {\n      element = strings.encode(element);\n    }\n    output += element;\n  }\n  return output;\n}\nexport function formatEncoded(arr, delimiter) {\n  return format(arr, delimiter, true);\n}\nexport function max(arr) {\n  if (arr === null || arr === undefined) {\n    return Math.max(arr);\n  }\n\n  // Math.max() returns 0 (not null!) if arr contains only null and negative elements.\n  let filtered = arr.filter(objects.isNumber);\n  return Math.max(...filtered);\n}\nexport function min(arr) {\n  if (arr === null || arr === undefined) {\n    return Math.min(arr);\n  }\n\n  // Math.min() returns 0 (not null!) if arr contains only null and non-negative elements.\n  let filtered = arr.filter(objects.isNumber);\n  return Math.min(...filtered);\n}\n\n/**\n * @returns {[]} all elements of the first array which are not in the second array\n */\nexport function diff(arr1, arr2) {\n  let diff = arr1.slice();\n  removeAll(diff, arr2);\n  return diff;\n}\nexport function flatMap(arr) {\n  let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n  let result = [];\n  ensure(arr).forEach(element => {\n    pushAll(result, func(element));\n  });\n  return result;\n}\n\n/**\n * Returns a flat array of all elements and their recursive child elements.\n *\n * @param arr The top-level list of all elements\n * @param childrenAccessor Function than extracts a list of child elements from a given element. Used to traverse the object structure.\n */\nexport function flattenRec(arr, childrenAccessor) {\n  return ensure(arr).reduce((acc, cur) => {\n    acc.push(cur);\n    if (cur && childrenAccessor) {\n      acc = acc.concat(flattenRec(childrenAccessor(cur), childrenAccessor));\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * Replacement for indexOf() that works for arrays of jQuery objects (compares DOM nodes).\n */\nexport function $indexOf(arr, $element) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i][0] === $element[0]) {\n      return i;\n    }\n  }\n}\n\n/**\n * Replacement for remove() that works for arrays of jQuery objects (compares DOM nodes).\n */\nexport function $remove(arr, $element) {\n  let index = $indexOf(arr, $element);\n  if (index >= 0) {\n    arr.splice(index, 1);\n  }\n}\nexport function randomElement(array) {\n  if (!array) {\n    return undefined;\n  }\n  if (!Array.isArray(array)) {\n    return array;\n  }\n  if (!array.length) {\n    return undefined;\n  }\n  return array[Math.floor(Math.random() * array.length)];\n}\n\n/**\n * Converts the given array to a map. For each element, key and value is determined by the given functions.\n * If no function is provided, the element itself is used.\n *\n * @template T\n * @param {T[]} array - array of elements\n * @param {function(T): string} [keyMapper] - function that maps each element to the target key\n * @param {function(T): string} [valueExtractor] - function that maps each element to the target value\n * @returns {object}\n */\nexport function toMap(array) {\n  let keyMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : el => el;\n  let valueMapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : el => el;\n  return objects.createMap(ensure(array).reduce((map, element) => {\n    map[keyMapper(element)] = valueMapper(element);\n    return map;\n  }, {}));\n}\n\n/**\n * If the argument is an empty array, null is returned. Otherwise, the argument is returned unchanged.\n *\n * @template T\n * @param {T[]} array\n * @return {T[]|null}\n */\nexport function nullIfEmpty(array) {\n  return empty(array) ? null : array;\n}\n\n/**\n * Clears the content of an array <i>in-place</i>. All elements are removed from the array and the\n * length will be set to 0. If the given argument is not an array, nothing happens.\n *\n * This is a more readable version of `array.splice(0, a.length)`.\n *\n * The return value is an array of all deleted elements (never null).\n *\n * @template T\n * @param {T[]} array\n * @return {T[]}\n */\nexport function clear(array) {\n  if (Array.isArray(array)) {\n    return array.splice(0, array.length);\n  }\n  return [];\n}\nexport default {\n  $indexOf,\n  $remove,\n  clear,\n  contains,\n  containsAll,\n  containsAny,\n  diff,\n  eachSibling,\n  empty,\n  ensure,\n  equals,\n  equalsIgnoreOrder,\n  find,\n  findFrom,\n  findFromForward,\n  findFromReverse,\n  findIndex,\n  findIndexFrom,\n  findIndexFromForward,\n  findIndexFromReverse,\n  first,\n  flatMap,\n  flattenRec,\n  format,\n  formatEncoded,\n  greater,\n  hasElements,\n  init,\n  insert,\n  insertAll,\n  insertSorted,\n  insertBefore,\n  insertAfter,\n  last,\n  length,\n  max,\n  min,\n  move,\n  nullIfEmpty,\n  pushAll,\n  pushIfDefined,\n  pushSet,\n  remove,\n  removeAll,\n  replace,\n  toMap,\n  union,\n  randomElement\n};","map":{"version":3,"names":["objects","strings","ensure","array","undefined","Array","isArray","init","length","initValue","i","remove","arr","element","index","indexOf","splice","removeAll","elements","modified","replace","replacement","insert","insertAll","concat","insertSorted","compareFunc","left","right","middle","Math","floor","c","insertBefore","elementToInsert","predicate","thisArg","findIndex","unshift","insertAfter","push","move","fromIndex","toIndex","contains","haystack","needle","containsAny","needles","some","containsAll","every","first","last","hasElements","empty","pushAll","arr2","union","array1","array2","result","map","forEach","entry","key","id","equalsIgnoreOrder","equals","greater","arrLength","arr2Length","eachSibling","func","elementAtI","call","find","findFrom","startIndex","reverse","findFromReverse","findFromForward","findIndexFrom","findIndexFromReverse","findIndexFromForward","pushIfDefined","filter","pushSet","format","delimiter","encodeHtml","output","encode","formatEncoded","max","filtered","isNumber","min","diff","arr1","slice","flatMap","x","flattenRec","childrenAccessor","reduce","acc","cur","$indexOf","$element","$remove","randomElement","random","toMap","keyMapper","el","valueMapper","createMap","nullIfEmpty","clear"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/arrays.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {objects, strings} from '../index';\n\n/**\n * Ensures the given parameter is an array\n *\n * @template T\n * @param {T[]|T|null} array\n * @return T[]\n */\nexport function ensure(array) {\n  if (array === undefined || array === null) {\n    return [];\n  }\n  if (!Array.isArray(array)) {\n    return [array];\n  }\n  return array;\n}\n\n/**\n * Creates an array with the given length and initializes each value with the given initValue.\n */\nexport function init(length, initValue) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array[i] = initValue;\n  }\n  return array;\n}\n\n/**\n * Removes the first occurrence of the specified element from the array,\n * if it is present (optional operation).  If the array does not contain\n * the element, it is unchanged.\n *\n * @return {boolean} true if the array contained the specified element\n */\nexport function remove(arr, element) {\n  if (arr) {\n    let index = arr.indexOf(element);\n    if (index !== -1) {\n      arr.splice(index, 1);\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Removes every given element from the array\n *\n * @return {boolean} true if the array contained at least one of the specified elements\n */\nexport function removeAll(arr, elements) {\n  let modified = false;\n  if (!elements || elements.length === 0) {\n    return false;\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (elements.indexOf(arr[i]) > -1) {\n      arr.splice(i, 1);\n      modified = true;\n    }\n  }\n  return modified;\n}\n\n/**\n * @return {number} the index of the replaced element\n */\nexport function replace(arr, element, replacement) {\n  let index = arr.indexOf(element);\n  if (index !== -1) {\n    arr[index] = replacement;\n  }\n  return index;\n}\n\n/**\n * Inserts the given element at the specified index.\n * <p>\n * This function uses insertAll() which relies on Array.prototype.splice(). Check its js-doc for details.\n */\nexport function insert(arr, element, index) {\n  insertAll(arr, [element], index);\n}\n\n/**\n * Inserts all elements of the given array at the specified index.\n * <p>\n * This function is based on Array.prototype.splice().\n * Thus, if the 'index' is greater than the length of the array, 'elements' will be added to the end of the array 'arr'.\n * This may cause unexpected behavior on accessing arr[index] after insertion.\n *\n * The caller must ensure the size of the array.\n */\nexport function insertAll(arr, elements, index) {\n  elements = ensure(elements);\n  arr.splice(...[index, 0].concat(elements));\n}\n\n/**\n * Inserts the given element into the array according to the sort order indicated by the given comparison function.\n *\n * All arguments are mandatory.\n */\nexport function insertSorted(arr, element, compareFunc) {\n  // https://en.wikipedia.org/wiki/Binary_search_algorithm\n  let left = 0;\n  let right = arr.length - 1;\n  while (left <= right) {\n    let middle = left + Math.floor((right - left) / 2);\n    let c = compareFunc(arr[middle], element);\n    if (c < 0) {\n      // Search in right half\n      left = middle + 1;\n    } else if (c > 0) {\n      // Search in left half\n      right = middle - 1;\n    } else {\n      // Found an exact match.\n      // The insertion point index is equal to the last index starting from \"middle\" that matches\n      // the element. This ensures a stable insertion order (because of the device-and-conquer\n      // method, \"middle\" might be any of the elements with the same value).\n      left = middle + 1;\n      while (left < arr.length && compareFunc(arr[left], element) === 0) {\n        left++;\n      }\n      break;\n    }\n  }\n  // \"left\" now contains the index to insert the element\n  arr.splice(left, 0, element);\n}\n\n/**\n * Inserts to given element into the array directly BEFORE the first array element that matches the given predicate.\n * If no such element can be found, the new element is inserted at the BEGIN of the array.\n *\n * @template T\n * @param {T[]} arr\n * @param {T} elementToInsert\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg] optional \"this\" binding for predicate function\n */\nexport function insertBefore(arr, elementToInsert, predicate, thisArg) {\n  let index = findIndex(arr, predicate, thisArg);\n  if (index === -1) {\n    arr.unshift(elementToInsert);\n  } else {\n    insert(arr, elementToInsert, index);\n  }\n}\n\n/**\n * Inserts to given element into the array directly AFTER the first array element that matches the given predicate.\n * If no such element can be found, the new element is inserted at the END of the array.\n *\n * @template T\n * @param {T[]} arr\n * @param {T} elementToInsert\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg] optional \"this\" binding for predicate function\n */\nexport function insertAfter(arr, elementToInsert, predicate) {\n  let index = findIndex(arr, predicate);\n  if (index === -1) {\n    arr.push(elementToInsert);\n  } else {\n    insert(arr, elementToInsert, index + 1);\n  }\n}\n\n/**\n * This function uses insert() which relies on Array.prototype.splice(). Check its js-doc for details.\n */\nexport function move(arr, fromIndex, toIndex) {\n  let element = arr.splice(fromIndex, 1)[0];\n  insert(arr, element, toIndex);\n}\n\nexport function contains(haystack, needle) {\n  haystack = ensure(haystack);\n  return haystack.indexOf(needle) !== -1;\n}\n\nexport function containsAny(haystack, needles) {\n  haystack = ensure(haystack);\n  needles = ensure(needles);\n  return needles.some(element => {\n    return haystack.indexOf(element) >= 0;\n  });\n}\n\nexport function containsAll(haystack, needles) {\n  haystack = ensure(haystack);\n  needles = ensure(needles);\n  return needles.every(element => {\n    return haystack.indexOf(element) >= 0;\n  });\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @return {T}\n */\nexport function first(arr) {\n  if (Array.isArray(arr)) {\n    return arr[0];\n  }\n  return arr;\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @return {T}\n */\nexport function last(arr) {\n  if (Array.isArray(arr)) {\n    return arr[arr.length - 1];\n  }\n  return arr;\n}\n\n/**\n * @returns {boolean} true if the given argument is an array and has a length > 0, false in any other case.\n */\nexport function hasElements(arr) {\n  return !empty(arr);\n}\n\n/**\n * @returns {boolean} true if the given argument is not an array or the length of the array is 0, false in any other case.\n */\nexport function empty(arr) {\n  if (Array.isArray(arr)) {\n    return arr.length === 0;\n  }\n  return true;\n}\n\n/**\n * @returns {number} the size of the array, or 0 if the argument is not an array\n */\nexport function length(arr) {\n  if (Array.isArray(arr)) {\n    return arr.length;\n  }\n  return 0;\n}\n\nexport function pushAll(arr, arr2) {\n  arr2 = ensure(arr2);\n  arr.push(...arr2);\n}\n\n/**\n * Merges the two given arrays and removes duplicate entries in O(n).\n * If the arrays contain objects instead of primitives, it uses their id to check for equality.\n */\nexport function union(array1, array2) {\n  let result = [];\n  let map = {};\n\n  array1 = ensure(array1);\n  array2 = ensure(array2);\n\n  array1.forEach(entry => {\n    let key = entry;\n    if (typeof entry === 'object') {\n      key = entry.id;\n    }\n    map[key] = entry;\n    result.push(entry);\n  });\n\n  array2.forEach(entry => {\n    let key = entry;\n    if (typeof entry === 'object') {\n      key = entry.id;\n    }\n    if (!(key in map)) {\n      result.push(entry);\n    }\n  });\n\n  return result;\n}\n\nexport function equalsIgnoreOrder(arr, arr2) {\n  // noinspection DuplicatedCode\n  if (arr === arr2) {\n    return true;\n  }\n  if ((!arr || arr.length === 0) && (!arr2 || arr2.length === 0)) {\n    return true;\n  }\n  if (!arr || !arr2) {\n    return false;\n  }\n  if (arr.length !== arr2.length) {\n    return false;\n  }\n  return containsAll(arr, arr2);\n}\n\nexport function equals(arr, arr2) {\n  // noinspection DuplicatedCode\n  if (arr === arr2) {\n    return true;\n  }\n  if ((!arr || arr.length === 0) && (!arr2 || arr2.length === 0)) {\n    return true;\n  }\n  if (!arr || !arr2) {\n    return false;\n  }\n  if (arr.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function greater(arr, arr2) {\n  let arrLength = 0,\n    arr2Length = 0;\n  if (arr) {\n    arrLength = arr.length;\n  }\n  if (arr2) {\n    arr2Length = arr2.length;\n  }\n  return arrLength > arr2Length;\n}\n\nexport function eachSibling(arr, element, func) {\n  if (!arr || !func) {\n    return;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    let elementAtI = arr[i];\n    if (elementAtI !== element) {\n      func(elementAtI, i);\n    }\n  }\n}\n\n/**\n * Alternative implementation of Array.findIndex(callback [, thisArg]), which is supported by most browsers.\n * See Array.findIndex for a detailed description.\n *\n * @template T\n * @param {T[]} arr\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg] optional \"this\" binding for predicate function\n * @returns {number}\n */\nexport function findIndex(arr, predicate, thisArg) {\n  if (!arr || !predicate) {\n    return -1;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate.call(thisArg, arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {function(T): boolean} predicate\n * @param {*} [thisArg]\n * @returns {T|null}\n */\nexport function find(arr, predicate, thisArg) {\n  let index = findIndex(arr, predicate, thisArg);\n  if (index === -1) {\n    return null;\n  }\n  return arr[index];\n}\n\nexport function findFrom(arr, startIndex, predicate, reverse) {\n  if (reverse) {\n    return findFromReverse(arr, startIndex, predicate);\n  }\n  return findFromForward(arr, startIndex, predicate);\n}\n\nexport function findIndexFrom(arr, startIndex, predicate, reverse) {\n  if (reverse) {\n    return findIndexFromReverse(arr, startIndex, predicate);\n  }\n  return findIndexFromForward(arr, startIndex, predicate);\n}\n\nexport function findFromForward(arr, startIndex, predicate) {\n  let index = findIndexFromForward(arr, startIndex, predicate);\n  if (index === -1) {\n    return null;\n  }\n  return arr[index];\n}\n\nexport function findIndexFromForward(arr, startIndex, predicate) {\n  if (!arr || !predicate || startIndex >= arr.length) {\n    return -1;\n  }\n  if (startIndex < 0) {\n    startIndex = 0;\n  }\n  for (let i = startIndex; i < arr.length; i++) {\n    let element = arr[i];\n    if (predicate(element, i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function findFromReverse(arr, startIndex, predicate) {\n  let index = findIndexFromReverse(arr, startIndex, predicate);\n  if (index === -1) {\n    return null;\n  }\n  return arr[index];\n}\n\nexport function findIndexFromReverse(arr, startIndex, predicate) {\n  if (!arr || !predicate || startIndex < 0) {\n    return -1;\n  }\n  if (startIndex >= arr.length) {\n    startIndex = arr.length - 1;\n  }\n  for (let i = startIndex; i >= 0; i--) {\n    let element = arr[i];\n    if (predicate(element, i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Pushes all elements to the given array that are not null or undefined.\n */\nexport function pushIfDefined(arr, ...elements) {\n  if (arr) {\n    pushAll(arr, elements.filter(element => element !== null && element !== undefined));\n  }\n}\n\n/**\n * Pushes the given element if it does not already exist in the array and the element is truthy. Thus the array is like a Set where every element\n * can only be added once to the collection. Note: the comparison is done with the === operator.\n */\nexport function pushSet(arr, element) {\n  if (element && arr.indexOf(element) === -1) {\n    arr.push(element);\n  }\n}\n\n/**\n * Creates a string containing all elements in the array separated by the given delimiter.\n * @param {[]} arr\n * @param {string} [delimiter=null]\n * @param {boolean} [encodeHtml=false] true to encode the elements, false if not\n */\nexport function format(arr, delimiter, encodeHtml) {\n  if (!arr || arr.length === 0) {\n    return '';\n  }\n\n  let output = '';\n  for (let i = 0; i < arr.length; i++) {\n    let element = arr[i];\n    if (delimiter && i > 0 && i < arr.length) {\n      output += delimiter;\n    }\n    if (encodeHtml) {\n      element = strings.encode(element);\n    }\n    output += element;\n  }\n  return output;\n}\n\nexport function formatEncoded(arr, delimiter) {\n  return format(arr, delimiter, true);\n}\n\nexport function max(arr) {\n  if (arr === null || arr === undefined) {\n    return Math.max(arr);\n  }\n\n  // Math.max() returns 0 (not null!) if arr contains only null and negative elements.\n  let filtered = arr.filter(objects.isNumber);\n  return Math.max(...filtered);\n}\n\nexport function min(arr) {\n  if (arr === null || arr === undefined) {\n    return Math.min(arr);\n  }\n\n  // Math.min() returns 0 (not null!) if arr contains only null and non-negative elements.\n  let filtered = arr.filter(objects.isNumber);\n  return Math.min(...filtered);\n}\n\n/**\n * @returns {[]} all elements of the first array which are not in the second array\n */\nexport function diff(arr1, arr2) {\n  let diff = arr1.slice();\n  removeAll(diff, arr2);\n  return diff;\n}\n\nexport function flatMap(arr, func = (x => x)) {\n  let result = [];\n  ensure(arr).forEach(element => {\n    pushAll(result, func(element));\n  });\n  return result;\n}\n\n/**\n * Returns a flat array of all elements and their recursive child elements.\n *\n * @param arr The top-level list of all elements\n * @param childrenAccessor Function than extracts a list of child elements from a given element. Used to traverse the object structure.\n */\nexport function flattenRec(arr, childrenAccessor) {\n  return ensure(arr).reduce((acc, cur) => {\n    acc.push(cur);\n    if (cur && childrenAccessor) {\n      acc = acc.concat(flattenRec(childrenAccessor(cur), childrenAccessor));\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * Replacement for indexOf() that works for arrays of jQuery objects (compares DOM nodes).\n */\nexport function $indexOf(arr, $element) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i][0] === $element[0]) {\n      return i;\n    }\n  }\n}\n\n/**\n * Replacement for remove() that works for arrays of jQuery objects (compares DOM nodes).\n */\nexport function $remove(arr, $element) {\n  let index = $indexOf(arr, $element);\n  if (index >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nexport function randomElement(array) {\n  if (!array) {\n    return undefined;\n  }\n  if (!Array.isArray(array)) {\n    return array;\n  }\n  if (!array.length) {\n    return undefined;\n  }\n  return array[Math.floor(Math.random() * array.length)];\n}\n\n/**\n * Converts the given array to a map. For each element, key and value is determined by the given functions.\n * If no function is provided, the element itself is used.\n *\n * @template T\n * @param {T[]} array - array of elements\n * @param {function(T): string} [keyMapper] - function that maps each element to the target key\n * @param {function(T): string} [valueExtractor] - function that maps each element to the target value\n * @returns {object}\n */\nexport function toMap(array, keyMapper = (el => el), valueMapper = (el => el)) {\n  return objects.createMap(ensure(array).reduce((map, element) => {\n    map[keyMapper(element)] = valueMapper(element);\n    return map;\n  }, {}));\n}\n\n/**\n * If the argument is an empty array, null is returned. Otherwise, the argument is returned unchanged.\n *\n * @template T\n * @param {T[]} array\n * @return {T[]|null}\n */\nexport function nullIfEmpty(array) {\n  return empty(array) ? null : array;\n}\n\n/**\n * Clears the content of an array <i>in-place</i>. All elements are removed from the array and the\n * length will be set to 0. If the given argument is not an array, nothing happens.\n *\n * This is a more readable version of `array.splice(0, a.length)`.\n *\n * The return value is an array of all deleted elements (never null).\n *\n * @template T\n * @param {T[]} array\n * @return {T[]}\n */\nexport function clear(array) {\n  if (Array.isArray(array)) {\n    return array.splice(0, array.length);\n  }\n  return [];\n}\n\nexport default {\n  $indexOf,\n  $remove,\n  clear,\n  contains,\n  containsAll,\n  containsAny,\n  diff,\n  eachSibling,\n  empty,\n  ensure,\n  equals,\n  equalsIgnoreOrder,\n  find,\n  findFrom,\n  findFromForward,\n  findFromReverse,\n  findIndex,\n  findIndexFrom,\n  findIndexFromForward,\n  findIndexFromReverse,\n  first,\n  flatMap,\n  flattenRec,\n  format,\n  formatEncoded,\n  greater,\n  hasElements,\n  init,\n  insert,\n  insertAll,\n  insertSorted,\n  insertBefore,\n  insertAfter,\n  last,\n  length,\n  max,\n  min,\n  move,\n  nullIfEmpty,\n  pushAll,\n  pushIfDefined,\n  pushSet,\n  remove,\n  removeAll,\n  replace,\n  toMap,\n  union,\n  randomElement\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}