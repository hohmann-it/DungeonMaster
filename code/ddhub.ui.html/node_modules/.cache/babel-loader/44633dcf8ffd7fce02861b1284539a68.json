{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, InputFieldKeyStrokeContext, keys, mimeTypes, scout, Session, strings, ValueField } from '../../../index';\nimport $ from 'jquery';\nexport default class ClipboardField extends ValueField {\n  constructor() {\n    super();\n    this.allowedMimeTypes = null;\n    this.maximumSize = null;\n    this._fileUploadWaitRetryCountTimeout = 99;\n    this._fullSelectionLength = 0;\n  }\n\n  // Keys that don't alter the content of a text field and are therefore always allowed in the clipboard field\n\n  /**\n   * @override Widget.js\n   */\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n  _render() {\n    // We don't use makeDiv() here intentionally because the DIV created must\n    // not have the 'unselectable' attribute.\n    this.addContainer(this.$parent, 'clipboard-field');\n    this.addLabel();\n    this.addField(this.$parent.makeElement('<div>').addClass('input-field'));\n    this.addStatus();\n    this.$field.disableSpellcheck().attr('contenteditable', true).attr('tabindex', '0').on('keydown', this._onKeyDown.bind(this)).on('input', this._onInput.bind(this)).on('paste', this._onPaste.bind(this)).on('copy', this._onCopy.bind(this)).on('cut', this._onCopy.bind(this));\n  }\n  _getDragAndDropHandlerOptions() {\n    let options = super._getDragAndDropHandlerOptions();\n    options.allowedTypes = () => this.allowedMimeTypes;\n    // use the smaller property (this.maximumSize for backwards compatibility) but ignore null values which would result in a maximum size of zero.\n    options.dropMaximumSize = () => Math.min(scout.nvl(this.dropMaximumSize, Number.MAX_VALUE), scout.nvl(this.maximumSize, Number.MAX_VALUE));\n    return options;\n  }\n  _renderDisplayText() {\n    let displayText = this.displayText;\n    let img;\n    this.$field.children().each((idx, elem) => {\n      if (!img && elem.nodeName === 'IMG') {\n        img = elem;\n      }\n    });\n    if (strings.hasText(displayText)) {\n      this.$field.html(strings.nl2br(displayText, true));\n      this._installScrollbars();\n      setTimeout(() => {\n        this.$field.selectAllText();\n        // store length of full selection, in order to determine if the whole text is selected in \"onCopy\"\n        let selection = this._getSelection();\n        this._fullSelectionLength = selection ? selection.toString().length : 0;\n      });\n    } else {\n      this.$field.empty();\n    }\n    // restore old img for firefox upload mechanism.\n    if (img) {\n      this.$field.prepend(img);\n    }\n  }\n\n  // Because a <div> is used as field, jQuery's val() used in ValueField.js is not working here, so\n  // the content of displayText variable is used instead.\n  // (For reading the displayText innerHmtl() _could_ be used on the div-field, but some browsers\n  // would collapse whitespaces which would also collapse multiple tabs when coping some table rows.\n  // So instead of reading the effective displayText from the field, the internal displayText value\n  // will be reused without actual reading. Parsing of pasted content is handled onPaste() and stored\n  // in this.displayText.)\n  _readDisplayText() {\n    return this.displayText;\n  }\n  _getSelection() {\n    let selection,\n      myWindow = this.$container.window(true);\n    if (myWindow.getSelection) {\n      selection = myWindow.getSelection();\n    } else if (document.getSelection) {\n      selection = document.getSelection();\n    }\n    if (!selection || selection.toString().length === 0) {\n      return null;\n    }\n    return selection;\n  }\n  _onKeyDown(event) {\n    if (scout.isOneOf(event.which, ClipboardField.ALWAYS_DESTRUCTIVE_KEYS)) {\n      return false; // never allowed\n    }\n\n    if (event.ctrlKey || event.altKey || event.metaKey || scout.isOneOf(event.which, ClipboardField.NON_DESTRUCTIVE_KEYS)) {\n      return; // allow bubble to other event handlers\n    }\n    // do not allow to enter something manually\n    return false;\n  }\n  _onInput(event) {\n    // if the user somehow managed to fire to input something (e.g. \"delete\" menu in FF & IE), just reset the value to the previous content\n    this._renderDisplayText();\n    return false;\n  }\n  _onCopy(event) {\n    if (Device.get().isIos() && this._onIosCopy(event) === false) {\n      return;\n    }\n    let selection,\n      text,\n      dataTransfer,\n      myWindow = this.$container.window(true);\n    try {\n      if (event.originalEvent.clipboardData) {\n        dataTransfer = event.originalEvent.clipboardData;\n      } else if (myWindow.clipboardData) {\n        dataTransfer = myWindow.clipboardData;\n      }\n    } catch (e) {\n      // Because windows forbids concurrent access to the clipboard, a possible exception is thrown on 'myWindow.clipboardData'\n      // (see Remarks on https://msdn.microsoft.com/en-us/library/windows/desktop/ms649048(v=vs.85).aspx)\n      // Because of this behavior a failed access will just be logged but not presented to the user.\n      $.log.error('Error while reading \"clipboardData\"', e);\n    }\n    if (!dataTransfer) {\n      $.log.error('Unable to access clipboard data.');\n      return false;\n    }\n\n    // scroll bar must not be in field when copying\n    this._uninstallScrollbars();\n    selection = this._getSelection();\n    if (!selection) {\n      return;\n    }\n\n    // if the length of the selection is equals to the length of the (initial) full selection\n    // use the internal 'displayText' value because some browsers are collapsing white spaces\n    // which lead to problems when coping data form tables with empty cells (\"\\t\\t\").\n    if (selection.toString().length === this._fullSelectionLength) {\n      text = this.displayText;\n    } else {\n      text = selection.toString();\n    }\n    try {\n      // Chrome, Firefox - causes an exception in IE\n      dataTransfer.setData('text/plain', text);\n    } catch (e) {\n      // IE, see https://www.lucidchart.com/techblog/2014/12/02/definitive-guide-copying-pasting-javascript/\n      dataTransfer.setData('Text', text);\n    }\n\n    // (re)install scroll bars\n    this._installScrollbars();\n    return false;\n  }\n  _onIosCopy(event) {\n    // Setting custom clipboard data is not possible with iOS due to a WebKit bug.\n    // The default behavior copies rich text. Since it is not expected to copy the style of the clipboard field, temporarily set color and background-color\n    // https://bugs.webkit.org/show_bug.cgi?id=176980\n    let oldStyle = this.$field.attr('style');\n    this.$field.css({\n      'color': '#000',\n      'background-color': 'transparent'\n    });\n    setTimeout(() => {\n      this.$field.attrOrRemove('style', oldStyle);\n    });\n    return false;\n  }\n  _onPaste(event) {\n    if (this.readOnly) {\n      // Prevent pasting in \"copy\" mode\n      return false;\n    }\n    let startPasteTimestamp = Date.now();\n    let dataTransfer,\n      myWindow = this.$container.window(true);\n    this.$field.selectAllText();\n    if (event.originalEvent.clipboardData) {\n      dataTransfer = event.originalEvent.clipboardData;\n    } else if (myWindow.clipboardData) {\n      dataTransfer = myWindow.clipboardData;\n    } else {\n      // unable to obtain data transfer object\n      throw new Error('Unable to access clipboard data.');\n    }\n    let filesArgument = [],\n      // options to be uploaded, arguments for this.session.uploadFiles\n      additionalOptions = {},\n      additionalOptionsCompatibilityIndex = 0,\n      // counter for additional options\n      contentCount = 0;\n\n    // some browsers (e.g. IE) specify text content simply as data of type 'Text', it is not listed in list of types\n    let textContent = dataTransfer.getData('Text');\n    if (textContent) {\n      if (window.Blob) {\n        filesArgument.push(new Blob([textContent], {\n          type: mimeTypes.TEXT_PLAIN\n        }));\n        contentCount++;\n      } else {\n        // compatibility workaround\n        additionalOptions['textTransferObject' + additionalOptionsCompatibilityIndex++] = textContent;\n        contentCount++;\n      }\n    }\n    if (contentCount === 0 && dataTransfer.items) {\n      Array.prototype.forEach.call(dataTransfer.items, item => {\n        if (item.type === mimeTypes.TEXT_PLAIN) {\n          item.getAsString(str => {\n            filesArgument.push(new Blob([str], {\n              type: mimeTypes.TEXT_PLAIN\n            }));\n            contentCount++;\n          });\n        } else if (scout.isOneOf(item.type, [mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF])) {\n          let file = item.getAsFile();\n          if (file) {\n            // When pasting an image from the clipboard, Chrome and Firefox create a File object with\n            // a generic name such as \"image.png\" or \"grafik.png\" (hardcoded in Chrome, locale-dependent\n            // in FF). It is therefore not possible to distinguish between a real file and a bitmap\n            // from the clipboard. The following code measures the time between the start of the paste\n            // event and the file's last modified timestamp. If it is \"very small\", the file is likely\n            // a bitmap from the clipboard and not a real file. In that case, add a special \"scoutName\"\n            // attribute to the file object that is then used as a filename in session.uploadFiles().\n            let lastModifiedDiff = startPasteTimestamp - file.lastModified;\n            if (lastModifiedDiff < 1000) {\n              file.scoutName = Session.EMPTY_UPLOAD_FILENAME;\n            }\n            filesArgument.push(file);\n            contentCount++;\n          }\n        }\n      });\n      this._cleanupFiles(filesArgument);\n    }\n    let waitForFileReaderEvents = 0;\n    if (contentCount === 0 && dataTransfer.files) {\n      Array.prototype.forEach.call(dataTransfer.files, item => {\n        let reader = new FileReader();\n        // register functions for file reader\n        reader.onload = event => {\n          let f = new Blob([event.target.result], {\n            type: item.type\n          });\n          f.name = item.name;\n          filesArgument.push(f);\n          waitForFileReaderEvents--;\n        };\n        reader.onerror = event => {\n          waitForFileReaderEvents--;\n          $.log.error('Error while reading file ' + item.name + ' / ' + event.target.error.code);\n        };\n        // start file reader\n        waitForFileReaderEvents++;\n        contentCount++;\n        reader.readAsArrayBuffer(item);\n      });\n    }\n\n    // upload function needs to be called asynchronously to support real files\n    let uploadFunctionTimeoutCount = 0;\n    let uploadFunction = () => {\n      if (waitForFileReaderEvents !== 0 && uploadFunctionTimeoutCount++ !== this._fileUploadWaitRetryCountTimeout) {\n        setTimeout(uploadFunction, 150);\n        return;\n      }\n      if (uploadFunctionTimeoutCount >= this._fileUploadWaitRetryCountTimeout) {\n        let boxOptions = {\n          entryPoint: this.$container.entryPoint(),\n          header: this.session.text('ui.ClipboardTimeoutTitle'),\n          body: this.session.text('ui.ClipboardTimeout'),\n          yesButtonText: this.session.text('Ok')\n        };\n        this.session.showFatalMessage(boxOptions);\n        return;\n      }\n\n      // upload paste event as files\n      if (filesArgument.length > 0 || Object.keys(additionalOptions).length > 0) {\n        this.session.uploadFiles(this, filesArgument, additionalOptions, this.maximumSize, this.allowedMimeTypes);\n      }\n    };\n\n    // upload content function, if content can not be read from event\n    // (e.g. \"Allow programmatic clipboard access\" is disabled in IE)\n    let uploadContentFunction = () => {\n      // store old inner html (will be replaced)\n      this._uninstallScrollbars();\n      let oldHtmlContent = this.$field.html();\n      this.$field.html('');\n      let restoreOldHtmlContent = () => {\n        this.$field.html(oldHtmlContent);\n        this._installScrollbars();\n      };\n      setTimeout(() => {\n        let imgElementsFound = false;\n        this.$field.children().each((idx, elem) => {\n          if (elem.nodeName === 'IMG') {\n            let srcAttr = $(elem).attr('src');\n            let srcDataMatch = /^data:(.*);base64,(.*)/.exec(srcAttr);\n            let mimeType = srcDataMatch && srcDataMatch[1];\n            if (scout.isOneOf(mimeType, mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF)) {\n              let encData = window.atob(srcDataMatch[2]); // base64 decode\n              let byteNumbers = [];\n              for (let i = 0; i < encData.length; i++) {\n                byteNumbers[i] = encData.charCodeAt(i);\n              }\n              let byteArray = new Uint8Array(byteNumbers);\n              let f = new Blob([byteArray], {\n                type: mimeType\n              });\n              f.name = '';\n              filesArgument.push(f);\n              imgElementsFound = true;\n            }\n          }\n        });\n        if (imgElementsFound) {\n          restoreOldHtmlContent();\n        } else {\n          // try to read nativly pasted text from field\n          let nativePasteContent = this.$field.text();\n          if (strings.hasText(nativePasteContent)) {\n            this.setDisplayText(nativePasteContent);\n            filesArgument.push(new Blob([nativePasteContent], {\n              type: mimeTypes.TEXT_PLAIN\n            }));\n          } else {\n            restoreOldHtmlContent();\n          }\n        }\n        uploadFunction();\n      }, 0);\n    };\n    if (contentCount > 0) {\n      uploadFunction();\n\n      // do not trigger any other actions\n      return false;\n    }\n    uploadContentFunction();\n\n    // trigger other actions to catch content\n    return true;\n  }\n\n  /**\n   * Safari creates two files when pasting an image from clipboard, one PNG and one JPEG.\n   * If that happens, remove the JPEG and only keep the PNG.\n   */\n  _cleanupFiles(files) {\n    if (files.length !== 2) {\n      return;\n    }\n    let pngImage;\n    let jpgImage;\n    files.forEach(file => {\n      // Check for the scoutName because it will only be set if it is likely a paste from clipboard event\n      if (file.name === 'image.png' && file.scoutName) {\n        pngImage = file;\n      } else if (file.name === 'image.jpeg' && file.scoutName) {\n        jpgImage = file;\n      }\n    });\n    if (pngImage && jpgImage) {\n      arrays.remove(files, jpgImage);\n    }\n  }\n}\n_defineProperty(ClipboardField, \"NON_DESTRUCTIVE_KEYS\", [\n// Default form handling\nkeys.ESC, keys.ENTER, keys.TAB,\n// Navigate and mark text\nkeys.PAGE_UP, keys.PAGE_DOWN, keys.END, keys.HOME, keys.LEFT, keys.UP, keys.RIGHT, keys.DOWN,\n// Browser hotkeys (e.g. developer tools)\nkeys.F1, keys.F2, keys.F3, keys.F4, keys.F5, keys.F6, keys.F7, keys.F8, keys.F9, keys.F10, keys.F11, keys.F12]);\n_defineProperty(ClipboardField, \"ALWAYS_DESTRUCTIVE_KEYS\", [keys.BACKSPACE, keys.DELETE]);","map":{"version":3,"names":["arrays","Device","InputFieldKeyStrokeContext","keys","mimeTypes","scout","Session","strings","ValueField","$","ClipboardField","constructor","allowedMimeTypes","maximumSize","_fileUploadWaitRetryCountTimeout","_fullSelectionLength","_createKeyStrokeContext","_render","addContainer","$parent","addLabel","addField","makeElement","addClass","addStatus","$field","disableSpellcheck","attr","on","_onKeyDown","bind","_onInput","_onPaste","_onCopy","_getDragAndDropHandlerOptions","options","allowedTypes","dropMaximumSize","Math","min","nvl","Number","MAX_VALUE","_renderDisplayText","displayText","img","children","each","idx","elem","nodeName","hasText","html","nl2br","_installScrollbars","setTimeout","selectAllText","selection","_getSelection","toString","length","empty","prepend","_readDisplayText","myWindow","$container","window","getSelection","document","event","isOneOf","which","ALWAYS_DESTRUCTIVE_KEYS","ctrlKey","altKey","metaKey","NON_DESTRUCTIVE_KEYS","get","isIos","_onIosCopy","text","dataTransfer","originalEvent","clipboardData","e","log","error","_uninstallScrollbars","setData","oldStyle","css","attrOrRemove","readOnly","startPasteTimestamp","Date","now","Error","filesArgument","additionalOptions","additionalOptionsCompatibilityIndex","contentCount","textContent","getData","Blob","push","type","TEXT_PLAIN","items","Array","prototype","forEach","call","item","getAsString","str","IMAGE_PNG","IMAGE_JPG","IMAGE_JPEG","IMAGE_GIF","file","getAsFile","lastModifiedDiff","lastModified","scoutName","EMPTY_UPLOAD_FILENAME","_cleanupFiles","waitForFileReaderEvents","files","reader","FileReader","onload","f","target","result","name","onerror","code","readAsArrayBuffer","uploadFunctionTimeoutCount","uploadFunction","boxOptions","entryPoint","header","session","body","yesButtonText","showFatalMessage","Object","uploadFiles","uploadContentFunction","oldHtmlContent","restoreOldHtmlContent","imgElementsFound","srcAttr","srcDataMatch","exec","mimeType","encData","atob","byteNumbers","i","charCodeAt","byteArray","Uint8Array","nativePasteContent","setDisplayText","pngImage","jpgImage","remove","ESC","ENTER","TAB","PAGE_UP","PAGE_DOWN","END","HOME","LEFT","UP","RIGHT","DOWN","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","BACKSPACE","DELETE"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/clipboardfield/ClipboardField.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, InputFieldKeyStrokeContext, keys, mimeTypes, scout, Session, strings, ValueField} from '../../../index';\nimport $ from 'jquery';\n\nexport default class ClipboardField extends ValueField {\n\n  constructor() {\n    super();\n\n    this.allowedMimeTypes = null;\n    this.maximumSize = null;\n    this._fileUploadWaitRetryCountTimeout = 99;\n    this._fullSelectionLength = 0;\n  }\n\n  // Keys that don't alter the content of a text field and are therefore always allowed in the clipboard field\n  static NON_DESTRUCTIVE_KEYS = [\n    // Default form handling\n    keys.ESC,\n    keys.ENTER,\n    keys.TAB,\n    // Navigate and mark text\n    keys.PAGE_UP,\n    keys.PAGE_DOWN,\n    keys.END,\n    keys.HOME,\n    keys.LEFT,\n    keys.UP,\n    keys.RIGHT,\n    keys.DOWN,\n    // Browser hotkeys (e.g. developer tools)\n    keys.F1,\n    keys.F2,\n    keys.F3,\n    keys.F4,\n    keys.F5,\n    keys.F6,\n    keys.F7,\n    keys.F8,\n    keys.F9,\n    keys.F10,\n    keys.F11,\n    keys.F12\n  ];\n\n  // Keys that always alter the content of a text field, independent from the modifier keys\n  static ALWAYS_DESTRUCTIVE_KEYS = [\n    keys.BACKSPACE,\n    keys.DELETE\n  ];\n\n  /**\n   * @override Widget.js\n   */\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n\n  _render() {\n    // We don't use makeDiv() here intentionally because the DIV created must\n    // not have the 'unselectable' attribute.\n    this.addContainer(this.$parent, 'clipboard-field');\n    this.addLabel();\n    this.addField(this.$parent.makeElement('<div>').addClass('input-field'));\n    this.addStatus();\n\n    this.$field\n      .disableSpellcheck()\n      .attr('contenteditable', true)\n      .attr('tabindex', '0')\n      .on('keydown', this._onKeyDown.bind(this))\n      .on('input', this._onInput.bind(this))\n      .on('paste', this._onPaste.bind(this))\n      .on('copy', this._onCopy.bind(this))\n      .on('cut', this._onCopy.bind(this));\n  }\n\n  _getDragAndDropHandlerOptions() {\n    let options = super._getDragAndDropHandlerOptions();\n    options.allowedTypes = () => this.allowedMimeTypes;\n    // use the smaller property (this.maximumSize for backwards compatibility) but ignore null values which would result in a maximum size of zero.\n    options.dropMaximumSize = () => Math.min(scout.nvl(this.dropMaximumSize, Number.MAX_VALUE), scout.nvl(this.maximumSize, Number.MAX_VALUE));\n    return options;\n  }\n\n  _renderDisplayText() {\n    let displayText = this.displayText;\n    let img;\n    this.$field.children().each((idx, elem) => {\n      if (!img && elem.nodeName === 'IMG') {\n        img = elem;\n      }\n    });\n\n    if (strings.hasText(displayText)) {\n      this.$field.html(strings.nl2br(displayText, true));\n      this._installScrollbars();\n\n      setTimeout(() => {\n        this.$field.selectAllText();\n        // store length of full selection, in order to determine if the whole text is selected in \"onCopy\"\n        let selection = this._getSelection();\n        this._fullSelectionLength = (selection) ? selection.toString().length : 0;\n      });\n    } else {\n      this.$field.empty();\n    }\n    // restore old img for firefox upload mechanism.\n    if (img) {\n      this.$field.prepend(img);\n    }\n  }\n\n  // Because a <div> is used as field, jQuery's val() used in ValueField.js is not working here, so\n  // the content of displayText variable is used instead.\n  // (For reading the displayText innerHmtl() _could_ be used on the div-field, but some browsers\n  // would collapse whitespaces which would also collapse multiple tabs when coping some table rows.\n  // So instead of reading the effective displayText from the field, the internal displayText value\n  // will be reused without actual reading. Parsing of pasted content is handled onPaste() and stored\n  // in this.displayText.)\n  _readDisplayText() {\n    return this.displayText;\n  }\n\n  _getSelection() {\n    let selection, myWindow = this.$container.window(true);\n    if (myWindow.getSelection) {\n      selection = myWindow.getSelection();\n    } else if (document.getSelection) {\n      selection = document.getSelection();\n    }\n    if (!selection || selection.toString().length === 0) {\n      return null;\n    }\n    return selection;\n  }\n\n  _onKeyDown(event) {\n    if (scout.isOneOf(event.which, ClipboardField.ALWAYS_DESTRUCTIVE_KEYS)) {\n      return false; // never allowed\n    }\n    if (event.ctrlKey || event.altKey || event.metaKey || scout.isOneOf(event.which, ClipboardField.NON_DESTRUCTIVE_KEYS)) {\n      return; // allow bubble to other event handlers\n    }\n    // do not allow to enter something manually\n    return false;\n  }\n\n  _onInput(event) {\n    // if the user somehow managed to fire to input something (e.g. \"delete\" menu in FF & IE), just reset the value to the previous content\n    this._renderDisplayText();\n    return false;\n  }\n\n  _onCopy(event) {\n    if (Device.get().isIos() && this._onIosCopy(event) === false) {\n      return;\n    }\n\n    let selection, text, dataTransfer, myWindow = this.$container.window(true);\n    try {\n      if (event.originalEvent.clipboardData) {\n        dataTransfer = event.originalEvent.clipboardData;\n      } else if (myWindow.clipboardData) {\n        dataTransfer = myWindow.clipboardData;\n      }\n    } catch (e) {\n      // Because windows forbids concurrent access to the clipboard, a possible exception is thrown on 'myWindow.clipboardData'\n      // (see Remarks on https://msdn.microsoft.com/en-us/library/windows/desktop/ms649048(v=vs.85).aspx)\n      // Because of this behavior a failed access will just be logged but not presented to the user.\n      $.log.error('Error while reading \"clipboardData\"', e);\n    }\n    if (!dataTransfer) {\n      $.log.error('Unable to access clipboard data.');\n      return false;\n    }\n\n    // scroll bar must not be in field when copying\n    this._uninstallScrollbars();\n\n    selection = this._getSelection();\n    if (!selection) {\n      return;\n    }\n\n    // if the length of the selection is equals to the length of the (initial) full selection\n    // use the internal 'displayText' value because some browsers are collapsing white spaces\n    // which lead to problems when coping data form tables with empty cells (\"\\t\\t\").\n    if (selection.toString().length === this._fullSelectionLength) {\n      text = this.displayText;\n    } else {\n      text = selection.toString();\n    }\n\n    try {\n      // Chrome, Firefox - causes an exception in IE\n      dataTransfer.setData('text/plain', text);\n    } catch (e) {\n      // IE, see https://www.lucidchart.com/techblog/2014/12/02/definitive-guide-copying-pasting-javascript/\n      dataTransfer.setData('Text', text);\n    }\n\n    // (re)install scroll bars\n    this._installScrollbars();\n\n    return false;\n  }\n\n  _onIosCopy(event) {\n    // Setting custom clipboard data is not possible with iOS due to a WebKit bug.\n    // The default behavior copies rich text. Since it is not expected to copy the style of the clipboard field, temporarily set color and background-color\n    // https://bugs.webkit.org/show_bug.cgi?id=176980\n    let oldStyle = this.$field.attr('style');\n    this.$field.css({\n      'color': '#000',\n      'background-color': 'transparent'\n    });\n    setTimeout(() => {\n      this.$field.attrOrRemove('style', oldStyle);\n    });\n    return false;\n  }\n\n  _onPaste(event) {\n    if (this.readOnly) {\n      // Prevent pasting in \"copy\" mode\n      return false;\n    }\n\n    let startPasteTimestamp = Date.now();\n    let dataTransfer, myWindow = this.$container.window(true);\n    this.$field.selectAllText();\n    if (event.originalEvent.clipboardData) {\n      dataTransfer = event.originalEvent.clipboardData;\n    } else if (myWindow.clipboardData) {\n      dataTransfer = myWindow.clipboardData;\n    } else {\n      // unable to obtain data transfer object\n      throw new Error('Unable to access clipboard data.');\n    }\n\n    let filesArgument = [], // options to be uploaded, arguments for this.session.uploadFiles\n      additionalOptions = {},\n      additionalOptionsCompatibilityIndex = 0, // counter for additional options\n      contentCount = 0;\n\n    // some browsers (e.g. IE) specify text content simply as data of type 'Text', it is not listed in list of types\n    let textContent = dataTransfer.getData('Text');\n    if (textContent) {\n      if (window.Blob) {\n        filesArgument.push(new Blob([textContent], {\n          type: mimeTypes.TEXT_PLAIN\n        }));\n        contentCount++;\n      } else {\n        // compatibility workaround\n        additionalOptions['textTransferObject' + additionalOptionsCompatibilityIndex++] = textContent;\n        contentCount++;\n      }\n    }\n\n    if (contentCount === 0 && dataTransfer.items) {\n      Array.prototype.forEach.call(dataTransfer.items, item => {\n        if (item.type === mimeTypes.TEXT_PLAIN) {\n          item.getAsString(str => {\n            filesArgument.push(new Blob([str], {\n              type: mimeTypes.TEXT_PLAIN\n            }));\n            contentCount++;\n          });\n        } else if (scout.isOneOf(item.type, [mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF])) {\n          let file = item.getAsFile();\n          if (file) {\n            // When pasting an image from the clipboard, Chrome and Firefox create a File object with\n            // a generic name such as \"image.png\" or \"grafik.png\" (hardcoded in Chrome, locale-dependent\n            // in FF). It is therefore not possible to distinguish between a real file and a bitmap\n            // from the clipboard. The following code measures the time between the start of the paste\n            // event and the file's last modified timestamp. If it is \"very small\", the file is likely\n            // a bitmap from the clipboard and not a real file. In that case, add a special \"scoutName\"\n            // attribute to the file object that is then used as a filename in session.uploadFiles().\n            let lastModifiedDiff = startPasteTimestamp - file.lastModified;\n            if (lastModifiedDiff < 1000) {\n              file.scoutName = Session.EMPTY_UPLOAD_FILENAME;\n            }\n            filesArgument.push(file);\n            contentCount++;\n          }\n        }\n      });\n      this._cleanupFiles(filesArgument);\n    }\n\n    let waitForFileReaderEvents = 0;\n    if (contentCount === 0 && dataTransfer.files) {\n      Array.prototype.forEach.call(dataTransfer.files, item => {\n        let reader = new FileReader();\n        // register functions for file reader\n        reader.onload = event => {\n          let f = new Blob([event.target.result], {\n            type: item.type\n          });\n          f.name = item.name;\n          filesArgument.push(f);\n          waitForFileReaderEvents--;\n        };\n        reader.onerror = event => {\n          waitForFileReaderEvents--;\n          $.log.error('Error while reading file ' + item.name + ' / ' + event.target.error.code);\n        };\n        // start file reader\n        waitForFileReaderEvents++;\n        contentCount++;\n        reader.readAsArrayBuffer(item);\n      });\n    }\n\n    // upload function needs to be called asynchronously to support real files\n    let uploadFunctionTimeoutCount = 0;\n    let uploadFunction = () => {\n      if (waitForFileReaderEvents !== 0 && uploadFunctionTimeoutCount++ !== this._fileUploadWaitRetryCountTimeout) {\n        setTimeout(uploadFunction, 150);\n        return;\n      }\n\n      if (uploadFunctionTimeoutCount >= this._fileUploadWaitRetryCountTimeout) {\n        let boxOptions = {\n          entryPoint: this.$container.entryPoint(),\n          header: this.session.text('ui.ClipboardTimeoutTitle'),\n          body: this.session.text('ui.ClipboardTimeout'),\n          yesButtonText: this.session.text('Ok')\n        };\n\n        this.session.showFatalMessage(boxOptions);\n        return;\n      }\n\n      // upload paste event as files\n      if (filesArgument.length > 0 || Object.keys(additionalOptions).length > 0) {\n        this.session.uploadFiles(this, filesArgument, additionalOptions, this.maximumSize, this.allowedMimeTypes);\n      }\n    };\n\n    // upload content function, if content can not be read from event\n    // (e.g. \"Allow programmatic clipboard access\" is disabled in IE)\n    let uploadContentFunction = () => {\n      // store old inner html (will be replaced)\n      this._uninstallScrollbars();\n      let oldHtmlContent = this.$field.html();\n      this.$field.html('');\n      let restoreOldHtmlContent = () => {\n        this.$field.html(oldHtmlContent);\n        this._installScrollbars();\n      };\n      setTimeout(() => {\n        let imgElementsFound = false;\n        this.$field.children().each((idx, elem) => {\n          if (elem.nodeName === 'IMG') {\n            let srcAttr = $(elem).attr('src');\n            let srcDataMatch = /^data:(.*);base64,(.*)/.exec(srcAttr);\n            let mimeType = srcDataMatch && srcDataMatch[1];\n            if (scout.isOneOf(mimeType, mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF)) {\n              let encData = window.atob(srcDataMatch[2]); // base64 decode\n              let byteNumbers = [];\n              for (let i = 0; i < encData.length; i++) {\n                byteNumbers[i] = encData.charCodeAt(i);\n              }\n              let byteArray = new Uint8Array(byteNumbers);\n              let f = new Blob([byteArray], {\n                type: mimeType\n              });\n              f.name = '';\n              filesArgument.push(f);\n              imgElementsFound = true;\n            }\n          }\n        });\n        if (imgElementsFound) {\n          restoreOldHtmlContent();\n        } else {\n          // try to read nativly pasted text from field\n          let nativePasteContent = this.$field.text();\n          if (strings.hasText(nativePasteContent)) {\n            this.setDisplayText(nativePasteContent);\n            filesArgument.push(new Blob([nativePasteContent], {\n              type: mimeTypes.TEXT_PLAIN\n            }));\n          } else {\n            restoreOldHtmlContent();\n          }\n        }\n        uploadFunction();\n      }, 0);\n    };\n\n    if (contentCount > 0) {\n      uploadFunction();\n\n      // do not trigger any other actions\n      return false;\n    }\n    uploadContentFunction();\n\n    // trigger other actions to catch content\n    return true;\n  }\n\n  /**\n   * Safari creates two files when pasting an image from clipboard, one PNG and one JPEG.\n   * If that happens, remove the JPEG and only keep the PNG.\n   */\n  _cleanupFiles(files) {\n    if (files.length !== 2) {\n      return;\n    }\n    let pngImage;\n    let jpgImage;\n    files.forEach(file => {\n      // Check for the scoutName because it will only be set if it is likely a paste from clipboard event\n      if (file.name === 'image.png' && file.scoutName) {\n        pngImage = file;\n      } else if (file.name === 'image.jpeg' && file.scoutName) {\n        jpgImage = file;\n      }\n    });\n    if (pngImage && jpgImage) {\n      arrays.remove(files, jpgImage);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}