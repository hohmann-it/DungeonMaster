{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, scout } from '../index';\nimport $ from 'jquery';\nexport default class EventSupport {\n  constructor() {\n    this._eventListeners = [];\n    this._subTypePredicates = objects.createMap();\n  }\n  _assertFunc(func) {\n    if (!func) {\n      throw new Error('Missing callback function');\n    }\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} func Event handler executed when the event is triggered. An event object is passed to the function as first parameter.\n   * @param {function} [origFunc] (optional) used internally when func is registered with one(). The property is set on the listener\n   *   object so the event-handler can be de-registered by using the original function.\n   */\n  on(type, func, origFunc) {\n    this._assertFunc(func);\n    let listener = {\n      type: type,\n      func: func,\n      origFunc: origFunc\n    };\n    this.addListener(listener);\n    return listener;\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   * The function will only be called once. After that it is automatically de-registered using {@link off}.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} func Event handler executed when the event is triggered. An event object is passed to the function as first parameter\n   */\n  one(type, func) {\n    this._assertFunc(func);\n    let offFunc = event => {\n      this.off(type, offFunc);\n      func(event);\n    };\n    return this.on(type, offFunc, func);\n  }\n\n  /**\n   * De-registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.<br/>\n   *      Important: the string must be equal to the one used for {@link on} or {@link one}. This also applies if a string containing multiple types separated by space was used.\n   * @param {function} [func] The exact same event handler that was used for registration using {@link on} or {@link one}.\n   *      If no handler is specified, all handlers are de-registered for the given type.\n   */\n  off(type, func) {\n    if (!type && !func) {\n      return;\n    }\n    for (let i = this._eventListeners.length - 1; i >= 0; i--) {\n      let listener = this._eventListeners[i];\n      let funcMatches = func === listener.func || func === listener.origFunc;\n      let typeMatches = type === listener.type;\n      let remove = false;\n      if (func && type) {\n        remove = funcMatches && typeMatches;\n      } else if (func) {\n        remove = funcMatches;\n      } else {\n        // always type. all other cases have been checked above\n        remove = typeMatches;\n      }\n      if (remove) {\n        this._eventListeners.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Adds an event handler using {@link #one()} and returns a promise.\n   * The promise is resolved as soon as the event is triggered.\n   */\n  when(type) {\n    let deferred = $.Deferred();\n    this.one(type, deferred.resolve.bind(deferred));\n    return deferred.promise();\n  }\n  addListener(listener) {\n    this._eventListeners.push(listener);\n  }\n  removeListener(listener) {\n    arrays.remove(this._eventListeners, listener);\n  }\n  count(type, func) {\n    let count = 0;\n    this._eventListeners.forEach(listener => {\n      if (type && type !== listener.type) {\n        return;\n      }\n      if (func && func !== listener.func) {\n        return;\n      }\n      count++;\n    });\n    return count;\n  }\n  trigger(type, event) {\n    event = event || {};\n    event.type = type;\n\n    // Create copy because firing a trigger might modify the list of listeners\n    let listeners = this._eventListeners.slice();\n    // Use traditional \"for\" loop to reduce size of stack trace\n    for (let i = 0; i < listeners.length; i++) {\n      let listener = listeners[i];\n      if (!listener.type || this._typeMatches(event, listener.type)) {\n        listener.func(event);\n      }\n    }\n  }\n  _typeMatches(event, listenerType) {\n    let eventType = event.type;\n    let types = listenerType.split(' ');\n    // support for multi type definition 'type1 type2 [...]'\n    for (let i = 0; i < types.length; i++) {\n      if (eventType === types[i]) {\n        return true;\n      }\n      if (this._subTypeMatches(event, types[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _subTypeMatches(event, listenerType) {\n    if (listenerType.indexOf(':') < 0) {\n      return false;\n    }\n    let parts = listenerType.split(':');\n    let type = parts[0];\n    let subType = parts[1];\n    let predicate = this._subTypePredicates[type];\n    if (!predicate) {\n      return;\n    }\n    return predicate(event, subType);\n  }\n\n  /**\n   *\n   * @param {string} type the type which could contain a sub type\n   * @param {function} predicate the predicate which will be tested when an event with the given type is triggered. The function has two parameters: event and subType\n   */\n  registerSubTypePredicate(type, predicate) {\n    scout.assertParameter('type', type);\n    scout.assertParameter('predicate', predicate);\n    this._subTypePredicates[type] = predicate;\n  }\n}","map":{"version":3,"names":["arrays","objects","scout","$","EventSupport","constructor","_eventListeners","_subTypePredicates","createMap","_assertFunc","func","Error","on","type","origFunc","listener","addListener","one","offFunc","event","off","i","length","funcMatches","typeMatches","remove","splice","when","deferred","Deferred","resolve","bind","promise","push","removeListener","count","forEach","trigger","listeners","slice","_typeMatches","listenerType","eventType","types","split","_subTypeMatches","indexOf","parts","subType","predicate","registerSubTypePredicate","assertParameter"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/EventSupport.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, scout} from '../index';\nimport $ from 'jquery';\n\nexport default class EventSupport {\n\n  constructor() {\n    this._eventListeners = [];\n    this._subTypePredicates = objects.createMap();\n  }\n\n  _assertFunc(func) {\n    if (!func) {\n      throw new Error('Missing callback function');\n    }\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} func Event handler executed when the event is triggered. An event object is passed to the function as first parameter.\n   * @param {function} [origFunc] (optional) used internally when func is registered with one(). The property is set on the listener\n   *   object so the event-handler can be de-registered by using the original function.\n   */\n  on(type, func, origFunc) {\n    this._assertFunc(func);\n    let listener = {\n      type: type,\n      func: func,\n      origFunc: origFunc\n    };\n    this.addListener(listener);\n    return listener;\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   * The function will only be called once. After that it is automatically de-registered using {@link off}.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} func Event handler executed when the event is triggered. An event object is passed to the function as first parameter\n   */\n  one(type, func) {\n    this._assertFunc(func);\n    let offFunc = event => {\n      this.off(type, offFunc);\n      func(event);\n    };\n    return this.on(type, offFunc, func);\n  }\n\n  /**\n   * De-registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.<br/>\n   *      Important: the string must be equal to the one used for {@link on} or {@link one}. This also applies if a string containing multiple types separated by space was used.\n   * @param {function} [func] The exact same event handler that was used for registration using {@link on} or {@link one}.\n   *      If no handler is specified, all handlers are de-registered for the given type.\n   */\n  off(type, func) {\n    if (!type && !func) {\n      return;\n    }\n\n    for (let i = this._eventListeners.length - 1; i >= 0; i--) {\n      let listener = this._eventListeners[i];\n      let funcMatches = (func === listener.func || func === listener.origFunc);\n      let typeMatches = (type === listener.type);\n      let remove = false;\n      if (func && type) {\n        remove = (funcMatches && typeMatches);\n      } else if (func) {\n        remove = funcMatches;\n      } else { // always type. all other cases have been checked above\n        remove = typeMatches;\n      }\n\n      if (remove) {\n        this._eventListeners.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Adds an event handler using {@link #one()} and returns a promise.\n   * The promise is resolved as soon as the event is triggered.\n   */\n  when(type) {\n    let deferred = $.Deferred();\n    this.one(type, deferred.resolve.bind(deferred));\n    return deferred.promise();\n  }\n\n  addListener(listener) {\n    this._eventListeners.push(listener);\n  }\n\n  removeListener(listener) {\n    arrays.remove(this._eventListeners, listener);\n  }\n\n  count(type, func) {\n    let count = 0;\n    this._eventListeners.forEach(listener => {\n      if (type && type !== listener.type) {\n        return;\n      }\n      if (func && func !== listener.func) {\n        return;\n      }\n      count++;\n    });\n    return count;\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.type = type;\n\n    // Create copy because firing a trigger might modify the list of listeners\n    let listeners = this._eventListeners.slice();\n    // Use traditional \"for\" loop to reduce size of stack trace\n    for (let i = 0; i < listeners.length; i++) {\n      let listener = listeners[i];\n      if (!listener.type || this._typeMatches(event, listener.type)) {\n        listener.func(event);\n      }\n    }\n  }\n\n  _typeMatches(event, listenerType) {\n    let eventType = event.type;\n    let types = listenerType.split(' ');\n    // support for multi type definition 'type1 type2 [...]'\n    for (let i = 0; i < types.length; i++) {\n      if (eventType === types[i]) {\n        return true;\n      }\n      if (this._subTypeMatches(event, types[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  _subTypeMatches(event, listenerType) {\n    if (listenerType.indexOf(':') < 0) {\n      return false;\n    }\n    let parts = listenerType.split(':');\n    let type = parts[0];\n    let subType = parts[1];\n    let predicate = this._subTypePredicates[type];\n    if (!predicate) {\n      return;\n    }\n    return predicate(event, subType);\n  }\n\n  /**\n   *\n   * @param {string} type the type which could contain a sub type\n   * @param {function} predicate the predicate which will be tested when an event with the given type is triggered. The function has two parameters: event and subType\n   */\n  registerSubTypePredicate(type, predicate) {\n    scout.assertParameter('type', type);\n    scout.assertParameter('predicate', predicate);\n    this._subTypePredicates[type] = predicate;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}