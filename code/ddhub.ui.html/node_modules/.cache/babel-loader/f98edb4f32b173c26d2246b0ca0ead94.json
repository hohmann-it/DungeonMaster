{"ast":null,"code":"/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\n\n/**\n * Definition of a date format pattern.\n *\n * A definition provides the following properties (most of which can be set with the 'options' argument):\n *\n * type:\n *   The \"group\" where the pattern definition belongs to. E.g. \"dd\" and \"d\" belong to the same group \"day\".\n *   This is used during analysis to find other definitions for the same type. Use one of the constants\n *   defined in DateFormatPatternType.\n *\n * terms:\n *   An array consisting of all pattern terms that this particular definition can handle. Multiple\n *   terms with the same meaning may be accepted (e.g. \"yyy\", \"yy\" and \"y\" can be all used for a\n *   2-digit year formatting, but different parsing rules may apply).\n *\n * dateFormat:\n *   Reference to the corresponding dateFormat object.\n *\n * formatFunction:\n *   An optional function that is used to format this particular term.\n *   @param formatContext\n *            See documentation at _createFormatContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            The function may return a string as result. If a string is returned, it is appended\n *            to the formatContext.formattedString automatically. If the formatFunction already did\n *            this, it should return \"undefined\".\n *\n * parseRegExp:\n *   A optional JavaScript RegExp object that is applied to the input string to extract this\n *   definition's term. The expression _must_ use exactly two capturing groups:\n *   [1] = matched part of the input\n *   [2] = remaining input (will be parsed later by other definitions)\n *   Example: /^(\\d{4})(.*)$/\n *\n * applyMatchFunction:\n *   If 'parseRegExp' is set and found a match, and this function is defined, it is called\n *   to apply the matched part to the parseContext.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param match\n *            The first match from the reg exp.\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            No return value.\n *\n * parseFunction:\n *   If parsing is not possible with a regular expression, this function may be defined to execute\n *   more complex parse logic.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            A string with the matched part of the input, or null if it did not match.\n */\nexport default class DateFormatPatternDefinition {\n  constructor(options) {\n    // NOSONAR\n    options = options || {};\n    this.type = options.type;\n    this.terms = options.terms;\n    this.dateFormat = options.dateFormat;\n    this.formatFunction = options.formatFunction && options.formatFunction.bind(this);\n    this.parseRegExp = options.parseRegExp;\n    this.applyMatchFunction = options.applyMatchFunction && options.applyMatchFunction.bind(this);\n    this.parseFunction = options.parseFunction && options.parseFunction.bind(this);\n  }\n  createFormatFunction(acceptedTerm) {\n    return function (formatContext) {\n      if (this.formatFunction) {\n        let result = this.formatFunction(formatContext, acceptedTerm);\n        if (result !== undefined) {\n          // convenience\n          formatContext.formattedString += result;\n        }\n      }\n    }.bind(this);\n  }\n  createParseFunction(acceptedTerm) {\n    return function (parseContext) {\n      let m, parsedTerm, match;\n      let success = false;\n      if (this.parseRegExp) {\n        // RegEx handling (default)\n        m = this.parseRegExp.exec(parseContext.inputString);\n        if (m) {\n          // match found\n          if (this.applyMatchFunction) {\n            this.applyMatchFunction(parseContext, m[1], acceptedTerm);\n          }\n          match = m[1];\n          // update remaining string\n          parseContext.inputString = m[2];\n          success = true;\n        }\n      }\n      if (!success && this.parseFunction) {\n        // Custom function\n        match = this.parseFunction(parseContext, acceptedTerm);\n        if (match !== null) {\n          success = true;\n        }\n      }\n      if (success) {\n        // If patternDefinition accepts more than one term, try to choose\n        // the form that matches the length of the match.\n        parsedTerm = this.terms[0];\n        if (this.terms.length > 1) {\n          this.terms.some(term => {\n            if (term.length === match.length) {\n              parsedTerm = term;\n              return true; // found\n            }\n\n            return false; // look further\n          });\n        }\n\n        parseContext.parsedPattern += parsedTerm;\n      }\n      return success;\n    }.bind(this);\n  }\n\n  /**\n   * @return {string|null} the accepted term (if is accepted) or null (if it is not accepted)\n   */\n  accept(term) {\n    if (term) {\n      // Check if one of the terms matches\n      for (let i = 0; i < this.terms.length; i++) {\n        if (term === this.terms[i]) {\n          return this.terms[i];\n        }\n      }\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["DateFormatPatternDefinition","constructor","options","type","terms","dateFormat","formatFunction","bind","parseRegExp","applyMatchFunction","parseFunction","createFormatFunction","acceptedTerm","formatContext","result","undefined","formattedString","createParseFunction","parseContext","m","parsedTerm","match","success","exec","inputString","length","some","term","parsedPattern","accept","i"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/text/DateFormatPatternDefinition.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\n\n/**\n * Definition of a date format pattern.\n *\n * A definition provides the following properties (most of which can be set with the 'options' argument):\n *\n * type:\n *   The \"group\" where the pattern definition belongs to. E.g. \"dd\" and \"d\" belong to the same group \"day\".\n *   This is used during analysis to find other definitions for the same type. Use one of the constants\n *   defined in DateFormatPatternType.\n *\n * terms:\n *   An array consisting of all pattern terms that this particular definition can handle. Multiple\n *   terms with the same meaning may be accepted (e.g. \"yyy\", \"yy\" and \"y\" can be all used for a\n *   2-digit year formatting, but different parsing rules may apply).\n *\n * dateFormat:\n *   Reference to the corresponding dateFormat object.\n *\n * formatFunction:\n *   An optional function that is used to format this particular term.\n *   @param formatContext\n *            See documentation at _createFormatContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            The function may return a string as result. If a string is returned, it is appended\n *            to the formatContext.formattedString automatically. If the formatFunction already did\n *            this, it should return \"undefined\".\n *\n * parseRegExp:\n *   A optional JavaScript RegExp object that is applied to the input string to extract this\n *   definition's term. The expression _must_ use exactly two capturing groups:\n *   [1] = matched part of the input\n *   [2] = remaining input (will be parsed later by other definitions)\n *   Example: /^(\\d{4})(.*)$/\n *\n * applyMatchFunction:\n *   If 'parseRegExp' is set and found a match, and this function is defined, it is called\n *   to apply the matched part to the parseContext.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param match\n *            The first match from the reg exp.\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            No return value.\n *\n * parseFunction:\n *   If parsing is not possible with a regular expression, this function may be defined to execute\n *   more complex parse logic.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            A string with the matched part of the input, or null if it did not match.\n */\nexport default class DateFormatPatternDefinition {\n  constructor(options) { // NOSONAR\n    options = options || {};\n    this.type = options.type;\n    this.terms = options.terms;\n    this.dateFormat = options.dateFormat;\n    this.formatFunction = options.formatFunction && options.formatFunction.bind(this);\n    this.parseRegExp = options.parseRegExp;\n    this.applyMatchFunction = options.applyMatchFunction && options.applyMatchFunction.bind(this);\n    this.parseFunction = options.parseFunction && options.parseFunction.bind(this);\n  }\n\n  createFormatFunction(acceptedTerm) {\n    return function(formatContext) {\n      if (this.formatFunction) {\n        let result = this.formatFunction(formatContext, acceptedTerm);\n        if (result !== undefined) { // convenience\n          formatContext.formattedString += result;\n        }\n      }\n    }.bind(this);\n  }\n\n  createParseFunction(acceptedTerm) {\n    return function(parseContext) {\n      let m, parsedTerm, match;\n\n      let success = false;\n      if (this.parseRegExp) {\n        // RegEx handling (default)\n        m = this.parseRegExp.exec(parseContext.inputString);\n        if (m) { // match found\n          if (this.applyMatchFunction) {\n            this.applyMatchFunction(parseContext, m[1], acceptedTerm);\n          }\n          match = m[1];\n          // update remaining string\n          parseContext.inputString = m[2];\n          success = true;\n        }\n      }\n      if (!success && this.parseFunction) {\n        // Custom function\n        match = this.parseFunction(parseContext, acceptedTerm);\n        if (match !== null) {\n          success = true;\n        }\n      }\n\n      if (success) {\n        // If patternDefinition accepts more than one term, try to choose\n        // the form that matches the length of the match.\n        parsedTerm = this.terms[0];\n        if (this.terms.length > 1) {\n          this.terms.some(term => {\n            if (term.length === match.length) {\n              parsedTerm = term;\n              return true; // found\n            }\n            return false; // look further\n          });\n        }\n        parseContext.parsedPattern += parsedTerm;\n      }\n      return success;\n    }.bind(this);\n  }\n\n  /**\n   * @return {string|null} the accepted term (if is accepted) or null (if it is not accepted)\n   */\n  accept(term) {\n    if (term) {\n      // Check if one of the terms matches\n      for (let i = 0; i < this.terms.length; i++) {\n        if (term === this.terms[i]) {\n          return this.terms[i];\n        }\n      }\n    }\n    return null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}