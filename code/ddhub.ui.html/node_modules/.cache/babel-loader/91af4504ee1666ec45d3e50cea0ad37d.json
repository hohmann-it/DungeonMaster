{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, ProposalChooser, scout, Tree } from '../../../index';\nexport default class TreeProposalChooser extends ProposalChooser {\n  constructor() {\n    super();\n  }\n  _createModel() {\n    let tree = scout.create('Tree', {\n      parent: this,\n      requestFocusOnNodeControlMouseDown: false,\n      scrollToSelection: true,\n      textFilterEnabled: false\n    });\n    tree.on('nodeClick', this._onNodeClick.bind(this));\n    return tree;\n  }\n  _onNodeClick(event) {\n    this.triggerLookupRowSelected(event.node);\n  }\n  selectedRow() {\n    return this.model.selectedNode();\n  }\n  isBrowseLoadIncremental() {\n    return this.smartField.browseLoadIncremental;\n  }\n  getSelectedLookupRow() {\n    let selectedNode = this.model.selectedNode();\n    if (!selectedNode) {\n      return null;\n    }\n    return selectedNode.lookupRow;\n  }\n  selectFirstLookupRow() {\n    if (this.model.nodes.length) {\n      this.model.selectNode(this.model.nodes[0]);\n    }\n  }\n  clearSelection() {\n    this.model.deselectAll();\n  }\n\n  /**\n   * @param {LookupResult} result\n   */\n  setLookupResult(result) {\n    let treeNodes,\n      treeNodesFlat,\n      lookupRows = result.lookupRows,\n      appendResult = scout.nvl(result.appendResult, false);\n    if (appendResult) {\n      treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n      treeNodes = this._flatListToSubTree(treeNodesFlat);\n      if (treeNodes.length) {\n        let parentNode = null;\n        treeNodes.forEach(treeNode => {\n          parentNode = this.model.nodesMap[treeNode.parentId];\n          this._appendChildNode(parentNode, treeNode);\n        });\n        if (parentNode) {\n          this.model.insertNodes(treeNodes, parentNode);\n        }\n      } else {\n        // remove control icon, when no child nodes are available\n        let node = this.model.nodesMap[result.rec];\n        node.leaf = true;\n        node.childrenLoaded = true;\n        this.model.updateNode(node);\n      }\n    } else {\n      this.model.deleteAllChildNodes();\n      treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n      treeNodes = this._flatListToSubTree(treeNodesFlat);\n      if (result.byText) {\n        this._expandAllParentNodes(treeNodesFlat);\n      }\n      this.model.insertNodes(treeNodes);\n    }\n    this._selectProposal(result, treeNodesFlat);\n  }\n  _expandAllParentNodes(treeNodesFlat) {\n    // when tree node is a leaf or children are not loaded yet\n    let leafs = treeNodesFlat.reduce((aggr, treeNode) => {\n      if (treeNode.leaf || !treeNode.childNodesLoaded && treeNode.childNodes.length === 0) {\n        aggr.push(treeNode);\n      }\n      return aggr;\n    }, []);\n    leafs.forEach(expandPath.bind(this));\n    function expandPath(treeNode) {\n      if (!treeNode.parentNode || treeNode.parentNode.expanded) {\n        return;\n      }\n      treeNode = treeNode.parentNode;\n      while (treeNode) {\n        this.model.setNodeExpanded(treeNode, true);\n        treeNode = treeNode.parentNode;\n      }\n    }\n  }\n  trySelectCurrentValue() {\n    let currentValue = this.smartField.getValueForSelection();\n    if (objects.isNullOrUndefined(currentValue)) {\n      return;\n    }\n    let allTreeNodes = objects.values(this.model.nodesMap);\n    let treeNode = arrays.find(allTreeNodes, node => {\n      return node.lookupRow.key === currentValue;\n    });\n    if (treeNode) {\n      this.model.selectNode(treeNode);\n    }\n  }\n  _createTreeNode(lookupRow) {\n    let initialLeaf = true,\n      expandAll = this.smartField.browseAutoExpandAll,\n      loadIncremental = this.isBrowseLoadIncremental();\n    if (loadIncremental) {\n      // when smartfield / lookup is configured as 'load incremental' it cannot expand all tree nodes\n      // because then we'd load the whole tree anyway, which is not the idea of load incremental\n      expandAll = false;\n\n      // when smartfield / lookup is configured as 'load incremental' we don't know if a node has children\n      // or not until we've made a lookup for that node. Thus all nodes are initially leaf=false, so the UI\n      // shows the expand icon.\n      initialLeaf = false;\n    }\n    return scout.create('ProposalTreeNode', {\n      parent: this.model,\n      proposalChooser: this,\n      childNodeIndex: 0,\n      enabled: lookupRow.enabled,\n      htmlEnabled: false,\n      iconId: lookupRow.iconId,\n      id: lookupRow.key,\n      parentId: lookupRow.parentKey,\n      expanded: expandAll,\n      initialExpanded: expandAll,\n      text: lookupRow.text,\n      lookupRow: lookupRow,\n      leaf: initialLeaf,\n      tooltipText: lookupRow.tooltipText\n    });\n  }\n\n  /**\n   * This function is required in the 'accept input' case to find out\n   * if we have exactly one lookup row that matches. With a tree this is a bit difficult\n   * because the lookup call does not only return the lookup rows with a match, but also\n   * their parent nodes up to the root node (which don't match).\n   *\n   * Note: because we only match nodes that have the property leaf set to true, it's not\n   * possible to accept a node with accept input that is not a leaf.\n   *\n   * @returns {TreeNode[]} the leafs in the current tree model.\n   */\n  findLeafs() {\n    let leafs = [];\n    Tree.visitNodes((node, parentNode) => {\n      if (node.leaf || !node.childNodes.length) {\n        leafs.push(node);\n      }\n    }, this.model.nodes);\n    return leafs;\n  }\n\n  /**\n   * This function creates a sub-tree from a list of flat tree nodes. It sets the parent/child references\n   * between the nodes and returns the top-level nodes of the sub-tree. This subtree is not yet attached\n   * to the real tree (= this.model).\n   */\n  _flatListToSubTree(treeNodesFlat) {\n    // 1. put all nodes with the same parent in a map (key=parentId, value=[nodes])\n    let nodesMap = {};\n    treeNodesFlat.forEach(treeNode => {\n      if (!objects.isNullOrUndefined(treeNode.id)) {\n        nodesMap[treeNode.id] = treeNode;\n      }\n    });\n    let rootNodes = [];\n\n    // 2. based on this map, set the childNodes references on the treeNodes\n    treeNodesFlat.forEach(treeNode => {\n      let parentNode = nodesMap[treeNode.parentId];\n      if (parentNode === treeNode) {\n        throw new Error('Cannot link a node to itself. Id: ' + treeNode.parentId);\n      }\n      if (parentNode) {\n        this._appendChildNode(parentNode, treeNode);\n      } else {\n        treeNode.childNodeIndex = rootNodes.length;\n        treeNode.parentNode = null;\n        rootNodes.push(treeNode);\n      }\n    });\n    return rootNodes;\n  }\n\n  /**\n   * This functions appends a tree node to a parent node and sets the required flags on the parent node.\n   */\n  _appendChildNode(parentNode, treeNode) {\n    if (!parentNode.childNodes) {\n      parentNode.childNodes = [];\n    }\n    treeNode.childNodeIndex = parentNode.childNodes.length;\n    treeNode.parentNode = parentNode;\n    parentNode.childNodes.push(treeNode);\n    parentNode.leaf = false;\n    parentNode.childrenLoaded = true;\n  }\n  clearLookupRows() {\n    this.model.deleteAllNodes();\n  }\n}","map":{"version":3,"names":["arrays","objects","ProposalChooser","scout","Tree","TreeProposalChooser","constructor","_createModel","tree","create","parent","requestFocusOnNodeControlMouseDown","scrollToSelection","textFilterEnabled","on","_onNodeClick","bind","event","triggerLookupRowSelected","node","selectedRow","model","selectedNode","isBrowseLoadIncremental","smartField","browseLoadIncremental","getSelectedLookupRow","lookupRow","selectFirstLookupRow","nodes","length","selectNode","clearSelection","deselectAll","setLookupResult","result","treeNodes","treeNodesFlat","lookupRows","appendResult","nvl","map","_createTreeNode","_flatListToSubTree","parentNode","forEach","treeNode","nodesMap","parentId","_appendChildNode","insertNodes","rec","leaf","childrenLoaded","updateNode","deleteAllChildNodes","byText","_expandAllParentNodes","_selectProposal","leafs","reduce","aggr","childNodesLoaded","childNodes","push","expandPath","expanded","setNodeExpanded","trySelectCurrentValue","currentValue","getValueForSelection","isNullOrUndefined","allTreeNodes","values","find","key","initialLeaf","expandAll","browseAutoExpandAll","loadIncremental","proposalChooser","childNodeIndex","enabled","htmlEnabled","iconId","id","parentKey","initialExpanded","text","tooltipText","findLeafs","visitNodes","rootNodes","Error","clearLookupRows","deleteAllNodes"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/smartfield/TreeProposalChooser.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, ProposalChooser, scout, Tree} from '../../../index';\n\nexport default class TreeProposalChooser extends ProposalChooser {\n\n  constructor() {\n    super();\n  }\n\n  _createModel() {\n    let tree = scout.create('Tree', {\n      parent: this,\n      requestFocusOnNodeControlMouseDown: false,\n      scrollToSelection: true,\n      textFilterEnabled: false\n    });\n    tree.on('nodeClick', this._onNodeClick.bind(this));\n    return tree;\n  }\n\n  _onNodeClick(event) {\n    this.triggerLookupRowSelected(event.node);\n  }\n\n  selectedRow() {\n    return this.model.selectedNode();\n  }\n\n  isBrowseLoadIncremental() {\n    return this.smartField.browseLoadIncremental;\n  }\n\n  getSelectedLookupRow() {\n    let selectedNode = this.model.selectedNode();\n    if (!selectedNode) {\n      return null;\n    }\n    return selectedNode.lookupRow;\n  }\n\n  selectFirstLookupRow() {\n    if (this.model.nodes.length) {\n      this.model.selectNode(this.model.nodes[0]);\n    }\n  }\n\n  clearSelection() {\n    this.model.deselectAll();\n  }\n\n  /**\n   * @param {LookupResult} result\n   */\n  setLookupResult(result) {\n    let treeNodes, treeNodesFlat,\n      lookupRows = result.lookupRows,\n      appendResult = scout.nvl(result.appendResult, false);\n\n    if (appendResult) {\n      treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n      treeNodes = this._flatListToSubTree(treeNodesFlat);\n      if (treeNodes.length) {\n        let parentNode = null;\n        treeNodes.forEach(treeNode => {\n          parentNode = this.model.nodesMap[treeNode.parentId];\n          this._appendChildNode(parentNode, treeNode);\n        });\n        if (parentNode) {\n          this.model.insertNodes(treeNodes, parentNode);\n        }\n      } else {\n        // remove control icon, when no child nodes are available\n        let node = this.model.nodesMap[result.rec];\n        node.leaf = true;\n        node.childrenLoaded = true;\n        this.model.updateNode(node);\n      }\n    } else {\n      this.model.deleteAllChildNodes();\n      treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n      treeNodes = this._flatListToSubTree(treeNodesFlat);\n      if (result.byText) {\n        this._expandAllParentNodes(treeNodesFlat);\n      }\n      this.model.insertNodes(treeNodes);\n    }\n\n    this._selectProposal(result, treeNodesFlat);\n  }\n\n  _expandAllParentNodes(treeNodesFlat) {\n    // when tree node is a leaf or children are not loaded yet\n    let leafs = treeNodesFlat.reduce((aggr, treeNode) => {\n      if (treeNode.leaf || !treeNode.childNodesLoaded && treeNode.childNodes.length === 0) {\n        aggr.push(treeNode);\n      }\n      return aggr;\n    }, []);\n    leafs.forEach(expandPath.bind(this));\n\n    function expandPath(treeNode) {\n      if (!treeNode.parentNode || treeNode.parentNode.expanded) {\n        return;\n      }\n      treeNode = treeNode.parentNode;\n      while (treeNode) {\n        this.model.setNodeExpanded(treeNode, true);\n        treeNode = treeNode.parentNode;\n      }\n    }\n  }\n\n  trySelectCurrentValue() {\n    let currentValue = this.smartField.getValueForSelection();\n    if (objects.isNullOrUndefined(currentValue)) {\n      return;\n    }\n    let allTreeNodes = objects.values(this.model.nodesMap);\n    let treeNode = arrays.find(allTreeNodes, node => {\n      return node.lookupRow.key === currentValue;\n    });\n    if (treeNode) {\n      this.model.selectNode(treeNode);\n    }\n  }\n\n  _createTreeNode(lookupRow) {\n    let\n      initialLeaf = true,\n      expandAll = this.smartField.browseAutoExpandAll,\n      loadIncremental = this.isBrowseLoadIncremental();\n\n    if (loadIncremental) {\n      // when smartfield / lookup is configured as 'load incremental' it cannot expand all tree nodes\n      // because then we'd load the whole tree anyway, which is not the idea of load incremental\n      expandAll = false;\n\n      // when smartfield / lookup is configured as 'load incremental' we don't know if a node has children\n      // or not until we've made a lookup for that node. Thus all nodes are initially leaf=false, so the UI\n      // shows the expand icon.\n      initialLeaf = false;\n    }\n\n    return scout.create('ProposalTreeNode', {\n      parent: this.model,\n      proposalChooser: this,\n      childNodeIndex: 0,\n      enabled: lookupRow.enabled,\n      htmlEnabled: false,\n      iconId: lookupRow.iconId,\n      id: lookupRow.key,\n      parentId: lookupRow.parentKey,\n      expanded: expandAll,\n      initialExpanded: expandAll,\n      text: lookupRow.text,\n      lookupRow: lookupRow,\n      leaf: initialLeaf,\n      tooltipText: lookupRow.tooltipText\n    });\n  }\n\n  /**\n   * This function is required in the 'accept input' case to find out\n   * if we have exactly one lookup row that matches. With a tree this is a bit difficult\n   * because the lookup call does not only return the lookup rows with a match, but also\n   * their parent nodes up to the root node (which don't match).\n   *\n   * Note: because we only match nodes that have the property leaf set to true, it's not\n   * possible to accept a node with accept input that is not a leaf.\n   *\n   * @returns {TreeNode[]} the leafs in the current tree model.\n   */\n  findLeafs() {\n    let leafs = [];\n    Tree.visitNodes((node, parentNode) => {\n      if (node.leaf || !node.childNodes.length) {\n        leafs.push(node);\n      }\n    }, this.model.nodes);\n    return leafs;\n  }\n\n  /**\n   * This function creates a sub-tree from a list of flat tree nodes. It sets the parent/child references\n   * between the nodes and returns the top-level nodes of the sub-tree. This subtree is not yet attached\n   * to the real tree (= this.model).\n   */\n  _flatListToSubTree(treeNodesFlat) {\n    // 1. put all nodes with the same parent in a map (key=parentId, value=[nodes])\n    let nodesMap = {};\n    treeNodesFlat.forEach(treeNode => {\n      if (!objects.isNullOrUndefined(treeNode.id)) {\n        nodesMap[treeNode.id] = treeNode;\n      }\n    });\n\n    let rootNodes = [];\n\n    // 2. based on this map, set the childNodes references on the treeNodes\n    treeNodesFlat.forEach(treeNode => {\n      let parentNode = nodesMap[treeNode.parentId];\n      if (parentNode === treeNode) {\n        throw new Error('Cannot link a node to itself. Id: ' + treeNode.parentId);\n      }\n      if (parentNode) {\n        this._appendChildNode(parentNode, treeNode);\n      } else {\n        treeNode.childNodeIndex = rootNodes.length;\n        treeNode.parentNode = null;\n        rootNodes.push(treeNode);\n      }\n    });\n\n    return rootNodes;\n  }\n\n  /**\n   * This functions appends a tree node to a parent node and sets the required flags on the parent node.\n   */\n  _appendChildNode(parentNode, treeNode) {\n    if (!parentNode.childNodes) {\n      parentNode.childNodes = [];\n    }\n    treeNode.childNodeIndex = parentNode.childNodes.length;\n    treeNode.parentNode = parentNode;\n    parentNode.childNodes.push(treeNode);\n    parentNode.leaf = false;\n    parentNode.childrenLoaded = true;\n  }\n\n  clearLookupRows() {\n    this.model.deleteAllNodes();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}