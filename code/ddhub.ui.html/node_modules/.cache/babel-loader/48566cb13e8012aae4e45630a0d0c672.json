{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, MenuDestinations, scout } from '../index';\nexport function filterAccordingToSelection(prefix, selectionLength, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n  let allowedTypes = [];\n  if (destination === MenuDestinations.MENU_BAR) {\n    allowedTypes = [prefix + '.EmptySpace', prefix + '.SingleSelection', prefix + '.MultiSelection'];\n  } else if (destination === MenuDestinations.CONTEXT_MENU) {\n    allowedTypes = [prefix + '.SingleSelection', prefix + '.MultiSelection'];\n  } else if (destination === MenuDestinations.HEADER) {\n    allowedTypes = [prefix + '.Header'];\n  }\n  if (allowedTypes.indexOf(prefix + '.SingleSelection') > -1 && selectionLength !== 1) {\n    arrays.remove(allowedTypes, prefix + '.SingleSelection');\n  }\n  if (allowedTypes.indexOf(prefix + '.MultiSelection') > -1 && selectionLength <= 1) {\n    arrays.remove(allowedTypes, prefix + '.MultiSelection');\n  }\n  notAllowedTypes = arrays.ensure(notAllowedTypes);\n  let fixedNotAllowedTypes = [];\n  // ensure prefix\n  prefix = prefix + '.';\n  notAllowedTypes.forEach(type => {\n    if (type.slice(0, prefix.length) !== prefix) {\n      type = prefix + type;\n    }\n    fixedNotAllowedTypes.push(type);\n  }, this);\n  return filter(menus, allowedTypes, onlyVisible, enableDisableKeyStroke, fixedNotAllowedTypes);\n}\n\n/**\n * Filters menus that don't match the given types, or in other words: only menus with the given types are returned\n * from this method. The visible state is only checked if the parameter onlyVisible is set to true. Otherwise invisible items are returned and added to the\n * menu-bar DOM (invisible, however). They may change their visible state later. If there are any types in notAllowedTypes each menu is checked also against\n * these types and if they are matching the menu is filtered.\n */\nexport function filter(menus, types, onlyVisible, enableDisableKeyStrokes, notAllowedTypes) {\n  if (!menus) {\n    return;\n  }\n  types = arrays.ensure(types);\n  notAllowedTypes = arrays.ensure(notAllowedTypes);\n  let filteredMenus = [],\n    separatorCount = 0;\n  menus.forEach(menu => {\n    let childMenus = menu.childActions;\n    if (childMenus.length > 0) {\n      childMenus = filter(childMenus, types, onlyVisible, enableDisableKeyStrokes, notAllowedTypes);\n      if (childMenus.length === 0) {\n        _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);\n        return;\n      }\n    } else if (!_checkType(menu, types) || notAllowedTypes.length !== 0 && _checkType(menu, notAllowedTypes)) {\n      // Don't check the menu type for a group\n      _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);\n      return;\n    }\n    if (onlyVisible && !menu.visible) {\n      _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);\n      return;\n    }\n    if (menu.separator) {\n      separatorCount++;\n    }\n    _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, false);\n    filteredMenus.push(menu);\n  });\n\n  // Ignore menus with only separators\n  if (separatorCount === filteredMenus.length) {\n    return [];\n  }\n  return filteredMenus;\n}\n\n/**\n * Makes leading, trailing and duplicate separators invisible or reverts the visibility change if needed.\n */\nexport function updateSeparatorVisibility(menus) {\n  menus = arrays.ensure(menus);\n  menus = menus.filter(menu => {\n    return menu.visible || menu.separator;\n  });\n  if (menus.length === 0) {\n    return;\n  }\n  let hasMenuBefore = false;\n  let hasMenuAfter = false;\n  menus.forEach((menu, i) => {\n    if (menu.ellipsis) {\n      return;\n    }\n    if (!menu.separator) {\n      hasMenuBefore = true;\n      return;\n    }\n    hasMenuAfter = menus[i + 1] && !menus[i + 1].separator && !menus[i + 1].ellipsis;\n\n    // If the separator has a separator next to it, make it invisible\n    if (!hasMenuBefore || !hasMenuAfter) {\n      if (menu.visibleOrig === undefined) {\n        menu.visibleOrig = menu.visible;\n        menu.setVisible(false);\n      }\n    } else if (menu.visibleOrig !== undefined) {\n      // Revert to original state\n      menu.setVisible(menu.visibleOrig);\n      menu.visibleOrig = undefined;\n    }\n  });\n}\nexport function checkType(menu, types) {\n  types = arrays.ensure(types);\n  if (menu.childActions.length > 0) {\n    let childMenus = filter(menu.childActions, types);\n    return childMenus.length > 0;\n  }\n  return _checkType(menu, types);\n}\nexport function _enableDisableMenuKeyStroke(menu, activated, exclude) {\n  if (activated) {\n    menu.excludedByFilter = exclude;\n  }\n}\n\n/**\n * Checks the type of a menu. Don't use this for menu groups.\n */\n\nexport function _checkType(menu, types) {\n  if (!types || types.length === 0) {\n    return false;\n  }\n  if (!menu.menuTypes) {\n    return false;\n  }\n  for (let j = 0; j < types.length; j++) {\n    if (menu.menuTypes.indexOf(types[j]) > -1) {\n      return true;\n    }\n  }\n}\nexport function createEllipsisMenu(options) {\n  return scout.create('EllipsisMenu', options);\n}\nexport function moveMenuIntoEllipsis(menu, ellipsis) {\n  menu.remove();\n  menu._setOverflown(true);\n  menu.overflowMenu = ellipsis;\n  let menusInEllipsis = ellipsis.childActions.slice();\n  menusInEllipsis.unshift(menu); // add as first element\n  ellipsis.setChildActions(menusInEllipsis);\n}\nexport function removeMenuFromEllipsis(menu, $parent) {\n  menu._setOverflown(false);\n  menu.overflowMenu = null;\n  if (!menu.rendered) {\n    menu.render($parent);\n  }\n}\nexport default {\n  checkType,\n  createEllipsisMenu,\n  filter,\n  filterAccordingToSelection,\n  moveMenuIntoEllipsis,\n  removeMenuFromEllipsis,\n  updateSeparatorVisibility\n};","map":{"version":3,"names":["arrays","MenuDestinations","scout","filterAccordingToSelection","prefix","selectionLength","menus","destination","onlyVisible","enableDisableKeyStroke","notAllowedTypes","allowedTypes","MENU_BAR","CONTEXT_MENU","HEADER","indexOf","remove","ensure","fixedNotAllowedTypes","forEach","type","slice","length","push","filter","types","enableDisableKeyStrokes","filteredMenus","separatorCount","menu","childMenus","childActions","_enableDisableMenuKeyStroke","_checkType","visible","separator","updateSeparatorVisibility","hasMenuBefore","hasMenuAfter","i","ellipsis","visibleOrig","undefined","setVisible","checkType","activated","exclude","excludedByFilter","menuTypes","j","createEllipsisMenu","options","create","moveMenuIntoEllipsis","_setOverflown","overflowMenu","menusInEllipsis","unshift","setChildActions","removeMenuFromEllipsis","$parent","rendered","render"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/menu/menus.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, MenuDestinations, scout} from '../index';\n\nexport function filterAccordingToSelection(prefix, selectionLength, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n  let allowedTypes = [];\n\n  if (destination === MenuDestinations.MENU_BAR) {\n    allowedTypes = [prefix + '.EmptySpace', prefix + '.SingleSelection', prefix + '.MultiSelection'];\n  } else if (destination === MenuDestinations.CONTEXT_MENU) {\n    allowedTypes = [prefix + '.SingleSelection', prefix + '.MultiSelection'];\n  } else if (destination === MenuDestinations.HEADER) {\n    allowedTypes = [prefix + '.Header'];\n  }\n\n  if (allowedTypes.indexOf(prefix + '.SingleSelection') > -1 && selectionLength !== 1) {\n    arrays.remove(allowedTypes, prefix + '.SingleSelection');\n  }\n  if (allowedTypes.indexOf(prefix + '.MultiSelection') > -1 && selectionLength <= 1) {\n    arrays.remove(allowedTypes, prefix + '.MultiSelection');\n  }\n  notAllowedTypes = arrays.ensure(notAllowedTypes);\n  let fixedNotAllowedTypes = [];\n  // ensure prefix\n  prefix = prefix + '.';\n  notAllowedTypes.forEach(type => {\n    if (type.slice(0, prefix.length) !== prefix) {\n      type = prefix + type;\n    }\n    fixedNotAllowedTypes.push(type);\n  }, this);\n  return filter(menus, allowedTypes, onlyVisible, enableDisableKeyStroke, fixedNotAllowedTypes);\n}\n\n/**\n * Filters menus that don't match the given types, or in other words: only menus with the given types are returned\n * from this method. The visible state is only checked if the parameter onlyVisible is set to true. Otherwise invisible items are returned and added to the\n * menu-bar DOM (invisible, however). They may change their visible state later. If there are any types in notAllowedTypes each menu is checked also against\n * these types and if they are matching the menu is filtered.\n */\nexport function filter(menus, types, onlyVisible, enableDisableKeyStrokes, notAllowedTypes) {\n  if (!menus) {\n    return;\n  }\n  types = arrays.ensure(types);\n  notAllowedTypes = arrays.ensure(notAllowedTypes);\n\n  let filteredMenus = [],\n    separatorCount = 0;\n\n  menus.forEach(menu => {\n    let childMenus = menu.childActions;\n    if (childMenus.length > 0) {\n      childMenus = filter(childMenus, types, onlyVisible, enableDisableKeyStrokes, notAllowedTypes);\n      if (childMenus.length === 0) {\n        _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);\n        return;\n      }\n    } else if (!_checkType(menu, types) || (notAllowedTypes.length !== 0 && _checkType(menu, notAllowedTypes))) {\n      // Don't check the menu type for a group\n      _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);\n      return;\n    }\n\n    if (onlyVisible && !menu.visible) {\n      _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);\n      return;\n    }\n    if (menu.separator) {\n      separatorCount++;\n    }\n    _enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, false);\n    filteredMenus.push(menu);\n  });\n\n  // Ignore menus with only separators\n  if (separatorCount === filteredMenus.length) {\n    return [];\n  }\n  return filteredMenus;\n}\n\n/**\n * Makes leading, trailing and duplicate separators invisible or reverts the visibility change if needed.\n */\nexport function updateSeparatorVisibility(menus) {\n  menus = arrays.ensure(menus);\n\n  menus = menus.filter(menu => {\n    return menu.visible || menu.separator;\n  });\n\n  if (menus.length === 0) {\n    return;\n  }\n\n  let hasMenuBefore = false;\n  let hasMenuAfter = false;\n  menus.forEach((menu, i) => {\n    if (menu.ellipsis) {\n      return;\n    }\n    if (!menu.separator) {\n      hasMenuBefore = true;\n      return;\n    }\n    hasMenuAfter = menus[i + 1] && !menus[i + 1].separator && !menus[i + 1].ellipsis;\n\n    // If the separator has a separator next to it, make it invisible\n    if (!hasMenuBefore || !hasMenuAfter) {\n      if (menu.visibleOrig === undefined) {\n        menu.visibleOrig = menu.visible;\n        menu.setVisible(false);\n      }\n    } else if (menu.visibleOrig !== undefined) {\n      // Revert to original state\n      menu.setVisible(menu.visibleOrig);\n      menu.visibleOrig = undefined;\n    }\n  });\n}\n\nexport function checkType(menu, types) {\n  types = arrays.ensure(types);\n  if (menu.childActions.length > 0) {\n    let childMenus = filter(menu.childActions, types);\n    return (childMenus.length > 0);\n  }\n  return _checkType(menu, types);\n}\n\nexport function _enableDisableMenuKeyStroke(menu, activated, exclude) {\n  if (activated) {\n    menu.excludedByFilter = exclude;\n  }\n}\n\n/**\n * Checks the type of a menu. Don't use this for menu groups.\n */\n\nexport function _checkType(menu, types) {\n  if (!types || types.length === 0) {\n    return false;\n  }\n  if (!menu.menuTypes) {\n    return false;\n  }\n  for (let j = 0; j < types.length; j++) {\n    if (menu.menuTypes.indexOf(types[j]) > -1) {\n      return true;\n    }\n  }\n}\n\nexport function createEllipsisMenu(options) {\n  return scout.create('EllipsisMenu', options);\n}\n\nexport function moveMenuIntoEllipsis(menu, ellipsis) {\n  menu.remove();\n  menu._setOverflown(true);\n  menu.overflowMenu = ellipsis;\n\n  let menusInEllipsis = ellipsis.childActions.slice();\n  menusInEllipsis.unshift(menu); // add as first element\n  ellipsis.setChildActions(menusInEllipsis);\n}\n\nexport function removeMenuFromEllipsis(menu, $parent) {\n  menu._setOverflown(false);\n  menu.overflowMenu = null;\n  if (!menu.rendered) {\n    menu.render($parent);\n  }\n}\n\nexport default {\n  checkType,\n  createEllipsisMenu,\n  filter,\n  filterAccordingToSelection,\n  moveMenuIntoEllipsis,\n  removeMenuFromEllipsis,\n  updateSeparatorVisibility\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}