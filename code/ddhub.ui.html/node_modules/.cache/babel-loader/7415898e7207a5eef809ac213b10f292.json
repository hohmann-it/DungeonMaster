{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, events, objects, strings } from '../index';\n\n/**\n * @returns {number} the x coordinate where the event happened, works for touch events as well.\n */\nexport function pageX(event) {\n  if (!objects.isNullOrUndefined(event.pageX)) {\n    return event.pageX;\n  }\n  return event.originalEvent.touches[0].pageX;\n}\n\n/**\n * @returns {number} the y coordinate where the event happened, works for touch events as well.\n */\nexport function pageY(event) {\n  if (!objects.isNullOrUndefined(event.pageY)) {\n    return event.pageY;\n  }\n  return event.originalEvent.touches[0].pageY;\n}\nexport function touchdown(touch, suffix) {\n  return touchOrMouse(touch, 'touchstart', 'mousedown', suffix);\n}\nexport function touchmove(touch, suffix) {\n  return touchOrMouse(touch, 'touchmove', 'mousemove', suffix);\n}\nexport function touchendcancel(touch, suffix) {\n  return touchOrMouse(touch, 'touchend touchcancel', 'mouseup', suffix);\n}\nexport function touchOrMouse(touch, touchevent, mouseevent, suffix) {\n  suffix = suffix || '';\n  if (suffix) {\n    suffix = '.' + suffix;\n  }\n  if (touch) {\n    return touchevent + suffix;\n  }\n  return mouseevent + suffix;\n}\nexport function isTouchEvent(event) {\n  return event && strings.startsWith(event.type, 'touch');\n}\nexport function fixTouchEvent(event) {\n  if (isTouchEvent(event)) {\n    let touches = event.touches || (event.originalEvent ? event.originalEvent.touches : null);\n    let touch = touches ? touches[0] : null;\n    if (touch) {\n      // Touch events may contain fractional values, while mouse events should not\n      // - https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX\n      // - https://www.chromestatus.com/features/6169687914184704\n      event.pageX = Math.round(touch.pageX);\n      event.pageY = Math.round(touch.pageY);\n    }\n  }\n}\n\n/**\n * @returns an object containing passive: true if the browser supports passive event listeners, otherwise returns false.\n */\nexport function passiveOptions() {\n  let options = false;\n  if (Device.get().supportsPassiveEventListener()) {\n    options = {\n      passive: true\n    };\n  }\n  return options;\n}\n\n/**\n * Listens for scroll events and executes startHandler on first event. It then regularly checks for further scroll events and executes endHandler if no event has fired since a certain amount of time and the user has released his finger.\n * If he does not release his finger the endHandler won't be called even if the pane has stopped scrolling.\n */\nexport function onScrollStartEndDuringTouch($elem, startHandler, endHandler) {\n  let scrollTimeout;\n  let started = false;\n  let touchend = false;\n  let scrollHandler = event => {\n    // Execute once on first scroll event (and not as soon as user touches the pane because he might not even want to scroll)\n    if (!started) {\n      startHandler();\n      started = true;\n    }\n    clearTimeout(scrollTimeout);\n    // Check some ms later if a scroll event has occurred in the mean time.\n    // If yes it (probably) is still scrolling. If no it (probably) is not scrolling anymore -> call handler\n    checkLater();\n  };\n  let touchEndHandler = event => {\n    touchend = true;\n    checkLater();\n  };\n  function checkLater() {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = setTimeout(() => {\n      if (touchend) {\n        // Only stop processing if user released the finger\n        removeHandlers();\n        endHandler();\n      }\n    }, 50);\n  }\n  function removeHandlers() {\n    $elem.off('scroll', scrollHandler);\n    $elem.document().off('touchend touchcancel', touchEndHandler);\n  }\n  $elem.on('scroll', scrollHandler);\n  // Make sure handler is executed and scroll listener removed if no scroll event occurs\n  $elem.document().one('touchend touchcancel', touchEndHandler);\n}\n\n/**\n * Forwards the event to the given target by creating a new event with the same data as the old one.\n * Prevents default action of the original event if preventDefault was called for the forwarded event.\n * Does not use jQuery to make sure the capture phase is executed as well.\n *\n * <p>\n * <b>Important</b>\n * This function only works in browsers supporting the Event constructor (e.g. KeyboardEvent: https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/KeyboardEvent).\n * </p>\n *\n * @param target {HTMLElement} the element which should receive the event\n * @param event {Event} the original event which should be propagated\n */\nexport function propagateEvent(target, event) {\n  if (typeof Event !== 'function') {\n    return;\n  }\n  let newEvent = new event.constructor(event.type, event);\n  if (!target.dispatchEvent(newEvent)) {\n    event.preventDefault();\n  }\n}\n\n/**\n * Adds an event listener for each given type to the source which propagates the events for that type to the target.\n *\n * <p>\n * <b>Important</b>\n * This function only works in browsers supporting the Event constructor (e.g. KeyboardEvent: https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/KeyboardEvent).\n * </p>\n *\n * @param source {HTMLElement} the element for which the event listener should be added.\n * @param target {HTMLElement} the element which should receive the event.\n * @param types {string[]} an array of event types.\n * @param {function} [filter] an optional filter function which can return false if the event should not be propagated.\n */\nexport function addPropagationListener(source, target, types, filter) {\n  types = arrays.ensure(types);\n  types.forEach(type => {\n    source.addEventListener(type, event => {\n      if (filter && !filter(event)) {\n        return;\n      }\n      propagateEvent(target, event);\n    });\n  });\n}\n\n/**\n * @typedef {Object} SwipeCallbackEvent\n * @property {MouseEvent|TouchEvent} originalEvent The original event received from the browser.\n * @property {number} originalLeft The left position of the element at the moment the swipe was started.\n * @property {number} deltaX The horizontal delta the swipe has already moved (negative values mean to the left of the original left position).\n * @property {number} newLeft The current left position of the element.\n * @property {number} direction -1 if the move is to the left, 1 if the move is to the right, 0 or -0 if it is not moved yet\n */\n\n/**\n * Adds swipe event listeners to the element given.\n *\n * @param {jQuery} $element The element on which the listeners should be attached.\n * @param {string} id An event listener id used to be registered on the window object.\n * @param {function(SwipeCallbackEvent)} [onDown] Callback to be invoked when the swipe is started (mouse or touch down).\n * @param {function(SwipeCallbackEvent)} [onMove] Callback to be invoked when mouse (or finger if touch) is moved (while being down).\n * @param {function(SwipeCallbackEvent)} [onUp] Callback to be invoked when the swipe is ended (mouse or finger released).\n */\nexport function onSwipe($element, id, onDown, onMove, onUp) {\n  let $window = $element.window();\n  let touch = Device.get().supportsOnlyTouch();\n  $element.on('touchmove', event => event.preventDefault()); // prevent scrolling the background when swiping (iOS)\n  $element.on('remove', event => $window.off('.' + id));\n  $element.on(touchdown(touch), event => {\n    let origPosLeft = $element.position().left;\n    let acceptDown = !onDown || !!onDown({\n      originalEvent: event,\n      originalLeft: origPosLeft,\n      deltaX: 0,\n      newLeft: origPosLeft,\n      direction: 0\n    });\n    if (!acceptDown) {\n      return;\n    }\n    let dragging = true;\n    let origPageX = events.pageX(event);\n    let curPosLeft = origPosLeft;\n    let direction = 0;\n    $window.on(touchmove(touch, id), event => {\n      let pageX = events.pageX(event);\n      let deltaX = pageX - origPageX;\n      let newLeft = origPosLeft + deltaX;\n      if (newLeft !== curPosLeft) {\n        // only update swipe direction if it actually changed\n        direction = Math.sign(newLeft - curPosLeft);\n      }\n      if (onMove) {\n        let l = onMove({\n          originalEvent: event,\n          originalLeft: origPosLeft,\n          deltaX: deltaX,\n          newLeft: newLeft,\n          direction: direction\n        });\n        curPosLeft = typeof l === 'number' ? l : newLeft;\n      } else {\n        curPosLeft = newLeft;\n      }\n    });\n    $window.on(touchendcancel(touch, id), event => {\n      if (!dragging) {\n        // On iOS touchcancel and touchend are fired right after each other when swiping twice very fast -> Ignore the second event\n        return;\n      }\n      dragging = false;\n      $window.off('.' + id);\n      if (onUp) {\n        onUp({\n          originalEvent: event,\n          originalLeft: origPosLeft,\n          deltaX: curPosLeft - origPosLeft,\n          newLeft: curPosLeft,\n          direction: direction\n        });\n      }\n    });\n  });\n}\nexport default {\n  addPropagationListener,\n  fixTouchEvent,\n  isTouchEvent,\n  onScrollStartEndDuringTouch,\n  pageX,\n  pageY,\n  passiveOptions,\n  propagateEvent,\n  touchOrMouse,\n  touchdown,\n  touchendcancel,\n  touchmove,\n  onSwipe\n};","map":{"version":3,"names":["arrays","Device","events","objects","strings","pageX","event","isNullOrUndefined","originalEvent","touches","pageY","touchdown","touch","suffix","touchOrMouse","touchmove","touchendcancel","touchevent","mouseevent","isTouchEvent","startsWith","type","fixTouchEvent","Math","round","passiveOptions","options","get","supportsPassiveEventListener","passive","onScrollStartEndDuringTouch","$elem","startHandler","endHandler","scrollTimeout","started","touchend","scrollHandler","clearTimeout","checkLater","touchEndHandler","setTimeout","removeHandlers","off","document","on","one","propagateEvent","target","Event","newEvent","constructor","dispatchEvent","preventDefault","addPropagationListener","source","types","filter","ensure","forEach","addEventListener","onSwipe","$element","id","onDown","onMove","onUp","$window","window","supportsOnlyTouch","origPosLeft","position","left","acceptDown","originalLeft","deltaX","newLeft","direction","dragging","origPageX","curPosLeft","sign","l"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/events.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, events, objects, strings} from '../index';\n\n/**\n * @returns {number} the x coordinate where the event happened, works for touch events as well.\n */\nexport function pageX(event) {\n  if (!objects.isNullOrUndefined(event.pageX)) {\n    return event.pageX;\n  }\n  return event.originalEvent.touches[0].pageX;\n}\n\n/**\n * @returns {number} the y coordinate where the event happened, works for touch events as well.\n */\nexport function pageY(event) {\n  if (!objects.isNullOrUndefined(event.pageY)) {\n    return event.pageY;\n  }\n  return event.originalEvent.touches[0].pageY;\n}\n\nexport function touchdown(touch, suffix) {\n  return touchOrMouse(touch, 'touchstart', 'mousedown', suffix);\n}\n\nexport function touchmove(touch, suffix) {\n  return touchOrMouse(touch, 'touchmove', 'mousemove', suffix);\n}\n\nexport function touchendcancel(touch, suffix) {\n  return touchOrMouse(touch, 'touchend touchcancel', 'mouseup', suffix);\n}\n\nexport function touchOrMouse(touch, touchevent, mouseevent, suffix) {\n  suffix = suffix || '';\n  if (suffix) {\n    suffix = '.' + suffix;\n  }\n  if (touch) {\n    return touchevent + suffix;\n  }\n  return mouseevent + suffix;\n}\n\nexport function isTouchEvent(event) {\n  return event && strings.startsWith(event.type, 'touch');\n}\n\nexport function fixTouchEvent(event) {\n  if (isTouchEvent(event)) {\n    let touches = event.touches || (event.originalEvent ? event.originalEvent.touches : null);\n    let touch = touches ? touches[0] : null;\n    if (touch) {\n      // Touch events may contain fractional values, while mouse events should not\n      // - https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX\n      // - https://www.chromestatus.com/features/6169687914184704\n      event.pageX = Math.round(touch.pageX);\n      event.pageY = Math.round(touch.pageY);\n    }\n  }\n}\n\n/**\n * @returns an object containing passive: true if the browser supports passive event listeners, otherwise returns false.\n */\nexport function passiveOptions() {\n  let options = false;\n  if (Device.get().supportsPassiveEventListener()) {\n    options = {\n      passive: true\n    };\n  }\n  return options;\n}\n\n/**\n * Listens for scroll events and executes startHandler on first event. It then regularly checks for further scroll events and executes endHandler if no event has fired since a certain amount of time and the user has released his finger.\n * If he does not release his finger the endHandler won't be called even if the pane has stopped scrolling.\n */\nexport function onScrollStartEndDuringTouch($elem, startHandler, endHandler) {\n  let scrollTimeout;\n  let started = false;\n  let touchend = false;\n  let scrollHandler = event => {\n    // Execute once on first scroll event (and not as soon as user touches the pane because he might not even want to scroll)\n    if (!started) {\n      startHandler();\n      started = true;\n    }\n\n    clearTimeout(scrollTimeout);\n    // Check some ms later if a scroll event has occurred in the mean time.\n    // If yes it (probably) is still scrolling. If no it (probably) is not scrolling anymore -> call handler\n    checkLater();\n  };\n\n  let touchEndHandler = event => {\n    touchend = true;\n    checkLater();\n  };\n\n  function checkLater() {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = setTimeout(() => {\n      if (touchend) {\n        // Only stop processing if user released the finger\n        removeHandlers();\n        endHandler();\n      }\n    }, 50);\n  }\n\n  function removeHandlers() {\n    $elem.off('scroll', scrollHandler);\n    $elem.document().off('touchend touchcancel', touchEndHandler);\n  }\n\n  $elem.on('scroll', scrollHandler);\n  // Make sure handler is executed and scroll listener removed if no scroll event occurs\n  $elem.document().one('touchend touchcancel', touchEndHandler);\n}\n\n/**\n * Forwards the event to the given target by creating a new event with the same data as the old one.\n * Prevents default action of the original event if preventDefault was called for the forwarded event.\n * Does not use jQuery to make sure the capture phase is executed as well.\n *\n * <p>\n * <b>Important</b>\n * This function only works in browsers supporting the Event constructor (e.g. KeyboardEvent: https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/KeyboardEvent).\n * </p>\n *\n * @param target {HTMLElement} the element which should receive the event\n * @param event {Event} the original event which should be propagated\n */\nexport function propagateEvent(target, event) {\n  if (typeof (Event) !== 'function') {\n    return;\n  }\n  let newEvent = new event.constructor(event.type, event);\n  if (!target.dispatchEvent(newEvent)) {\n    event.preventDefault();\n  }\n}\n\n/**\n * Adds an event listener for each given type to the source which propagates the events for that type to the target.\n *\n * <p>\n * <b>Important</b>\n * This function only works in browsers supporting the Event constructor (e.g. KeyboardEvent: https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/KeyboardEvent).\n * </p>\n *\n * @param source {HTMLElement} the element for which the event listener should be added.\n * @param target {HTMLElement} the element which should receive the event.\n * @param types {string[]} an array of event types.\n * @param {function} [filter] an optional filter function which can return false if the event should not be propagated.\n */\nexport function addPropagationListener(source, target, types, filter) {\n  types = arrays.ensure(types);\n  types.forEach(type => {\n    source.addEventListener(type, event => {\n      if (filter && !filter(event)) {\n        return;\n      }\n      propagateEvent(target, event);\n    });\n  });\n}\n\n/**\n * @typedef {Object} SwipeCallbackEvent\n * @property {MouseEvent|TouchEvent} originalEvent The original event received from the browser.\n * @property {number} originalLeft The left position of the element at the moment the swipe was started.\n * @property {number} deltaX The horizontal delta the swipe has already moved (negative values mean to the left of the original left position).\n * @property {number} newLeft The current left position of the element.\n * @property {number} direction -1 if the move is to the left, 1 if the move is to the right, 0 or -0 if it is not moved yet\n */\n\n/**\n * Adds swipe event listeners to the element given.\n *\n * @param {jQuery} $element The element on which the listeners should be attached.\n * @param {string} id An event listener id used to be registered on the window object.\n * @param {function(SwipeCallbackEvent)} [onDown] Callback to be invoked when the swipe is started (mouse or touch down).\n * @param {function(SwipeCallbackEvent)} [onMove] Callback to be invoked when mouse (or finger if touch) is moved (while being down).\n * @param {function(SwipeCallbackEvent)} [onUp] Callback to be invoked when the swipe is ended (mouse or finger released).\n */\nexport function onSwipe($element, id, onDown, onMove, onUp) {\n  let $window = $element.window();\n  let touch = Device.get().supportsOnlyTouch();\n\n  $element.on('touchmove', event => event.preventDefault()); // prevent scrolling the background when swiping (iOS)\n  $element.on('remove', event => $window.off('.' + id));\n\n  $element.on(touchdown(touch), event => {\n    let origPosLeft = $element.position().left;\n    let acceptDown = !onDown || !!onDown({originalEvent: event, originalLeft: origPosLeft, deltaX: 0, newLeft: origPosLeft, direction: 0});\n    if (!acceptDown) {\n      return;\n    }\n\n    let dragging = true;\n    let origPageX = events.pageX(event);\n    let curPosLeft = origPosLeft;\n    let direction = 0;\n\n    $window.on(touchmove(touch, id), event => {\n      let pageX = events.pageX(event);\n      let deltaX = pageX - origPageX;\n      let newLeft = origPosLeft + deltaX;\n      if (newLeft !== curPosLeft) {\n        // only update swipe direction if it actually changed\n        direction = Math.sign(newLeft - curPosLeft);\n      }\n      if (onMove) {\n        let l = onMove({originalEvent: event, originalLeft: origPosLeft, deltaX: deltaX, newLeft: newLeft, direction: direction});\n        curPosLeft = typeof l === 'number' ? l : newLeft;\n      } else {\n        curPosLeft = newLeft;\n      }\n    });\n\n    $window.on(touchendcancel(touch, id), event => {\n      if (!dragging) {\n        // On iOS touchcancel and touchend are fired right after each other when swiping twice very fast -> Ignore the second event\n        return;\n      }\n      dragging = false;\n      $window.off('.' + id);\n      if (onUp) {\n        onUp({originalEvent: event, originalLeft: origPosLeft, deltaX: curPosLeft - origPosLeft, newLeft: curPosLeft, direction: direction});\n      }\n    });\n  });\n}\n\nexport default {\n  addPropagationListener,\n  fixTouchEvent,\n  isTouchEvent,\n  onScrollStartEndDuringTouch,\n  pageX,\n  pageY,\n  passiveOptions,\n  propagateEvent,\n  touchOrMouse,\n  touchdown,\n  touchendcancel,\n  touchmove,\n  onSwipe\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,OAAO,EAAEC,OAAO,QAAO,UAAU;;AAEjE;AACA;AACA;AACA,OAAO,SAASC,KAAK,CAACC,KAAK,EAAE;EAC3B,IAAI,CAACH,OAAO,CAACI,iBAAiB,CAACD,KAAK,CAACD,KAAK,CAAC,EAAE;IAC3C,OAAOC,KAAK,CAACD,KAAK;EACpB;EACA,OAAOC,KAAK,CAACE,aAAa,CAACC,OAAO,CAAC,CAAC,CAAC,CAACJ,KAAK;AAC7C;;AAEA;AACA;AACA;AACA,OAAO,SAASK,KAAK,CAACJ,KAAK,EAAE;EAC3B,IAAI,CAACH,OAAO,CAACI,iBAAiB,CAACD,KAAK,CAACI,KAAK,CAAC,EAAE;IAC3C,OAAOJ,KAAK,CAACI,KAAK;EACpB;EACA,OAAOJ,KAAK,CAACE,aAAa,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,KAAK;AAC7C;AAEA,OAAO,SAASC,SAAS,CAACC,KAAK,EAAEC,MAAM,EAAE;EACvC,OAAOC,YAAY,CAACF,KAAK,EAAE,YAAY,EAAE,WAAW,EAAEC,MAAM,CAAC;AAC/D;AAEA,OAAO,SAASE,SAAS,CAACH,KAAK,EAAEC,MAAM,EAAE;EACvC,OAAOC,YAAY,CAACF,KAAK,EAAE,WAAW,EAAE,WAAW,EAAEC,MAAM,CAAC;AAC9D;AAEA,OAAO,SAASG,cAAc,CAACJ,KAAK,EAAEC,MAAM,EAAE;EAC5C,OAAOC,YAAY,CAACF,KAAK,EAAE,sBAAsB,EAAE,SAAS,EAAEC,MAAM,CAAC;AACvE;AAEA,OAAO,SAASC,YAAY,CAACF,KAAK,EAAEK,UAAU,EAAEC,UAAU,EAAEL,MAAM,EAAE;EAClEA,MAAM,GAAGA,MAAM,IAAI,EAAE;EACrB,IAAIA,MAAM,EAAE;IACVA,MAAM,GAAG,GAAG,GAAGA,MAAM;EACvB;EACA,IAAID,KAAK,EAAE;IACT,OAAOK,UAAU,GAAGJ,MAAM;EAC5B;EACA,OAAOK,UAAU,GAAGL,MAAM;AAC5B;AAEA,OAAO,SAASM,YAAY,CAACb,KAAK,EAAE;EAClC,OAAOA,KAAK,IAAIF,OAAO,CAACgB,UAAU,CAACd,KAAK,CAACe,IAAI,EAAE,OAAO,CAAC;AACzD;AAEA,OAAO,SAASC,aAAa,CAAChB,KAAK,EAAE;EACnC,IAAIa,YAAY,CAACb,KAAK,CAAC,EAAE;IACvB,IAAIG,OAAO,GAAGH,KAAK,CAACG,OAAO,KAAKH,KAAK,CAACE,aAAa,GAAGF,KAAK,CAACE,aAAa,CAACC,OAAO,GAAG,IAAI,CAAC;IACzF,IAAIG,KAAK,GAAGH,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI;IACvC,IAAIG,KAAK,EAAE;MACT;MACA;MACA;MACAN,KAAK,CAACD,KAAK,GAAGkB,IAAI,CAACC,KAAK,CAACZ,KAAK,CAACP,KAAK,CAAC;MACrCC,KAAK,CAACI,KAAK,GAAGa,IAAI,CAACC,KAAK,CAACZ,KAAK,CAACF,KAAK,CAAC;IACvC;EACF;AACF;;AAEA;AACA;AACA;AACA,OAAO,SAASe,cAAc,GAAG;EAC/B,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIzB,MAAM,CAAC0B,GAAG,EAAE,CAACC,4BAA4B,EAAE,EAAE;IAC/CF,OAAO,GAAG;MACRG,OAAO,EAAE;IACX,CAAC;EACH;EACA,OAAOH,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASI,2BAA2B,CAACC,KAAK,EAAEC,YAAY,EAAEC,UAAU,EAAE;EAC3E,IAAIC,aAAa;EACjB,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,QAAQ,GAAG,KAAK;EACpB,IAAIC,aAAa,GAAG/B,KAAK,IAAI;IAC3B;IACA,IAAI,CAAC6B,OAAO,EAAE;MACZH,YAAY,EAAE;MACdG,OAAO,GAAG,IAAI;IAChB;IAEAG,YAAY,CAACJ,aAAa,CAAC;IAC3B;IACA;IACAK,UAAU,EAAE;EACd,CAAC;EAED,IAAIC,eAAe,GAAGlC,KAAK,IAAI;IAC7B8B,QAAQ,GAAG,IAAI;IACfG,UAAU,EAAE;EACd,CAAC;EAED,SAASA,UAAU,GAAG;IACpBD,YAAY,CAACJ,aAAa,CAAC;IAC3BA,aAAa,GAAGO,UAAU,CAAC,MAAM;MAC/B,IAAIL,QAAQ,EAAE;QACZ;QACAM,cAAc,EAAE;QAChBT,UAAU,EAAE;MACd;IACF,CAAC,EAAE,EAAE,CAAC;EACR;EAEA,SAASS,cAAc,GAAG;IACxBX,KAAK,CAACY,GAAG,CAAC,QAAQ,EAAEN,aAAa,CAAC;IAClCN,KAAK,CAACa,QAAQ,EAAE,CAACD,GAAG,CAAC,sBAAsB,EAAEH,eAAe,CAAC;EAC/D;EAEAT,KAAK,CAACc,EAAE,CAAC,QAAQ,EAAER,aAAa,CAAC;EACjC;EACAN,KAAK,CAACa,QAAQ,EAAE,CAACE,GAAG,CAAC,sBAAsB,EAAEN,eAAe,CAAC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,cAAc,CAACC,MAAM,EAAE1C,KAAK,EAAE;EAC5C,IAAI,OAAQ2C,KAAM,KAAK,UAAU,EAAE;IACjC;EACF;EACA,IAAIC,QAAQ,GAAG,IAAI5C,KAAK,CAAC6C,WAAW,CAAC7C,KAAK,CAACe,IAAI,EAAEf,KAAK,CAAC;EACvD,IAAI,CAAC0C,MAAM,CAACI,aAAa,CAACF,QAAQ,CAAC,EAAE;IACnC5C,KAAK,CAAC+C,cAAc,EAAE;EACxB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sBAAsB,CAACC,MAAM,EAAEP,MAAM,EAAEQ,KAAK,EAAEC,MAAM,EAAE;EACpED,KAAK,GAAGxD,MAAM,CAAC0D,MAAM,CAACF,KAAK,CAAC;EAC5BA,KAAK,CAACG,OAAO,CAACtC,IAAI,IAAI;IACpBkC,MAAM,CAACK,gBAAgB,CAACvC,IAAI,EAAEf,KAAK,IAAI;MACrC,IAAImD,MAAM,IAAI,CAACA,MAAM,CAACnD,KAAK,CAAC,EAAE;QAC5B;MACF;MACAyC,cAAc,CAACC,MAAM,EAAE1C,KAAK,CAAC;IAC/B,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuD,OAAO,CAACC,QAAQ,EAAEC,EAAE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAC1D,IAAIC,OAAO,GAAGL,QAAQ,CAACM,MAAM,EAAE;EAC/B,IAAIxD,KAAK,GAAGX,MAAM,CAAC0B,GAAG,EAAE,CAAC0C,iBAAiB,EAAE;EAE5CP,QAAQ,CAACjB,EAAE,CAAC,WAAW,EAAEvC,KAAK,IAAIA,KAAK,CAAC+C,cAAc,EAAE,CAAC,CAAC,CAAC;EAC3DS,QAAQ,CAACjB,EAAE,CAAC,QAAQ,EAAEvC,KAAK,IAAI6D,OAAO,CAACxB,GAAG,CAAC,GAAG,GAAGoB,EAAE,CAAC,CAAC;EAErDD,QAAQ,CAACjB,EAAE,CAAClC,SAAS,CAACC,KAAK,CAAC,EAAEN,KAAK,IAAI;IACrC,IAAIgE,WAAW,GAAGR,QAAQ,CAACS,QAAQ,EAAE,CAACC,IAAI;IAC1C,IAAIC,UAAU,GAAG,CAACT,MAAM,IAAI,CAAC,CAACA,MAAM,CAAC;MAACxD,aAAa,EAAEF,KAAK;MAAEoE,YAAY,EAAEJ,WAAW;MAAEK,MAAM,EAAE,CAAC;MAAEC,OAAO,EAAEN,WAAW;MAAEO,SAAS,EAAE;IAAC,CAAC,CAAC;IACtI,IAAI,CAACJ,UAAU,EAAE;MACf;IACF;IAEA,IAAIK,QAAQ,GAAG,IAAI;IACnB,IAAIC,SAAS,GAAG7E,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC;IACnC,IAAI0E,UAAU,GAAGV,WAAW;IAC5B,IAAIO,SAAS,GAAG,CAAC;IAEjBV,OAAO,CAACtB,EAAE,CAAC9B,SAAS,CAACH,KAAK,EAAEmD,EAAE,CAAC,EAAEzD,KAAK,IAAI;MACxC,IAAID,KAAK,GAAGH,MAAM,CAACG,KAAK,CAACC,KAAK,CAAC;MAC/B,IAAIqE,MAAM,GAAGtE,KAAK,GAAG0E,SAAS;MAC9B,IAAIH,OAAO,GAAGN,WAAW,GAAGK,MAAM;MAClC,IAAIC,OAAO,KAAKI,UAAU,EAAE;QAC1B;QACAH,SAAS,GAAGtD,IAAI,CAAC0D,IAAI,CAACL,OAAO,GAAGI,UAAU,CAAC;MAC7C;MACA,IAAIf,MAAM,EAAE;QACV,IAAIiB,CAAC,GAAGjB,MAAM,CAAC;UAACzD,aAAa,EAAEF,KAAK;UAAEoE,YAAY,EAAEJ,WAAW;UAAEK,MAAM,EAAEA,MAAM;UAAEC,OAAO,EAAEA,OAAO;UAAEC,SAAS,EAAEA;QAAS,CAAC,CAAC;QACzHG,UAAU,GAAG,OAAOE,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGN,OAAO;MAClD,CAAC,MAAM;QACLI,UAAU,GAAGJ,OAAO;MACtB;IACF,CAAC,CAAC;IAEFT,OAAO,CAACtB,EAAE,CAAC7B,cAAc,CAACJ,KAAK,EAAEmD,EAAE,CAAC,EAAEzD,KAAK,IAAI;MAC7C,IAAI,CAACwE,QAAQ,EAAE;QACb;QACA;MACF;MACAA,QAAQ,GAAG,KAAK;MAChBX,OAAO,CAACxB,GAAG,CAAC,GAAG,GAAGoB,EAAE,CAAC;MACrB,IAAIG,IAAI,EAAE;QACRA,IAAI,CAAC;UAAC1D,aAAa,EAAEF,KAAK;UAAEoE,YAAY,EAAEJ,WAAW;UAAEK,MAAM,EAAEK,UAAU,GAAGV,WAAW;UAAEM,OAAO,EAAEI,UAAU;UAAEH,SAAS,EAAEA;QAAS,CAAC,CAAC;MACtI;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,eAAe;EACbvB,sBAAsB;EACtBhC,aAAa;EACbH,YAAY;EACZW,2BAA2B;EAC3BzB,KAAK;EACLK,KAAK;EACLe,cAAc;EACdsB,cAAc;EACdjC,YAAY;EACZH,SAAS;EACTK,cAAc;EACdD,SAAS;EACT8C;AACF,CAAC"},"metadata":{},"sourceType":"module"}