{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { strings } from '../index';\nexport default class ResponseQueue {\n  constructor(session) {\n    this.session = session;\n    this.queue = [];\n    this.lastProcessedSequenceNo = 0;\n    this.nextExpectedSequenceNo = 1;\n    this.force = false;\n    this.forceTimeoutId = null;\n  }\n  // in ms\n\n  add(response) {\n    let sequenceNo = response && response['#'];\n\n    // Ignore responses that were already processed (duplicate detection)\n    if (sequenceNo && sequenceNo <= this.lastProcessedSequenceNo) {\n      return;\n    }\n\n    // \"Fast-forward\" the expected sequence no. when a combined response is received\n    if (sequenceNo && response.combined) {\n      this.lastProcessedSequenceNo = Math.max(sequenceNo - 1, this.lastProcessedSequenceNo);\n      this.nextExpectedSequenceNo = Math.max(sequenceNo, this.nextExpectedSequenceNo);\n    }\n    if (!sequenceNo || this.queue.length === 0) {\n      // Handle messages without sequenceNo in the order they were received\n      this.queue.push(response);\n    } else {\n      // Insert at correct position (ascending order)\n      let newQueue = [];\n      let responseToInsert = response;\n      for (let i = 0; i < this.queue.length; i++) {\n        let el = this.queue[i];\n        if (el['#']) {\n          if (responseToInsert && el['#'] > sequenceNo) {\n            // insert at position\n            newQueue.push(response);\n            responseToInsert = null;\n          }\n          if (el['#'] <= this.lastProcessedSequenceNo) {\n            // skip obsolete elements (may happen when a combined response is added to the queue)\n            continue;\n          }\n        }\n        newQueue.push(el);\n      }\n      if (responseToInsert) {\n        // no element with bigger seqNo found -> insert as last element\n        newQueue.push(responseToInsert);\n      }\n      this.queue = newQueue;\n    }\n  }\n  process(response) {\n    if (response) {\n      this.add(response);\n    }\n\n    // Process the queue in ascending order\n    let responseSuccess = true;\n    let missingResponse = false;\n    let nonProcessedResponses = [];\n    for (let i = 0; i < this.queue.length; i++) {\n      let el = this.queue[i];\n      let sequenceNo = el['#'];\n\n      // For elements with a sequence number, check if they are in the expected order\n      if (sequenceNo) {\n        if (this.nextExpectedSequenceNo && !this.force && !missingResponse) {\n          missingResponse = this.nextExpectedSequenceNo !== sequenceNo;\n        }\n        if (missingResponse) {\n          // Sequence is not complete, process those messages later\n          nonProcessedResponses.push(el);\n          continue;\n        }\n      }\n\n      // Handle the element\n      let success = this.session.processJsonResponseInternal(el);\n      // Only return success value of the response that was passed to the process() call\n      if (response && el === response) {\n        responseSuccess = success;\n      }\n\n      // Update the expected next sequenceNo\n      if (sequenceNo) {\n        this.lastProcessedSequenceNo = sequenceNo;\n        this.nextExpectedSequenceNo = sequenceNo + 1;\n      }\n    }\n    // Keep non-processed events (because they are not in sequence) in the queue\n    this.queue = nonProcessedResponses;\n    this._checkTimeout();\n    return responseSuccess;\n  }\n  size() {\n    return this.queue.length;\n  }\n  _checkTimeout() {\n    // If there are non-processed elements, schedule a job that forces the processing of those\n    // elements after a certain timeout to prevent the \"blocked forever syndrome\" if a response\n    // was lost on the network.\n    if (this.queue.length === 0) {\n      clearTimeout(this.forceTimeoutId);\n      this.forceTimeoutId = null;\n    } else if (!this.forceTimeoutId) {\n      this.forceTimeoutId = setTimeout(() => {\n        try {\n          let s = '[';\n          for (let i = 0; i < this.queue.length; i++) {\n            if (i > 0) {\n              s += ', ';\n            }\n            s += strings.box('#', this.queue[i]['#']) || '<none>';\n          }\n          s += ']';\n          this.session.sendLogRequest('Expected response #' + this.nextExpectedSequenceNo + ' still missing after ' + ResponseQueue.FORCE_TIMEOUT + ' ms. Forcing response queue to process ' + this.size() + ' elements: ' + s);\n        } catch (error) {\n          // nop\n        }\n        this.force = true;\n        try {\n          this.process();\n        } finally {\n          this.force = false;\n          this.forceTimeoutId = null;\n        }\n      }, ResponseQueue.FORCE_TIMEOUT);\n    }\n  }\n  prepareRequest(request) {\n    request['#ACK'] = this.lastProcessedSequenceNo;\n  }\n  prepareHttpRequest(ajaxOptions) {\n    ajaxOptions.headers = ajaxOptions.headers || {};\n    ajaxOptions.headers['X-Scout-#ACK'] = this.lastProcessedSequenceNo;\n  }\n}\n_defineProperty(ResponseQueue, \"FORCE_TIMEOUT\", 10 * 1000);","map":{"version":3,"names":["strings","ResponseQueue","constructor","session","queue","lastProcessedSequenceNo","nextExpectedSequenceNo","force","forceTimeoutId","add","response","sequenceNo","combined","Math","max","length","push","newQueue","responseToInsert","i","el","process","responseSuccess","missingResponse","nonProcessedResponses","success","processJsonResponseInternal","_checkTimeout","size","clearTimeout","setTimeout","s","box","sendLogRequest","FORCE_TIMEOUT","error","prepareRequest","request","prepareHttpRequest","ajaxOptions","headers"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/session/ResponseQueue.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {strings} from '../index';\n\nexport default class ResponseQueue {\n\n  constructor(session) {\n    this.session = session;\n    this.queue = [];\n    this.lastProcessedSequenceNo = 0;\n    this.nextExpectedSequenceNo = 1;\n\n    this.force = false;\n    this.forceTimeoutId = null;\n  }\n\n  static FORCE_TIMEOUT = 10 * 1000; // in ms\n\n  add(response) {\n    let sequenceNo = response && response['#'];\n\n    // Ignore responses that were already processed (duplicate detection)\n    if (sequenceNo && sequenceNo <= this.lastProcessedSequenceNo) {\n      return;\n    }\n\n    // \"Fast-forward\" the expected sequence no. when a combined response is received\n    if (sequenceNo && response.combined) {\n      this.lastProcessedSequenceNo = Math.max(sequenceNo - 1, this.lastProcessedSequenceNo);\n      this.nextExpectedSequenceNo = Math.max(sequenceNo, this.nextExpectedSequenceNo);\n    }\n\n    if (!sequenceNo || this.queue.length === 0) { // Handle messages without sequenceNo in the order they were received\n      this.queue.push(response);\n    } else {\n      // Insert at correct position (ascending order)\n      let newQueue = [];\n      let responseToInsert = response;\n      for (let i = 0; i < this.queue.length; i++) {\n        let el = this.queue[i];\n        if (el['#']) {\n          if (responseToInsert && el['#'] > sequenceNo) {\n            // insert at position\n            newQueue.push(response);\n            responseToInsert = null;\n          }\n          if (el['#'] <= this.lastProcessedSequenceNo) {\n            // skip obsolete elements (may happen when a combined response is added to the queue)\n            continue;\n          }\n        }\n        newQueue.push(el);\n      }\n      if (responseToInsert) {\n        // no element with bigger seqNo found -> insert as last element\n        newQueue.push(responseToInsert);\n      }\n      this.queue = newQueue;\n    }\n  }\n\n  process(response) {\n    if (response) {\n      this.add(response);\n    }\n\n    // Process the queue in ascending order\n    let responseSuccess = true;\n    let missingResponse = false;\n    let nonProcessedResponses = [];\n    for (let i = 0; i < this.queue.length; i++) {\n      let el = this.queue[i];\n      let sequenceNo = el['#'];\n\n      // For elements with a sequence number, check if they are in the expected order\n      if (sequenceNo) {\n        if (this.nextExpectedSequenceNo && !this.force && !missingResponse) {\n          missingResponse = (this.nextExpectedSequenceNo !== sequenceNo);\n        }\n        if (missingResponse) {\n          // Sequence is not complete, process those messages later\n          nonProcessedResponses.push(el);\n          continue;\n        }\n      }\n\n      // Handle the element\n      let success = this.session.processJsonResponseInternal(el);\n      // Only return success value of the response that was passed to the process() call\n      if (response && el === response) {\n        responseSuccess = success;\n      }\n\n      // Update the expected next sequenceNo\n      if (sequenceNo) {\n        this.lastProcessedSequenceNo = sequenceNo;\n        this.nextExpectedSequenceNo = sequenceNo + 1;\n      }\n    }\n    // Keep non-processed events (because they are not in sequence) in the queue\n    this.queue = nonProcessedResponses;\n\n    this._checkTimeout();\n\n    return responseSuccess;\n  }\n\n  size() {\n    return this.queue.length;\n  }\n\n  _checkTimeout() {\n    // If there are non-processed elements, schedule a job that forces the processing of those\n    // elements after a certain timeout to prevent the \"blocked forever syndrome\" if a response\n    // was lost on the network.\n    if (this.queue.length === 0) {\n      clearTimeout(this.forceTimeoutId);\n      this.forceTimeoutId = null;\n    } else if (!this.forceTimeoutId) {\n      this.forceTimeoutId = setTimeout(() => {\n        try {\n          let s = '[';\n          for (let i = 0; i < this.queue.length; i++) {\n            if (i > 0) {\n              s += ', ';\n            }\n            s += (strings.box('#', this.queue[i]['#']) || '<none>');\n          }\n          s += ']';\n          this.session.sendLogRequest('Expected response #' + this.nextExpectedSequenceNo + ' still missing after ' +\n            ResponseQueue.FORCE_TIMEOUT + ' ms. Forcing response queue to process ' + this.size() + ' elements: ' + s);\n        } catch (error) {\n          // nop\n        }\n        this.force = true;\n        try {\n          this.process();\n        } finally {\n          this.force = false;\n          this.forceTimeoutId = null;\n        }\n      }, ResponseQueue.FORCE_TIMEOUT);\n    }\n  }\n\n  prepareRequest(request) {\n    request['#ACK'] = this.lastProcessedSequenceNo;\n  }\n\n  prepareHttpRequest(ajaxOptions) {\n    ajaxOptions.headers = ajaxOptions.headers || {};\n    ajaxOptions.headers['X-Scout-#ACK'] = this.lastProcessedSequenceNo;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}