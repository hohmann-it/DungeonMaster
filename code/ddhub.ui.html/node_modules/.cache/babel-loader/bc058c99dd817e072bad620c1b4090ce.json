{"ast":null,"code":"/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ContextMenuKeyStroke, DoubleClickSupport, FilterSupport, graphics, HtmlComponent, KeyStrokeContext, LoadingSupport, LogicalGridData, MenuDestinations, menus as menus_1, numbers, objects, PlaceholderTile, Range, scout, TileGridGridConfig, TileGridLayout, TileGridLayoutConfig, TileGridSelectAllKeyStroke, TileGridSelectDownKeyStroke, TileGridSelectFirstKeyStroke, TileGridSelectionHandler, TileGridSelectLastKeyStroke, TileGridSelectLeftKeyStroke, TileGridSelectRightKeyStroke, TileGridSelectUpKeyStroke, TileTextFilter, VirtualScrolling, Widget } from '../index';\nimport $ from 'jquery';\n\n/**\n * Only select top-level tile elements. Do not select elements with a 'tile' class deeper in the tree.\n * This prevents errors when a developer accidentally adds an element that has the 'tile' class. #262146\n * @type {string}\n */\nconst TILE_SELECTOR = '> .tile';\nexport default class TileGrid extends Widget {\n  constructor() {\n    super();\n    this.animateTileRemoval = true;\n    this.animateTileInsertion = true;\n    this.comparator = null;\n    this._doubleClickSupport = new DoubleClickSupport();\n    this.empty = false;\n    this.filters = [];\n    this.filteredTiles = [];\n    this.filteredElementsDirty = true;\n    this.focusedTile = null;\n    // GridColumnCount will be modified by the layout, prefGridColumnCount remains unchanged\n    this.gridColumnCount = 4;\n    this.prefGridColumnCount = this.gridColumnCount;\n    this.logicalGrid = scout.create('scout.HorizontalGrid');\n    this.layoutConfig = null;\n    this.menus = [];\n    this.multiSelect = true;\n    this.renderAnimationEnabled = false;\n    this.selectable = false;\n    this.selectedTiles = [];\n    this.selectionHandler = new TileGridSelectionHandler(this);\n    this.scrollable = true;\n    this.startupAnimationDone = false;\n    this.startupAnimationEnabled = false;\n    this.tiles = [];\n    this.tileRemovalPendingCount = 0;\n    this.viewRangeSize = 0;\n    this.viewRangeRendered = new Range(0, 0);\n    this.virtual = false;\n    this.virtualScrolling = null;\n    this.withPlaceholders = false;\n    this.placeholderProducer = null;\n    this.$filterFieldContainer = null;\n    this.textFilterEnabled = false;\n    this.filterSupport = this._createFilterSupport();\n    this.createTextFilter = null;\n    this.updateTextFilterText = null;\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._renderViewPortAfterAttach = false;\n    this._scrollParentScrollHandler = this._onScrollParentScroll.bind(this);\n    this._addWidgetProperties(['tiles', 'selectedTiles', 'menus']);\n    this._addPreserveOnPropertyChangeProperties(['selectedTiles']);\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n  }\n  _init(model) {\n    super._init(model);\n    this._setGridColumnCount(this.gridColumnCount);\n    this._setLayoutConfig(this.layoutConfig);\n    this._initVirtualScrolling();\n    this._initTiles();\n    this.setFilters(this.filters, false);\n    this.filter();\n    this.updateFilteredElements();\n    this._setMenus(this.menus);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n  _initVirtualScrolling() {\n    this.virtualScrolling = this._createVirtualScrolling();\n  }\n  _createVirtualScrolling() {\n    return new VirtualScrolling({\n      widget: this,\n      enabled: this.virtual,\n      viewRangeSize: this.viewRangeSize,\n      rowHeight: this._heightForRow.bind(this),\n      rowCount: this.rowCount.bind(this),\n      _renderViewRange: this._renderViewRange.bind(this)\n    });\n  }\n\n  /**\n   * @override\n   */\n  _createLoadingSupport() {\n    return new LoadingSupport({\n      widget: this\n    });\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke([new TileGridSelectAllKeyStroke(this), new TileGridSelectLeftKeyStroke(this), new TileGridSelectRightKeyStroke(this), new TileGridSelectDownKeyStroke(this), new TileGridSelectUpKeyStroke(this), new TileGridSelectFirstKeyStroke(this), new TileGridSelectLastKeyStroke(this), new ContextMenuKeyStroke(this, this.showContextMenu, this)]);\n  }\n  _initTiles() {\n    this.tiles.forEach(function (tile) {\n      this._initTile(tile);\n    }, this);\n  }\n  _initTile(tile) {\n    tile.setSelectable(this.selectable);\n    tile.setSelected(this.selectedTiles.indexOf(tile) >= 0);\n\n    // Set proper state in case tile was used in another grid\n    tile.setParent(this);\n    tile.setFilterAccepted(true);\n  }\n  _render() {\n    this.$container = this.$parent.appendDiv('tile-grid');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(this._createLayout());\n    this.$container.on('mousedown', TILE_SELECTOR, this._onTileMouseDown.bind(this)).on('click', TILE_SELECTOR, this._onTileClick.bind(this)).on('dblclick', TILE_SELECTOR, this._onTileDoubleClick.bind(this));\n    this.$filterFieldContainer = this.$container.prependDiv('filter-field-container');\n  }\n  _createLayout() {\n    return new TileGridLayout(this, this.layoutConfig);\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderLayoutConfig();\n    this._renderScrollable();\n    this._renderVirtual();\n    this._renderSelectable();\n    this._renderEmpty();\n    this._renderTextFilterEnabled();\n  }\n  _remove() {\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.filterSupport.remove();\n    this.viewRangeRendered = new Range(0, 0);\n    this._updateVirtualScrollable();\n    super._remove();\n  }\n\n  /**\n   * @override\n   */\n  _renderOnAttach() {\n    super._renderOnAttach();\n    if (this._renderViewPortAfterAttach) {\n      this._renderViewPort();\n      this._renderViewPortAfterAttach = false;\n    }\n  }\n  _renderEnabled() {\n    super._renderEnabled();\n    this._updateTabbable();\n  }\n  _updateTabbable() {\n    if (!this.textFilterEnabled && !this.selectable) {\n      this.$container.setTabbable(false);\n    } else {\n      this.$container.setTabbableOrFocusable(this.enabledComputed);\n    }\n  }\n  insertTile(tile) {\n    this.insertTiles([tile]);\n  }\n  insertTiles(tilesToInsert, appendPlaceholders) {\n    tilesToInsert = arrays.ensure(tilesToInsert);\n    if (tilesToInsert.length === 0) {\n      return;\n    }\n    this.setTiles(this.tiles.concat(tilesToInsert), appendPlaceholders);\n  }\n  deleteTile(tile) {\n    this.deleteTiles([tile]);\n  }\n  deleteTiles(tilesToDelete, appendPlaceholders) {\n    tilesToDelete = arrays.ensure(tilesToDelete);\n    if (tilesToDelete.length === 0) {\n      return;\n    }\n    let tiles = this.tiles.slice();\n    arrays.removeAll(tiles, tilesToDelete);\n    this.setTiles(tiles, appendPlaceholders);\n  }\n  deleteAllTiles() {\n    this.setTiles([]);\n  }\n  setTiles(tiles, appendPlaceholders) {\n    tiles = arrays.ensure(tiles);\n    if (objects.equals(this.tiles, tiles)) {\n      return;\n    }\n\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n    if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n      // Remove placeholders from new tiles, they will be added later\n      this._deletePlaceholders(tiles);\n    }\n\n    // Only insert those which are not already there\n    let tilesToInsert = arrays.diff(tiles, this.tiles);\n    this._insertTiles(tilesToInsert);\n\n    // Append the existing placeholders, otherwise they would be unnecessarily deleted if a tile is deleted\n    if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n      let placeholders = this.placeholders();\n      // But only add as much placeholders as needed: If a new tile is added, it should replace the placeholder underneath.\n      // If this were not done the placeholders would move animated when a new tile is inserted rather than just staying where they are\n      placeholders = placeholders.slice(Math.min(this._filterTiles(tilesToInsert).length, placeholders.length), placeholders.length);\n      arrays.pushAll(tiles, placeholders);\n    }\n\n    // Only delete those which are not in the new array\n    let tilesToDelete = arrays.diff(this.tiles, tiles);\n    this._deleteTiles(tilesToDelete);\n    this._sort(tiles);\n    this.filteredElementsDirty = this.filteredElementsDirty || tilesToDelete.length > 0 || tilesToInsert.length > 0 || !arrays.equals(this.tiles, tiles); // last check necessary if sorting changed\n    let currentTiles = this.tiles;\n    this._setProperty('tiles', tiles);\n    this.updateFilteredElements();\n    if (this.rendered) {\n      this._renderTileDelta();\n      this._renderTileOrder(currentTiles);\n      this._renderInsertTiles(tilesToInsert);\n    }\n  }\n  _insertTiles(tiles) {\n    if (tiles.length === 0) {\n      return;\n    }\n    tiles.forEach(function (tile) {\n      this._insertTile(tile);\n    }, this);\n  }\n  _insertTile(tile) {\n    this._initTile(tile);\n    this._applyFilters([tile]);\n    if (!this.virtual && this.rendered) {\n      this._renderTile(tile);\n    }\n  }\n  _renderTile(tile) {\n    if (tile.removalPending) {\n      // If tile is being removed by the filter and the filter cleared so that the tile should be rendered again while the animation is still running,\n      // we need to wait for the remove animation, otherwise an already rendered exception occurs\n      tile.one('remove', () => {\n        if (tile.rendered) {\n          // Might be already rendered again by renderTileDelta because filter was changed again\n          return;\n        }\n        this._renderTile(tile);\n        this._renderTileVisibleForFilter(tile);\n        if (this.tileRemovalPendingCount === 0) {\n          this.invalidateLayoutTree();\n        }\n      });\n      return;\n    }\n    tile.render();\n    tile.setLayoutData(new LogicalGridData(tile));\n    tile.$container.addClass('newly-rendered');\n  }\n  _renderInsertTiles(tiles) {\n    tiles.forEach(function (tile) {\n      if (!tile.rendered) {\n        return;\n      }\n      tile.$container.addClass('invisible');\n      // Wait until the layout animation is done before animating the insert operation.\n      // Also make them invisible to not cover existing tiles while they are moving or changing size.\n      // Also do it for tiles which don't have an insert animation (e.g. placeholders), due to the same reason.\n      this.one('layoutAnimationDone', () => {\n        if (tile.rendered) {\n          tile.$container.removeClass('invisible');\n          if (this._animateTileInsertion(tile)) {\n            tile.$container.addClassForAnimation('animate-insert');\n          }\n        }\n      });\n    }, this);\n    if (!this.htmlComp.layouting) {\n      // no need to invalidate when tile placeholders are added or removed while layouting\n      this.invalidateLayoutTree();\n    }\n  }\n  _removeAllTiles() {\n    this.tiles.forEach(tile => {\n      tile.remove();\n    });\n    this.viewRangeRendered = new Range(0, 0);\n  }\n  _renderAllTiles() {\n    this.tiles.forEach(function (tile) {\n      this._renderTile(tile);\n    }, this);\n  }\n  _deleteTiles(tiles) {\n    if (tiles.length === 0) {\n      return;\n    }\n    tiles.forEach(function (tile) {\n      this._deleteTile(tile);\n    }, this);\n    this.deselectTiles(tiles);\n    if (this.rendered && !this.htmlComp.layouting) {\n      // no need to invalidate when tile placeholders are added or removed while layouting\n      this.invalidateLayoutTree();\n    }\n  }\n  _deleteTile(tile) {\n    if (this._animateTileRemoval(tile)) {\n      // Animate tile removal, but not while layouting when tile placeholders are added or removed\n      tile.animateRemoval = true;\n    }\n    // Destroy only if it is the owner, if tile belongs to another widget, just remove it\n    if (tile.owner === this) {\n      tile.destroy();\n    } else if (this.rendered) {\n      tile.remove();\n    }\n    this._onAnimatedTileRemove(tile);\n    tile.animateRemoval = false;\n    if (tile === this.focusedTile) {\n      this.setFocusedTile(null);\n    }\n  }\n  _animateTileRemoval(tile) {\n    return this.animateTileRemoval && tile && tile.isVisible() && !(tile instanceof PlaceholderTile);\n  }\n  _animateTileInsertion(tile) {\n    return this.animateTileInsertion && tile && tile.isVisible() && !(tile instanceof PlaceholderTile);\n  }\n  _onAnimatedTileRemove(tile) {\n    if (!tile.removalPending) {\n      return;\n    }\n    this.tileRemovalPendingCount++;\n    tile.one('remove', () => {\n      this.tileRemovalPendingCount--;\n      if (this.rendered && this.tileRemovalPendingCount === 0 && !this.htmlComp.layouting) {\n        this.invalidateLayoutTree();\n      }\n    });\n  }\n  setComparator(comparator) {\n    if (this.comparator === comparator) {\n      return;\n    }\n    this.comparator = comparator;\n  }\n  sort() {\n    let tiles = this.tiles.slice();\n    this._sort(tiles);\n    if (arrays.equals(this.tiles, tiles)) {\n      // Check is needed anyway to determine whether filteredElementsDirty needs to be set, so we can use it here as well to early return if nothing changed\n      return;\n    }\n    let currentTiles = this.tiles;\n    this._setProperty('tiles', tiles);\n\n    // Sort list of filtered tiles as well\n    this.filteredElementsDirty = true;\n    this.updateFilteredElements();\n    if (this.rendered) {\n      this._renderTileDelta();\n      this._renderTileOrder(currentTiles);\n    }\n  }\n  _sort(tiles) {\n    if (this.comparator === null) {\n      return;\n    }\n    let placeholders = [];\n    if (this.withPlaceholders) {\n      // Don't reorder placeholders -> remove them first, then sort and add them afterwards again\n      placeholders = this._deletePlaceholders(tiles);\n    }\n    tiles.sort(this.comparator);\n    arrays.pushAll(tiles, placeholders);\n  }\n  invalidateLayoutTree(invalidateParents) {\n    if (this.tileRemovalPendingCount > 0) {\n      // Do not invalidate while tile removal is still pending\n      return;\n    }\n    super.invalidateLayoutTree(invalidateParents);\n  }\n  setGridColumnCount(gridColumnCount) {\n    this.setProperty('gridColumnCount', gridColumnCount);\n  }\n  _setGridColumnCount(gridColumnCount) {\n    this._setProperty('gridColumnCount', gridColumnCount);\n    this.prefGridColumnCount = gridColumnCount;\n    this.invalidateLogicalGrid();\n  }\n  setLayoutConfig(layoutConfig) {\n    this.setProperty('layoutConfig', layoutConfig);\n  }\n  _setLayoutConfig(layoutConfig) {\n    if (!layoutConfig) {\n      layoutConfig = new TileGridLayoutConfig();\n    }\n    this._setProperty('layoutConfig', TileGridLayoutConfig.ensure(layoutConfig));\n  }\n  _renderLayoutConfig() {\n    let oldMinWidth = this.htmlComp.layout.minWidth;\n    this.layoutConfig.applyToLayout(this.htmlComp.layout);\n    if (this.virtualScrolling) {\n      this.virtualScrolling.setMinRowHeight(this._minRowHeight());\n      this.setViewRangeSize(this.virtualScrolling.viewRangeSize, false);\n    }\n    if (oldMinWidth !== this.htmlComp.layout.minWidth) {\n      this._renderScrollable();\n    }\n    this.invalidateLayoutTree();\n  }\n  _setMenus(menus, oldMenus) {\n    this.updateKeyStrokes(menus, oldMenus);\n    this._setProperty('menus', menus);\n  }\n  _filterMenus(menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n    return menus_1.filterAccordingToSelection('TileGrid', this.selectedTiles.length, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);\n  }\n  showContextMenu(options) {\n    this.session.onRequestsDone(this._showContextMenu.bind(this, options));\n  }\n\n  /**\n   * @param options may contain pageX, pageY, menuItems and menuFilter.\n   * If these properties are not provided they are determined automatically.\n   */\n  _showContextMenu(options) {\n    options = options || {};\n    if (!this.rendered || !this.attached) {\n      // check needed because function is called asynchronously\n      return;\n    }\n    if (this.selectedTiles.length === 0) {\n      return;\n    }\n    let menuItems = options.menuItems || this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false);\n    if (menuItems.length === 0) {\n      return;\n    }\n    let pageX = scout.nvl(options.pageX, null);\n    let pageY = scout.nvl(options.pageY, null);\n    if (pageX === null || pageY === null) {\n      let offset;\n      let $scrollable = this.$container.scrollParent();\n      if ($scrollable.length === 0) {\n        $scrollable = this.$container;\n      }\n      let scrollableBounds = graphics.offsetBounds($scrollable);\n      let focusedTile = this.focusedTile || arrays.last(this.selectedTiles);\n      if (this.isTileInView(focusedTile)) {\n        // Place the context menu on the focused tile if possible\n        offset = focusedTile.$container.offset();\n      } else {\n        // If focused tile is not in view place the popup in the top left corner of the tile grid\n        offset = this.$container.offset();\n      }\n      pageX = offset.left + 10;\n      pageY = offset.top + 10;\n      // Ensure popup is always in view. Add +-1 to make sure it won't be made invisible by Popup._isInView even if bounds are fractional\n      pageX = Math.min(Math.max(pageX, scrollableBounds.x + 1), scrollableBounds.right() - 1);\n      pageY = Math.min(Math.max(pageY, scrollableBounds.y + 1), scrollableBounds.bottom() - 1);\n    }\n    // Prevent firing of 'onClose'-handler during contextMenu.open()\n    // (Can lead to null-access when adding a new handler to this.contextMenu)\n    if (this.contextMenu) {\n      this.contextMenu.close();\n    }\n    this.contextMenu = scout.create('ContextMenuPopup', {\n      parent: this,\n      menuItems: menuItems,\n      location: {\n        x: pageX,\n        y: pageY\n      },\n      $anchor: this.$container,\n      menuFilter: options.menuFilter || this._filterMenusHandler\n    });\n    this.contextMenu.open();\n  }\n  setScrollable(scrollable) {\n    this.setProperty('scrollable', scrollable);\n  }\n  _renderScrollable() {\n    this._uninstallScrollbars();\n\n    // horizontal (x-axis) scrollbar is only installed when minWidth is > 0\n    if (this.scrollable) {\n      this._installScrollbars({\n        axis: this.layoutConfig.minWidth > 0 ? 'both' : 'y'\n      });\n    } else if (this.layoutConfig.minWidth > 0) {\n      this._installScrollbars({\n        axis: 'x'\n      });\n    }\n    this.$container.toggleClass('scrollable', this.scrollable);\n    this._updateVirtualScrollable();\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    let scrollTop = this.$container[0].scrollTop;\n    let scrollLeft = this.$container[0].scrollLeft;\n    if (this.scrollTop !== scrollTop && this.virtual) {\n      this.htmlComp.layout.updateViewPort();\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n  }\n  _onScrollParentScroll(event) {\n    this.htmlComp.layout.updateViewPort();\n  }\n  setWithPlaceholders(withPlaceholders) {\n    this.setProperty('withPlaceholders', withPlaceholders);\n  }\n  _renderWithPlaceholders() {\n    this.invalidateLayoutTree();\n  }\n  setPlaceholderProducer(placeholderProducer) {\n    this.setProperty('placeholderProducer', placeholderProducer);\n  }\n  fillUpWithPlaceholders() {\n    if (!this.withPlaceholders) {\n      this._deleteAllPlaceholders();\n      return;\n    }\n    this._deleteObsoletePlaceholders();\n    this._insertMissingPlaceholders();\n  }\n  tilesWithoutPlaceholders() {\n    if (!this.withPlaceholders) {\n      return this.tiles;\n    }\n    return this.tiles.filter(tile => !(tile instanceof PlaceholderTile));\n  }\n  _createPlaceholders() {\n    let numPlaceholders,\n      lastX,\n      columnCount = this.gridColumnCount,\n      tiles = this.filteredTiles,\n      placeholders = [];\n    if (tiles.length > 0) {\n      let tile = tiles[tiles.length - 1];\n      lastX = tile.gridData.x + tile.gridData.w - 1;\n    } else {\n      // If there are no tiles, create one row with placeholders\n      lastX = -1;\n    }\n    if (lastX === columnCount - 1) {\n      // If last tile is the last element in the row, don't create placeholders\n      return [];\n    }\n\n    // Otherwise create placeholders for every missing tile in the last row\n    numPlaceholders = columnCount - 1 - lastX;\n    for (let i = 0; i < numPlaceholders; i++) {\n      placeholders.push(this._createPlaceholder());\n    }\n    return placeholders;\n  }\n  _createPlaceholder() {\n    let placeholder = this.placeholderProducer && this.placeholderProducer() || {};\n    if (placeholder instanceof PlaceholderTile) {\n      return placeholder;\n    }\n    if (objects.isPlainObject(placeholder)) {\n      return scout.create($.extend(true, {}, {\n        objectType: 'PlaceholderTile',\n        parent: this\n      }, placeholder));\n    }\n    throw new Error('Placeholder producer returned unexpected result.');\n  }\n  _deleteObsoletePlaceholders() {\n    let obsoletePlaceholders = [],\n      obsolete = false;\n    let placeholders = this.placeholders();\n    placeholders.forEach(function (placeholder) {\n      // Remove all placeholder in the row if there is one at x=0 (don't do it if there are only placeholders)\n      if (placeholder.gridData.x === 0 && this.filteredTiles[0] !== placeholder) {\n        obsolete = true;\n      }\n      if (obsolete) {\n        obsoletePlaceholders.push(placeholder);\n      }\n    }, this);\n    this.deleteTiles(obsoletePlaceholders, false);\n  }\n  _deleteAllPlaceholders() {\n    this.deleteTiles(this.placeholders(), false);\n  }\n  placeholders() {\n    let i,\n      placeholders = [];\n    for (i = this.tiles.length - 1; i >= 0; i--) {\n      if (!(this.tiles[i] instanceof PlaceholderTile)) {\n        // Placeholders are always at the end -> we may stop as soon as no more placeholders are found\n        break;\n      }\n      arrays.insert(placeholders, this.tiles[i], 0);\n    }\n    return placeholders;\n  }\n  _insertMissingPlaceholders() {\n    let placeholders = this._createPlaceholders();\n    this.insertTiles(placeholders, false);\n  }\n  _deletePlaceholders(tiles) {\n    let i;\n    let deletedPlaceholders = [];\n    for (i = tiles.length - 1; i >= 0; i--) {\n      if (tiles[i] instanceof PlaceholderTile) {\n        deletedPlaceholders.push(tiles[i]);\n        arrays.remove(tiles, tiles[i]);\n      }\n    }\n    return deletedPlaceholders.reverse();\n  }\n  _replacePlaceholders(tiles, tilesToInsert) {\n    // Find index of the first tile which is not a placeholder (placeholders are always added at the end, so it is faster if search is done backwards)\n    let index = arrays.findIndexFromReverse(tiles, tiles.length - 1, tile => {\n      return !(tile instanceof PlaceholderTile);\n    });\n    let numPlaceholders = tiles.length - 1 - index;\n    for (let i = 1; i <= numPlaceholders; i++) {\n      let tile = tiles[index + i];\n      if (tilesToInsert[i - 1] && !(tilesToInsert[i - 1] instanceof PlaceholderTile)) {\n        arrays.remove(tiles, tile);\n      }\n    }\n  }\n  validateLogicalGrid() {\n    if (!this.logicalGrid.dirty) {\n      return;\n    }\n    this.logicalGrid.validate(this);\n    this.fillUpWithPlaceholders();\n    this.logicalGrid.setDirty(true);\n    this.logicalGrid.validate(this);\n  }\n\n  /**\n   * @override\n   */\n  _setLogicalGrid(logicalGrid) {\n    super._setLogicalGrid(logicalGrid);\n    if (this.logicalGrid) {\n      this.logicalGrid.setGridConfig(new TileGridGridConfig());\n    }\n  }\n  setFocusedTile(tile) {\n    if (this.focusedTile === tile) {\n      return;\n    }\n    this.focusedTile = tile;\n    if (!this.rendered || !tile || this.isFocused()) {\n      return;\n    }\n    let $scrollables = this.$container.scrollParents();\n    if ($scrollables.length === 0) {\n      return;\n    }\n    // Make sure the tile grid has the focus when focusing a tile\n    this.focus({\n      preventScroll: true\n    });\n  }\n  setSelectable(selectable) {\n    this.setProperty('selectable', selectable);\n    if (!selectable) {\n      this.deselectAllTiles();\n    }\n    this.tiles.forEach(tile => {\n      tile.setSelectable(selectable);\n    });\n  }\n  _renderSelectable() {\n    this.$container.toggleClass('selectable', this.selectable);\n    this._updateTabbable();\n    this.invalidateLayoutTree();\n  }\n  setMultiSelect(multiSelect) {\n    this.setProperty('multiSelect', multiSelect);\n  }\n\n  /**\n   * Selects the given tiles and deselects the previously selected ones.\n   */\n  selectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n    tiles = this._filterTiles(tiles); // Selecting invisible tiles is not allowed\n\n    // Ensure no tiles will be selected if selectable is disabled\n    if (!this.selectable) {\n      tiles = [];\n    }\n\n    // Ensure only one tile is selected if multiSelect is disabled\n    if (!this.multiSelect && tiles.length > 1) {\n      tiles = [tiles[0]];\n    }\n    if (arrays.equals(this.selectedTiles, tiles)) {\n      // Do nothing if new selection is same as old one\n      return;\n    }\n\n    // Deselect the tiles which are not part of the new selection\n    let tilesToUnselect = this.selectedTiles;\n    arrays.removeAll(tilesToUnselect, tiles);\n    tilesToUnselect.forEach(function (tile) {\n      tile.setSelected(false);\n      if (tile === this.focusedTile) {\n        this.setFocusedTile(null);\n      }\n    }, this);\n\n    // Select the tiles\n    tiles.forEach(tile => {\n      tile.setSelected(true);\n    }, this);\n    this.setProperty('selectedTiles', tiles.slice());\n  }\n  selectTile(tile) {\n    this.selectTiles([tile]);\n  }\n\n  /**\n   * Selects all tiles. As for every selection operation: only filtered tiles are considered.\n   */\n  selectAllTiles() {\n    this.selectTiles(this.filteredTiles);\n  }\n  deselectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    let selectedTiles = this.selectedTiles.slice();\n    if (arrays.removeAll(selectedTiles, tiles)) {\n      this.selectTiles(selectedTiles);\n    }\n  }\n  deselectTile(tile) {\n    this.deselectTiles([tile]);\n  }\n  deselectAllTiles() {\n    this.selectTiles([]);\n  }\n  toggleSelection() {\n    if (this.selectedTiles.length === this.filteredTiles.length) {\n      this.deselectAllTiles();\n    } else {\n      this.selectAllTiles();\n    }\n  }\n  addTilesToSelection(tiles) {\n    tiles = arrays.ensure(tiles);\n    this.selectTiles(this.selectedTiles.concat(tiles));\n  }\n  addTileToSelection(tile) {\n    this.addTilesToSelection([tile]);\n  }\n\n  /**\n   * @returns {boolean} true if the tile is completely or partially visible in the first scrollable parent.\n   */\n  isTileInView(tile) {\n    let $scrollable = this.$container.scrollParent();\n    if ($scrollable.length === 0) {\n      $scrollable = this.$container;\n    }\n    if (!tile || !tile.$container || !$scrollable) {\n      return false;\n    }\n    return graphics.offsetBounds(tile.$container).intersects(graphics.offsetBounds($scrollable));\n  }\n  _onTileMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    this._selectTileOnMouseDown(event);\n    if (event.which === 3) {\n      this.showContextMenu({\n        pageX: event.pageX,\n        pageY: event.pageY\n      });\n      return false;\n    }\n  }\n  _onTileClick(event) {\n    let $tile = $(event.currentTarget);\n    let tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    if (this._doubleClickSupport.doubleClicked()) {\n      // Don't execute on double click events\n      return;\n    }\n    let mouseButton = event.which;\n    this._triggerTileClick(tile, mouseButton);\n  }\n  _triggerTileClick(tile, mouseButton) {\n    let event = {\n      tile: tile,\n      mouseButton: mouseButton\n    };\n    this.trigger('tileClick', event);\n  }\n  _onTileDoubleClick(event) {\n    let $tile = $(event.currentTarget);\n    let tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    this.doTileAction(tile);\n  }\n  doTileAction(tile) {\n    if (!tile) {\n      return;\n    }\n    this._triggerTileAction(tile);\n  }\n  _triggerTileAction(tile) {\n    this.trigger('tileAction', {\n      tile: tile\n    });\n  }\n  setSelectionHandler(selectionHandler) {\n    this.selectionHandler = selectionHandler;\n  }\n  _selectTileOnMouseDown(event) {\n    this.selectionHandler.selectTileOnMouseDown(event);\n  }\n  scrollTo(tile, options) {\n    this.ensureTileRendered(tile);\n    // If tile was not rendered it is not yet positioned correctly -> make sure layout is valid before trying to scroll\n    // Layout must not render the viewport because scroll position is not correct yet -> just make sure tiles are at the correct position\n    this.htmlComp.layout.updateViewPort(true);\n    tile.reveal(options);\n  }\n  revealSelection() {\n    if (!this.rendered) {\n      // Execute delayed because tileGrid may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n    if (this.selectedTiles.length > 0) {\n      this.scrollTo(this.selectedTiles[0]);\n    }\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to add.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  addFilter(filter) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.addFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to remove.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  removeFilter(filter) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.removeFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The new filters.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  setFilters(filters) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.setFilters(filters, applyFilter);\n  }\n  filter() {\n    this.filterSupport.filter();\n  }\n  _applyFilters(tiles, fullReset) {\n    return this.filterSupport.applyFilters(tiles.filter(tile => !(tile instanceof PlaceholderTile)), fullReset);\n  }\n\n  /**\n   * @returns {FilterSupport}\n   */\n  _createFilterSupport() {\n    return new FilterSupport({\n      widget: this,\n      $container: () => this.$filterFieldContainer,\n      getElementsForFiltering: this.tilesWithoutPlaceholders.bind(this),\n      createTextFilter: this._createTextFilter.bind(this),\n      updateTextFilterText: this._updateTextFilterText.bind(this)\n    });\n  }\n  _createTextFilter() {\n    if (objects.isFunction(this.createTextFilter)) {\n      return this.createTextFilter();\n    }\n    return new TileTextFilter();\n  }\n  _updateTextFilterText(filter, text) {\n    if (objects.isFunction(this.updateTextFilterText)) {\n      return this.updateTextFilterText(filter, text);\n    }\n    if (filter instanceof TileTextFilter) {\n      return filter.setText(text);\n    }\n    return false;\n  }\n  setTextFilterEnabled(textFilterEnabled) {\n    this.setProperty('textFilterEnabled', textFilterEnabled);\n  }\n  isTextFilterFieldVisible() {\n    return this.textFilterEnabled;\n  }\n  _renderTextFilterEnabled() {\n    this._updateTabbable();\n    this.filterSupport.renderFilterField();\n  }\n  updateFilteredElements(result, opts) {\n    if (!this.filteredElementsDirty) {\n      this._updateEmpty();\n      return;\n    }\n    this.setProperty('filteredTiles', this._filterTiles());\n    this.invalidateLogicalGrid(false);\n    this.filteredElementsDirty = false;\n    if (result) {\n      if (result.newlyHidden.some(tile => tile === this.focusedTile)) {\n        this.setFocusedTile(null);\n      }\n      // Non visible tiles must be deselected\n      this.deselectTiles(result.newlyHidden);\n      if (this.rendered && !this.removing) {\n        // Not all tiles may be rendered yet (e.g. if filter is active before grid is rendered and removed after grid is rendered)\n        // But updating the view range is necessary anyway (fillers, scrollbars, viewRangeRendered etc.)\n        this._renderTileDelta(result);\n        this._renderTileOrder(this.tiles);\n      }\n    }\n    this._updateEmpty();\n  }\n  _updateEmpty() {\n    this.setEmpty(this.filteredTiles.length === 0);\n  }\n  setEmpty(empty) {\n    this.setProperty('empty', empty);\n  }\n  _renderEmpty() {\n    this.$container.toggleClass('empty', this.empty);\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * @returns {Tile[]} the tiles which are accepted by the filter and therefore visible.\n   */\n  _filterTiles(tiles) {\n    tiles = scout.nvl(tiles, this.tiles);\n    if (this.filters.length === 0) {\n      return tiles.slice();\n    }\n    return tiles.filter(tile => {\n      return tile.filterAccepted;\n    });\n  }\n  findTileIndexAt(x, y, startIndex, reverse) {\n    startIndex = scout.nvl(startIndex, 0);\n    return arrays.findIndexFrom(this.filteredTiles, startIndex, (tile, i) => {\n      return tile.gridData.x === x && tile.gridData.y === y;\n    }, reverse);\n  }\n\n  /**\n   * If the max range is used, the live list of filtered tiles is returned, because every tile has to be in the range.\n   */\n  findTilesInRange(viewRange, filter) {\n    if (viewRange.equals(this.virtualScrolling.maxViewRange())) {\n      // Directly return all tiles if max view range\n      return this.filteredTiles;\n    }\n    let tiles = [];\n    for (let row = viewRange.from; row < viewRange.to; row++) {\n      this.eachTileInRow(row, tile => {\n        // jshint ignore:line\n        if (!filter || filter(tile)) {\n          tiles.push(tile);\n        }\n      });\n    }\n    return tiles;\n  }\n  findTilesInRow(row) {\n    let tiles = [];\n    this.eachTileInRow(row, tile => {\n      tiles.push(tile);\n    });\n    return tiles;\n  }\n\n  /**\n   * Executes the given function for each tile in a row.\n   */\n  eachTileInRow(row, func) {\n    let startIndex = row * this.gridColumnCount;\n    let tiles = [];\n    for (let i = startIndex; i < startIndex + this.gridColumnCount; i++) {\n      if (this.filteredTiles[i]) {\n        func(this.filteredTiles[i], i);\n      }\n    }\n    return tiles;\n  }\n  setVirtual(virtual) {\n    this.setProperty('virtual', virtual);\n  }\n  _setVirtual(virtual) {\n    this._setProperty('virtual', virtual);\n    this.virtualScrolling.setEnabled(this.virtual);\n  }\n  _renderVirtual() {\n    this._updateVirtualScrollable();\n    if (!this.rendering) {\n      // No need to do it while rendering, will be done by the layout. But needs to be done if virtual changes on the fly\n      this.setViewRangeSize(this.calculateViewRangeSize(), false);\n    }\n    if (this.rendered) {\n      // When virtual toggles, remove all tiles and render them anew (to have the correct tiles rendered in the new mode)\n      this._removeAllTiles();\n      if (this.virtual) {\n        // RenderViewPort may do nothing if all tiles are already in the view port, but fillers may not be created yet\n        this._renderFiller();\n      }\n    }\n    if (!this.virtual) {\n      // Render all tiles (on toggle and initially) (_renderViewRange is not used in non virtual mode because filtered tiles need to be rendered as well)\n      this._renderAllTiles();\n    }\n    this._renderViewPort();\n    this.invalidateLayoutTree();\n  }\n  _updateVirtualScrollable() {\n    let $scrollable = this.virtualScrolling.$scrollable;\n    if ($scrollable) {\n      $scrollable.off('scroll', this._scrollParentScrollHandler);\n    }\n    if (!this.virtual || this.removing) {\n      this.virtualScrolling.set$Scrollable(null);\n      return;\n    }\n    if (this.scrollable) {\n      this.virtualScrolling.set$Scrollable(this.$container);\n    } else {\n      this.virtualScrolling.set$Scrollable(this.$container.scrollParent());\n      this.virtualScrolling.$scrollable.on('scroll', this._scrollParentScrollHandler);\n    }\n  }\n  calculateViewRangeSize() {\n    return this.virtualScrolling.calculateViewRangeSize();\n  }\n  setViewRangeSize(viewRangeSize, updateViewPort) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    this.virtualScrolling.setViewRangeSize(viewRangeSize, updateViewPort);\n  }\n  _heightForRow(row) {\n    let height = 0;\n    height = this.htmlComp.layout.rowHeight;\n    if (row !== this.rowCount() - 1) {\n      // Add row gap unless it is the last row\n      height += this.htmlComp.layout.vgap;\n    }\n    if (!numbers.isNumber(height)) {\n      throw new Error('Calculated height is not a number: ' + height);\n    }\n    return height;\n  }\n\n  /**\n   * Used for virtual scrolling to calculate the view range size.\n   * @returns {number} the configured rowHeight + vgap / 2. Reason: the gaps are only between rows, the first and last row therefore only have 1 gap.\n   */\n  _minRowHeight() {\n    return this.htmlComp.layout.rowHeight + this.htmlComp.layout.vgap / 2;\n  }\n  rowCount(gridColumnCount) {\n    gridColumnCount = scout.nvl(gridColumnCount, this.gridColumnCount);\n    return Math.ceil(this.filteredTiles.length / gridColumnCount);\n  }\n\n  /**\n   * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n   */\n  _renderViewPort() {\n    if (!this.isAttachedAndRendered()) {\n      // if grid is not attached the correct viewPort can not be evaluated. Mark for render after attach.\n      this._renderViewPortAfterAttach = true;\n      return;\n    }\n    if (!this.virtual) {\n      return;\n    }\n    this.virtualScrolling._renderViewPort();\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.equals(this.viewRangeRendered)) {\n      if (viewRange.size() === 0) {\n        // Iif view range is empty initially viewRangeRendered will be empty as well -> make sure fillers are rendered correctly (used for pref size)\n        this._renderFiller();\n      }\n      // Range already rendered -> do nothing\n      return;\n    }\n    let rangesToRemove = this.viewRangeRendered.subtract(viewRange).filter(range => {\n      return range.size() > 0;\n    });\n    rangesToRemove.forEach(range => {\n      this._removeTilesInRange(range);\n    });\n    let rangesToRender = viewRange.subtract(this.viewRangeRendered).filter(range => {\n      return range.size() > 0;\n    });\n    rangesToRender.forEach(range => {\n      this._renderTilesInRange(range);\n    });\n    this._renderFiller();\n  }\n  _renderTilesInRange(range) {\n    let numRowsRendered = 0;\n    let tilesRendered = 0;\n    let tiles = this.filteredTiles;\n    if (tiles.length === 0) {\n      return;\n    }\n    let maxRange = this.virtualScrolling.maxViewRange();\n    range = maxRange.intersect(range);\n    let newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n    for (let row = range.from; row < range.to; row++) {\n      this.eachTileInRow(row, renderTile.bind(this));\n      numRowsRendered++;\n    }\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRendered + ' new rows rendered from ' + range);\n      $.log.trace(this._rowsRenderedInfo());\n    }\n    function renderTile(tile) {\n      if (tile.rendered) {\n        return;\n      }\n      this._renderTile(tile);\n      tilesRendered++;\n    }\n  }\n\n  /**\n   * @returns {Tile[]} the newly rendered tiles\n   */\n  _renderTileDelta(filterResult) {\n    if (!this.virtual) {\n      return [];\n    }\n    let prevTiles = this.renderedTiles();\n    let newViewRange = this.virtualScrolling.calculateCurrentViewRange();\n    let newTiles = this.findTilesInRange(newViewRange);\n    let tilesToRemove = arrays.diff(prevTiles, newTiles);\n    let tilesToRender = arrays.diff(newTiles, prevTiles);\n    if (filterResult) {\n      filterResult.newlyHidden.forEach(function (tile) {\n        if (tile.rendered) {\n          this._removeTileByFilter(tile);\n        }\n      }, this);\n    }\n\n    // tilesToRemove contains newlyHidden as well but remove() does nothing if it is already removing\n    tilesToRemove.forEach(tile => {\n      tile.remove();\n    });\n    tilesToRender.forEach(function (tile) {\n      this._renderTile(tile);\n    }, this);\n    if (filterResult) {\n      // Suppress because Tile.js would invalidate which leads to poor performance if grid is used in a Group.js and group is being expanded while tiles are shown\n      // invalidating will be done afterwards anyway so no need to do it for each tile\n      this.htmlComp.suppressInvalidate = true;\n      filterResult.newlyShown.forEach(function (tile) {\n        if (tile.rendered) {\n          this._renderTileVisibleForFilter(tile);\n        }\n      }, this);\n      this.htmlComp.suppressInvalidate = false;\n    }\n    this.viewRangeRendered = newViewRange;\n    this._renderFiller();\n    if (!this.htmlComp.layouting) {\n      // If a tile is inserted while a group of the tile accordion is being expanded,\n      // invalidating may create a loop because the group resizes the body which triggers the TileGridLayout and eventually calls this function again -> Don't invalidate while layouting\n      this.invalidateLayoutTree();\n    }\n    return tilesToRender;\n  }\n  _removeTileByFilter(tile) {\n    // In virtual mode, filtered tiles are not rendered. In normal mode, the filter animation is triggered by _renderVisible of the tile.\n    // Since the tile is removed immediately, the invisible animation would not start, so we use the remove animation instead.\n    // But because the delete animation is a different one to the filter animation, the removeClass needs to be swapped\n    // Remove class first to make sure animation won't be finished before the animationend listener is attached in Widget._removeAnimated (which may happen because a setTimeout is used there)\n    tile.$container.removeClass('animate-invisible');\n    tile.animateRemoval = true;\n    tile.animateRemovalClass = 'animate-invisible';\n    tile.remove();\n    this._onAnimatedTileRemove(tile);\n    tile.animateRemoval = false;\n    // Remove animation is started by a set timeout -> use set timeout as well to come after\n    setTimeout(() => {\n      // Reset to default\n      tile.animateRemovalClass = 'animate-remove';\n    });\n  }\n  _renderTileVisibleForFilter(tile) {\n    if (!tile.filterAccepted || tile.$container.hasClass('animate-visible')) {\n      return;\n    }\n    if (tile.removalPending) {\n      return;\n    }\n    // Start filter animation (at the time setFilterAccepted was set the tile was not rendered)\n    tile.$container.setVisible(false);\n    tile._renderVisible();\n  }\n  _renderTileOrder(prevTiles) {\n    // Loop through the tiles and move every html element to the end of the container\n    // Only move if the order is different to the old order\n    // This is actually only necessary to make debugging easier, since the tiles are positioned absolutely it would work without it\n    let different = false;\n    this.tiles.forEach(function (tile, i) {\n      if (prevTiles[i] !== tile || different) {\n        // Start ordering as soon as the order of the arrays starts to differ\n        if (this.virtual && !tile.rendered) {\n          // In non virtual mode, every tile is rendered, even the filtered one. So if a tile is not rendered ignore it in virtual, but fail in non virtual\n          return;\n        }\n        different = true;\n        tile.$container.appendTo(this.$container);\n      }\n    }, this);\n    if (different && !this.virtual) {\n      // In virtual mode this is done by _renderTileDelta()\n      this.invalidateLayoutTree();\n    }\n  }\n  _rowsRenderedInfo() {\n    let numRenderedTiles = this.$container.children('.tile').length;\n    let renderedRowsRange = '(' + this.viewRangeRendered + ')';\n    return numRenderedTiles + ' tiles rendered in range ' + renderedRowsRange;\n  }\n  _removeTilesInRange(range) {\n    let numRowsRemoved = 0;\n    let newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n    for (let i = range.from; i < range.to; i++) {\n      this._removeTilesInRow(i);\n      numRowsRemoved++;\n    }\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');\n      $.log.trace(this._rowsRenderedInfo());\n    }\n  }\n  _removeTilesInRow(row) {\n    let tiles = this.findTilesInRow(row);\n    tiles.forEach(tile => {\n      tile.remove();\n    });\n  }\n  rowHasRenderedTiles(row) {\n    let tilesInRow = this.findTilesInRow(row);\n    return tilesInRow.some(tile => {\n      return tile.rendered && !tile.removing;\n    });\n  }\n  ensureTileRendered(tile) {\n    if (!tile.rendered) {\n      let rowIndex = tile.gridData.y;\n      this.virtualScrolling._renderViewRangeForRowIndex(rowIndex);\n      this.invalidateLayoutTree();\n    }\n  }\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$container.prependDiv('filler');\n    }\n    let fillBeforeHeight = this._calculateFillerHeight(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeHeight);\n    this.$fillBefore.css('width', '100%');\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeHeight);\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$container.appendDiv('filler');\n    }\n    // Make sure filler is always at the end\n    this.$fillAfter.appendTo(this.$container);\n    let renderedTilesHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.from, this.viewRangeRendered.to));\n    this.$fillAfter.cssTop(fillBeforeHeight + renderedTilesHeight);\n    let fillAfterHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.to, this.rowCount()));\n    this.$fillAfter.cssHeight(fillAfterHeight);\n    this.$fillAfter.css('width', '100%');\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterHeight);\n  }\n  _calculateFillerHeight(range) {\n    let totalHeight = 0;\n    for (let i = range.from; i < range.to; i++) {\n      totalHeight += this._heightForRow(i);\n    }\n    return totalHeight;\n  }\n\n  /**\n   * If virtual is false, the live list of filtered tiles is returned, because every tile has to be rendered. If virtual is true, the rendered tiles are collected and returned.\n   */\n  renderedTiles() {\n    if (!this.rendered) {\n      return [];\n    }\n    if (!this.virtual) {\n      return this.filteredTiles;\n    }\n    let tiles = [];\n    this.$container.children('.tile').each((i, elem) => {\n      let tile = scout.widget(elem);\n      if (!tile.removalPending) {\n        // Don't return the tiles which are being removed\n        // Otherwise delta could be wrong if called while removing. Example: filter is added and removed right after while the tiles are still being removed -> RenderTileDelta has to render the tiles being removed\n        tiles.push(tile);\n      }\n    });\n    return tiles;\n  }\n}","map":{"version":3,"names":["arrays","ContextMenuKeyStroke","DoubleClickSupport","FilterSupport","graphics","HtmlComponent","KeyStrokeContext","LoadingSupport","LogicalGridData","MenuDestinations","menus","menus_1","numbers","objects","PlaceholderTile","Range","scout","TileGridGridConfig","TileGridLayout","TileGridLayoutConfig","TileGridSelectAllKeyStroke","TileGridSelectDownKeyStroke","TileGridSelectFirstKeyStroke","TileGridSelectionHandler","TileGridSelectLastKeyStroke","TileGridSelectLeftKeyStroke","TileGridSelectRightKeyStroke","TileGridSelectUpKeyStroke","TileTextFilter","VirtualScrolling","Widget","$","TILE_SELECTOR","TileGrid","constructor","animateTileRemoval","animateTileInsertion","comparator","_doubleClickSupport","empty","filters","filteredTiles","filteredElementsDirty","focusedTile","gridColumnCount","prefGridColumnCount","logicalGrid","create","layoutConfig","multiSelect","renderAnimationEnabled","selectable","selectedTiles","selectionHandler","scrollable","startupAnimationDone","startupAnimationEnabled","tiles","tileRemovalPendingCount","viewRangeSize","viewRangeRendered","virtual","virtualScrolling","withPlaceholders","placeholderProducer","$filterFieldContainer","textFilterEnabled","filterSupport","_createFilterSupport","createTextFilter","updateTextFilterText","_filterMenusHandler","_filterMenus","bind","_renderViewPortAfterAttach","_scrollParentScrollHandler","_onScrollParentScroll","_addWidgetProperties","_addPreserveOnPropertyChangeProperties","$fillBefore","$fillAfter","_init","model","_setGridColumnCount","_setLayoutConfig","_initVirtualScrolling","_initTiles","setFilters","filter","updateFilteredElements","_setMenus","_createKeyStrokeContext","_createVirtualScrolling","widget","enabled","rowHeight","_heightForRow","rowCount","_renderViewRange","_createLoadingSupport","_initKeyStrokeContext","keyStrokeContext","registerKeyStroke","showContextMenu","forEach","tile","_initTile","setSelectable","setSelected","indexOf","setParent","setFilterAccepted","_render","$container","$parent","appendDiv","htmlComp","install","session","setLayout","_createLayout","on","_onTileMouseDown","_onTileClick","_onTileDoubleClick","prependDiv","_renderProperties","_renderLayoutConfig","_renderScrollable","_renderVirtual","_renderSelectable","_renderEmpty","_renderTextFilterEnabled","_remove","remove","_updateVirtualScrollable","_renderOnAttach","_renderViewPort","_renderEnabled","_updateTabbable","setTabbable","setTabbableOrFocusable","enabledComputed","insertTile","insertTiles","tilesToInsert","appendPlaceholders","ensure","length","setTiles","concat","deleteTile","deleteTiles","tilesToDelete","slice","removeAll","deleteAllTiles","equals","_createChildren","nvl","_deletePlaceholders","diff","_insertTiles","placeholders","Math","min","_filterTiles","pushAll","_deleteTiles","_sort","currentTiles","_setProperty","rendered","_renderTileDelta","_renderTileOrder","_renderInsertTiles","_insertTile","_applyFilters","_renderTile","removalPending","one","_renderTileVisibleForFilter","invalidateLayoutTree","render","setLayoutData","addClass","removeClass","_animateTileInsertion","addClassForAnimation","layouting","_removeAllTiles","_renderAllTiles","_deleteTile","deselectTiles","_animateTileRemoval","animateRemoval","owner","destroy","_onAnimatedTileRemove","setFocusedTile","isVisible","setComparator","sort","invalidateParents","setGridColumnCount","setProperty","invalidateLogicalGrid","setLayoutConfig","oldMinWidth","layout","minWidth","applyToLayout","setMinRowHeight","_minRowHeight","setViewRangeSize","oldMenus","updateKeyStrokes","destination","onlyVisible","enableDisableKeyStroke","notAllowedTypes","filterAccordingToSelection","options","onRequestsDone","_showContextMenu","attached","menuItems","CONTEXT_MENU","pageX","pageY","offset","$scrollable","scrollParent","scrollableBounds","offsetBounds","last","isTileInView","left","top","max","x","right","y","bottom","contextMenu","close","parent","location","$anchor","menuFilter","open","setScrollable","_uninstallScrollbars","_installScrollbars","axis","toggleClass","_onScroll","scrollTop","scrollLeft","updateViewPort","event","setWithPlaceholders","_renderWithPlaceholders","setPlaceholderProducer","fillUpWithPlaceholders","_deleteAllPlaceholders","_deleteObsoletePlaceholders","_insertMissingPlaceholders","tilesWithoutPlaceholders","_createPlaceholders","numPlaceholders","lastX","columnCount","gridData","w","i","push","_createPlaceholder","placeholder","isPlainObject","extend","objectType","Error","obsoletePlaceholders","obsolete","insert","deletedPlaceholders","reverse","_replacePlaceholders","index","findIndexFromReverse","validateLogicalGrid","dirty","validate","setDirty","_setLogicalGrid","setGridConfig","isFocused","$scrollables","scrollParents","focus","preventScroll","deselectAllTiles","setMultiSelect","selectTiles","tilesToUnselect","selectTile","selectAllTiles","deselectTile","toggleSelection","addTilesToSelection","addTileToSelection","intersects","mousedown","_selectTileOnMouseDown","which","$tile","currentTarget","data","doubleClicked","mouseButton","_triggerTileClick","trigger","doTileAction","_triggerTileAction","setSelectionHandler","selectTileOnMouseDown","scrollTo","ensureTileRendered","reveal","revealSelection","layoutValidator","schedulePostValidateFunction","addFilter","applyFilter","removeFilter","fullReset","applyFilters","getElementsForFiltering","_createTextFilter","_updateTextFilterText","isFunction","text","setText","setTextFilterEnabled","isTextFilterFieldVisible","renderFilterField","result","opts","_updateEmpty","newlyHidden","some","removing","setEmpty","filterAccepted","findTileIndexAt","startIndex","findIndexFrom","findTilesInRange","viewRange","maxViewRange","row","from","to","eachTileInRow","findTilesInRow","func","setVirtual","_setVirtual","setEnabled","rendering","calculateViewRangeSize","_renderFiller","off","set$Scrollable","height","vgap","isNumber","ceil","isAttachedAndRendered","size","rangesToRemove","subtract","range","_removeTilesInRange","rangesToRender","_renderTilesInRange","numRowsRendered","tilesRendered","maxRange","intersect","newRange","union","renderTile","log","isTraceEnabled","trace","_rowsRenderedInfo","filterResult","prevTiles","renderedTiles","newViewRange","calculateCurrentViewRange","newTiles","tilesToRemove","tilesToRender","_removeTileByFilter","suppressInvalidate","newlyShown","animateRemovalClass","setTimeout","hasClass","setVisible","_renderVisible","different","appendTo","numRenderedTiles","children","renderedRowsRange","numRowsRemoved","_removeTilesInRow","rowHasRenderedTiles","tilesInRow","rowIndex","_renderViewRangeForRowIndex","fillBeforeHeight","_calculateFillerHeight","cssHeight","css","renderedTilesHeight","cssTop","fillAfterHeight","totalHeight","each","elem"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/tile/TileGrid.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, ContextMenuKeyStroke, DoubleClickSupport, FilterSupport, graphics, HtmlComponent, KeyStrokeContext, LoadingSupport, LogicalGridData, MenuDestinations, menus as menus_1, numbers, objects, PlaceholderTile, Range, scout, TileGridGridConfig, TileGridLayout, TileGridLayoutConfig, TileGridSelectAllKeyStroke, TileGridSelectDownKeyStroke, TileGridSelectFirstKeyStroke, TileGridSelectionHandler, TileGridSelectLastKeyStroke, TileGridSelectLeftKeyStroke, TileGridSelectRightKeyStroke, TileGridSelectUpKeyStroke, TileTextFilter, VirtualScrolling, Widget} from '../index';\nimport $ from 'jquery';\n\n/**\n * Only select top-level tile elements. Do not select elements with a 'tile' class deeper in the tree.\n * This prevents errors when a developer accidentally adds an element that has the 'tile' class. #262146\n * @type {string}\n */\nconst TILE_SELECTOR = '> .tile';\n\nexport default class TileGrid extends Widget {\n  constructor() {\n    super();\n    this.animateTileRemoval = true;\n    this.animateTileInsertion = true;\n    this.comparator = null;\n    this._doubleClickSupport = new DoubleClickSupport();\n    this.empty = false;\n    this.filters = [];\n    this.filteredTiles = [];\n    this.filteredElementsDirty = true;\n    this.focusedTile = null;\n    // GridColumnCount will be modified by the layout, prefGridColumnCount remains unchanged\n    this.gridColumnCount = 4;\n    this.prefGridColumnCount = this.gridColumnCount;\n    this.logicalGrid = scout.create('scout.HorizontalGrid');\n    this.layoutConfig = null;\n    this.menus = [];\n    this.multiSelect = true;\n    this.renderAnimationEnabled = false;\n    this.selectable = false;\n    this.selectedTiles = [];\n    this.selectionHandler = new TileGridSelectionHandler(this);\n    this.scrollable = true;\n    this.startupAnimationDone = false;\n    this.startupAnimationEnabled = false;\n    this.tiles = [];\n    this.tileRemovalPendingCount = 0;\n    this.viewRangeSize = 0;\n    this.viewRangeRendered = new Range(0, 0);\n    this.virtual = false;\n    this.virtualScrolling = null;\n    this.withPlaceholders = false;\n    this.placeholderProducer = null;\n\n    this.$filterFieldContainer = null;\n    this.textFilterEnabled = false;\n    this.filterSupport = this._createFilterSupport();\n    this.createTextFilter = null;\n    this.updateTextFilterText = null;\n\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._renderViewPortAfterAttach = false;\n    this._scrollParentScrollHandler = this._onScrollParentScroll.bind(this);\n    this._addWidgetProperties(['tiles', 'selectedTiles', 'menus']);\n    this._addPreserveOnPropertyChangeProperties(['selectedTiles']);\n\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n  }\n\n  _init(model) {\n    super._init(model);\n    this._setGridColumnCount(this.gridColumnCount);\n    this._setLayoutConfig(this.layoutConfig);\n    this._initVirtualScrolling();\n    this._initTiles();\n    this.setFilters(this.filters, false);\n    this.filter();\n    this.updateFilteredElements();\n    this._setMenus(this.menus);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  _initVirtualScrolling() {\n    this.virtualScrolling = this._createVirtualScrolling();\n  }\n\n  _createVirtualScrolling() {\n    return new VirtualScrolling({\n      widget: this,\n      enabled: this.virtual,\n      viewRangeSize: this.viewRangeSize,\n      rowHeight: this._heightForRow.bind(this),\n      rowCount: this.rowCount.bind(this),\n      _renderViewRange: this._renderViewRange.bind(this)\n    });\n  }\n\n  /**\n   * @override\n   */\n  _createLoadingSupport() {\n    return new LoadingSupport({\n      widget: this\n    });\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke([\n      new TileGridSelectAllKeyStroke(this),\n      new TileGridSelectLeftKeyStroke(this),\n      new TileGridSelectRightKeyStroke(this),\n      new TileGridSelectDownKeyStroke(this),\n      new TileGridSelectUpKeyStroke(this),\n      new TileGridSelectFirstKeyStroke(this),\n      new TileGridSelectLastKeyStroke(this),\n      new ContextMenuKeyStroke(this, this.showContextMenu, this)\n    ]);\n  }\n\n  _initTiles() {\n    this.tiles.forEach(function(tile) {\n      this._initTile(tile);\n    }, this);\n  }\n\n  _initTile(tile) {\n    tile.setSelectable(this.selectable);\n    tile.setSelected(this.selectedTiles.indexOf(tile) >= 0);\n\n    // Set proper state in case tile was used in another grid\n    tile.setParent(this);\n    tile.setFilterAccepted(true);\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('tile-grid');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(this._createLayout());\n    this.$container\n      .on('mousedown', TILE_SELECTOR, this._onTileMouseDown.bind(this))\n      .on('click', TILE_SELECTOR, this._onTileClick.bind(this))\n      .on('dblclick', TILE_SELECTOR, this._onTileDoubleClick.bind(this));\n    this.$filterFieldContainer = this.$container.prependDiv('filter-field-container');\n  }\n\n  _createLayout() {\n    return new TileGridLayout(this, this.layoutConfig);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderLayoutConfig();\n    this._renderScrollable();\n    this._renderVirtual();\n    this._renderSelectable();\n    this._renderEmpty();\n    this._renderTextFilterEnabled();\n  }\n\n  _remove() {\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.filterSupport.remove();\n    this.viewRangeRendered = new Range(0, 0);\n    this._updateVirtualScrollable();\n    super._remove();\n  }\n\n  /**\n   * @override\n   */\n  _renderOnAttach() {\n    super._renderOnAttach();\n    if (this._renderViewPortAfterAttach) {\n      this._renderViewPort();\n      this._renderViewPortAfterAttach = false;\n    }\n  }\n\n  _renderEnabled() {\n    super._renderEnabled();\n\n    this._updateTabbable();\n  }\n\n  _updateTabbable() {\n    if (!this.textFilterEnabled && !this.selectable) {\n      this.$container.setTabbable(false);\n    } else {\n      this.$container.setTabbableOrFocusable(this.enabledComputed);\n    }\n  }\n\n  insertTile(tile) {\n    this.insertTiles([tile]);\n  }\n\n  insertTiles(tilesToInsert, appendPlaceholders) {\n    tilesToInsert = arrays.ensure(tilesToInsert);\n    if (tilesToInsert.length === 0) {\n      return;\n    }\n    this.setTiles(this.tiles.concat(tilesToInsert), appendPlaceholders);\n  }\n\n  deleteTile(tile) {\n    this.deleteTiles([tile]);\n  }\n\n  deleteTiles(tilesToDelete, appendPlaceholders) {\n    tilesToDelete = arrays.ensure(tilesToDelete);\n    if (tilesToDelete.length === 0) {\n      return;\n    }\n    let tiles = this.tiles.slice();\n    arrays.removeAll(tiles, tilesToDelete);\n    this.setTiles(tiles, appendPlaceholders);\n  }\n\n  deleteAllTiles() {\n    this.setTiles([]);\n  }\n\n  setTiles(tiles, appendPlaceholders) {\n    tiles = arrays.ensure(tiles);\n    if (objects.equals(this.tiles, tiles)) {\n      return;\n    }\n\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n      // Remove placeholders from new tiles, they will be added later\n      this._deletePlaceholders(tiles);\n    }\n\n    // Only insert those which are not already there\n    let tilesToInsert = arrays.diff(tiles, this.tiles);\n    this._insertTiles(tilesToInsert);\n\n    // Append the existing placeholders, otherwise they would be unnecessarily deleted if a tile is deleted\n    if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n      let placeholders = this.placeholders();\n      // But only add as much placeholders as needed: If a new tile is added, it should replace the placeholder underneath.\n      // If this were not done the placeholders would move animated when a new tile is inserted rather than just staying where they are\n      placeholders = placeholders.slice(Math.min(this._filterTiles(tilesToInsert).length, placeholders.length), placeholders.length);\n      arrays.pushAll(tiles, placeholders);\n    }\n\n    // Only delete those which are not in the new array\n    let tilesToDelete = arrays.diff(this.tiles, tiles);\n    this._deleteTiles(tilesToDelete);\n\n    this._sort(tiles);\n    this.filteredElementsDirty = this.filteredElementsDirty || tilesToDelete.length > 0 || tilesToInsert.length > 0 || !arrays.equals(this.tiles, tiles); // last check necessary if sorting changed\n    let currentTiles = this.tiles;\n    this._setProperty('tiles', tiles);\n    this.updateFilteredElements();\n\n    if (this.rendered) {\n      this._renderTileDelta();\n      this._renderTileOrder(currentTiles);\n      this._renderInsertTiles(tilesToInsert);\n    }\n  }\n\n  _insertTiles(tiles) {\n    if (tiles.length === 0) {\n      return;\n    }\n\n    tiles.forEach(function(tile) {\n      this._insertTile(tile);\n    }, this);\n  }\n\n  _insertTile(tile) {\n    this._initTile(tile);\n    this._applyFilters([tile]);\n    if (!this.virtual && this.rendered) {\n      this._renderTile(tile);\n    }\n  }\n\n  _renderTile(tile) {\n    if (tile.removalPending) {\n      // If tile is being removed by the filter and the filter cleared so that the tile should be rendered again while the animation is still running,\n      // we need to wait for the remove animation, otherwise an already rendered exception occurs\n      tile.one('remove', () => {\n        if (tile.rendered) {\n          // Might be already rendered again by renderTileDelta because filter was changed again\n          return;\n        }\n        this._renderTile(tile);\n        this._renderTileVisibleForFilter(tile);\n        if (this.tileRemovalPendingCount === 0) {\n          this.invalidateLayoutTree();\n        }\n      });\n      return;\n    }\n    tile.render();\n    tile.setLayoutData(new LogicalGridData(tile));\n    tile.$container.addClass('newly-rendered');\n  }\n\n  _renderInsertTiles(tiles) {\n    tiles.forEach(function(tile) {\n      if (!tile.rendered) {\n        return;\n      }\n      tile.$container.addClass('invisible');\n      // Wait until the layout animation is done before animating the insert operation.\n      // Also make them invisible to not cover existing tiles while they are moving or changing size.\n      // Also do it for tiles which don't have an insert animation (e.g. placeholders), due to the same reason.\n      this.one('layoutAnimationDone', () => {\n        if (tile.rendered) {\n          tile.$container.removeClass('invisible');\n          if (this._animateTileInsertion(tile)) {\n            tile.$container.addClassForAnimation('animate-insert');\n          }\n        }\n      });\n    }, this);\n\n    if (!this.htmlComp.layouting) {\n      // no need to invalidate when tile placeholders are added or removed while layouting\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _removeAllTiles() {\n    this.tiles.forEach(tile => {\n      tile.remove();\n    });\n    this.viewRangeRendered = new Range(0, 0);\n  }\n\n  _renderAllTiles() {\n    this.tiles.forEach(function(tile) {\n      this._renderTile(tile);\n    }, this);\n  }\n\n  _deleteTiles(tiles) {\n    if (tiles.length === 0) {\n      return;\n    }\n\n    tiles.forEach(function(tile) {\n      this._deleteTile(tile);\n    }, this);\n    this.deselectTiles(tiles);\n\n    if (this.rendered && !this.htmlComp.layouting) {\n      // no need to invalidate when tile placeholders are added or removed while layouting\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _deleteTile(tile) {\n    if (this._animateTileRemoval(tile)) {\n      // Animate tile removal, but not while layouting when tile placeholders are added or removed\n      tile.animateRemoval = true;\n    }\n    // Destroy only if it is the owner, if tile belongs to another widget, just remove it\n    if (tile.owner === this) {\n      tile.destroy();\n    } else if (this.rendered) {\n      tile.remove();\n    }\n    this._onAnimatedTileRemove(tile);\n    tile.animateRemoval = false;\n    if (tile === this.focusedTile) {\n      this.setFocusedTile(null);\n    }\n  }\n\n  _animateTileRemoval(tile) {\n    return this.animateTileRemoval && tile && tile.isVisible() && !(tile instanceof PlaceholderTile);\n  }\n\n  _animateTileInsertion(tile) {\n    return this.animateTileInsertion && tile && tile.isVisible() && !(tile instanceof PlaceholderTile);\n  }\n\n  _onAnimatedTileRemove(tile) {\n    if (!tile.removalPending) {\n      return;\n    }\n    this.tileRemovalPendingCount++;\n    tile.one('remove', () => {\n      this.tileRemovalPendingCount--;\n      if (this.rendered && this.tileRemovalPendingCount === 0 && !this.htmlComp.layouting) {\n        this.invalidateLayoutTree();\n      }\n    });\n  }\n\n  setComparator(comparator) {\n    if (this.comparator === comparator) {\n      return;\n    }\n    this.comparator = comparator;\n  }\n\n  sort() {\n    let tiles = this.tiles.slice();\n    this._sort(tiles);\n    if (arrays.equals(this.tiles, tiles)) {\n      // Check is needed anyway to determine whether filteredElementsDirty needs to be set, so we can use it here as well to early return if nothing changed\n      return;\n    }\n    let currentTiles = this.tiles;\n    this._setProperty('tiles', tiles);\n\n    // Sort list of filtered tiles as well\n    this.filteredElementsDirty = true;\n    this.updateFilteredElements();\n\n    if (this.rendered) {\n      this._renderTileDelta();\n      this._renderTileOrder(currentTiles);\n    }\n  }\n\n  _sort(tiles) {\n    if (this.comparator === null) {\n      return;\n    }\n\n    let placeholders = [];\n    if (this.withPlaceholders) {\n      // Don't reorder placeholders -> remove them first, then sort and add them afterwards again\n      placeholders = this._deletePlaceholders(tiles);\n    }\n    tiles.sort(this.comparator);\n    arrays.pushAll(tiles, placeholders);\n  }\n\n  invalidateLayoutTree(invalidateParents) {\n    if (this.tileRemovalPendingCount > 0) {\n      // Do not invalidate while tile removal is still pending\n      return;\n    }\n    super.invalidateLayoutTree(invalidateParents);\n  }\n\n  setGridColumnCount(gridColumnCount) {\n    this.setProperty('gridColumnCount', gridColumnCount);\n  }\n\n  _setGridColumnCount(gridColumnCount) {\n    this._setProperty('gridColumnCount', gridColumnCount);\n    this.prefGridColumnCount = gridColumnCount;\n    this.invalidateLogicalGrid();\n  }\n\n  setLayoutConfig(layoutConfig) {\n    this.setProperty('layoutConfig', layoutConfig);\n  }\n\n  _setLayoutConfig(layoutConfig) {\n    if (!layoutConfig) {\n      layoutConfig = new TileGridLayoutConfig();\n    }\n    this._setProperty('layoutConfig', TileGridLayoutConfig.ensure(layoutConfig));\n  }\n\n  _renderLayoutConfig() {\n    let oldMinWidth = this.htmlComp.layout.minWidth;\n    this.layoutConfig.applyToLayout(this.htmlComp.layout);\n    if (this.virtualScrolling) {\n      this.virtualScrolling.setMinRowHeight(this._minRowHeight());\n      this.setViewRangeSize(this.virtualScrolling.viewRangeSize, false);\n    }\n    if (oldMinWidth !== this.htmlComp.layout.minWidth) {\n      this._renderScrollable();\n    }\n    this.invalidateLayoutTree();\n  }\n\n  _setMenus(menus, oldMenus) {\n    this.updateKeyStrokes(menus, oldMenus);\n    this._setProperty('menus', menus);\n  }\n\n  _filterMenus(menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n    return menus_1.filterAccordingToSelection('TileGrid', this.selectedTiles.length, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);\n  }\n\n  showContextMenu(options) {\n    this.session.onRequestsDone(this._showContextMenu.bind(this, options));\n  }\n\n  /**\n   * @param options may contain pageX, pageY, menuItems and menuFilter.\n   * If these properties are not provided they are determined automatically.\n   */\n  _showContextMenu(options) {\n    options = options || {};\n    if (!this.rendered || !this.attached) { // check needed because function is called asynchronously\n      return;\n    }\n    if (this.selectedTiles.length === 0) {\n      return;\n    }\n    let menuItems = options.menuItems || this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false);\n    if (menuItems.length === 0) {\n      return;\n    }\n    let pageX = scout.nvl(options.pageX, null);\n    let pageY = scout.nvl(options.pageY, null);\n    if (pageX === null || pageY === null) {\n      let offset;\n      let $scrollable = this.$container.scrollParent();\n      if ($scrollable.length === 0) {\n        $scrollable = this.$container;\n      }\n      let scrollableBounds = graphics.offsetBounds($scrollable);\n      let focusedTile = this.focusedTile || arrays.last(this.selectedTiles);\n      if (this.isTileInView(focusedTile)) {\n        // Place the context menu on the focused tile if possible\n        offset = focusedTile.$container.offset();\n      } else {\n        // If focused tile is not in view place the popup in the top left corner of the tile grid\n        offset = this.$container.offset();\n      }\n      pageX = offset.left + 10;\n      pageY = offset.top + 10;\n      // Ensure popup is always in view. Add +-1 to make sure it won't be made invisible by Popup._isInView even if bounds are fractional\n      pageX = Math.min(Math.max(pageX, scrollableBounds.x + 1), scrollableBounds.right() - 1);\n      pageY = Math.min(Math.max(pageY, scrollableBounds.y + 1), scrollableBounds.bottom() - 1);\n    }\n    // Prevent firing of 'onClose'-handler during contextMenu.open()\n    // (Can lead to null-access when adding a new handler to this.contextMenu)\n    if (this.contextMenu) {\n      this.contextMenu.close();\n    }\n    this.contextMenu = scout.create('ContextMenuPopup', {\n      parent: this,\n      menuItems: menuItems,\n      location: {\n        x: pageX,\n        y: pageY\n      },\n      $anchor: this.$container,\n      menuFilter: options.menuFilter || this._filterMenusHandler\n    });\n    this.contextMenu.open();\n  }\n\n  setScrollable(scrollable) {\n    this.setProperty('scrollable', scrollable);\n  }\n\n  _renderScrollable() {\n    this._uninstallScrollbars();\n\n    // horizontal (x-axis) scrollbar is only installed when minWidth is > 0\n    if (this.scrollable) {\n      this._installScrollbars({\n        axis: this.layoutConfig.minWidth > 0 ? 'both' : 'y'\n      });\n    } else if (this.layoutConfig.minWidth > 0) {\n      this._installScrollbars({\n        axis: 'x'\n      });\n    }\n    this.$container.toggleClass('scrollable', this.scrollable);\n    this._updateVirtualScrollable();\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    let scrollTop = this.$container[0].scrollTop;\n    let scrollLeft = this.$container[0].scrollLeft;\n    if (this.scrollTop !== scrollTop && this.virtual) {\n      this.htmlComp.layout.updateViewPort();\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n  }\n\n  _onScrollParentScroll(event) {\n    this.htmlComp.layout.updateViewPort();\n  }\n\n  setWithPlaceholders(withPlaceholders) {\n    this.setProperty('withPlaceholders', withPlaceholders);\n  }\n\n  _renderWithPlaceholders() {\n    this.invalidateLayoutTree();\n  }\n\n  setPlaceholderProducer(placeholderProducer) {\n    this.setProperty('placeholderProducer', placeholderProducer);\n  }\n\n  fillUpWithPlaceholders() {\n    if (!this.withPlaceholders) {\n      this._deleteAllPlaceholders();\n      return;\n    }\n    this._deleteObsoletePlaceholders();\n    this._insertMissingPlaceholders();\n  }\n\n  tilesWithoutPlaceholders() {\n    if (!this.withPlaceholders) {\n      return this.tiles;\n    }\n    return this.tiles.filter(tile => !(tile instanceof PlaceholderTile));\n  }\n\n  _createPlaceholders() {\n    let numPlaceholders, lastX,\n      columnCount = this.gridColumnCount,\n      tiles = this.filteredTiles,\n      placeholders = [];\n\n    if (tiles.length > 0) {\n      let tile = tiles[tiles.length - 1];\n      lastX = tile.gridData.x + tile.gridData.w - 1;\n    } else {\n      // If there are no tiles, create one row with placeholders\n      lastX = -1;\n    }\n\n    if (lastX === columnCount - 1) {\n      // If last tile is the last element in the row, don't create placeholders\n      return [];\n    }\n\n    // Otherwise create placeholders for every missing tile in the last row\n    numPlaceholders = columnCount - 1 - lastX;\n    for (let i = 0; i < numPlaceholders; i++) {\n      placeholders.push(this._createPlaceholder());\n    }\n    return placeholders;\n  }\n\n  _createPlaceholder() {\n    let placeholder = (this.placeholderProducer && this.placeholderProducer()) || {};\n    if (placeholder instanceof PlaceholderTile) {\n      return placeholder;\n    }\n    if (objects.isPlainObject(placeholder)) {\n      return scout.create($.extend(true, {}, {\n        objectType: 'PlaceholderTile',\n        parent: this\n      }, placeholder));\n    }\n    throw new Error('Placeholder producer returned unexpected result.');\n  }\n\n  _deleteObsoletePlaceholders() {\n    let obsoletePlaceholders = [],\n      obsolete = false;\n\n    let placeholders = this.placeholders();\n    placeholders.forEach(function(placeholder) {\n      // Remove all placeholder in the row if there is one at x=0 (don't do it if there are only placeholders)\n      if (placeholder.gridData.x === 0 && this.filteredTiles[0] !== placeholder) {\n        obsolete = true;\n      }\n      if (obsolete) {\n        obsoletePlaceholders.push(placeholder);\n      }\n    }, this);\n\n    this.deleteTiles(obsoletePlaceholders, false);\n  }\n\n  _deleteAllPlaceholders() {\n    this.deleteTiles(this.placeholders(), false);\n  }\n\n  placeholders() {\n    let i, placeholders = [];\n    for (i = this.tiles.length - 1; i >= 0; i--) {\n      if (!(this.tiles[i] instanceof PlaceholderTile)) {\n        // Placeholders are always at the end -> we may stop as soon as no more placeholders are found\n        break;\n      }\n      arrays.insert(placeholders, this.tiles[i], 0);\n    }\n    return placeholders;\n  }\n\n  _insertMissingPlaceholders() {\n    let placeholders = this._createPlaceholders();\n    this.insertTiles(placeholders, false);\n  }\n\n  _deletePlaceholders(tiles) {\n    let i;\n    let deletedPlaceholders = [];\n    for (i = tiles.length - 1; i >= 0; i--) {\n      if (tiles[i] instanceof PlaceholderTile) {\n        deletedPlaceholders.push(tiles[i]);\n        arrays.remove(tiles, tiles[i]);\n      }\n    }\n    return deletedPlaceholders.reverse();\n  }\n\n  _replacePlaceholders(tiles, tilesToInsert) {\n    // Find index of the first tile which is not a placeholder (placeholders are always added at the end, so it is faster if search is done backwards)\n    let index = arrays.findIndexFromReverse(tiles, tiles.length - 1, tile => {\n      return !(tile instanceof PlaceholderTile);\n    });\n\n    let numPlaceholders = tiles.length - 1 - index;\n    for (let i = 1; i <= numPlaceholders; i++) {\n      let tile = tiles[index + i];\n      if (tilesToInsert[i - 1] && !(tilesToInsert[i - 1] instanceof PlaceholderTile)) {\n        arrays.remove(tiles, tile);\n      }\n    }\n  }\n\n  validateLogicalGrid() {\n    if (!this.logicalGrid.dirty) {\n      return;\n    }\n    this.logicalGrid.validate(this);\n    this.fillUpWithPlaceholders();\n    this.logicalGrid.setDirty(true);\n    this.logicalGrid.validate(this);\n  }\n\n  /**\n   * @override\n   */\n  _setLogicalGrid(logicalGrid) {\n    super._setLogicalGrid(logicalGrid);\n    if (this.logicalGrid) {\n      this.logicalGrid.setGridConfig(new TileGridGridConfig());\n    }\n  }\n\n  setFocusedTile(tile) {\n    if (this.focusedTile === tile) {\n      return;\n    }\n    this.focusedTile = tile;\n    if (!this.rendered || !tile || this.isFocused()) {\n      return;\n    }\n    let $scrollables = this.$container.scrollParents();\n    if ($scrollables.length === 0) {\n      return;\n    }\n    // Make sure the tile grid has the focus when focusing a tile\n    this.focus({\n      preventScroll: true\n    });\n  }\n\n  setSelectable(selectable) {\n    this.setProperty('selectable', selectable);\n    if (!selectable) {\n      this.deselectAllTiles();\n    }\n    this.tiles.forEach(tile => {\n      tile.setSelectable(selectable);\n    });\n  }\n\n  _renderSelectable() {\n    this.$container.toggleClass('selectable', this.selectable);\n    this._updateTabbable();\n    this.invalidateLayoutTree();\n  }\n\n  setMultiSelect(multiSelect) {\n    this.setProperty('multiSelect', multiSelect);\n  }\n\n  /**\n   * Selects the given tiles and deselects the previously selected ones.\n   */\n  selectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n    tiles = this._filterTiles(tiles); // Selecting invisible tiles is not allowed\n\n    // Ensure no tiles will be selected if selectable is disabled\n    if (!this.selectable) {\n      tiles = [];\n    }\n\n    // Ensure only one tile is selected if multiSelect is disabled\n    if (!this.multiSelect && tiles.length > 1) {\n      tiles = [tiles[0]];\n    }\n\n    if (arrays.equals(this.selectedTiles, tiles)) {\n      // Do nothing if new selection is same as old one\n      return;\n    }\n\n    // Deselect the tiles which are not part of the new selection\n    let tilesToUnselect = this.selectedTiles;\n    arrays.removeAll(tilesToUnselect, tiles);\n    tilesToUnselect.forEach(function(tile) {\n      tile.setSelected(false);\n      if (tile === this.focusedTile) {\n        this.setFocusedTile(null);\n      }\n    }, this);\n\n    // Select the tiles\n    tiles.forEach(tile => {\n      tile.setSelected(true);\n    }, this);\n\n    this.setProperty('selectedTiles', tiles.slice());\n  }\n\n  selectTile(tile) {\n    this.selectTiles([tile]);\n  }\n\n  /**\n   * Selects all tiles. As for every selection operation: only filtered tiles are considered.\n   */\n  selectAllTiles() {\n    this.selectTiles(this.filteredTiles);\n  }\n\n  deselectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    let selectedTiles = this.selectedTiles.slice();\n    if (arrays.removeAll(selectedTiles, tiles)) {\n      this.selectTiles(selectedTiles);\n    }\n  }\n\n  deselectTile(tile) {\n    this.deselectTiles([tile]);\n  }\n\n  deselectAllTiles() {\n    this.selectTiles([]);\n  }\n\n  toggleSelection() {\n    if (this.selectedTiles.length === this.filteredTiles.length) {\n      this.deselectAllTiles();\n    } else {\n      this.selectAllTiles();\n    }\n  }\n\n  addTilesToSelection(tiles) {\n    tiles = arrays.ensure(tiles);\n    this.selectTiles(this.selectedTiles.concat(tiles));\n  }\n\n  addTileToSelection(tile) {\n    this.addTilesToSelection([tile]);\n  }\n\n  /**\n   * @returns {boolean} true if the tile is completely or partially visible in the first scrollable parent.\n   */\n  isTileInView(tile) {\n    let $scrollable = this.$container.scrollParent();\n    if ($scrollable.length === 0) {\n      $scrollable = this.$container;\n    }\n    if (!tile || !tile.$container || !$scrollable) {\n      return false;\n    }\n    return graphics.offsetBounds(tile.$container).intersects(graphics.offsetBounds($scrollable));\n  }\n\n  _onTileMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    this._selectTileOnMouseDown(event);\n\n    if (event.which === 3) {\n      this.showContextMenu({\n        pageX: event.pageX,\n        pageY: event.pageY\n      });\n      return false;\n    }\n  }\n\n  _onTileClick(event) {\n    let $tile = $(event.currentTarget);\n    let tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n\n    if (this._doubleClickSupport.doubleClicked()) {\n      // Don't execute on double click events\n      return;\n    }\n\n    let mouseButton = event.which;\n    this._triggerTileClick(tile, mouseButton);\n  }\n\n  _triggerTileClick(tile, mouseButton) {\n    let event = {\n      tile: tile,\n      mouseButton: mouseButton\n    };\n    this.trigger('tileClick', event);\n  }\n\n  _onTileDoubleClick(event) {\n    let $tile = $(event.currentTarget);\n    let tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    this.doTileAction(tile);\n  }\n\n  doTileAction(tile) {\n    if (!tile) {\n      return;\n    }\n    this._triggerTileAction(tile);\n  }\n\n  _triggerTileAction(tile) {\n    this.trigger('tileAction', {\n      tile: tile\n    });\n  }\n\n  setSelectionHandler(selectionHandler) {\n    this.selectionHandler = selectionHandler;\n  }\n\n  _selectTileOnMouseDown(event) {\n    this.selectionHandler.selectTileOnMouseDown(event);\n  }\n\n  scrollTo(tile, options) {\n    this.ensureTileRendered(tile);\n    // If tile was not rendered it is not yet positioned correctly -> make sure layout is valid before trying to scroll\n    // Layout must not render the viewport because scroll position is not correct yet -> just make sure tiles are at the correct position\n    this.htmlComp.layout.updateViewPort(true);\n    tile.reveal(options);\n  }\n\n  revealSelection() {\n    if (!this.rendered) {\n      // Execute delayed because tileGrid may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n\n    if (this.selectedTiles.length > 0) {\n      this.scrollTo(this.selectedTiles[0]);\n    }\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to add.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  addFilter(filter, applyFilter = true) {\n    this.filterSupport.addFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to remove.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  removeFilter(filter, applyFilter = true) {\n    this.filterSupport.removeFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The new filters.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  setFilters(filters, applyFilter = true) {\n    this.filterSupport.setFilters(filters, applyFilter);\n  }\n\n  filter() {\n    this.filterSupport.filter();\n  }\n\n  _applyFilters(tiles, fullReset) {\n    return this.filterSupport.applyFilters(tiles.filter(tile => !(tile instanceof PlaceholderTile)), fullReset);\n  }\n\n  /**\n   * @returns {FilterSupport}\n   */\n  _createFilterSupport() {\n    return new FilterSupport({\n      widget: this,\n      $container: () => this.$filterFieldContainer,\n      getElementsForFiltering: this.tilesWithoutPlaceholders.bind(this),\n      createTextFilter: this._createTextFilter.bind(this),\n      updateTextFilterText: this._updateTextFilterText.bind(this)\n    });\n  }\n\n  _createTextFilter() {\n    if (objects.isFunction(this.createTextFilter)) {\n      return this.createTextFilter();\n    }\n    return new TileTextFilter();\n  }\n\n  _updateTextFilterText(filter, text) {\n    if (objects.isFunction(this.updateTextFilterText)) {\n      return this.updateTextFilterText(filter, text);\n    }\n    if (filter instanceof TileTextFilter) {\n      return filter.setText(text);\n    }\n    return false;\n  }\n\n  setTextFilterEnabled(textFilterEnabled) {\n    this.setProperty('textFilterEnabled', textFilterEnabled);\n  }\n\n  isTextFilterFieldVisible() {\n    return this.textFilterEnabled;\n  }\n\n  _renderTextFilterEnabled() {\n    this._updateTabbable();\n    this.filterSupport.renderFilterField();\n  }\n\n  updateFilteredElements(result, opts) {\n    if (!this.filteredElementsDirty) {\n      this._updateEmpty();\n      return;\n    }\n\n    this.setProperty('filteredTiles', this._filterTiles());\n    this.invalidateLogicalGrid(false);\n    this.filteredElementsDirty = false;\n\n    if (result) {\n      if (result.newlyHidden.some(tile => tile === this.focusedTile)) {\n        this.setFocusedTile(null);\n      }\n      // Non visible tiles must be deselected\n      this.deselectTiles(result.newlyHidden);\n\n      if (this.rendered && !this.removing) {\n        // Not all tiles may be rendered yet (e.g. if filter is active before grid is rendered and removed after grid is rendered)\n        // But updating the view range is necessary anyway (fillers, scrollbars, viewRangeRendered etc.)\n        this._renderTileDelta(result);\n        this._renderTileOrder(this.tiles);\n      }\n    }\n\n    this._updateEmpty();\n  }\n\n  _updateEmpty() {\n    this.setEmpty(this.filteredTiles.length === 0);\n  }\n\n  setEmpty(empty) {\n    this.setProperty('empty', empty);\n  }\n\n  _renderEmpty() {\n    this.$container.toggleClass('empty', this.empty);\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * @returns {Tile[]} the tiles which are accepted by the filter and therefore visible.\n   */\n  _filterTiles(tiles) {\n    tiles = scout.nvl(tiles, this.tiles);\n    if (this.filters.length === 0) {\n      return tiles.slice();\n    }\n    return tiles.filter(tile => {\n      return tile.filterAccepted;\n    });\n  }\n\n  findTileIndexAt(x, y, startIndex, reverse) {\n    startIndex = scout.nvl(startIndex, 0);\n    return arrays.findIndexFrom(this.filteredTiles, startIndex, (tile, i) => {\n      return tile.gridData.x === x && tile.gridData.y === y;\n    }, reverse);\n  }\n\n  /**\n   * If the max range is used, the live list of filtered tiles is returned, because every tile has to be in the range.\n   */\n  findTilesInRange(viewRange, filter) {\n    if (viewRange.equals(this.virtualScrolling.maxViewRange())) {\n      // Directly return all tiles if max view range\n      return this.filteredTiles;\n    }\n\n    let tiles = [];\n    for (let row = viewRange.from; row < viewRange.to; row++) {\n      this.eachTileInRow(row, tile => { // jshint ignore:line\n        if (!filter || filter(tile)) {\n          tiles.push(tile);\n        }\n      });\n    }\n    return tiles;\n  }\n\n  findTilesInRow(row) {\n    let tiles = [];\n    this.eachTileInRow(row, tile => {\n      tiles.push(tile);\n    });\n    return tiles;\n  }\n\n  /**\n   * Executes the given function for each tile in a row.\n   */\n  eachTileInRow(row, func) {\n    let startIndex = row * this.gridColumnCount;\n    let tiles = [];\n    for (let i = startIndex; i < startIndex + this.gridColumnCount; i++) {\n      if (this.filteredTiles[i]) {\n        func(this.filteredTiles[i], i);\n      }\n    }\n    return tiles;\n  }\n\n  setVirtual(virtual) {\n    this.setProperty('virtual', virtual);\n  }\n\n  _setVirtual(virtual) {\n    this._setProperty('virtual', virtual);\n    this.virtualScrolling.setEnabled(this.virtual);\n  }\n\n  _renderVirtual() {\n    this._updateVirtualScrollable();\n    if (!this.rendering) {\n      // No need to do it while rendering, will be done by the layout. But needs to be done if virtual changes on the fly\n      this.setViewRangeSize(this.calculateViewRangeSize(), false);\n    }\n\n    if (this.rendered) {\n      // When virtual toggles, remove all tiles and render them anew (to have the correct tiles rendered in the new mode)\n      this._removeAllTiles();\n      if (this.virtual) {\n        // RenderViewPort may do nothing if all tiles are already in the view port, but fillers may not be created yet\n        this._renderFiller();\n      }\n    }\n    if (!this.virtual) {\n      // Render all tiles (on toggle and initially) (_renderViewRange is not used in non virtual mode because filtered tiles need to be rendered as well)\n      this._renderAllTiles();\n    }\n\n    this._renderViewPort();\n    this.invalidateLayoutTree();\n  }\n\n  _updateVirtualScrollable() {\n    let $scrollable = this.virtualScrolling.$scrollable;\n    if ($scrollable) {\n      $scrollable.off('scroll', this._scrollParentScrollHandler);\n    }\n    if (!this.virtual || this.removing) {\n      this.virtualScrolling.set$Scrollable(null);\n      return;\n    }\n    if (this.scrollable) {\n      this.virtualScrolling.set$Scrollable(this.$container);\n    } else {\n      this.virtualScrolling.set$Scrollable(this.$container.scrollParent());\n      this.virtualScrolling.$scrollable.on('scroll', this._scrollParentScrollHandler);\n    }\n  }\n\n  calculateViewRangeSize() {\n    return this.virtualScrolling.calculateViewRangeSize();\n  }\n\n  setViewRangeSize(viewRangeSize, updateViewPort) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    this.virtualScrolling.setViewRangeSize(viewRangeSize, updateViewPort);\n  }\n\n  _heightForRow(row) {\n    let height = 0;\n\n    height = this.htmlComp.layout.rowHeight;\n    if (row !== this.rowCount() - 1) {\n      // Add row gap unless it is the last row\n      height += this.htmlComp.layout.vgap;\n    }\n\n    if (!numbers.isNumber(height)) {\n      throw new Error('Calculated height is not a number: ' + height);\n    }\n    return height;\n  }\n\n  /**\n   * Used for virtual scrolling to calculate the view range size.\n   * @returns {number} the configured rowHeight + vgap / 2. Reason: the gaps are only between rows, the first and last row therefore only have 1 gap.\n   */\n  _minRowHeight() {\n    return this.htmlComp.layout.rowHeight + this.htmlComp.layout.vgap / 2;\n  }\n\n  rowCount(gridColumnCount) {\n    gridColumnCount = scout.nvl(gridColumnCount, this.gridColumnCount);\n    return Math.ceil(this.filteredTiles.length / gridColumnCount);\n  }\n\n  /**\n   * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n   */\n  _renderViewPort() {\n    if (!this.isAttachedAndRendered()) {\n      // if grid is not attached the correct viewPort can not be evaluated. Mark for render after attach.\n      this._renderViewPortAfterAttach = true;\n      return;\n    }\n    if (!this.virtual) {\n      return;\n    }\n    this.virtualScrolling._renderViewPort();\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.equals(this.viewRangeRendered)) {\n      if (viewRange.size() === 0) {\n        // Iif view range is empty initially viewRangeRendered will be empty as well -> make sure fillers are rendered correctly (used for pref size)\n        this._renderFiller();\n      }\n      // Range already rendered -> do nothing\n      return;\n    }\n    let rangesToRemove = this.viewRangeRendered.subtract(viewRange).filter(range => {\n      return range.size() > 0;\n    });\n    rangesToRemove.forEach(range => {\n      this._removeTilesInRange(range);\n    });\n\n    let rangesToRender = viewRange.subtract(this.viewRangeRendered).filter(range => {\n      return range.size() > 0;\n    });\n    rangesToRender.forEach(range => {\n      this._renderTilesInRange(range);\n    });\n\n    this._renderFiller();\n  }\n\n  _renderTilesInRange(range) {\n    let numRowsRendered = 0;\n    let tilesRendered = 0;\n    let tiles = this.filteredTiles;\n    if (tiles.length === 0) {\n      return;\n    }\n\n    let maxRange = this.virtualScrolling.maxViewRange();\n    range = maxRange.intersect(range);\n    let newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (let row = range.from; row < range.to; row++) {\n      this.eachTileInRow(row, renderTile.bind(this));\n      numRowsRendered++;\n    }\n\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRendered + ' new rows rendered from ' + range);\n      $.log.trace(this._rowsRenderedInfo());\n    }\n\n    function renderTile(tile) {\n      if (tile.rendered) {\n        return;\n      }\n      this._renderTile(tile);\n      tilesRendered++;\n    }\n  }\n\n  /**\n   * @returns {Tile[]} the newly rendered tiles\n   */\n  _renderTileDelta(filterResult) {\n    if (!this.virtual) {\n      return [];\n    }\n    let prevTiles = this.renderedTiles();\n    let newViewRange = this.virtualScrolling.calculateCurrentViewRange();\n    let newTiles = this.findTilesInRange(newViewRange);\n\n    let tilesToRemove = arrays.diff(prevTiles, newTiles);\n    let tilesToRender = arrays.diff(newTiles, prevTiles);\n    if (filterResult) {\n      filterResult.newlyHidden.forEach(function(tile) {\n        if (tile.rendered) {\n          this._removeTileByFilter(tile);\n        }\n      }, this);\n    }\n\n    // tilesToRemove contains newlyHidden as well but remove() does nothing if it is already removing\n    tilesToRemove.forEach(tile => {\n      tile.remove();\n    });\n    tilesToRender.forEach(function(tile) {\n      this._renderTile(tile);\n    }, this);\n\n    if (filterResult) {\n      // Suppress because Tile.js would invalidate which leads to poor performance if grid is used in a Group.js and group is being expanded while tiles are shown\n      // invalidating will be done afterwards anyway so no need to do it for each tile\n      this.htmlComp.suppressInvalidate = true;\n      filterResult.newlyShown.forEach(function(tile) {\n        if (tile.rendered) {\n          this._renderTileVisibleForFilter(tile);\n        }\n      }, this);\n      this.htmlComp.suppressInvalidate = false;\n    }\n\n    this.viewRangeRendered = newViewRange;\n    this._renderFiller();\n    if (!this.htmlComp.layouting) {\n      // If a tile is inserted while a group of the tile accordion is being expanded,\n      // invalidating may create a loop because the group resizes the body which triggers the TileGridLayout and eventually calls this function again -> Don't invalidate while layouting\n      this.invalidateLayoutTree();\n    }\n    return tilesToRender;\n  }\n\n  _removeTileByFilter(tile) {\n    // In virtual mode, filtered tiles are not rendered. In normal mode, the filter animation is triggered by _renderVisible of the tile.\n    // Since the tile is removed immediately, the invisible animation would not start, so we use the remove animation instead.\n    // But because the delete animation is a different one to the filter animation, the removeClass needs to be swapped\n    // Remove class first to make sure animation won't be finished before the animationend listener is attached in Widget._removeAnimated (which may happen because a setTimeout is used there)\n    tile.$container.removeClass('animate-invisible');\n    tile.animateRemoval = true;\n    tile.animateRemovalClass = 'animate-invisible';\n    tile.remove();\n    this._onAnimatedTileRemove(tile);\n    tile.animateRemoval = false;\n    // Remove animation is started by a set timeout -> use set timeout as well to come after\n    setTimeout(() => {\n      // Reset to default\n      tile.animateRemovalClass = 'animate-remove';\n    });\n  }\n\n  _renderTileVisibleForFilter(tile) {\n    if (!tile.filterAccepted || tile.$container.hasClass('animate-visible')) {\n      return;\n    }\n    if (tile.removalPending) {\n      return;\n    }\n    // Start filter animation (at the time setFilterAccepted was set the tile was not rendered)\n    tile.$container.setVisible(false);\n    tile._renderVisible();\n  }\n\n  _renderTileOrder(prevTiles) {\n    // Loop through the tiles and move every html element to the end of the container\n    // Only move if the order is different to the old order\n    // This is actually only necessary to make debugging easier, since the tiles are positioned absolutely it would work without it\n    let different = false;\n    this.tiles.forEach(function(tile, i) {\n      if (prevTiles[i] !== tile || different) {\n        // Start ordering as soon as the order of the arrays starts to differ\n        if (this.virtual && !tile.rendered) {\n          // In non virtual mode, every tile is rendered, even the filtered one. So if a tile is not rendered ignore it in virtual, but fail in non virtual\n          return;\n        }\n        different = true;\n        tile.$container.appendTo(this.$container);\n      }\n    }, this);\n\n    if (different && !this.virtual) {\n      // In virtual mode this is done by _renderTileDelta()\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _rowsRenderedInfo() {\n    let numRenderedTiles = this.$container.children('.tile').length;\n    let renderedRowsRange = '(' + this.viewRangeRendered + ')';\n    return numRenderedTiles + ' tiles rendered in range ' + renderedRowsRange;\n  }\n\n  _removeTilesInRange(range) {\n    let numRowsRemoved = 0;\n    let newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (let i = range.from; i < range.to; i++) {\n      this._removeTilesInRow(i);\n      numRowsRemoved++;\n    }\n\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');\n      $.log.trace(this._rowsRenderedInfo());\n    }\n  }\n\n  _removeTilesInRow(row) {\n    let tiles = this.findTilesInRow(row);\n    tiles.forEach(tile => {\n      tile.remove();\n    });\n  }\n\n  rowHasRenderedTiles(row) {\n    let tilesInRow = this.findTilesInRow(row);\n    return tilesInRow.some(tile => {\n      return tile.rendered && !tile.removing;\n    });\n  }\n\n  ensureTileRendered(tile) {\n    if (!tile.rendered) {\n      let rowIndex = tile.gridData.y;\n      this.virtualScrolling._renderViewRangeForRowIndex(rowIndex);\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$container.prependDiv('filler');\n    }\n\n    let fillBeforeHeight = this._calculateFillerHeight(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeHeight);\n    this.$fillBefore.css('width', '100%');\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeHeight);\n\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$container.appendDiv('filler');\n    }\n    // Make sure filler is always at the end\n    this.$fillAfter.appendTo(this.$container);\n\n    let renderedTilesHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.from, this.viewRangeRendered.to));\n    this.$fillAfter.cssTop(fillBeforeHeight + renderedTilesHeight);\n\n    let fillAfterHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.to, this.rowCount()));\n    this.$fillAfter.cssHeight(fillAfterHeight);\n    this.$fillAfter.css('width', '100%');\n\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterHeight);\n  }\n\n  _calculateFillerHeight(range) {\n    let totalHeight = 0;\n    for (let i = range.from; i < range.to; i++) {\n      totalHeight += this._heightForRow(i);\n    }\n    return totalHeight;\n  }\n\n  /**\n   * If virtual is false, the live list of filtered tiles is returned, because every tile has to be rendered. If virtual is true, the rendered tiles are collected and returned.\n   */\n  renderedTiles() {\n    if (!this.rendered) {\n      return [];\n    }\n    if (!this.virtual) {\n      return this.filteredTiles;\n    }\n    let tiles = [];\n    this.$container.children('.tile').each((i, elem) => {\n      let tile = scout.widget(elem);\n      if (!tile.removalPending) {\n        // Don't return the tiles which are being removed\n        // Otherwise delta could be wrong if called while removing. Example: filter is added and removed right after while the tiles are still being removed -> RenderTileDelta has to render the tiles being removed\n        tiles.push(tile);\n      }\n    });\n    return tiles;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}