{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, DeferredGlassPaneTarget, Desktop, Device, Event, EventDelegator, EventSupport, filters, focusUtils, Form, graphics, icons, inspector, objects, scout, scrollbars, strings, texts, TreeVisitResult } from '../index';\nimport $ from 'jquery';\nexport default class Widget {\n  constructor() {\n    this.id = null;\n    this.objectType = null;\n    this.session = null;\n\n    /**\n     * The owner is responsible that its children are destroyed when the owner is being destroyed.\n     */\n    this.owner = null;\n    /**\n     * The parent is typically the same as the owner.\n     * But the widget may be used by another widget (like a popup), in that case the parent will be changed to the popup but the owner stays the same.\n     * This means the popup is now the temporary parent, when the popup is destroyed its widgets are not because the popup is not the owner.\n     * Example: ViewMenuPopup uses the ViewButtons as menu items. These view buttons are owned by the desktop and must therefore not be destroyed\n     * when the popup closes, otherwise they could not be reused the second time the popup opens.\n     */\n    this.parent = null;\n    this.children = [];\n    this.initialized = false;\n\n    /**\n     * Will be set on the clone after a widget has been cloned.\n     * @type {Widget}\n     */\n    this.cloneOf = null;\n\n    /**\n     * The 'rendering' flag is set the true while the _initial_ rendering is performed.\n     * It is used to to something different in a _render* method when the method is\n     * called for the first time.\n     */\n    this.rendering = false;\n    this.removing = false;\n    this.removalPending = false;\n\n    /**\n     * The 'rendered' flag is set the true when initial rendering of the widget is completed.\n     */\n    this._rendered = false;\n    this.attached = false;\n    this.destroyed = false;\n    this.destroying = false;\n    this.enabled = true;\n    /**\n     * The computed enabled state. The difference to the 'enabled' property is that this member\n     * also considers the enabled-states of the parent widgets.\n     */\n    this.enabledComputed = true;\n    this.inheritAccessibility = true;\n    this.disabledStyle = Widget.DisabledStyle.DEFAULT;\n    this.visible = true;\n    this.focused = false;\n    this.loading = false;\n    this.cssClass = null;\n    this.scrollTop = null;\n    this.scrollLeft = null;\n\n    /** @type {$} */\n    this.$parent = null;\n    /** @type {$} */\n    this.$container = null;\n\n    /**\n     * Widgets creating a HtmlComponent for the main $container should assign it to this variable.\n     * This enables the execution of layout related operations like invalidateLayoutTree directly on the widget.\n     * @type {HtmlComponent}\n     */\n    this.htmlComp = null;\n\n    /**\n     * If set to true, remove won't remove the element immediately but after the animation has been finished\n     * This expects a css animation which may be triggered by the class 'animate-remove'\n     * If browser does not support css animation, remove will be executed immediately\n     */\n    this.animateRemoval = false;\n    this.animateRemovalClass = 'animate-remove';\n    this._widgetProperties = [];\n    this._cloneProperties = ['visible', 'enabled', 'inheritAccessibility', 'cssClass'];\n    this.eventDelegators = [];\n    this._preserveOnPropertyChangeProperties = [];\n    this._postRenderActions = [];\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._parentDestroyHandler = this._onParentDestroy.bind(this);\n    this._parentRemovingWhileAnimatingHandler = this._onParentRemovingWhileAnimating.bind(this);\n    this._scrollHandler = this._onScroll.bind(this);\n    this.events = this._createEventSupport();\n    this.events.registerSubTypePredicate('propertyChange', (event, propertyName) => {\n      return event.propertyName === propertyName;\n    });\n    this.loadingSupport = this._createLoadingSupport();\n    this.keyStrokeContext = this._createKeyStrokeContext();\n    // Widgets using LogicalGridLayout may have a grid to calculate the grid data of the children\n    this.logicalGrid = null;\n\n    // focus tracking\n    this.trackFocus = false;\n    this._$lastFocusedElement = null;\n    this._storedFocusedWidget = null;\n    this._glassPaneContributions = [];\n  }\n\n  /**\n   * Enum used to define different styles used when the field is disabled.\n   */\n\n  /**\n   * Initializes the widget instance. All properties of the model parameter (object) are set as properties on the widget instance.\n   * Calls {@link Widget#_init} and triggers an <em>init</em> event when initialization has been completed.\n   *\n   * @param {object} model\n   */\n  init(model) {\n    let staticModel = this._jsonModel();\n    if (staticModel) {\n      model = $.extend({}, staticModel, model);\n    }\n    model = model || {};\n    model = this._prepareModel(model);\n    this._init(model);\n    this._initKeyStrokeContext();\n    this.recomputeEnabled();\n    this.initialized = true;\n    this.trigger('init');\n  }\n\n  /**\n   * Default implementation simply returns the unmodified model. A Subclass\n   * may override this method to alter the JSON model before the widgets\n   * are created out of the widgetProperties in the model.\n   */\n  _prepareModel(model) {\n    return model;\n  }\n\n  /**\n   * Initializes the widget instance. All properties of the model parameter (object) are set as properties on the widget instance.\n   * Override this function to initialize widget specific properties in sub-classes.\n   *\n   * @param {object} model Properties:<ul>\n   *   <li>parent (required): parent widget</li>\n   *   <li>session (optional): If not specified, session of parent widget is used</li></ul>\n   */\n  _init(model) {\n    if (!model.parent) {\n      throw new Error('Parent expected: ' + this);\n    }\n    this.setOwner(model.owner || model.parent);\n    this.setParent(model.parent);\n    this.session = model.session || this.parent.session;\n    if (!this.session) {\n      throw new Error('Session expected: ' + this);\n    }\n    this._eachProperty(model, (propertyName, value, isWidgetProperty) => {\n      if (value === undefined) {\n        // Don't set the value if it is undefined, compared to null which is allowed explicitly ($.extend works in the same way)\n        return;\n      }\n      if (isWidgetProperty) {\n        value = this._prepareWidgetProperty(propertyName, value);\n      }\n      this._initProperty(propertyName, value);\n    });\n    this._setCssClass(this.cssClass);\n    this._setLogicalGrid(this.logicalGrid);\n    this._setEnabled(this.enabled);\n  }\n\n  /**\n   * This function sets the property value. Override this function when you need special init behavior for certain properties.\n   * For instance you could not simply set the property value, but extend an already existing value.\n   */\n  _initProperty(propertyName, value) {\n    this[propertyName] = value;\n  }\n\n  /**\n   * Default implementation simply returns undefined. A Subclass\n   * may override this method to load or extend a JSON model with models.getModel or models.extend.\n   */\n  _jsonModel() {}\n\n  /**\n   * Creates the widgets using the given models, or returns the widgets if the given models already are widgets.\n   * @returns {Widget[]|Widget} an array of created widgets if models was an array. Or the created widget if models is not an array.\n   */\n  _createChildren(models) {\n    if (!models) {\n      return null;\n    }\n    if (!Array.isArray(models)) {\n      return this._createChild(models);\n    }\n    let widgets = [];\n    models.forEach(function (model, i) {\n      widgets[i] = this._createChild(model);\n    }, this);\n    return widgets;\n  }\n\n  /**\n   * Calls {@link scout.create} for the given model, or if model is already a Widget simply returns the widget.\n   *\n   * @param model {Object|Widget}\n   * @returns {AnyWidget}\n   */\n  _createChild(model) {\n    if (model instanceof Widget) {\n      return model;\n    }\n    if (typeof model === 'string') {\n      // Special case: If only an ID is supplied, try to (locally) resolve the corresponding widget\n      let existingWidget = this.widget(model);\n      if (!existingWidget) {\n        throw new Error('Referenced widget not found: ' + model);\n      }\n      return existingWidget;\n    }\n    model.parent = this;\n    return scout.create(model);\n  }\n  _initKeyStrokeContext() {\n    if (!this.keyStrokeContext) {\n      return;\n    }\n    this.keyStrokeContext.$scopeTarget = () => this.$container;\n    this.keyStrokeContext.$bindTarget = () => this.$container;\n  }\n  destroy() {\n    if (this.destroyed) {\n      // Already destroyed, do nothing\n      return;\n    }\n    this.destroying = true;\n    if (this._rendered && (this.animateRemoval || this._isRemovalPrevented())) {\n      // Do not destroy yet if the removal happens animated\n      // Also don't destroy if the removal is pending to keep the parent / child link until removal finishes\n      this.one('remove', () => {\n        this.destroy();\n      });\n      this.remove();\n      return;\n    }\n\n    // Destroy children in reverse order\n    this._destroyChildren(this.children.slice().reverse());\n    this.remove();\n    this._destroy();\n\n    // Disconnect from owner and parent\n    this.owner._removeChild(this);\n    this.owner = null;\n    this.parent._removeChild(this);\n    this.parent.off('destroy', this._parentDestroyHandler);\n    this.parent = null;\n    this.destroying = false;\n    this.destroyed = true;\n    this.trigger('destroy');\n  }\n\n  /**\n   * Override this function to do clean-up (like removing listeners) when the widget is destroyed.\n   * The default impl. does nothing.\n   */\n  _destroy() {\n    // NOP\n  }\n\n  /**\n   * @param {Widget[]|Widget} widgets may be an object or array of objects\n   */\n  _destroyChildren(widgets) {\n    if (!widgets) {\n      return;\n    }\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function (widget, i) {\n      this._destroyChild(widget);\n    }, this);\n  }\n  _destroyChild(child) {\n    if (child.owner !== this) {\n      return;\n    }\n    child.destroy();\n  }\n\n  /**\n   * @param [$parent] The jQuery element which is used as {@link Widget.$parent} when rendering this widget.\n   * It will be put onto the widget and is therefore accessible as this.$parent in the {@link _render} method.\n   * If not specified, the {@link Widget.$container} of the parent is used.\n   */\n  render($parent) {\n    $.log.isTraceEnabled() && $.log.trace('Rendering widget: ' + this);\n    if (!this.initialized) {\n      throw new Error('Not initialized: ' + this);\n    }\n    if (this._rendered) {\n      throw new Error('Already rendered: ' + this);\n    }\n    if (this.destroyed) {\n      throw new Error('Widget is destroyed: ' + this);\n    }\n    this.rendering = true;\n    this.$parent = $parent || this.parent.$container;\n    this._render();\n    this._renderProperties();\n    this._renderInspectorInfo();\n    this._linkWithDOM();\n    this.session.keyStrokeManager.installKeyStrokeContext(this.keyStrokeContext);\n    this.rendering = false;\n    this.rendered = true;\n    this.attached = true;\n    this.trigger('render');\n    this.restoreFocus();\n    this._postRender();\n  }\n\n  /**\n   * Creates the UI by creating html elements and appending them to the DOM.\n   * <p>\n   * A typical widget creates exactly one container element and stores it to {@link Widget.$container}.\n   * If it needs JS based layouting, it creates a {@link HtmlComponent} for that container and stores it to {@link Widget.htmlComp}.\n   * <p>\n   * The rendering of individual properties should be done in the corresponding render methods of the properties, called by {@link _renderProperties} instead of doing it here.\n   * This has the advantage that the render methods can also be called on property changes, allowing individual widget parts to be dynamically re-rendered.\n   * <p>\n   * The default implementation does nothing.\n   */\n  _render() {\n    // NOP\n  }\n\n  /**\n   * Returns whether it is allowed to render something on the widget.\n   * Rendering is only possible if the widget itself is rendered and not about to be removed.\n   * <p>\n   * While the removal is pending, no rendering must happen to get a smooth remove animation.\n   * It also prevents errors on property changes because {@link remove} won't be executed as well.\n   * Preventing removal but allowing rendering could result in already rendered exceptions.\n   *\n   * @return {boolean} true if the widget is rendered and not being removed by an animation\n   *\n   * @see isRemovalPending\n   */\n  get rendered() {\n    return this._rendered && !this.isRemovalPending();\n  }\n  set rendered(rendered) {\n    this._rendered = rendered;\n  }\n\n  /**\n   * Calls the render methods for each property that needs to be rendered during the rendering process initiated by {@link render}.\n   * Each widget has to override this method and call the render methods for its own properties, after doing the super call.\n   * <p>\n   * This method is called right after {@link _render} has been executed.\n   */\n  _renderProperties() {\n    this._renderCssClass();\n    this._renderEnabled();\n    this._renderVisible();\n    this._renderTrackFocus();\n    this._renderFocused();\n    this._renderLoading();\n    this._renderScrollTop();\n    this._renderScrollLeft();\n  }\n\n  /**\n   * Method invoked once rendering completed and 'rendered' flag is set to 'true'.<p>\n   * By default executes every action of this._postRenderActions\n   */\n  _postRender() {\n    let actions = this._postRenderActions;\n    this._postRenderActions = [];\n    actions.forEach(action => {\n      action();\n    });\n  }\n\n  /**\n   * Removes the widget and all its children from the DOM.\n   * <p>\n   * It traverses down the widget hierarchy and calls {@link _remove} for each widget from the bottom up (depth first search).\n   * <p>\n   * If the property {@link Widget.animateRemoval} is set to true, the widget won't be removed immediately.\n   * Instead it waits for the remove animation to complete so it's content is still visible while the animation runs.\n   * During that time, {@link isRemovalPending} returns true.\n   */\n  remove() {\n    if (!this._rendered || this._isRemovalPrevented()) {\n      return;\n    }\n    if (this.animateRemoval) {\n      this._removeAnimated();\n    } else {\n      this._removeInternal();\n    }\n  }\n\n  /**\n   * Removes the element without starting the remove animation or waiting for the remove animation to complete.\n   * If the remove animation is running it will stop immediately because the element is removed. There will no animationend event be triggered.\n   *<p>\n   * <b>Important</b>: You should only use this method if your widget uses remove animations (this.animateRemoval = true)\n   * and you deliberately want to not execute or abort it. Otherwise you should use the regular {@link remove} method.\n   */\n  removeImmediately() {\n    this._removeInternal();\n  }\n\n  /**\n   * Will be called by {@link #remove()}. If true is returned, the widget won't be removed.<p>\n   * By default it just delegates to {@link #isRemovalPending}. May be overridden to customize it.\n   */\n  _isRemovalPrevented() {\n    return this.isRemovalPending();\n  }\n\n  /**\n   * @deprecated use isRemovalPending instead. Will be removed with 23.0\n   */\n  _isRemovalPending() {\n    return this.isRemovalPending();\n  }\n\n  /**\n   * Returns true if the removal of this or an ancestor widget is pending. Checking the ancestor is omitted if the parent is being removed.\n   * This may be used to prevent a removal if an ancestor will be removed (e.g by an animation)\n   */\n  isRemovalPending() {\n    if (this.removalPending) {\n      return true;\n    }\n    let parent = this.parent;\n    if (!parent || parent.removing || parent.rendering) {\n      // If parent is being removed or rendered, no need to check the ancestors because removing / rendering is already in progress\n      return false;\n    }\n    while (parent) {\n      if (parent.removalPending) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n  _removeInternal() {\n    if (!this._rendered) {\n      return;\n    }\n    $.log.isTraceEnabled() && $.log.trace('Removing widget: ' + this);\n    this.removing = true;\n    this.removalPending = false;\n    this.trigger('removing');\n    // transform last focused element into a scout widget\n    if (this.$container) {\n      this.$container.off('focusin', this._focusInListener);\n    }\n    if (this._$lastFocusedElement) {\n      this._storedFocusedWidget = scout.widget(this._$lastFocusedElement);\n      this._$lastFocusedElement = null;\n    }\n    // remove children in reverse order.\n    this.children.slice().reverse().forEach(function (child) {\n      // Only remove the child if this widget is the current parent (if that is not the case this widget is the owner)\n      if (child.parent === this) {\n        child.remove();\n      }\n    }, this);\n    if (!this._rendered) {\n      // The widget may have been removed already by one of the above remove() calls (e.g. by a remove listener)\n      // -> don't try to do it again, it might fail\n      return;\n    }\n    this._cleanup();\n    this._remove();\n    this.$parent = null;\n    this.rendered = false;\n    this.attached = false;\n    this.removing = false;\n    this.trigger('remove');\n  }\n\n  /**\n   * Adds class 'animate-remove' to container which can be used to trigger the animation.\n   * After the animation is executed, the element gets removed using this._removeInternal.\n   */\n  _removeAnimated() {\n    let animateRemovalWhileRemovingParent = this._animateRemovalWhileRemovingParent();\n    if (this.parent.removing && !animateRemovalWhileRemovingParent || !Device.get().supportsCssAnimation() || !this.$container || this.$container.isDisplayNone()) {\n      // Cannot remove animated, remove regularly\n      this._removeInternal();\n      return;\n    }\n\n    // Remove open popups first, they would be positioned wrongly during the animation\n    // Normally they would be closed automatically by a user interaction (click),\n    this.session.desktop.removePopupsFor(this);\n    this.removalPending = true;\n    // Don't execute immediately to make sure nothing interferes with the animation (e.g. layouting) which could make it laggy\n    setTimeout(() => {\n      // check if the container has been removed in the meantime\n      if (!this._rendered) {\n        return;\n      }\n      if (!this.animateRemovalClass) {\n        throw new Error('Missing animate removal class. Cannot remove animated.');\n      }\n      if (!this.$container.isVisible() || !this.$container.isEveryParentVisible() || !this.$container.isAttached()) {\n        // If element is not visible, animationEnd would never fire -> remove it immediately\n        this._removeInternal();\n        return;\n      }\n      this.$container.addClass(this.animateRemovalClass);\n      this.$container.oneAnimationEnd(() => {\n        this._removeInternal();\n      });\n    });\n\n    // If the parent is being removed while the animation is running, the animationEnd event will never fire\n    // -> Make sure remove is called nevertheless. Important: remove it before the parent is removed to maintain the regular remove order\n    if (!animateRemovalWhileRemovingParent) {\n      this.parent.one('removing', this._parentRemovingWhileAnimatingHandler);\n    }\n  }\n  _animateRemovalWhileRemovingParent() {\n    // By default, remove animation is prevented when parent is being removed\n    return false;\n  }\n  _onParentRemovingWhileAnimating() {\n    this._removeInternal();\n  }\n  _renderInspectorInfo() {\n    if (!this.session.inspector) {\n      return;\n    }\n    inspector.applyInfo(this);\n  }\n\n  /**\n   * Links $container with the widget.\n   */\n  _linkWithDOM() {\n    if (this.$container) {\n      this.$container.data('widget', this);\n    }\n  }\n\n  /**\n   * Called right before _remove is called.\n   * Default calls LayoutValidator.cleanupInvalidComponents to make sure that child components are removed from the invalid components list.\n   * Also uninstalls key stroke context, loading support and scrollbars.\n   */\n  _cleanup() {\n    this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n    this.session.keyStrokeManager.uninstallKeyStrokeContext(this.keyStrokeContext);\n    if (this.loadingSupport) {\n      this.loadingSupport.remove();\n    }\n    this._uninstallScrollbars();\n    if (this.$container) {\n      this.session.layoutValidator.cleanupInvalidComponents(this.$container);\n    }\n  }\n  _remove() {\n    if (this.$container) {\n      this.$container.remove();\n      this.$container = null;\n    }\n  }\n  setOwner(owner) {\n    scout.assertParameter('owner', owner);\n    if (owner === this.owner) {\n      return;\n    }\n    if (this.owner) {\n      // Remove from old owner\n      this.owner._removeChild(this);\n    }\n    this.owner = owner;\n    this.owner._addChild(this);\n  }\n  setParent(parent) {\n    scout.assertParameter('parent', parent);\n    if (parent === this.parent) {\n      return;\n    }\n    if (this.rendered && !parent.rendered) {\n      $.log.isInfoEnabled() && $.log.info('rendered child ' + this + ' is added to not rendered parent ' + parent + '. Removing child.', new Error('origin'));\n      this.remove();\n    }\n    if (this.parent) {\n      // Don't link to new parent yet if removal is still pending.\n      // After the animation the parent will remove its children.\n      // If they are already linked to a new parent, removing the children is not possible anymore.\n      // This may lead to an \"Already rendered\" exception if the new parent wants to render its children.\n      if (this.parent.isRemovalPending()) {\n        this.parent.one('remove', () => {\n          this.setParent(parent);\n        });\n        return;\n      }\n      this.parent.off('destroy', this._parentDestroyHandler);\n      this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n      if (this.parent !== this.owner) {\n        // Remove from old parent if getting relinked\n        // If the old parent is still the owner, don't remove it because owner stays responsible for destroying it\n        this.parent._removeChild(this);\n      }\n    }\n    let oldParent = this.parent;\n    this.parent = parent;\n    this.parent._addChild(this);\n    this.trigger('hierarchyChange', {\n      oldParent: oldParent,\n      parent: parent\n    });\n    if (this.initialized) {\n      this.recomputeEnabled(this.parent.enabledComputed);\n    }\n    this.parent.one('destroy', this._parentDestroyHandler);\n  }\n  _addChild(child) {\n    $.log.isTraceEnabled() && $.log.trace('addChild(' + child + ') to ' + this);\n    arrays.pushSet(this.children, child);\n  }\n  _removeChild(child) {\n    $.log.isTraceEnabled() && $.log.trace('removeChild(' + child + ') from ' + this);\n    arrays.remove(this.children, child);\n  }\n\n  /**\n   * @returns {Widget[]} a list of all ancestors\n   */\n  ancestors() {\n    let ancestors = [];\n    let parent = this.parent;\n    while (parent) {\n      ancestors.push(parent);\n      parent = parent.parent;\n    }\n    return ancestors;\n  }\n\n  /**\n   * @returns {boolean} true if the given widget is the same as this or a descendant\n   */\n  isOrHas(widget) {\n    if (widget === this) {\n      return true;\n    }\n    return this.has(widget);\n  }\n\n  /**\n   * @returns {boolean} true if the given widget is a descendant\n   */\n  has(widget) {\n    while (widget) {\n      if (widget.parent === this) {\n        return true;\n      }\n      widget = widget.parent;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {Form} the form the widget belongs to (returns the first parent which is a {@link Form}.\n   */\n  getForm() {\n    return Form.findForm(this);\n  }\n\n  /**\n   * @returns {Form} the first form which is not an inner form of a wrapped form field\n   */\n  findNonWrappedForm() {\n    return Form.findNonWrappedForm(this);\n  }\n\n  /**\n   * @returns {Desktop} the desktop linked to the current session.\n   * If desktop is still initializing it might not be available yet, in that case it searches the parent hierarchy for it.\n   */\n  findDesktop() {\n    if (this.session.desktop) {\n      return this.session.desktop;\n    }\n    return this.findParent(parent => {\n      return parent instanceof Desktop;\n    });\n  }\n\n  /**\n   * Changes the enabled property of this form field to the given value.\n   *\n   * @param {boolean} enabled\n   *          Required. The new enabled value\n   * @param {boolean} [updateParents]\n   *          (optional) If true, the enabled property of all parent form fields are\n   *          updated to same value as well. Default is false.\n   * @param {boolean} [updateChildren]\n   *          (optional) If true the enabled property of all child form fields (recursive)\n   *          are updated to same value as well. Default is false.\n   */\n  setEnabled(enabled, updateParents, updateChildren) {\n    this.setProperty('enabled', enabled);\n    if (enabled && updateParents && this.parent) {\n      this.parent.setEnabled(true, true, false);\n    }\n    if (updateChildren) {\n      this.visitChildren(field => {\n        field.setEnabled(enabled);\n      });\n    }\n  }\n  _setEnabled(enabled) {\n    this._setProperty('enabled', enabled);\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n  recomputeEnabled(parentEnabled) {\n    if (parentEnabled === undefined) {\n      parentEnabled = true;\n      if (this.parent && this.parent.initialized && this.parent.enabledComputed !== undefined) {\n        parentEnabled = this.parent.enabledComputed;\n      }\n    }\n    let enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n    this._updateEnabledComputed(enabledComputed);\n  }\n  _updateEnabledComputed(enabledComputed, enabledComputedForChildren) {\n    if (this.enabledComputed === enabledComputed && enabledComputedForChildren === undefined) {\n      // no change for this instance. there is no need to propagate to children\n      // exception: the enabledComputed for the children differs from the one for me. In this case the propagation is necessary.\n      return;\n    }\n    this.setProperty('enabledComputed', enabledComputed);\n\n    // Manually call _renderEnabled(), because _renderEnabledComputed() does not exist\n    if (this.rendered) {\n      this._renderEnabled();\n    }\n    let computedStateForChildren = scout.nvl(enabledComputedForChildren, enabledComputed);\n    this._childrenForEnabledComputed().forEach(child => {\n      if (child.inheritAccessibility) {\n        child.recomputeEnabled(computedStateForChildren);\n      }\n    });\n  }\n  _childrenForEnabledComputed() {\n    return this.children;\n  }\n  _computeEnabled(inheritAccessibility, parentEnabled) {\n    return this.enabled && (inheritAccessibility ? parentEnabled : true);\n  }\n  _renderEnabled() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.setEnabled(this.enabledComputed);\n    this._renderDisabledStyle();\n  }\n  setInheritAccessibility(inheritAccessibility) {\n    this.setProperty('inheritAccessibility', inheritAccessibility);\n  }\n  _setInheritAccessibility(inheritAccessibility) {\n    this._setProperty('inheritAccessibility', inheritAccessibility);\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n  setDisabledStyle(disabledStyle) {\n    this.setProperty('disabledStyle', disabledStyle);\n    this.children.forEach(child => {\n      child.setDisabledStyle(disabledStyle);\n    });\n  }\n  _renderDisabledStyle() {\n    this._renderDisabledStyleInternal(this.$container);\n  }\n\n  /**\n   * This function is used by subclasses to render the read-only class for a given $field.\n   * Some fields like DateField have two input fields and thus cannot use the this.$field property.\n   */\n  _renderDisabledStyleInternal($element) {\n    if (!$element) {\n      return;\n    }\n    if (this.enabledComputed) {\n      $element.removeClass('read-only');\n    } else {\n      $element.toggleClass('read-only', this.disabledStyle === Widget.DisabledStyle.READ_ONLY);\n    }\n  }\n\n  /**\n   * @param {boolean} visible true, to make the widget visible, false to hide it\n   */\n  setVisible(visible) {\n    this.setProperty('visible', visible);\n  }\n\n  /**\n   * @returns {boolean} whether the widget is visible or not. May depend on other conditions than the visible property only\n   */\n  isVisible() {\n    return this.visible;\n  }\n  _renderVisible() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.setVisible(this.isVisible());\n    this.invalidateParentLogicalGrid();\n  }\n\n  /**\n   * @returns {boolean} true if every parent within the hierarchy is visible.\n   */\n  isEveryParentVisible() {\n    let parent = this.parent;\n    while (parent) {\n      if (!parent.isVisible()) {\n        return false;\n      }\n      parent = parent.parent;\n    }\n    return true;\n  }\n\n  /**\n   * This function does not set the focus to the field. It toggles the 'focused' class on the field container if present.\n   * Objects using widget as prototype must call this function onBlur and onFocus to ensure the class gets toggled.\n   *\n   *  Use Widget.focus to set the focus to the widget.\n   */\n  setFocused(focused) {\n    this.setProperty('focused', focused);\n  }\n  _renderFocused() {\n    if (this.$container) {\n      this.$container.toggleClass('focused', this.focused);\n    }\n  }\n  _setCssClass(cssClass) {\n    if (this.rendered) {\n      this._removeCssClass();\n    }\n    this._setProperty('cssClass', cssClass);\n  }\n  _removeCssClass() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.removeClass(this.cssClass);\n  }\n  _renderCssClass() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.addClass(this.cssClass);\n    if (this.htmlComp) {\n      // Replacing css classes may enlarge or shrink the widget (e.g. setting the font weight to bold makes the text bigger) -> invalidate layout\n      this.invalidateLayoutTree();\n    }\n  }\n  setCssClass(cssClass) {\n    this.setProperty('cssClass', cssClass);\n  }\n  addCssClass(cssClass) {\n    let cssClasses = this.cssClassAsArray();\n    let cssClassesToAdd = Widget.cssClassAsArray(cssClass);\n    cssClassesToAdd.forEach(newCssClass => {\n      if (cssClasses.indexOf(newCssClass) >= 0) {\n        return;\n      }\n      cssClasses.push(newCssClass);\n    }, this);\n    this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n  }\n  removeCssClass(cssClass) {\n    let cssClasses = this.cssClassAsArray();\n    let cssClassesToRemove = Widget.cssClassAsArray(cssClass);\n    if (arrays.removeAll(cssClasses, cssClassesToRemove)) {\n      this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n    }\n  }\n  toggleCssClass(cssClass, condition) {\n    if (condition) {\n      this.addCssClass(cssClass);\n    } else {\n      this.removeCssClass(cssClass);\n    }\n  }\n  cssClassAsArray() {\n    return Widget.cssClassAsArray(this.cssClass);\n  }\n\n  /**\n   * Creates nothing by default. If a widget needs loading support, override this method and return a loading support.\n   * @returns {LoadingSupport}\n   */\n  _createLoadingSupport() {\n    return null;\n  }\n  setLoading(loading) {\n    this.setProperty('loading', loading);\n  }\n  isLoading() {\n    return this.loading;\n  }\n  _renderLoading() {\n    if (!this.loadingSupport) {\n      return;\n    }\n    this.loadingSupport.renderLoading();\n  }\n\n  // --- Layouting / HtmlComponent methods ---\n\n  pack() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.pack();\n  }\n  invalidateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.invalidateLayout();\n  }\n  validateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.validateLayout();\n  }\n  revalidateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.revalidateLayout();\n  }\n\n  /**\n   * @param [invalidateParents] optional, default is true\n   */\n  invalidateLayoutTree(invalidateParents) {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.invalidateLayoutTree(invalidateParents);\n  }\n  validateLayoutTree() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.validateLayoutTree();\n  }\n  revalidateLayoutTree(invalidateParents) {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.revalidateLayoutTree(invalidateParents);\n  }\n\n  /**\n   * The layout data contains hints for the layout of the parent container to layout this individual child widget inside the container.<br>\n   * Note: this is not the same as the LayoutConfig. The LayoutConfig contains constraints for the layout itself and is therefore set on the parent container directly.\n   * <p>\n   * Example: The parent container uses a LogicalGridLayout to layout its children. Every child has a LogicalGridLayoutData to tell the layout how this specific child should be layouted.\n   * The parent may have a LogicalGridLayoutConfig to specify constraints which affect either only the container or every child in the container.\n   */\n  setLayoutData(layoutData) {\n    if (!this.rendered) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.layoutData = layoutData;\n  }\n\n  /**\n   * If the widget uses a logical grid layout, the grid may be validated using this method.\n   * <p>\n   * If the grid is not dirty, nothing happens.\n   */\n  validateLogicalGrid() {\n    if (this.logicalGrid) {\n      this.logicalGrid.validate(this);\n    }\n  }\n\n  /**\n   * Marks the logical grid as dirty.<br>\n   * Does nothing, if there is no logical grid.\n   * @param {boolean} [invalidateLayout] true, to invalidate the layout afterwards, false if not. Default is true.\n   */\n  invalidateLogicalGrid(invalidateLayout) {\n    if (!this.initialized) {\n      return;\n    }\n    if (!this.logicalGrid) {\n      return;\n    }\n    this.logicalGrid.setDirty(true);\n    if (scout.nvl(invalidateLayout, true)) {\n      this.invalidateLayoutTree();\n    }\n  }\n\n  /**\n   * Invalidates the logical grid of the parent widget. Typically done when the visibility of the widget changes.\n   * @param {boolean} [invalidateLayout] true, to invalidate the layout of the parent of this.htmlComp, false if not. Default is true.\n   */\n  invalidateParentLogicalGrid(invalidateLayout) {\n    this.parent.invalidateLogicalGrid(false);\n    if (!this.rendered || !this.htmlComp) {\n      return;\n    }\n    if (scout.nvl(invalidateLayout, true)) {\n      let htmlCompParent = this.htmlComp.getParent();\n      if (htmlCompParent) {\n        htmlCompParent.invalidateLayoutTree();\n      }\n    }\n  }\n  revalidateLogicalGrid(invalidateLayout) {\n    this.invalidateLogicalGrid(invalidateLayout);\n    this.validateLogicalGrid();\n  }\n  setLogicalGrid(logicalGrid) {\n    this.setProperty('logicalGrid', logicalGrid);\n  }\n\n  /**\n   * @param logicalGrid an instance of {@link LogicalGrid} or a string representing the object type of a logical grid.\n   */\n  _setLogicalGrid(logicalGrid) {\n    if (typeof logicalGrid === 'string') {\n      logicalGrid = scout.create(logicalGrid);\n    }\n    this._setProperty('logicalGrid', logicalGrid);\n    this.invalidateLogicalGrid();\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   * The function will only be called once. After that it is automatically de-registered using {@link off}.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} handler Event handler executed when the event is triggered. An event object is passed to the function as first parameter\n   */\n  one(type, handler) {\n    this.events.one(type, handler);\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} handler Event handler executed when the event is triggered. An event object is passed to the function as first parameter.\n   **/\n  on(type, handler) {\n    return this.events.on(type, handler);\n  }\n\n  /**\n   * De-registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.<br/>\n   *      Important: the string must be equal to the one used for {@link on} or {@link one}. This also applies if a string containing multiple types separated by space was used.\n   * @param {function} [handler] The exact same event handler that was used for registration using {@link on} or {@link one}.\n   *      If no handler is specified, all handlers are de-registered for the given type.\n   */\n  off(type, handler) {\n    this.events.off(type, handler);\n  }\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n\n  /**\n   * Adds an event handler using {@link one} and returns a promise.\n   * The promise is resolved as soon as the event is triggered.\n   * @returns {Promise}\n   */\n  when(type) {\n    return this.events.when(type);\n  }\n\n  /**\n   * @returns {$} the entry-point for this Widget or its parent. If the widget is part of the main-window it returns this.session.$entryPoint,\n   * for popup-window this function will return the body of the document in the popup window.\n   */\n  entryPoint() {\n    let $element = scout.nvl(this.$container, this.parent.$container);\n    if (!$element || !$element.length) {\n      throw new Error('Cannot resolve entryPoint, $element.length is 0 or undefined');\n    }\n    return $element.entryPoint();\n  }\n  window(domElement) {\n    let $el = this.$container || this.$parent;\n    return $el ? $el.window(domElement) : domElement ? null : $(null);\n  }\n  document(domElement) {\n    let $el = this.$container || this.$parent;\n    return $el ? $el.document(domElement) : domElement ? null : $(null);\n  }\n\n  /**\n   * This method attaches the detached $container to the DOM.\n   */\n  attach() {\n    if (this.attached || !this.rendered) {\n      return;\n    }\n    this._attach();\n    this._installFocusContext();\n    this.restoreFocus();\n    this.attached = true;\n    this._postAttach();\n    this._onAttach();\n    this._triggerChildrenOnAttach(this);\n  }\n\n  /**\n   * Override this method to do something when Widget is attached again. Typically\n   * you will append this.$container to this.$parent.\n   */\n  _attach() {\n    // NOP\n  }\n\n  /**\n   * Override this method to do something after this widget is attached.\n   * This function is not called on any child of the attached widget.\n   */\n  _postAttach() {\n    // NOP\n  }\n  _triggerChildrenOnAttach(parent) {\n    this.children.forEach(child => {\n      child._onAttach();\n      child._triggerChildrenOnAttach(parent);\n    });\n  }\n\n  /**\n   * Override this method to do something after this widget or any parent of it is attached.\n   * This function is called whether or not the widget is rendered.\n   */\n  _onAttach() {\n    if (this.rendered) {\n      this._renderOnAttach();\n    }\n  }\n\n  /**\n   * Override this method to do something after this widget or any parent of it is attached.\n   * This function is only called when this widget is rendered.\n   */\n  _renderOnAttach() {\n    this._renderScrollTop();\n    this._renderScrollLeft();\n  }\n\n  /**\n   * This method calls detach() on all child-widgets. It is used to store some data\n   * before a DOM element is detached and propagate the detach \"event\" to all child-\n   * widgets, because when a DOM element is detached - child elements are not notified\n   */\n  detach() {\n    if (this.rendering) {\n      // Defer the execution of detach. If it was detached while rendering the attached flag would be wrong.\n      this._postRenderActions.push(this.detach.bind(this));\n    }\n    if (!this.attached || !this.rendered) {\n      return;\n    }\n    this._beforeDetach();\n    this._onDetach();\n    this._triggerChildrenOnDetach(this);\n    this._detach();\n    this.attached = false;\n  }\n\n  /**\n   * This function is called before a widget gets detached. The function is only called on the detached widget and NOT on\n   * any of its children.\n   */\n  _beforeDetach(parent) {\n    if (!this.$container) {\n      return;\n    }\n    let activeElement = this.$container.document(true).activeElement;\n    let isFocused = this.$container.isOrHas(activeElement);\n    let focusManager = this.session.focusManager;\n    if (focusManager.isFocusContextInstalled(this.$container)) {\n      this._uninstallFocusContext();\n    } else if (isFocused) {\n      // exclude the container or any of its child elements to gain focus\n      focusManager.validateFocus(filters.outsideFilter(this.$container));\n    }\n  }\n  _triggerChildrenOnDetach() {\n    this.children.forEach(child => {\n      child._onDetach();\n      child._triggerChildrenOnDetach(parent);\n    });\n  }\n\n  /**\n   * This function is called before a widget or any of its parent getting detached.\n   * This function is thought to be overridden.\n   */\n  _onDetach() {\n    if (this.rendered) {\n      this._renderOnDetach();\n    }\n  }\n  _renderOnDetach() {\n    // NOP\n  }\n\n  /**\n   * Override this method to do something when Widget is detached. Typically you\n   * will call this.$container.detach(). The default\n   * implementation sets this.attached to false.\n   */\n  _detach() {}\n  _uninstallFocusContext() {\n    // NOP\n  }\n  _installFocusContext() {\n    // NOP\n  }\n\n  /**\n   * Does nothing by default. If a widget needs keystroke support override this method and return a keystroke context, e.g. the default KeyStrokeContext.\n   * @returns {KeyStrokeContext}\n   */\n  _createKeyStrokeContext() {\n    return null;\n  }\n  updateKeyStrokes(newKeyStrokes, oldKeyStrokes) {\n    this.unregisterKeyStrokes(oldKeyStrokes);\n    this.registerKeyStrokes(newKeyStrokes);\n  }\n  registerKeyStrokes(keyStrokes) {\n    this.keyStrokeContext.registerKeyStrokes(keyStrokes);\n  }\n  unregisterKeyStrokes(keyStrokes) {\n    this.keyStrokeContext.unregisterKeyStrokes(keyStrokes);\n  }\n\n  /**\n   * Triggers a property change for a single property.\n   */\n  triggerPropertyChange(propertyName, oldValue, newValue) {\n    scout.assertParameter('propertyName', propertyName);\n    let event = new Event({\n      propertyName: propertyName,\n      oldValue: oldValue,\n      newValue: newValue\n    });\n    this.trigger('propertyChange', event);\n    return event;\n  }\n\n  /**\n   * Sets the value of the property 'propertyName' to 'newValue' and then fires a propertyChange event for that property.\n   * @return {boolean} true if the property was changed, false if not.\n   */\n  _setProperty(propertyName, newValue) {\n    scout.assertParameter('propertyName', propertyName);\n    let oldValue = this[propertyName];\n    if (objects.equals(oldValue, newValue)) {\n      return false;\n    }\n    this[propertyName] = newValue;\n    let event = this.triggerPropertyChange(propertyName, oldValue, newValue);\n    if (event.defaultPrevented) {\n      // Revert to old value if property change should be prevented\n      this[propertyName] = oldValue;\n      return false; // not changed\n    }\n\n    return true;\n  }\n\n  /**\n   * Sets a new value for a specific property. If the new value is the same value as the old one, nothing is performed.\n   * Otherwise the following phases are executed:\n   * <p>\n   * 1. Preparation: If the property is a widget property, several actions are performed in _prepareWidgetProperty().\n   * 2. DOM removal: If the property is a widget property and the widget is rendered, the changed widget(s) are removed unless the property should not be preserved (see _preserveOnPropertyChangeProperties).\n   *    If there is a custom remove function (e.g. _removeXY where XY is the property name), it will be called instead of removing the widgets directly.\n   * 3. Model update: If there is a custom set function (e.g. _setXY where XY is the property name), it will be called. Otherwise the default set function _setProperty is called.\n   * 4. DOM rendering: If the widget is rendered and there is a custom render function (e.g. _renderXY where XY is the property name), it will be called. Otherwise nothing happens.\n   * @return {boolean} true if the property was changed, false if not.\n   */\n  setProperty(propertyName, value) {\n    if (objects.equals(this[propertyName], value)) {\n      return false;\n    }\n    value = this._prepareProperty(propertyName, value);\n    if (this.rendered) {\n      this._callRemoveProperty(propertyName);\n    }\n    this._callSetProperty(propertyName, value);\n    if (this.rendered) {\n      this._callRenderProperty(propertyName);\n    }\n    return true;\n  }\n  _prepareProperty(propertyName, value) {\n    if (!this.isWidgetProperty(propertyName)) {\n      return value;\n    }\n    return this._prepareWidgetProperty(propertyName, value);\n  }\n  _prepareWidgetProperty(propertyName, widgets) {\n    // Create new child widget(s)\n    widgets = this._createChildren(widgets);\n    let oldWidgets = this[propertyName];\n    if (oldWidgets && Array.isArray(widgets)) {\n      // If new value is an array, old value has to be one as well\n      // Only destroy those which are not in the new array\n      oldWidgets = arrays.diff(oldWidgets, widgets);\n    }\n    if (!this.isPreserveOnPropertyChangeProperty(propertyName)) {\n      // Destroy old child widget(s)\n      this._destroyChildren(oldWidgets);\n\n      // Link to new parent\n      this.link(widgets);\n    }\n    return widgets;\n  }\n\n  /**\n   * Does nothing if the property is not a widget property.<p>\n   * If it is a widget property, it removes the existing widgets. Render has to be implemented by the widget itself.\n   */\n  _callRemoveProperty(propertyName) {\n    if (!this.isWidgetProperty(propertyName)) {\n      return;\n    }\n    if (this.isPreserveOnPropertyChangeProperty(propertyName)) {\n      return;\n    }\n    let widgets = this[propertyName];\n    if (!widgets) {\n      return;\n    }\n    let removeFuncName = '_remove' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[removeFuncName]) {\n      this[removeFuncName]();\n    } else {\n      this._internalRemoveWidgets(widgets);\n    }\n  }\n\n  /**\n   * Removes the given widgets\n   */\n  _internalRemoveWidgets(widgets) {\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(widget => {\n      widget.remove();\n    });\n  }\n  _callSetProperty(propertyName, value) {\n    let setFuncName = '_set' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[setFuncName]) {\n      this[setFuncName](value);\n    } else {\n      this._setProperty(propertyName, value);\n    }\n  }\n  _callRenderProperty(propertyName) {\n    let renderFuncName = '_render' + strings.toUpperCaseFirstLetter(propertyName);\n    if (!this[renderFuncName]) {\n      return;\n    }\n    this[renderFuncName]();\n  }\n\n  /**\n   * Sets this widget as parent of the given widget(s).\n   *\n   * @param {Widget[]|Widget} widgets may be a widget or array of widgets\n   */\n  link(widgets) {\n    if (!widgets) {\n      return;\n    }\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function (child, i) {\n      child.setParent(this);\n    }, this);\n  }\n\n  /**\n   * Method required for widgets which are supposed to be directly covered by a glasspane.<p>\n   *\n   * Returns the DOM elements to paint a glassPanes over, once a modal Form, message-box or file-chooser is shown with this widget as its 'displayParent'.<br>\n   * If the widget is not rendered yet, a scout.DeferredGlassPaneTarget is returned.<br>\n   * In both cases the method _glassPaneTargets is called which may be overridden by the actual widget.\n   * @param {Widget} element widget that requested a glass pane\n   * @returns [$]|[DeferredGlassPaneTarget]\n   */\n  glassPaneTargets(element) {\n    let resolveGlassPanes = element => {\n      // contributions\n      let targets = arrays.flatMap(this._glassPaneContributions, cont => {\n        let $elements = cont(element);\n        if ($elements) {\n          return arrays.ensure($elements);\n        }\n        return [];\n      });\n      return targets.concat(this._glassPaneTargets(element));\n    };\n    if (this.rendered) {\n      return resolveGlassPanes(element);\n    }\n    return DeferredGlassPaneTarget.createFor(this, resolveGlassPanes.bind(this, element));\n  }\n\n  /**\n   *\n   * @param {Widget} element widget that requested a glass pane\n   * @returns [$]\n   */\n  _glassPaneTargets(element) {\n    // since popups are rendered outside the DOM of the widget parent-child hierarchy, get glassPaneTargets of popups belonging to this widget separately.\n    return [this.$container].concat(this.session.desktop.getPopupsFor(this).filter(popup => !element.has(popup)).reduce((acc, popup) => acc.concat(popup.glassPaneTargets()), []));\n  }\n  addGlassPaneContribution(contribution) {\n    this._glassPaneContributions.push(contribution);\n    this.trigger('glassPaneContributionAdded', {\n      contribution: contribution\n    });\n  }\n\n  /**\n   * @param [contribution] a function which returns glass pane targets (jQuery elements)\n   */\n  removeGlassPaneContribution(contribution) {\n    arrays.remove(this._glassPaneContributions, contribution);\n    this.trigger('glassPaneContributionRemoved', {\n      contribution: contribution\n    });\n  }\n  toString() {\n    let attrs = '';\n    attrs += 'id=' + this.id;\n    attrs += ' objectType=' + this.objectType;\n    attrs += ' rendered=' + this.rendered;\n    if (this.$container) {\n      attrs += ' $container=' + graphics.debugOutput(this.$container);\n    }\n    return 'Widget[' + attrs.trim() + ']';\n  }\n\n  /**\n   * Returns the ancestors as string delimited by '\\n'.\n   * @param {number} [count] the number of ancestors to be processed. Default is -1 which means all.\n   */\n  ancestorsToString(count) {\n    let str = '',\n      ancestors = this.ancestors();\n    count = scout.nvl(count, -1);\n    ancestors.some((ancestor, i) => {\n      if (count > -1 && i >= count) {\n        return true;\n      }\n      if (i > 0 && i < ancestors.length - 1) {\n        str += '\\n';\n      }\n      str += ancestor.toString();\n      return false;\n    });\n    return str;\n  }\n  resolveTextKeys(properties) {\n    properties.forEach(function (property) {\n      texts.resolveTextProperty(this, property);\n    }, this);\n  }\n  resolveIconIds(properties) {\n    properties.forEach(function (property) {\n      icons.resolveIconProperty(this, property);\n    }, this);\n  }\n  resolveConsts(configs) {\n    configs.forEach(function (config) {\n      objects.resolveConstProperty(this, config);\n    }, this);\n  }\n\n  /**\n   * A so called widget property is a property with a widget as value incl. automatic resolution of that widget.\n   * This means the property not only accepts the actual widget, but also a widget model or a widget reference (id)\n   * and then either creates a new widget based on the model or resolves the id and uses the referenced widget as value.\n   * Furthermore it will take care of its lifecycle which means, the widget will automatically be removed and destroyed (as long as the parent is also the owner).\n   * <p>\n   * If only the resolve operations without the lifecycle actions should be performed, you need to add the property to the list _preserveOnPropertyChangeProperties as well.\n   */\n  _addWidgetProperties(properties) {\n    this._addProperties('_widgetProperties', properties);\n  }\n  isWidgetProperty(propertyName) {\n    return this._widgetProperties.indexOf(propertyName) > -1;\n  }\n  _addCloneProperties(properties) {\n    this._addProperties('_cloneProperties', properties);\n  }\n  isCloneProperty(propertyName) {\n    return this._cloneProperties.indexOf(propertyName) > -1;\n  }\n\n  /**\n   * Properties in this list won't be affected by the automatic lifecycle actions performed for regular widget properties.\n   * This means, the widget won't be removed, destroyed and also not linked, which means the parent stays the same.\n   * But the resolve operations are still applied, as for regular widget properties.\n   * <p>\n   * The typical use case for such properties is referencing another widget without taking care of that widget.\n   */\n  _addPreserveOnPropertyChangeProperties(properties) {\n    this._addProperties('_preserveOnPropertyChangeProperties', properties);\n  }\n  isPreserveOnPropertyChangeProperty(propertyName) {\n    return this._preserveOnPropertyChangeProperties.indexOf(propertyName) > -1;\n  }\n  _addProperties(propertyName, properties) {\n    properties = arrays.ensure(properties);\n    properties.forEach(function (property) {\n      if (this[propertyName].indexOf(property) > -1) {\n        throw new Error(propertyName + ' already contains the property ' + property);\n      }\n      this[propertyName].push(property);\n    }, this);\n  }\n  _eachProperty(model, func) {\n    let propertyName, value, i;\n\n    // Loop through primitive properties\n    for (propertyName in model) {\n      if (this._widgetProperties.indexOf(propertyName) > -1) {\n        continue; // will be handled below\n      }\n\n      value = model[propertyName];\n      func(propertyName, value);\n    }\n\n    // Loop through adapter properties (any order will do).\n    for (i = 0; i < this._widgetProperties.length; i++) {\n      propertyName = this._widgetProperties[i];\n      value = model[propertyName];\n      if (value === undefined) {\n        continue;\n      }\n      func(propertyName, value, true);\n    }\n  }\n  _removeWidgetProperties(properties) {\n    if (Array.isArray(properties)) {\n      arrays.removeAll(this._widgetProperties, properties);\n    } else {\n      arrays.remove(this._widgetProperties, properties);\n    }\n  }\n\n  /**\n   * Clones the widget and mirrors the events, see this.clone() and this.mirror() for details.\n   */\n  cloneAndMirror(model) {\n    return this.clone(model, {\n      delegateAllPropertiesToClone: true\n    });\n  }\n\n  /**\n   * @returns {AnyWidget} the original widget from which this one was cloned. If it is not a clone, itself is returned.\n   */\n  original() {\n    let original = this;\n    while (original.cloneOf) {\n      original = original.cloneOf;\n    }\n    return original;\n  }\n\n  /**\n   * Clones the widget and returns the clone. Only the properties defined in this._cloneProperties are copied to the clone.\n   * The parameter model has to contain at least the property 'parent'.\n   *\n   * @param model The model used to create the clone is a combination of the clone properties and this model.\n   * Therefore this model may be used to override the cloned properties or to add additional properties.\n   * @param {object} [options] Options passed to the mirror function.\n   * @param {[string]} [options.delegatePropertiesToClone] An array of all properties to be delegated from the original to the clone when changed on the original widget. Default is [].\n   * @param {[string]} [options.delegatePropertiesToOriginal] An array of all properties to be delegated from the clone to the original when changed on the clone widget. Default is [].\n   * @param {[string]} [options.excludePropertiesToOriginal] An array of all properties to be excluded from delegating from the clone to the original in any cases. Default is [].\n   * @param {[string]} [options.delegateEventsToOriginal] An array of all events to be delegated from the clone to the original when fired on the clone widget. Default is [].\n   * @param {boolean} [options.delegateAllPropertiesToClone] True to delegate all property changes from the original to the clone. Default is false.\n   * @param {boolean} [options.delegateAllPropertiesToOriginal] True to delegate all property changes from the clone to the original. Default is false.\n   */\n  clone(model, options) {\n    let clone, cloneModel;\n    model = model || {};\n    options = options || {};\n    cloneModel = objects.extractProperties(this, model, this._cloneProperties);\n    clone = scout.create(this.objectType, cloneModel);\n    clone.cloneOf = this;\n    this._mirror(clone, options);\n    if (this.logicalGrid) {\n      // Create a new logical grid to make sure it does not influence the original widget\n      // This also creates the correct grid config for the specific widget\n      clone.setLogicalGrid(this.logicalGrid.objectType);\n    } else {\n      // Remove the grid if the original does not have one either\n      clone.setLogicalGrid(null);\n    }\n    return clone;\n  }\n  _deepCloneProperties(clone, properties, options) {\n    if (!properties) {\n      return clone;\n    }\n    properties = arrays.ensure(properties);\n    properties.forEach(property => {\n      let propertyValue = this[property],\n        clonedProperty = null;\n      if (propertyValue === undefined) {\n        throw new Error('Property \\'' + property + '\\' is undefined. Deep copy not possible.');\n      }\n      if (this._widgetProperties.indexOf(property) > -1) {\n        if (Array.isArray(propertyValue)) {\n          clonedProperty = propertyValue.map(val => {\n            return val.clone({\n              parent: clone\n            }, options);\n          });\n        } else {\n          clonedProperty = propertyValue.clone({\n            parent: clone\n          }, options);\n        }\n      } else if (Array.isArray(propertyValue)) {\n        clonedProperty = propertyValue.map(val => {\n          return val;\n        });\n      } else {\n        clonedProperty = propertyValue;\n      }\n      clone[property] = clonedProperty;\n    });\n  }\n\n  /**\n   * Delegates every property change event from the original widget to this cloned widget by calling the appropriate setter.\n   * If no target is set it works only if this widget is a clone.\n   * @param {object} [options]\n   */\n  mirror(options, target) {\n    target = target || this.cloneOf;\n    if (!target) {\n      throw new Error('No target for mirroring.');\n    }\n    this._mirror(target, options);\n  }\n  _mirror(clone, options) {\n    let eventDelegator = arrays.find(this.eventDelegators, eventDelegator => {\n      return eventDelegator.clone === clone;\n    });\n    if (eventDelegator) {\n      throw new Error('_mirror can only be called on not mirrored widgets. call unmirror first.');\n    }\n    options = options || {};\n    eventDelegator = {\n      clone: clone,\n      originalToClone: EventDelegator.create(this, clone, {\n        delegateProperties: options.delegatePropertiesToClone,\n        delegateAllProperties: options.delegateAllPropertiesToClone\n      }),\n      cloneToOriginal: EventDelegator.create(clone, this, {\n        delegateProperties: options.delegatePropertiesToOriginal,\n        delegateAllProperties: options.delegateAllPropertiesToOriginal,\n        excludeProperties: options.excludePropertiesToOriginal,\n        delegateEvents: options.delegateEventsToOriginal\n      })\n    };\n    this.eventDelegators.push(eventDelegator);\n    clone.one('destroy', () => {\n      this._unmirror(clone);\n    });\n  }\n  unmirror(target) {\n    target = target || this.cloneOf;\n    if (!target) {\n      throw new Error('No target for unmirroring.');\n    }\n    this._unmirror(target);\n  }\n  _unmirror(target) {\n    let eventDelegatorIndex = arrays.findIndex(this.eventDelegators, eventDelegator => {\n        return eventDelegator.clone === target;\n      }),\n      eventDelegator = eventDelegatorIndex > -1 ? this.eventDelegators.splice(eventDelegatorIndex, 1)[0] : null;\n    if (!eventDelegator) {\n      return;\n    }\n    if (eventDelegator.originalToClone) {\n      eventDelegator.originalToClone.destroy();\n    }\n    if (eventDelegator.cloneToOriginal) {\n      eventDelegator.cloneToOriginal.destroy();\n    }\n  }\n  _onParentDestroy(event) {\n    if (this.destroyed) {\n      return;\n    }\n    // If the parent is destroyed but the widget not make sure it gets a new parent\n    // This ensures the old one may be properly garbage collected\n    this.setParent(this.owner);\n  }\n  callSetter(propertyName, value) {\n    let setterFuncName = 'set' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[setterFuncName]) {\n      this[setterFuncName](value);\n    } else {\n      this.setProperty(propertyName, value);\n    }\n  }\n\n  /**\n   * Traverses the object-tree (children) of this widget and searches for a widget with the given ID.\n   * Returns the widget with the requested ID or null if no widget has been found.\n   *\n   * @param {string} widgetId\n   * @returns {AnyWidget} the found widget for the given id\n   */\n  widget(widgetId) {\n    if (predicate(this)) {\n      return this;\n    }\n    return this.findChild(predicate);\n    function predicate(widget) {\n      if (widget.id === widgetId) {\n        return widget;\n      }\n    }\n  }\n\n  /**\n   * Similar to widget(), but uses \"breadth-first\" strategy, i.e. it checks all children of the\n   * same depth (level) before it advances to the next level. If multiple widgets with the same\n   * ID exist, the one with the smallest distance to this widget is returned.\n   *\n   * Example:\n   *\n   *    Widget ['MyWidget']                     #1\n   *    +- GroupBox ['LeftBox']                 #2\n   *       +- StringField ['NameField']         #3\n   *       +- StringField ['CityField']         #4\n   *       +- GroupBox ['InnerBox']             #5\n   *          +- GroupBox ['LeftBox']           #6\n   *             +- DateField ['StartDate']     #7\n   *          +- GroupBox ['RightBox']          #8\n   *             +- DateField ['EndDate']       #9\n   *    +- GroupBox ['RightBox']                #10\n   *       +- StringField ['NameField']         #11\n   *       +- DateField ['StartDate']           #12\n   *\n   *   CALL:                                    RESULT:\n   *   ---------------------------------------------------------------------------------------------\n   *   this.widget('RightBox')                  #8               (might not be the expected result)\n   *   this.nearestWidget('RightBox')           #10\n   *\n   *   this.widget('NameField')                 #3\n   *   this.nearestWidget('NameField')          null             (because no direct child has the requested id)\n   *   this.nearestWidget('NameField', true)    #3               (because #3 and #11 have the same distance)\n   *\n   *   this.widget('StartDate')                 #7\n   *   this.nearestWidget('StartDate', true)    #12              (#12 has smaller distance than #7)\n   *\n   * @param {string} widgetId\n   *          The ID of the widget to find.\n   * @param {boolean} [deep=false]\n   *          If false, only this widget and the next level are checked. This is the default.\n   *          If true, the entire tree is traversed.\n   * @return {Widget} the first found widget, or null if no widget was found.\n   */\n  nearestWidget(widgetId, deep) {\n    if (this.id === widgetId) {\n      return this;\n    }\n    let widgets = this.children.slice(); // list of widgets to check\n    while (widgets.length) {\n      let widget = widgets.shift();\n      if (widget.id === widgetId) {\n        return widget; // found\n      }\n\n      if (deep) {\n        for (let i = 0; i < widget.children.length; i++) {\n          let child = widget.children[i];\n          if (child.parent === widget) {\n            // same check as in visitChildren()\n            widgets.push(child);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @returns {AnyWidget} the first parent for which the given function returns true.\n   */\n  findParent(predicate) {\n    let parent = this.parent;\n    while (parent) {\n      if (predicate(parent)) {\n        return parent;\n      }\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @returns {AnyWidget} the first child for which the given function returns true.\n   */\n  findChild(predicate) {\n    let foundChild = null;\n    this.visitChildren(child => {\n      if (predicate(child)) {\n        foundChild = child;\n        return true;\n      }\n    });\n    return foundChild;\n  }\n  setTrackFocus(trackFocus) {\n    this.setProperty('trackFocus', trackFocus);\n  }\n  _renderTrackFocus() {\n    if (!this.$container) {\n      return;\n    }\n    if (this.trackFocus) {\n      this.$container.on('focusin', this._focusInListener);\n    } else {\n      this.$container.off('focusin', this._focusInListener);\n    }\n  }\n  restoreFocus() {\n    if (this._$lastFocusedElement) {\n      this.session.focusManager.requestFocus(this._$lastFocusedElement);\n    } else if (this._storedFocusedWidget) {\n      this._storedFocusedWidget.focus();\n      this._storedFocusedWidget = null;\n    }\n  }\n\n  /**\n   * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusIn(event) {\n    // do not track focus events during rendering to avoid initial focus to be restored.\n    if (this.rendering) {\n      return;\n    }\n    let $target = $(event.target);\n    if (this.$container.has($target)) {\n      this._$lastFocusedElement = $target;\n    }\n  }\n\n  /**\n   * Tries to set the focus on the widget.\n   * <p>\n   * By default the focus is set on the container but this may vary from widget to widget.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   * @returns {boolean} true if the element could be focused, false if not\n   */\n  focus(options) {\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.focus.bind(this, options));\n      return false;\n    }\n    return this.session.focusManager.requestFocus(this.getFocusableElement(), null, options);\n  }\n\n  /**\n   * Calls {@link focus()} and prevents the default behavior of the event if the focusing was successful.\n   */\n  focusAndPreventDefault(event) {\n    if (this.focus()) {\n      // Preventing blur is bad for touch devices because it prevents that the keyboard can close.\n      // In that case focus() will return false because focus manager is disabled.\n      event.preventDefault();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether the widget is the currently active element\n   */\n  isFocused() {\n    return this.rendered && focusUtils.isActiveElement(this.getFocusableElement());\n  }\n\n  /**\n   * @param {boolean} [checkTabbable=true] if true, the widget has to be tabbable, not only focusable.\n   * @return {boolean} true if the element is focusable (and tabbable, unless checkTabbable is set to false), false if not.\n   */\n  isFocusable(checkTabbable) {\n    if (!this.rendered || !this.visible) {\n      return false;\n    }\n    let elem = this.getFocusableElement();\n    if (!elem) {\n      return false;\n    }\n    let $elem = $.ensure(elem);\n    if (!$elem.is(':focusable')) {\n      return false;\n    }\n    if (scout.nvl(checkTabbable, true)) {\n      return $elem.is(':tabbable');\n    }\n    return true;\n  }\n\n  /**\n   * This method returns the HtmlElement to be used when {@link #focus()} is called.\n   * It can be overridden, in case the widget needs to return something other than this.$container[0].\n   */\n  getFocusableElement() {\n    if (this.rendered && this.$container) {\n      return this.$container[0];\n    }\n    return null;\n  }\n\n  /**\n   * @param {object} [options]\n   */\n  _installScrollbars(options) {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      throw new Error('Scrollable is not defined, cannot install scrollbars');\n    }\n    if ($scrollable.data('scrollable')) {\n      // already installed\n      return;\n    }\n    options = options || {};\n    let defaults = {\n      parent: this\n    };\n    options = $.extend({}, defaults, options);\n    scrollbars.install($scrollable, options);\n    $scrollable.on('scroll', this._scrollHandler);\n  }\n  _uninstallScrollbars() {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable || !$scrollable.data('scrollable')) {\n      return;\n    }\n    scrollbars.uninstall($scrollable, this.session);\n    $scrollable.off('scroll', this._scrollHandler);\n    if (!this.removing) {\n      // If scrollbars are removed on the fly and not because the widget is removing, reset scroll positions to initial state\n      // Only reset if position is 0 to preserve the position (uninstalling does not reset the position of the scrollable either)\n      if ($scrollable[0].scrollTop === 0) {\n        this.scrollTop = null;\n      }\n      if ($scrollable[0].scrollLeft === 0) {\n        this.scrollLeft = null;\n      }\n    }\n  }\n  _onScroll() {\n    let $scrollable = this.get$Scrollable();\n    this._setProperty('scrollTop', $scrollable[0].scrollTop);\n    this._setProperty('scrollLeft', $scrollable[0].scrollLeft);\n  }\n  setScrollTop(scrollTop) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().setScrollTop(scrollTop);\n      return;\n    }\n    this.setProperty('scrollTop', scrollTop);\n  }\n  _renderScrollTop() {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable || this.scrollTop === null) {\n      // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollTop must not be done while rendering because it would provoke a reflow\n      return;\n    }\n    if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n      // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n      // If scroll top is set while layouting, layout obviously wants to set it -> do it\n      this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollTop.bind(this));\n      return;\n    }\n    scrollbars.scrollTop($scrollable, this.scrollTop);\n  }\n  setScrollLeft(scrollLeft) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().setScrollLeft(scrollLeft);\n      return;\n    }\n    this.setProperty('scrollLeft', scrollLeft);\n  }\n  _renderScrollLeft() {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable || this.scrollLeft === null) {\n      // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollLeft must not be done while rendering because it would provoke a reflow\n      return;\n    }\n    if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n      // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n      // If scroll left is set while layouting, layout obviously wants to set it -> do it\n      this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollLeft.bind(this));\n      return;\n    }\n    scrollbars.scrollLeft($scrollable, this.scrollLeft);\n  }\n\n  /**\n   * Returns the jQuery element which is supposed to be scrollable. This element will be used by the scroll functions like {@link #_installScrollbars}, {@link #setScrollTop}, {@link #setScrollLeft}, {@link #scrollToBottom} etc..\n   * The element won't be used unless {@link #_installScrollbars} is called.\n   * If the widget is mainly a wrapper for a scrollable widget and does not have a scrollable element by itself, you can use @{link #getDelegateScrollable} instead.\n   * @return {$}\n   */\n  get$Scrollable() {\n    return this.$container;\n  }\n  hasScrollShadow(position) {\n    return scrollbars.hasScrollShadow(this.get$Scrollable(), position);\n  }\n\n  /**\n   * If the widget is mainly a wrapper for another widget, it is often the case that the other widget is scrollable and not the wrapper.\n   * In that case implement this method and return the other widget so that the calls to the scroll functions can be delegated.\n   * @return {Widget}\n   */\n  getDelegateScrollable() {\n    return null;\n  }\n  scrollToTop(options) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().scrollToTop();\n      return;\n    }\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      return;\n    }\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.scrollToTop.bind(this));\n      return;\n    }\n    scrollbars.scrollTop($scrollable, 0, options);\n  }\n  scrollToBottom(options) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().scrollToBottom();\n      return;\n    }\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      return;\n    }\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.scrollToBottom.bind(this));\n      return;\n    }\n    scrollbars.scrollToBottom($scrollable, options);\n  }\n\n  /**\n   * Brings the widget into view by scrolling the first scrollable parent.\n   */\n  reveal(options) {\n    if (!this.rendered) {\n      return;\n    }\n    let $scrollParent = this.$container.scrollParent();\n    if ($scrollParent.length === 0) {\n      // No scrollable parent found -> scrolling is not possible\n      return;\n    }\n    scrollbars.scrollTo($scrollParent, this.$container, options);\n  }\n\n  /**\n   * Visits every child of this widget in pre-order (top-down).<br>\n   * This widget itself is not visited! Only child widgets are visited recursively.\n   * <p>\n   * The children with a different parent are excluded.<br>\n   * This makes sure the child is not visited twice if the owner and the parent are not the same\n   * (in that case the widget would be in the children list of the owner and of the parent).\n   * <p>\n   * In order to abort visiting, the visitor can return true.\n   *\n   * @param {function(AnyWidget):boolean|TreeVisitResult|null} visitor\n   * @returns {boolean} true if the visitor aborted the visiting, false if the visiting completed without aborting\n   */\n  visitChildren(visitor) {\n    for (let i = 0; i < this.children.length; i++) {\n      let child = this.children[i];\n      if (child.parent === this) {\n        let treeVisitResult = visitor(child);\n        if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n          // Visitor wants to abort the visiting\n          return TreeVisitResult.TERMINATE;\n        } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n          treeVisitResult = child.visitChildren(visitor);\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            return TreeVisitResult.TERMINATE;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {boolean} Whether or not the widget is rendered (or rendering) and the DOM $container isAttached()\n   */\n  isAttachedAndRendered() {\n    return (this.rendered || this.rendering) && this.$container.isAttached();\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  static cssClassAsArray(cssClass) {\n    let cssClasses = [],\n      cssClassesStr = cssClass || '';\n    cssClassesStr = cssClassesStr.trim();\n    if (cssClassesStr.length > 0) {\n      cssClasses = cssClassesStr.split(' ');\n    }\n    return cssClasses;\n  }\n}\n_defineProperty(Widget, \"DisabledStyle\", {\n  DEFAULT: 0,\n  READ_ONLY: 1\n});","map":{"version":3,"names":["arrays","DeferredGlassPaneTarget","Desktop","Device","Event","EventDelegator","EventSupport","filters","focusUtils","Form","graphics","icons","inspector","objects","scout","scrollbars","strings","texts","TreeVisitResult","$","Widget","constructor","id","objectType","session","owner","parent","children","initialized","cloneOf","rendering","removing","removalPending","_rendered","attached","destroyed","destroying","enabled","enabledComputed","inheritAccessibility","disabledStyle","DisabledStyle","DEFAULT","visible","focused","loading","cssClass","scrollTop","scrollLeft","$parent","$container","htmlComp","animateRemoval","animateRemovalClass","_widgetProperties","_cloneProperties","eventDelegators","_preserveOnPropertyChangeProperties","_postRenderActions","_focusInListener","_onFocusIn","bind","_parentDestroyHandler","_onParentDestroy","_parentRemovingWhileAnimatingHandler","_onParentRemovingWhileAnimating","_scrollHandler","_onScroll","events","_createEventSupport","registerSubTypePredicate","event","propertyName","loadingSupport","_createLoadingSupport","keyStrokeContext","_createKeyStrokeContext","logicalGrid","trackFocus","_$lastFocusedElement","_storedFocusedWidget","_glassPaneContributions","init","model","staticModel","_jsonModel","extend","_prepareModel","_init","_initKeyStrokeContext","recomputeEnabled","trigger","Error","setOwner","setParent","_eachProperty","value","isWidgetProperty","undefined","_prepareWidgetProperty","_initProperty","_setCssClass","_setLogicalGrid","_setEnabled","_createChildren","models","Array","isArray","_createChild","widgets","forEach","i","existingWidget","widget","create","$scopeTarget","$bindTarget","destroy","_isRemovalPrevented","one","remove","_destroyChildren","slice","reverse","_destroy","_removeChild","off","ensure","_destroyChild","child","render","log","isTraceEnabled","trace","_render","_renderProperties","_renderInspectorInfo","_linkWithDOM","keyStrokeManager","installKeyStrokeContext","rendered","restoreFocus","_postRender","isRemovalPending","_renderCssClass","_renderEnabled","_renderVisible","_renderTrackFocus","_renderFocused","_renderLoading","_renderScrollTop","_renderScrollLeft","actions","action","_removeAnimated","_removeInternal","removeImmediately","_isRemovalPending","_cleanup","_remove","animateRemovalWhileRemovingParent","_animateRemovalWhileRemovingParent","get","supportsCssAnimation","isDisplayNone","desktop","removePopupsFor","setTimeout","isVisible","isEveryParentVisible","isAttached","addClass","oneAnimationEnd","applyInfo","data","uninstallKeyStrokeContext","_uninstallScrollbars","layoutValidator","cleanupInvalidComponents","assertParameter","_addChild","isInfoEnabled","info","oldParent","pushSet","ancestors","push","isOrHas","has","getForm","findForm","findNonWrappedForm","findDesktop","findParent","setEnabled","updateParents","updateChildren","setProperty","visitChildren","field","_setProperty","parentEnabled","_computeEnabled","_updateEnabledComputed","enabledComputedForChildren","computedStateForChildren","nvl","_childrenForEnabledComputed","_renderDisabledStyle","setInheritAccessibility","_setInheritAccessibility","setDisabledStyle","_renderDisabledStyleInternal","$element","removeClass","toggleClass","READ_ONLY","setVisible","invalidateParentLogicalGrid","setFocused","_removeCssClass","invalidateLayoutTree","setCssClass","addCssClass","cssClasses","cssClassAsArray","cssClassesToAdd","newCssClass","indexOf","format","removeCssClass","cssClassesToRemove","removeAll","toggleCssClass","condition","setLoading","isLoading","renderLoading","pack","invalidateLayout","validateLayout","revalidateLayout","invalidateParents","validateLayoutTree","revalidateLayoutTree","setLayoutData","layoutData","validateLogicalGrid","validate","invalidateLogicalGrid","setDirty","htmlCompParent","getParent","revalidateLogicalGrid","setLogicalGrid","type","source","handler","on","addListener","listener","removeListener","when","entryPoint","length","window","domElement","$el","document","attach","_attach","_installFocusContext","_postAttach","_onAttach","_triggerChildrenOnAttach","_renderOnAttach","detach","_beforeDetach","_onDetach","_triggerChildrenOnDetach","_detach","activeElement","isFocused","focusManager","isFocusContextInstalled","_uninstallFocusContext","validateFocus","outsideFilter","_renderOnDetach","updateKeyStrokes","newKeyStrokes","oldKeyStrokes","unregisterKeyStrokes","registerKeyStrokes","keyStrokes","triggerPropertyChange","oldValue","newValue","equals","defaultPrevented","_prepareProperty","_callRemoveProperty","_callSetProperty","_callRenderProperty","oldWidgets","diff","isPreserveOnPropertyChangeProperty","link","removeFuncName","toUpperCaseFirstLetter","_internalRemoveWidgets","setFuncName","renderFuncName","glassPaneTargets","element","resolveGlassPanes","targets","flatMap","cont","$elements","concat","_glassPaneTargets","createFor","getPopupsFor","filter","popup","reduce","acc","addGlassPaneContribution","contribution","removeGlassPaneContribution","toString","attrs","debugOutput","trim","ancestorsToString","count","str","some","ancestor","resolveTextKeys","properties","property","resolveTextProperty","resolveIconIds","resolveIconProperty","resolveConsts","configs","config","resolveConstProperty","_addWidgetProperties","_addProperties","_addCloneProperties","isCloneProperty","_addPreserveOnPropertyChangeProperties","func","_removeWidgetProperties","cloneAndMirror","clone","delegateAllPropertiesToClone","original","options","cloneModel","extractProperties","_mirror","_deepCloneProperties","propertyValue","clonedProperty","map","val","mirror","target","eventDelegator","find","originalToClone","delegateProperties","delegatePropertiesToClone","delegateAllProperties","cloneToOriginal","delegatePropertiesToOriginal","delegateAllPropertiesToOriginal","excludeProperties","excludePropertiesToOriginal","delegateEvents","delegateEventsToOriginal","_unmirror","unmirror","eventDelegatorIndex","findIndex","splice","callSetter","setterFuncName","widgetId","predicate","findChild","nearestWidget","deep","shift","foundChild","setTrackFocus","requestFocus","focus","$target","schedulePostValidateFunction","getFocusableElement","focusAndPreventDefault","preventDefault","isActiveElement","isFocusable","checkTabbable","elem","$elem","is","_installScrollbars","$scrollable","get$Scrollable","defaults","install","uninstall","setScrollTop","getDelegateScrollable","layouted","layouting","setScrollLeft","hasScrollShadow","position","scrollToTop","scrollToBottom","reveal","$scrollParent","scrollParent","scrollTo","visitor","treeVisitResult","TERMINATE","SKIP_SUBTREE","isAttachedAndRendered","cssClassesStr","split"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/widget/Widget.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, DeferredGlassPaneTarget, Desktop, Device, Event, EventDelegator, EventSupport, filters, focusUtils, Form, graphics, icons, inspector, objects, scout, scrollbars, strings, texts, TreeVisitResult} from '../index';\nimport $ from 'jquery';\n\nexport default class Widget {\n  constructor() {\n    this.id = null;\n    this.objectType = null;\n    this.session = null;\n\n    /**\n     * The owner is responsible that its children are destroyed when the owner is being destroyed.\n     */\n    this.owner = null;\n    /**\n     * The parent is typically the same as the owner.\n     * But the widget may be used by another widget (like a popup), in that case the parent will be changed to the popup but the owner stays the same.\n     * This means the popup is now the temporary parent, when the popup is destroyed its widgets are not because the popup is not the owner.\n     * Example: ViewMenuPopup uses the ViewButtons as menu items. These view buttons are owned by the desktop and must therefore not be destroyed\n     * when the popup closes, otherwise they could not be reused the second time the popup opens.\n     */\n    this.parent = null;\n    this.children = [];\n    this.initialized = false;\n\n    /**\n     * Will be set on the clone after a widget has been cloned.\n     * @type {Widget}\n     */\n    this.cloneOf = null;\n\n    /**\n     * The 'rendering' flag is set the true while the _initial_ rendering is performed.\n     * It is used to to something different in a _render* method when the method is\n     * called for the first time.\n     */\n    this.rendering = false;\n    this.removing = false;\n    this.removalPending = false;\n\n    /**\n     * The 'rendered' flag is set the true when initial rendering of the widget is completed.\n     */\n    this._rendered = false;\n    this.attached = false;\n    this.destroyed = false;\n    this.destroying = false;\n\n    this.enabled = true;\n    /**\n     * The computed enabled state. The difference to the 'enabled' property is that this member\n     * also considers the enabled-states of the parent widgets.\n     */\n    this.enabledComputed = true;\n    this.inheritAccessibility = true;\n    this.disabledStyle = Widget.DisabledStyle.DEFAULT;\n    this.visible = true;\n    this.focused = false;\n    this.loading = false;\n    this.cssClass = null;\n    this.scrollTop = null;\n    this.scrollLeft = null;\n\n    /** @type {$} */\n    this.$parent = null;\n    /** @type {$} */\n    this.$container = null;\n\n    /**\n     * Widgets creating a HtmlComponent for the main $container should assign it to this variable.\n     * This enables the execution of layout related operations like invalidateLayoutTree directly on the widget.\n     * @type {HtmlComponent}\n     */\n    this.htmlComp = null;\n\n    /**\n     * If set to true, remove won't remove the element immediately but after the animation has been finished\n     * This expects a css animation which may be triggered by the class 'animate-remove'\n     * If browser does not support css animation, remove will be executed immediately\n     */\n    this.animateRemoval = false;\n    this.animateRemovalClass = 'animate-remove';\n\n    this._widgetProperties = [];\n    this._cloneProperties = ['visible', 'enabled', 'inheritAccessibility', 'cssClass'];\n    this.eventDelegators = [];\n    this._preserveOnPropertyChangeProperties = [];\n    this._postRenderActions = [];\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._parentDestroyHandler = this._onParentDestroy.bind(this);\n    this._parentRemovingWhileAnimatingHandler = this._onParentRemovingWhileAnimating.bind(this);\n    this._scrollHandler = this._onScroll.bind(this);\n    this.events = this._createEventSupport();\n    this.events.registerSubTypePredicate('propertyChange', (event, propertyName) => {\n      return event.propertyName === propertyName;\n    });\n    this.loadingSupport = this._createLoadingSupport();\n    this.keyStrokeContext = this._createKeyStrokeContext();\n    // Widgets using LogicalGridLayout may have a grid to calculate the grid data of the children\n    this.logicalGrid = null;\n\n    // focus tracking\n    this.trackFocus = false;\n    this._$lastFocusedElement = null;\n    this._storedFocusedWidget = null;\n\n    this._glassPaneContributions = [];\n  }\n\n  /**\n   * Enum used to define different styles used when the field is disabled.\n   */\n  static DisabledStyle = {\n    DEFAULT: 0,\n    READ_ONLY: 1\n  };\n\n  /**\n   * Initializes the widget instance. All properties of the model parameter (object) are set as properties on the widget instance.\n   * Calls {@link Widget#_init} and triggers an <em>init</em> event when initialization has been completed.\n   *\n   * @param {object} model\n   */\n  init(model) {\n    let staticModel = this._jsonModel();\n    if (staticModel) {\n      model = $.extend({}, staticModel, model);\n    }\n    model = model || {};\n    model = this._prepareModel(model);\n    this._init(model);\n    this._initKeyStrokeContext();\n    this.recomputeEnabled();\n    this.initialized = true;\n    this.trigger('init');\n  }\n\n  /**\n   * Default implementation simply returns the unmodified model. A Subclass\n   * may override this method to alter the JSON model before the widgets\n   * are created out of the widgetProperties in the model.\n   */\n  _prepareModel(model) {\n    return model;\n  }\n\n  /**\n   * Initializes the widget instance. All properties of the model parameter (object) are set as properties on the widget instance.\n   * Override this function to initialize widget specific properties in sub-classes.\n   *\n   * @param {object} model Properties:<ul>\n   *   <li>parent (required): parent widget</li>\n   *   <li>session (optional): If not specified, session of parent widget is used</li></ul>\n   */\n  _init(model) {\n    if (!model.parent) {\n      throw new Error('Parent expected: ' + this);\n    }\n    this.setOwner(model.owner || model.parent);\n    this.setParent(model.parent);\n\n    this.session = model.session || this.parent.session;\n    if (!this.session) {\n      throw new Error('Session expected: ' + this);\n    }\n\n    this._eachProperty(model, (propertyName, value, isWidgetProperty) => {\n      if (value === undefined) {\n        // Don't set the value if it is undefined, compared to null which is allowed explicitly ($.extend works in the same way)\n        return;\n      }\n      if (isWidgetProperty) {\n        value = this._prepareWidgetProperty(propertyName, value);\n      }\n      this._initProperty(propertyName, value);\n    });\n\n    this._setCssClass(this.cssClass);\n    this._setLogicalGrid(this.logicalGrid);\n    this._setEnabled(this.enabled);\n  }\n\n  /**\n   * This function sets the property value. Override this function when you need special init behavior for certain properties.\n   * For instance you could not simply set the property value, but extend an already existing value.\n   */\n  _initProperty(propertyName, value) {\n    this[propertyName] = value;\n  }\n\n  /**\n   * Default implementation simply returns undefined. A Subclass\n   * may override this method to load or extend a JSON model with models.getModel or models.extend.\n   */\n  _jsonModel() {\n  }\n\n  /**\n   * Creates the widgets using the given models, or returns the widgets if the given models already are widgets.\n   * @returns {Widget[]|Widget} an array of created widgets if models was an array. Or the created widget if models is not an array.\n   */\n  _createChildren(models) {\n    if (!models) {\n      return null;\n    }\n\n    if (!Array.isArray(models)) {\n      return this._createChild(models);\n    }\n\n    let widgets = [];\n    models.forEach(function(model, i) {\n      widgets[i] = this._createChild(model);\n    }, this);\n    return widgets;\n  }\n\n  /**\n   * Calls {@link scout.create} for the given model, or if model is already a Widget simply returns the widget.\n   *\n   * @param model {Object|Widget}\n   * @returns {AnyWidget}\n   */\n  _createChild(model) {\n    if (model instanceof Widget) {\n      return model;\n    }\n    if (typeof model === 'string') {\n      // Special case: If only an ID is supplied, try to (locally) resolve the corresponding widget\n      let existingWidget = this.widget(model);\n      if (!existingWidget) {\n        throw new Error('Referenced widget not found: ' + model);\n      }\n      return existingWidget;\n    }\n    model.parent = this;\n    return scout.create(model);\n  }\n\n  _initKeyStrokeContext() {\n    if (!this.keyStrokeContext) {\n      return;\n    }\n    this.keyStrokeContext.$scopeTarget = () => this.$container;\n    this.keyStrokeContext.$bindTarget = () => this.$container;\n  }\n\n  destroy() {\n    if (this.destroyed) {\n      // Already destroyed, do nothing\n      return;\n    }\n    this.destroying = true;\n    if (this._rendered && (this.animateRemoval || this._isRemovalPrevented())) {\n      // Do not destroy yet if the removal happens animated\n      // Also don't destroy if the removal is pending to keep the parent / child link until removal finishes\n      this.one('remove', () => {\n        this.destroy();\n      });\n      this.remove();\n      return;\n    }\n\n    // Destroy children in reverse order\n    this._destroyChildren(this.children.slice().reverse());\n    this.remove();\n    this._destroy();\n\n    // Disconnect from owner and parent\n    this.owner._removeChild(this);\n    this.owner = null;\n    this.parent._removeChild(this);\n    this.parent.off('destroy', this._parentDestroyHandler);\n    this.parent = null;\n\n    this.destroying = false;\n    this.destroyed = true;\n    this.trigger('destroy');\n  }\n\n  /**\n   * Override this function to do clean-up (like removing listeners) when the widget is destroyed.\n   * The default impl. does nothing.\n   */\n  _destroy() {\n    // NOP\n  }\n\n  /**\n   * @param {Widget[]|Widget} widgets may be an object or array of objects\n   */\n  _destroyChildren(widgets) {\n    if (!widgets) {\n      return;\n    }\n\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function(widget, i) {\n      this._destroyChild(widget);\n    }, this);\n  }\n\n  _destroyChild(child) {\n    if (child.owner !== this) {\n      return;\n    }\n    child.destroy();\n  }\n\n  /**\n   * @param [$parent] The jQuery element which is used as {@link Widget.$parent} when rendering this widget.\n   * It will be put onto the widget and is therefore accessible as this.$parent in the {@link _render} method.\n   * If not specified, the {@link Widget.$container} of the parent is used.\n   */\n  render($parent) {\n    $.log.isTraceEnabled() && $.log.trace('Rendering widget: ' + this);\n    if (!this.initialized) {\n      throw new Error('Not initialized: ' + this);\n    }\n    if (this._rendered) {\n      throw new Error('Already rendered: ' + this);\n    }\n    if (this.destroyed) {\n      throw new Error('Widget is destroyed: ' + this);\n    }\n    this.rendering = true;\n    this.$parent = $parent || this.parent.$container;\n    this._render();\n    this._renderProperties();\n    this._renderInspectorInfo();\n    this._linkWithDOM();\n    this.session.keyStrokeManager.installKeyStrokeContext(this.keyStrokeContext);\n    this.rendering = false;\n    this.rendered = true;\n    this.attached = true;\n    this.trigger('render');\n    this.restoreFocus();\n    this._postRender();\n  }\n\n  /**\n   * Creates the UI by creating html elements and appending them to the DOM.\n   * <p>\n   * A typical widget creates exactly one container element and stores it to {@link Widget.$container}.\n   * If it needs JS based layouting, it creates a {@link HtmlComponent} for that container and stores it to {@link Widget.htmlComp}.\n   * <p>\n   * The rendering of individual properties should be done in the corresponding render methods of the properties, called by {@link _renderProperties} instead of doing it here.\n   * This has the advantage that the render methods can also be called on property changes, allowing individual widget parts to be dynamically re-rendered.\n   * <p>\n   * The default implementation does nothing.\n   */\n  _render() {\n    // NOP\n  }\n\n  /**\n   * Returns whether it is allowed to render something on the widget.\n   * Rendering is only possible if the widget itself is rendered and not about to be removed.\n   * <p>\n   * While the removal is pending, no rendering must happen to get a smooth remove animation.\n   * It also prevents errors on property changes because {@link remove} won't be executed as well.\n   * Preventing removal but allowing rendering could result in already rendered exceptions.\n   *\n   * @return {boolean} true if the widget is rendered and not being removed by an animation\n   *\n   * @see isRemovalPending\n   */\n  get rendered() {\n    return this._rendered && !this.isRemovalPending();\n  }\n\n  set rendered(rendered) {\n    this._rendered = rendered;\n  }\n\n  /**\n   * Calls the render methods for each property that needs to be rendered during the rendering process initiated by {@link render}.\n   * Each widget has to override this method and call the render methods for its own properties, after doing the super call.\n   * <p>\n   * This method is called right after {@link _render} has been executed.\n   */\n  _renderProperties() {\n    this._renderCssClass();\n    this._renderEnabled();\n    this._renderVisible();\n    this._renderTrackFocus();\n    this._renderFocused();\n    this._renderLoading();\n    this._renderScrollTop();\n    this._renderScrollLeft();\n  }\n\n  /**\n   * Method invoked once rendering completed and 'rendered' flag is set to 'true'.<p>\n   * By default executes every action of this._postRenderActions\n   */\n  _postRender() {\n    let actions = this._postRenderActions;\n    this._postRenderActions = [];\n    actions.forEach(action => {\n      action();\n    });\n  }\n\n  /**\n   * Removes the widget and all its children from the DOM.\n   * <p>\n   * It traverses down the widget hierarchy and calls {@link _remove} for each widget from the bottom up (depth first search).\n   * <p>\n   * If the property {@link Widget.animateRemoval} is set to true, the widget won't be removed immediately.\n   * Instead it waits for the remove animation to complete so it's content is still visible while the animation runs.\n   * During that time, {@link isRemovalPending} returns true.\n   */\n  remove() {\n    if (!this._rendered || this._isRemovalPrevented()) {\n      return;\n    }\n    if (this.animateRemoval) {\n      this._removeAnimated();\n    } else {\n      this._removeInternal();\n    }\n  }\n\n  /**\n   * Removes the element without starting the remove animation or waiting for the remove animation to complete.\n   * If the remove animation is running it will stop immediately because the element is removed. There will no animationend event be triggered.\n   *<p>\n   * <b>Important</b>: You should only use this method if your widget uses remove animations (this.animateRemoval = true)\n   * and you deliberately want to not execute or abort it. Otherwise you should use the regular {@link remove} method.\n   */\n  removeImmediately() {\n    this._removeInternal();\n  }\n\n  /**\n   * Will be called by {@link #remove()}. If true is returned, the widget won't be removed.<p>\n   * By default it just delegates to {@link #isRemovalPending}. May be overridden to customize it.\n   */\n  _isRemovalPrevented() {\n    return this.isRemovalPending();\n  }\n\n  /**\n   * @deprecated use isRemovalPending instead. Will be removed with 23.0\n   */\n  _isRemovalPending() {\n    return this.isRemovalPending();\n  }\n\n  /**\n   * Returns true if the removal of this or an ancestor widget is pending. Checking the ancestor is omitted if the parent is being removed.\n   * This may be used to prevent a removal if an ancestor will be removed (e.g by an animation)\n   */\n  isRemovalPending() {\n    if (this.removalPending) {\n      return true;\n    }\n    let parent = this.parent;\n    if (!parent || parent.removing || parent.rendering) {\n      // If parent is being removed or rendered, no need to check the ancestors because removing / rendering is already in progress\n      return false;\n    }\n    while (parent) {\n      if (parent.removalPending) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  _removeInternal() {\n    if (!this._rendered) {\n      return;\n    }\n\n    $.log.isTraceEnabled() && $.log.trace('Removing widget: ' + this);\n    this.removing = true;\n    this.removalPending = false;\n    this.trigger('removing');\n    // transform last focused element into a scout widget\n    if (this.$container) {\n      this.$container.off('focusin', this._focusInListener);\n    }\n    if (this._$lastFocusedElement) {\n      this._storedFocusedWidget = scout.widget(this._$lastFocusedElement);\n      this._$lastFocusedElement = null;\n    }\n    // remove children in reverse order.\n    this.children.slice().reverse()\n      .forEach(function(child) {\n        // Only remove the child if this widget is the current parent (if that is not the case this widget is the owner)\n        if (child.parent === this) {\n          child.remove();\n        }\n      }, this);\n\n    if (!this._rendered) {\n      // The widget may have been removed already by one of the above remove() calls (e.g. by a remove listener)\n      // -> don't try to do it again, it might fail\n      return;\n    }\n    this._cleanup();\n    this._remove();\n    this.$parent = null;\n    this.rendered = false;\n    this.attached = false;\n    this.removing = false;\n    this.trigger('remove');\n  }\n\n  /**\n   * Adds class 'animate-remove' to container which can be used to trigger the animation.\n   * After the animation is executed, the element gets removed using this._removeInternal.\n   */\n  _removeAnimated() {\n    let animateRemovalWhileRemovingParent = this._animateRemovalWhileRemovingParent();\n    if ((this.parent.removing && !animateRemovalWhileRemovingParent) || !Device.get().supportsCssAnimation() || !this.$container || this.$container.isDisplayNone()) {\n      // Cannot remove animated, remove regularly\n      this._removeInternal();\n      return;\n    }\n\n    // Remove open popups first, they would be positioned wrongly during the animation\n    // Normally they would be closed automatically by a user interaction (click),\n    this.session.desktop.removePopupsFor(this);\n\n    this.removalPending = true;\n    // Don't execute immediately to make sure nothing interferes with the animation (e.g. layouting) which could make it laggy\n    setTimeout(() => {\n      // check if the container has been removed in the meantime\n      if (!this._rendered) {\n        return;\n      }\n      if (!this.animateRemovalClass) {\n        throw new Error('Missing animate removal class. Cannot remove animated.');\n      }\n      if (!this.$container.isVisible() || !this.$container.isEveryParentVisible() || !this.$container.isAttached()) {\n        // If element is not visible, animationEnd would never fire -> remove it immediately\n        this._removeInternal();\n        return;\n      }\n      this.$container.addClass(this.animateRemovalClass);\n      this.$container.oneAnimationEnd(() => {\n        this._removeInternal();\n      });\n    });\n\n    // If the parent is being removed while the animation is running, the animationEnd event will never fire\n    // -> Make sure remove is called nevertheless. Important: remove it before the parent is removed to maintain the regular remove order\n    if (!animateRemovalWhileRemovingParent) {\n      this.parent.one('removing', this._parentRemovingWhileAnimatingHandler);\n    }\n  }\n\n  _animateRemovalWhileRemovingParent() {\n    // By default, remove animation is prevented when parent is being removed\n    return false;\n  }\n\n  _onParentRemovingWhileAnimating() {\n    this._removeInternal();\n  }\n\n  _renderInspectorInfo() {\n    if (!this.session.inspector) {\n      return;\n    }\n    inspector.applyInfo(this);\n  }\n\n  /**\n   * Links $container with the widget.\n   */\n  _linkWithDOM() {\n    if (this.$container) {\n      this.$container.data('widget', this);\n    }\n  }\n\n  /**\n   * Called right before _remove is called.\n   * Default calls LayoutValidator.cleanupInvalidComponents to make sure that child components are removed from the invalid components list.\n   * Also uninstalls key stroke context, loading support and scrollbars.\n   */\n  _cleanup() {\n    this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n    this.session.keyStrokeManager.uninstallKeyStrokeContext(this.keyStrokeContext);\n    if (this.loadingSupport) {\n      this.loadingSupport.remove();\n    }\n    this._uninstallScrollbars();\n    if (this.$container) {\n      this.session.layoutValidator.cleanupInvalidComponents(this.$container);\n    }\n  }\n\n  _remove() {\n    if (this.$container) {\n      this.$container.remove();\n      this.$container = null;\n    }\n  }\n\n  setOwner(owner) {\n    scout.assertParameter('owner', owner);\n    if (owner === this.owner) {\n      return;\n    }\n\n    if (this.owner) {\n      // Remove from old owner\n      this.owner._removeChild(this);\n    }\n    this.owner = owner;\n    this.owner._addChild(this);\n  }\n\n  setParent(parent) {\n    scout.assertParameter('parent', parent);\n    if (parent === this.parent) {\n      return;\n    }\n    if (this.rendered && !parent.rendered) {\n      $.log.isInfoEnabled() && $.log.info('rendered child ' + this + ' is added to not rendered parent ' + parent + '. Removing child.', new Error('origin'));\n      this.remove();\n    }\n\n    if (this.parent) {\n      // Don't link to new parent yet if removal is still pending.\n      // After the animation the parent will remove its children.\n      // If they are already linked to a new parent, removing the children is not possible anymore.\n      // This may lead to an \"Already rendered\" exception if the new parent wants to render its children.\n      if (this.parent.isRemovalPending()) {\n        this.parent.one('remove', () => {\n          this.setParent(parent);\n        });\n        return;\n      }\n\n      this.parent.off('destroy', this._parentDestroyHandler);\n      this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n\n      if (this.parent !== this.owner) {\n        // Remove from old parent if getting relinked\n        // If the old parent is still the owner, don't remove it because owner stays responsible for destroying it\n        this.parent._removeChild(this);\n      }\n    }\n    let oldParent = this.parent;\n    this.parent = parent;\n    this.parent._addChild(this);\n    this.trigger('hierarchyChange', {\n      oldParent: oldParent,\n      parent: parent\n    });\n    if (this.initialized) {\n      this.recomputeEnabled(this.parent.enabledComputed);\n    }\n    this.parent.one('destroy', this._parentDestroyHandler);\n  }\n\n  _addChild(child) {\n    $.log.isTraceEnabled() && $.log.trace('addChild(' + child + ') to ' + this);\n    arrays.pushSet(this.children, child);\n  }\n\n  _removeChild(child) {\n    $.log.isTraceEnabled() && $.log.trace('removeChild(' + child + ') from ' + this);\n    arrays.remove(this.children, child);\n  }\n\n  /**\n   * @returns {Widget[]} a list of all ancestors\n   */\n  ancestors() {\n    let ancestors = [];\n    let parent = this.parent;\n    while (parent) {\n      ancestors.push(parent);\n      parent = parent.parent;\n    }\n    return ancestors;\n  }\n\n  /**\n   * @returns {boolean} true if the given widget is the same as this or a descendant\n   */\n  isOrHas(widget) {\n    if (widget === this) {\n      return true;\n    }\n    return this.has(widget);\n  }\n\n  /**\n   * @returns {boolean} true if the given widget is a descendant\n   */\n  has(widget) {\n    while (widget) {\n      if (widget.parent === this) {\n        return true;\n      }\n      widget = widget.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * @returns {Form} the form the widget belongs to (returns the first parent which is a {@link Form}.\n   */\n  getForm() {\n    return Form.findForm(this);\n  }\n\n  /**\n   * @returns {Form} the first form which is not an inner form of a wrapped form field\n   */\n  findNonWrappedForm() {\n    return Form.findNonWrappedForm(this);\n  }\n\n  /**\n   * @returns {Desktop} the desktop linked to the current session.\n   * If desktop is still initializing it might not be available yet, in that case it searches the parent hierarchy for it.\n   */\n  findDesktop() {\n    if (this.session.desktop) {\n      return this.session.desktop;\n    }\n    return this.findParent(parent => {\n      return parent instanceof Desktop;\n    });\n  }\n\n  /**\n   * Changes the enabled property of this form field to the given value.\n   *\n   * @param {boolean} enabled\n   *          Required. The new enabled value\n   * @param {boolean} [updateParents]\n   *          (optional) If true, the enabled property of all parent form fields are\n   *          updated to same value as well. Default is false.\n   * @param {boolean} [updateChildren]\n   *          (optional) If true the enabled property of all child form fields (recursive)\n   *          are updated to same value as well. Default is false.\n   */\n  setEnabled(enabled, updateParents, updateChildren) {\n    this.setProperty('enabled', enabled);\n\n    if (enabled && updateParents && this.parent) {\n      this.parent.setEnabled(true, true, false);\n    }\n\n    if (updateChildren) {\n      this.visitChildren(field => {\n        field.setEnabled(enabled);\n      });\n    }\n  }\n\n  _setEnabled(enabled) {\n    this._setProperty('enabled', enabled);\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  recomputeEnabled(parentEnabled) {\n    if (parentEnabled === undefined) {\n      parentEnabled = true;\n      if (this.parent && this.parent.initialized && this.parent.enabledComputed !== undefined) {\n        parentEnabled = this.parent.enabledComputed;\n      }\n    }\n\n    let enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n    this._updateEnabledComputed(enabledComputed);\n  }\n\n  _updateEnabledComputed(enabledComputed, enabledComputedForChildren) {\n    if (this.enabledComputed === enabledComputed && enabledComputedForChildren === undefined) {\n      // no change for this instance. there is no need to propagate to children\n      // exception: the enabledComputed for the children differs from the one for me. In this case the propagation is necessary.\n      return;\n    }\n\n    this.setProperty('enabledComputed', enabledComputed);\n\n    // Manually call _renderEnabled(), because _renderEnabledComputed() does not exist\n    if (this.rendered) {\n      this._renderEnabled();\n    }\n\n    let computedStateForChildren = scout.nvl(enabledComputedForChildren, enabledComputed);\n    this._childrenForEnabledComputed().forEach(child => {\n      if (child.inheritAccessibility) {\n        child.recomputeEnabled(computedStateForChildren);\n      }\n    });\n  }\n\n  _childrenForEnabledComputed() {\n    return this.children;\n  }\n\n  _computeEnabled(inheritAccessibility, parentEnabled) {\n    return this.enabled && (inheritAccessibility ? parentEnabled : true);\n  }\n\n  _renderEnabled() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.setEnabled(this.enabledComputed);\n    this._renderDisabledStyle();\n  }\n\n  setInheritAccessibility(inheritAccessibility) {\n    this.setProperty('inheritAccessibility', inheritAccessibility);\n  }\n\n  _setInheritAccessibility(inheritAccessibility) {\n    this._setProperty('inheritAccessibility', inheritAccessibility);\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  setDisabledStyle(disabledStyle) {\n    this.setProperty('disabledStyle', disabledStyle);\n\n    this.children.forEach(child => {\n      child.setDisabledStyle(disabledStyle);\n    });\n  }\n\n  _renderDisabledStyle() {\n    this._renderDisabledStyleInternal(this.$container);\n  }\n\n  /**\n   * This function is used by subclasses to render the read-only class for a given $field.\n   * Some fields like DateField have two input fields and thus cannot use the this.$field property.\n   */\n  _renderDisabledStyleInternal($element) {\n    if (!$element) {\n      return;\n    }\n    if (this.enabledComputed) {\n      $element.removeClass('read-only');\n    } else {\n      $element.toggleClass('read-only', this.disabledStyle === Widget.DisabledStyle.READ_ONLY);\n    }\n  }\n\n  /**\n   * @param {boolean} visible true, to make the widget visible, false to hide it\n   */\n  setVisible(visible) {\n    this.setProperty('visible', visible);\n  }\n\n  /**\n   * @returns {boolean} whether the widget is visible or not. May depend on other conditions than the visible property only\n   */\n  isVisible() {\n    return this.visible;\n  }\n\n  _renderVisible() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.setVisible(this.isVisible());\n    this.invalidateParentLogicalGrid();\n  }\n\n  /**\n   * @returns {boolean} true if every parent within the hierarchy is visible.\n   */\n  isEveryParentVisible() {\n    let parent = this.parent;\n    while (parent) {\n      if (!parent.isVisible()) {\n        return false;\n      }\n      parent = parent.parent;\n    }\n\n    return true;\n  }\n\n  /**\n   * This function does not set the focus to the field. It toggles the 'focused' class on the field container if present.\n   * Objects using widget as prototype must call this function onBlur and onFocus to ensure the class gets toggled.\n   *\n   *  Use Widget.focus to set the focus to the widget.\n   */\n  setFocused(focused) {\n    this.setProperty('focused', focused);\n  }\n\n  _renderFocused() {\n    if (this.$container) {\n      this.$container.toggleClass('focused', this.focused);\n    }\n  }\n\n  _setCssClass(cssClass) {\n    if (this.rendered) {\n      this._removeCssClass();\n    }\n    this._setProperty('cssClass', cssClass);\n  }\n\n  _removeCssClass() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.removeClass(this.cssClass);\n  }\n\n  _renderCssClass() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.addClass(this.cssClass);\n    if (this.htmlComp) {\n      // Replacing css classes may enlarge or shrink the widget (e.g. setting the font weight to bold makes the text bigger) -> invalidate layout\n      this.invalidateLayoutTree();\n    }\n  }\n\n  setCssClass(cssClass) {\n    this.setProperty('cssClass', cssClass);\n  }\n\n  addCssClass(cssClass) {\n    let cssClasses = this.cssClassAsArray();\n    let cssClassesToAdd = Widget.cssClassAsArray(cssClass);\n    cssClassesToAdd.forEach(newCssClass => {\n      if (cssClasses.indexOf(newCssClass) >= 0) {\n        return;\n      }\n      cssClasses.push(newCssClass);\n    }, this);\n    this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n  }\n\n  removeCssClass(cssClass) {\n    let cssClasses = this.cssClassAsArray();\n    let cssClassesToRemove = Widget.cssClassAsArray(cssClass);\n    if (arrays.removeAll(cssClasses, cssClassesToRemove)) {\n      this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n    }\n  }\n\n  toggleCssClass(cssClass, condition) {\n    if (condition) {\n      this.addCssClass(cssClass);\n    } else {\n      this.removeCssClass(cssClass);\n    }\n  }\n\n  cssClassAsArray() {\n    return Widget.cssClassAsArray(this.cssClass);\n  }\n\n  /**\n   * Creates nothing by default. If a widget needs loading support, override this method and return a loading support.\n   * @returns {LoadingSupport}\n   */\n  _createLoadingSupport() {\n    return null;\n  }\n\n  setLoading(loading) {\n    this.setProperty('loading', loading);\n  }\n\n  isLoading() {\n    return this.loading;\n  }\n\n  _renderLoading() {\n    if (!this.loadingSupport) {\n      return;\n    }\n    this.loadingSupport.renderLoading();\n  }\n\n  // --- Layouting / HtmlComponent methods ---\n\n  pack() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.pack();\n  }\n\n  invalidateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.invalidateLayout();\n  }\n\n  validateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.validateLayout();\n  }\n\n  revalidateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.revalidateLayout();\n  }\n\n  /**\n   * @param [invalidateParents] optional, default is true\n   */\n  invalidateLayoutTree(invalidateParents) {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.invalidateLayoutTree(invalidateParents);\n  }\n\n  validateLayoutTree() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.validateLayoutTree();\n  }\n\n  revalidateLayoutTree(invalidateParents) {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.revalidateLayoutTree(invalidateParents);\n  }\n\n  /**\n   * The layout data contains hints for the layout of the parent container to layout this individual child widget inside the container.<br>\n   * Note: this is not the same as the LayoutConfig. The LayoutConfig contains constraints for the layout itself and is therefore set on the parent container directly.\n   * <p>\n   * Example: The parent container uses a LogicalGridLayout to layout its children. Every child has a LogicalGridLayoutData to tell the layout how this specific child should be layouted.\n   * The parent may have a LogicalGridLayoutConfig to specify constraints which affect either only the container or every child in the container.\n   */\n  setLayoutData(layoutData) {\n    if (!this.rendered) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.layoutData = layoutData;\n  }\n\n  /**\n   * If the widget uses a logical grid layout, the grid may be validated using this method.\n   * <p>\n   * If the grid is not dirty, nothing happens.\n   */\n  validateLogicalGrid() {\n    if (this.logicalGrid) {\n      this.logicalGrid.validate(this);\n    }\n  }\n\n  /**\n   * Marks the logical grid as dirty.<br>\n   * Does nothing, if there is no logical grid.\n   * @param {boolean} [invalidateLayout] true, to invalidate the layout afterwards, false if not. Default is true.\n   */\n  invalidateLogicalGrid(invalidateLayout) {\n    if (!this.initialized) {\n      return;\n    }\n    if (!this.logicalGrid) {\n      return;\n    }\n    this.logicalGrid.setDirty(true);\n    if (scout.nvl(invalidateLayout, true)) {\n      this.invalidateLayoutTree();\n    }\n  }\n\n  /**\n   * Invalidates the logical grid of the parent widget. Typically done when the visibility of the widget changes.\n   * @param {boolean} [invalidateLayout] true, to invalidate the layout of the parent of this.htmlComp, false if not. Default is true.\n   */\n  invalidateParentLogicalGrid(invalidateLayout) {\n    this.parent.invalidateLogicalGrid(false);\n    if (!this.rendered || !this.htmlComp) {\n      return;\n    }\n    if (scout.nvl(invalidateLayout, true)) {\n      let htmlCompParent = this.htmlComp.getParent();\n      if (htmlCompParent) {\n        htmlCompParent.invalidateLayoutTree();\n      }\n    }\n  }\n\n  revalidateLogicalGrid(invalidateLayout) {\n    this.invalidateLogicalGrid(invalidateLayout);\n    this.validateLogicalGrid();\n  }\n\n  setLogicalGrid(logicalGrid) {\n    this.setProperty('logicalGrid', logicalGrid);\n  }\n\n  /**\n   * @param logicalGrid an instance of {@link LogicalGrid} or a string representing the object type of a logical grid.\n   */\n  _setLogicalGrid(logicalGrid) {\n    if (typeof logicalGrid === 'string') {\n      logicalGrid = scout.create(logicalGrid);\n    }\n    this._setProperty('logicalGrid', logicalGrid);\n    this.invalidateLogicalGrid();\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   * The function will only be called once. After that it is automatically de-registered using {@link off}.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} handler Event handler executed when the event is triggered. An event object is passed to the function as first parameter\n   */\n  one(type, handler) {\n    this.events.one(type, handler);\n  }\n\n  /**\n   * Registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.\n   * @param {function} handler Event handler executed when the event is triggered. An event object is passed to the function as first parameter.\n   **/\n  on(type, handler) {\n    return this.events.on(type, handler);\n  }\n\n  /**\n   * De-registers the given event handler for the event specified by the type param.\n   *\n   * @param {string} type One or more event names separated by space.<br/>\n   *      Important: the string must be equal to the one used for {@link on} or {@link one}. This also applies if a string containing multiple types separated by space was used.\n   * @param {function} [handler] The exact same event handler that was used for registration using {@link on} or {@link one}.\n   *      If no handler is specified, all handlers are de-registered for the given type.\n   */\n  off(type, handler) {\n    this.events.off(type, handler);\n  }\n\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n\n  /**\n   * Adds an event handler using {@link one} and returns a promise.\n   * The promise is resolved as soon as the event is triggered.\n   * @returns {Promise}\n   */\n  when(type) {\n    return this.events.when(type);\n  }\n\n  /**\n   * @returns {$} the entry-point for this Widget or its parent. If the widget is part of the main-window it returns this.session.$entryPoint,\n   * for popup-window this function will return the body of the document in the popup window.\n   */\n  entryPoint() {\n    let $element = scout.nvl(this.$container, this.parent.$container);\n    if (!$element || !$element.length) {\n      throw new Error('Cannot resolve entryPoint, $element.length is 0 or undefined');\n    }\n    return $element.entryPoint();\n  }\n\n  window(domElement) {\n    let $el = this.$container || this.$parent;\n    return $el ? $el.window(domElement) : domElement ? null : $(null);\n  }\n\n  document(domElement) {\n    let $el = this.$container || this.$parent;\n    return $el ? $el.document(domElement) : domElement ? null : $(null);\n  }\n\n  /**\n   * This method attaches the detached $container to the DOM.\n   */\n  attach() {\n    if (this.attached || !this.rendered) {\n      return;\n    }\n    this._attach();\n    this._installFocusContext();\n    this.restoreFocus();\n    this.attached = true;\n    this._postAttach();\n    this._onAttach();\n    this._triggerChildrenOnAttach(this);\n  }\n\n  /**\n   * Override this method to do something when Widget is attached again. Typically\n   * you will append this.$container to this.$parent.\n   */\n  _attach() {\n    // NOP\n  }\n\n  /**\n   * Override this method to do something after this widget is attached.\n   * This function is not called on any child of the attached widget.\n   */\n  _postAttach() {\n    // NOP\n  }\n\n  _triggerChildrenOnAttach(parent) {\n    this.children.forEach(child => {\n      child._onAttach();\n      child._triggerChildrenOnAttach(parent);\n    });\n  }\n\n  /**\n   * Override this method to do something after this widget or any parent of it is attached.\n   * This function is called whether or not the widget is rendered.\n   */\n  _onAttach() {\n    if (this.rendered) {\n      this._renderOnAttach();\n    }\n  }\n\n  /**\n   * Override this method to do something after this widget or any parent of it is attached.\n   * This function is only called when this widget is rendered.\n   */\n  _renderOnAttach() {\n    this._renderScrollTop();\n    this._renderScrollLeft();\n  }\n\n  /**\n   * This method calls detach() on all child-widgets. It is used to store some data\n   * before a DOM element is detached and propagate the detach \"event\" to all child-\n   * widgets, because when a DOM element is detached - child elements are not notified\n   */\n  detach() {\n    if (this.rendering) {\n      // Defer the execution of detach. If it was detached while rendering the attached flag would be wrong.\n      this._postRenderActions.push(this.detach.bind(this));\n    }\n    if (!this.attached || !this.rendered) {\n      return;\n    }\n\n    this._beforeDetach();\n    this._onDetach();\n    this._triggerChildrenOnDetach(this);\n    this._detach();\n    this.attached = false;\n  }\n\n  /**\n   * This function is called before a widget gets detached. The function is only called on the detached widget and NOT on\n   * any of its children.\n   */\n  _beforeDetach(parent) {\n    if (!this.$container) {\n      return;\n    }\n\n    let activeElement = this.$container.document(true).activeElement;\n    let isFocused = this.$container.isOrHas(activeElement);\n    let focusManager = this.session.focusManager;\n\n    if (focusManager.isFocusContextInstalled(this.$container)) {\n      this._uninstallFocusContext();\n    } else if (isFocused) {\n      // exclude the container or any of its child elements to gain focus\n      focusManager.validateFocus(filters.outsideFilter(this.$container));\n    }\n  }\n\n  _triggerChildrenOnDetach() {\n    this.children.forEach(child => {\n      child._onDetach();\n      child._triggerChildrenOnDetach(parent);\n    });\n  }\n\n  /**\n   * This function is called before a widget or any of its parent getting detached.\n   * This function is thought to be overridden.\n   */\n  _onDetach() {\n    if (this.rendered) {\n      this._renderOnDetach();\n    }\n  }\n\n  _renderOnDetach() {\n    // NOP\n  }\n\n  /**\n   * Override this method to do something when Widget is detached. Typically you\n   * will call this.$container.detach(). The default\n   * implementation sets this.attached to false.\n   */\n  _detach() {\n  }\n\n  _uninstallFocusContext() {\n    // NOP\n  }\n\n  _installFocusContext() {\n    // NOP\n  }\n\n  /**\n   * Does nothing by default. If a widget needs keystroke support override this method and return a keystroke context, e.g. the default KeyStrokeContext.\n   * @returns {KeyStrokeContext}\n   */\n  _createKeyStrokeContext() {\n    return null;\n  }\n\n  updateKeyStrokes(newKeyStrokes, oldKeyStrokes) {\n    this.unregisterKeyStrokes(oldKeyStrokes);\n    this.registerKeyStrokes(newKeyStrokes);\n  }\n\n  registerKeyStrokes(keyStrokes) {\n    this.keyStrokeContext.registerKeyStrokes(keyStrokes);\n  }\n\n  unregisterKeyStrokes(keyStrokes) {\n    this.keyStrokeContext.unregisterKeyStrokes(keyStrokes);\n  }\n\n  /**\n   * Triggers a property change for a single property.\n   */\n  triggerPropertyChange(propertyName, oldValue, newValue) {\n    scout.assertParameter('propertyName', propertyName);\n    let event = new Event({\n      propertyName: propertyName,\n      oldValue: oldValue,\n      newValue: newValue\n    });\n    this.trigger('propertyChange', event);\n    return event;\n  }\n\n  /**\n   * Sets the value of the property 'propertyName' to 'newValue' and then fires a propertyChange event for that property.\n   * @return {boolean} true if the property was changed, false if not.\n   */\n  _setProperty(propertyName, newValue) {\n    scout.assertParameter('propertyName', propertyName);\n    let oldValue = this[propertyName];\n    if (objects.equals(oldValue, newValue)) {\n      return false;\n    }\n    this[propertyName] = newValue;\n    let event = this.triggerPropertyChange(propertyName, oldValue, newValue);\n    if (event.defaultPrevented) {\n      // Revert to old value if property change should be prevented\n      this[propertyName] = oldValue;\n      return false; // not changed\n    }\n    return true;\n  }\n\n  /**\n   * Sets a new value for a specific property. If the new value is the same value as the old one, nothing is performed.\n   * Otherwise the following phases are executed:\n   * <p>\n   * 1. Preparation: If the property is a widget property, several actions are performed in _prepareWidgetProperty().\n   * 2. DOM removal: If the property is a widget property and the widget is rendered, the changed widget(s) are removed unless the property should not be preserved (see _preserveOnPropertyChangeProperties).\n   *    If there is a custom remove function (e.g. _removeXY where XY is the property name), it will be called instead of removing the widgets directly.\n   * 3. Model update: If there is a custom set function (e.g. _setXY where XY is the property name), it will be called. Otherwise the default set function _setProperty is called.\n   * 4. DOM rendering: If the widget is rendered and there is a custom render function (e.g. _renderXY where XY is the property name), it will be called. Otherwise nothing happens.\n   * @return {boolean} true if the property was changed, false if not.\n   */\n  setProperty(propertyName, value) {\n    if (objects.equals(this[propertyName], value)) {\n      return false;\n    }\n\n    value = this._prepareProperty(propertyName, value);\n    if (this.rendered) {\n      this._callRemoveProperty(propertyName);\n    }\n    this._callSetProperty(propertyName, value);\n    if (this.rendered) {\n      this._callRenderProperty(propertyName);\n    }\n    return true;\n  }\n\n  _prepareProperty(propertyName, value) {\n    if (!this.isWidgetProperty(propertyName)) {\n      return value;\n    }\n    return this._prepareWidgetProperty(propertyName, value);\n  }\n\n  _prepareWidgetProperty(propertyName, widgets) {\n    // Create new child widget(s)\n    widgets = this._createChildren(widgets);\n\n    let oldWidgets = this[propertyName];\n    if (oldWidgets && Array.isArray(widgets)) {\n      // If new value is an array, old value has to be one as well\n      // Only destroy those which are not in the new array\n      oldWidgets = arrays.diff(oldWidgets, widgets);\n    }\n\n    if (!this.isPreserveOnPropertyChangeProperty(propertyName)) {\n      // Destroy old child widget(s)\n      this._destroyChildren(oldWidgets);\n\n      // Link to new parent\n      this.link(widgets);\n    }\n\n    return widgets;\n  }\n\n  /**\n   * Does nothing if the property is not a widget property.<p>\n   * If it is a widget property, it removes the existing widgets. Render has to be implemented by the widget itself.\n   */\n  _callRemoveProperty(propertyName) {\n    if (!this.isWidgetProperty(propertyName)) {\n      return;\n    }\n    if (this.isPreserveOnPropertyChangeProperty(propertyName)) {\n      return;\n    }\n    let widgets = this[propertyName];\n    if (!widgets) {\n      return;\n    }\n    let removeFuncName = '_remove' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[removeFuncName]) {\n      this[removeFuncName]();\n    } else {\n      this._internalRemoveWidgets(widgets);\n    }\n  }\n\n  /**\n   * Removes the given widgets\n   */\n  _internalRemoveWidgets(widgets) {\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(widget => {\n      widget.remove();\n    });\n  }\n\n  _callSetProperty(propertyName, value) {\n    let setFuncName = '_set' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[setFuncName]) {\n      this[setFuncName](value);\n    } else {\n      this._setProperty(propertyName, value);\n    }\n  }\n\n  _callRenderProperty(propertyName) {\n    let renderFuncName = '_render' + strings.toUpperCaseFirstLetter(propertyName);\n    if (!this[renderFuncName]) {\n      return;\n    }\n    this[renderFuncName]();\n  }\n\n  /**\n   * Sets this widget as parent of the given widget(s).\n   *\n   * @param {Widget[]|Widget} widgets may be a widget or array of widgets\n   */\n  link(widgets) {\n    if (!widgets) {\n      return;\n    }\n\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function(child, i) {\n      child.setParent(this);\n    }, this);\n  }\n\n  /**\n   * Method required for widgets which are supposed to be directly covered by a glasspane.<p>\n   *\n   * Returns the DOM elements to paint a glassPanes over, once a modal Form, message-box or file-chooser is shown with this widget as its 'displayParent'.<br>\n   * If the widget is not rendered yet, a scout.DeferredGlassPaneTarget is returned.<br>\n   * In both cases the method _glassPaneTargets is called which may be overridden by the actual widget.\n   * @param {Widget} element widget that requested a glass pane\n   * @returns [$]|[DeferredGlassPaneTarget]\n   */\n  glassPaneTargets(element) {\n    let resolveGlassPanes = element => {\n      // contributions\n      let targets = arrays.flatMap(this._glassPaneContributions, cont => {\n        let $elements = cont(element);\n        if ($elements) {\n          return arrays.ensure($elements);\n        }\n        return [];\n      });\n      return targets.concat(this._glassPaneTargets(element));\n    };\n    if (this.rendered) {\n      return resolveGlassPanes(element);\n    }\n\n    return DeferredGlassPaneTarget.createFor(this, resolveGlassPanes.bind(this, element));\n  }\n\n  /**\n   *\n   * @param {Widget} element widget that requested a glass pane\n   * @returns [$]\n   */\n  _glassPaneTargets(element) {\n    // since popups are rendered outside the DOM of the widget parent-child hierarchy, get glassPaneTargets of popups belonging to this widget separately.\n    return [this.$container].concat(\n      this.session.desktop.getPopupsFor(this)\n        .filter(popup => !element.has(popup))\n        .reduce((acc, popup) => acc.concat(popup.glassPaneTargets()), []));\n  }\n\n  addGlassPaneContribution(contribution) {\n    this._glassPaneContributions.push(contribution);\n    this.trigger('glassPaneContributionAdded', {\n      contribution: contribution\n    });\n  }\n\n  /**\n   * @param [contribution] a function which returns glass pane targets (jQuery elements)\n   */\n  removeGlassPaneContribution(contribution) {\n    arrays.remove(this._glassPaneContributions, contribution);\n    this.trigger('glassPaneContributionRemoved', {\n      contribution: contribution\n    });\n  }\n\n  toString() {\n    let attrs = '';\n    attrs += 'id=' + this.id;\n    attrs += ' objectType=' + this.objectType;\n    attrs += ' rendered=' + this.rendered;\n    if (this.$container) {\n      attrs += ' $container=' + graphics.debugOutput(this.$container);\n    }\n    return 'Widget[' + attrs.trim() + ']';\n  }\n\n  /**\n   * Returns the ancestors as string delimited by '\\n'.\n   * @param {number} [count] the number of ancestors to be processed. Default is -1 which means all.\n   */\n  ancestorsToString(count) {\n    let str = '',\n      ancestors = this.ancestors();\n\n    count = scout.nvl(count, -1);\n    ancestors.some((ancestor, i) => {\n      if (count > -1 && i >= count) {\n        return true;\n      }\n      if (i > 0 && i < ancestors.length - 1) {\n        str += '\\n';\n      }\n      str += ancestor.toString();\n      return false;\n    });\n    return str;\n  }\n\n  resolveTextKeys(properties) {\n    properties.forEach(function(property) {\n      texts.resolveTextProperty(this, property);\n    }, this);\n  }\n\n  resolveIconIds(properties) {\n    properties.forEach(function(property) {\n      icons.resolveIconProperty(this, property);\n    }, this);\n  }\n\n  resolveConsts(configs) {\n    configs.forEach(function(config) {\n      objects.resolveConstProperty(this, config);\n    }, this);\n  }\n\n  /**\n   * A so called widget property is a property with a widget as value incl. automatic resolution of that widget.\n   * This means the property not only accepts the actual widget, but also a widget model or a widget reference (id)\n   * and then either creates a new widget based on the model or resolves the id and uses the referenced widget as value.\n   * Furthermore it will take care of its lifecycle which means, the widget will automatically be removed and destroyed (as long as the parent is also the owner).\n   * <p>\n   * If only the resolve operations without the lifecycle actions should be performed, you need to add the property to the list _preserveOnPropertyChangeProperties as well.\n   */\n  _addWidgetProperties(properties) {\n    this._addProperties('_widgetProperties', properties);\n  }\n\n  isWidgetProperty(propertyName) {\n    return this._widgetProperties.indexOf(propertyName) > -1;\n  }\n\n  _addCloneProperties(properties) {\n    this._addProperties('_cloneProperties', properties);\n  }\n\n  isCloneProperty(propertyName) {\n    return this._cloneProperties.indexOf(propertyName) > -1;\n  }\n\n  /**\n   * Properties in this list won't be affected by the automatic lifecycle actions performed for regular widget properties.\n   * This means, the widget won't be removed, destroyed and also not linked, which means the parent stays the same.\n   * But the resolve operations are still applied, as for regular widget properties.\n   * <p>\n   * The typical use case for such properties is referencing another widget without taking care of that widget.\n   */\n  _addPreserveOnPropertyChangeProperties(properties) {\n    this._addProperties('_preserveOnPropertyChangeProperties', properties);\n  }\n\n  isPreserveOnPropertyChangeProperty(propertyName) {\n    return this._preserveOnPropertyChangeProperties.indexOf(propertyName) > -1;\n  }\n\n  _addProperties(propertyName, properties) {\n    properties = arrays.ensure(properties);\n    properties.forEach(function(property) {\n      if (this[propertyName].indexOf(property) > -1) {\n        throw new Error(propertyName + ' already contains the property ' + property);\n      }\n      this[propertyName].push(property);\n    }, this);\n  }\n\n  _eachProperty(model, func) {\n    let propertyName, value, i;\n\n    // Loop through primitive properties\n    for (propertyName in model) {\n      if (this._widgetProperties.indexOf(propertyName) > -1) {\n        continue; // will be handled below\n      }\n      value = model[propertyName];\n      func(propertyName, value);\n    }\n\n    // Loop through adapter properties (any order will do).\n    for (i = 0; i < this._widgetProperties.length; i++) {\n      propertyName = this._widgetProperties[i];\n      value = model[propertyName];\n      if (value === undefined) {\n        continue;\n      }\n\n      func(propertyName, value, true);\n    }\n  }\n\n  _removeWidgetProperties(properties) {\n    if (Array.isArray(properties)) {\n      arrays.removeAll(this._widgetProperties, properties);\n    } else {\n      arrays.remove(this._widgetProperties, properties);\n    }\n  }\n\n  /**\n   * Clones the widget and mirrors the events, see this.clone() and this.mirror() for details.\n   */\n  cloneAndMirror(model) {\n    return this.clone(model, {\n      delegateAllPropertiesToClone: true\n    });\n  }\n\n  /**\n   * @returns {AnyWidget} the original widget from which this one was cloned. If it is not a clone, itself is returned.\n   */\n  original() {\n    let original = this;\n    while (original.cloneOf) {\n      original = original.cloneOf;\n    }\n    return original;\n  }\n\n  /**\n   * Clones the widget and returns the clone. Only the properties defined in this._cloneProperties are copied to the clone.\n   * The parameter model has to contain at least the property 'parent'.\n   *\n   * @param model The model used to create the clone is a combination of the clone properties and this model.\n   * Therefore this model may be used to override the cloned properties or to add additional properties.\n   * @param {object} [options] Options passed to the mirror function.\n   * @param {[string]} [options.delegatePropertiesToClone] An array of all properties to be delegated from the original to the clone when changed on the original widget. Default is [].\n   * @param {[string]} [options.delegatePropertiesToOriginal] An array of all properties to be delegated from the clone to the original when changed on the clone widget. Default is [].\n   * @param {[string]} [options.excludePropertiesToOriginal] An array of all properties to be excluded from delegating from the clone to the original in any cases. Default is [].\n   * @param {[string]} [options.delegateEventsToOriginal] An array of all events to be delegated from the clone to the original when fired on the clone widget. Default is [].\n   * @param {boolean} [options.delegateAllPropertiesToClone] True to delegate all property changes from the original to the clone. Default is false.\n   * @param {boolean} [options.delegateAllPropertiesToOriginal] True to delegate all property changes from the clone to the original. Default is false.\n   */\n  clone(model, options) {\n    let clone, cloneModel;\n    model = model || {};\n    options = options || {};\n\n    cloneModel = objects.extractProperties(this, model, this._cloneProperties);\n    clone = scout.create(this.objectType, cloneModel);\n    clone.cloneOf = this;\n    this._mirror(clone, options);\n\n    if (this.logicalGrid) {\n      // Create a new logical grid to make sure it does not influence the original widget\n      // This also creates the correct grid config for the specific widget\n      clone.setLogicalGrid(this.logicalGrid.objectType);\n    } else {\n      // Remove the grid if the original does not have one either\n      clone.setLogicalGrid(null);\n    }\n\n    return clone;\n  }\n\n  _deepCloneProperties(clone, properties, options) {\n    if (!properties) {\n      return clone;\n    }\n    properties = arrays.ensure(properties);\n    properties.forEach(property => {\n      let propertyValue = this[property],\n        clonedProperty = null;\n      if (propertyValue === undefined) {\n        throw new Error('Property \\'' + property + '\\' is undefined. Deep copy not possible.');\n      }\n      if (this._widgetProperties.indexOf(property) > -1) {\n        if (Array.isArray(propertyValue)) {\n          clonedProperty = propertyValue.map(val => {\n            return val.clone({\n              parent: clone\n            }, options);\n          });\n        } else {\n          clonedProperty = propertyValue.clone({\n            parent: clone\n          }, options);\n        }\n      } else if (Array.isArray(propertyValue)) {\n        clonedProperty = propertyValue.map(val => {\n          return val;\n        });\n      } else {\n        clonedProperty = propertyValue;\n      }\n      clone[property] = clonedProperty;\n    });\n  }\n\n  /**\n   * Delegates every property change event from the original widget to this cloned widget by calling the appropriate setter.\n   * If no target is set it works only if this widget is a clone.\n   * @param {object} [options]\n   */\n  mirror(options, target) {\n    target = target || this.cloneOf;\n    if (!target) {\n      throw new Error('No target for mirroring.');\n    }\n    this._mirror(target, options);\n  }\n\n  _mirror(clone, options) {\n    let eventDelegator = arrays.find(this.eventDelegators, eventDelegator => {\n      return eventDelegator.clone === clone;\n    });\n    if (eventDelegator) {\n      throw new Error('_mirror can only be called on not mirrored widgets. call unmirror first.');\n    }\n    options = options || {};\n    eventDelegator = {\n      clone: clone,\n      originalToClone: EventDelegator.create(this, clone, {\n        delegateProperties: options.delegatePropertiesToClone,\n        delegateAllProperties: options.delegateAllPropertiesToClone\n      }),\n      cloneToOriginal: EventDelegator.create(clone, this, {\n        delegateProperties: options.delegatePropertiesToOriginal,\n        delegateAllProperties: options.delegateAllPropertiesToOriginal,\n        excludeProperties: options.excludePropertiesToOriginal,\n        delegateEvents: options.delegateEventsToOriginal\n      })\n    };\n    this.eventDelegators.push(eventDelegator);\n    clone.one('destroy', () => {\n      this._unmirror(clone);\n    });\n  }\n\n  unmirror(target) {\n    target = target || this.cloneOf;\n    if (!target) {\n      throw new Error('No target for unmirroring.');\n    }\n    this._unmirror(target);\n  }\n\n  _unmirror(target) {\n    let eventDelegatorIndex = arrays.findIndex(this.eventDelegators, eventDelegator => {\n        return eventDelegator.clone === target;\n      }),\n      eventDelegator = eventDelegatorIndex > -1 ? this.eventDelegators.splice(eventDelegatorIndex, 1)[0] : null;\n    if (!eventDelegator) {\n      return;\n    }\n    if (eventDelegator.originalToClone) {\n      eventDelegator.originalToClone.destroy();\n    }\n    if (eventDelegator.cloneToOriginal) {\n      eventDelegator.cloneToOriginal.destroy();\n    }\n  }\n\n  _onParentDestroy(event) {\n    if (this.destroyed) {\n      return;\n    }\n    // If the parent is destroyed but the widget not make sure it gets a new parent\n    // This ensures the old one may be properly garbage collected\n    this.setParent(this.owner);\n  }\n\n  callSetter(propertyName, value) {\n    let setterFuncName = 'set' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[setterFuncName]) {\n      this[setterFuncName](value);\n    } else {\n      this.setProperty(propertyName, value);\n    }\n  }\n\n  /**\n   * Traverses the object-tree (children) of this widget and searches for a widget with the given ID.\n   * Returns the widget with the requested ID or null if no widget has been found.\n   *\n   * @param {string} widgetId\n   * @returns {AnyWidget} the found widget for the given id\n   */\n  widget(widgetId) {\n    if (predicate(this)) {\n      return this;\n    }\n    return this.findChild(predicate);\n\n    function predicate(widget) {\n      if (widget.id === widgetId) {\n        return widget;\n      }\n    }\n  }\n\n  /**\n   * Similar to widget(), but uses \"breadth-first\" strategy, i.e. it checks all children of the\n   * same depth (level) before it advances to the next level. If multiple widgets with the same\n   * ID exist, the one with the smallest distance to this widget is returned.\n   *\n   * Example:\n   *\n   *    Widget ['MyWidget']                     #1\n   *    +- GroupBox ['LeftBox']                 #2\n   *       +- StringField ['NameField']         #3\n   *       +- StringField ['CityField']         #4\n   *       +- GroupBox ['InnerBox']             #5\n   *          +- GroupBox ['LeftBox']           #6\n   *             +- DateField ['StartDate']     #7\n   *          +- GroupBox ['RightBox']          #8\n   *             +- DateField ['EndDate']       #9\n   *    +- GroupBox ['RightBox']                #10\n   *       +- StringField ['NameField']         #11\n   *       +- DateField ['StartDate']           #12\n   *\n   *   CALL:                                    RESULT:\n   *   ---------------------------------------------------------------------------------------------\n   *   this.widget('RightBox')                  #8               (might not be the expected result)\n   *   this.nearestWidget('RightBox')           #10\n   *\n   *   this.widget('NameField')                 #3\n   *   this.nearestWidget('NameField')          null             (because no direct child has the requested id)\n   *   this.nearestWidget('NameField', true)    #3               (because #3 and #11 have the same distance)\n   *\n   *   this.widget('StartDate')                 #7\n   *   this.nearestWidget('StartDate', true)    #12              (#12 has smaller distance than #7)\n   *\n   * @param {string} widgetId\n   *          The ID of the widget to find.\n   * @param {boolean} [deep=false]\n   *          If false, only this widget and the next level are checked. This is the default.\n   *          If true, the entire tree is traversed.\n   * @return {Widget} the first found widget, or null if no widget was found.\n   */\n  nearestWidget(widgetId, deep) {\n    if (this.id === widgetId) {\n      return this;\n    }\n    let widgets = this.children.slice(); // list of widgets to check\n    while (widgets.length) {\n      let widget = widgets.shift();\n      if (widget.id === widgetId) {\n        return widget; // found\n      }\n      if (deep) {\n        for (let i = 0; i < widget.children.length; i++) {\n          let child = widget.children[i];\n          if (child.parent === widget) { // same check as in visitChildren()\n            widgets.push(child);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @returns {AnyWidget} the first parent for which the given function returns true.\n   */\n  findParent(predicate) {\n    let parent = this.parent;\n    while (parent) {\n      if (predicate(parent)) {\n        return parent;\n      }\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @returns {AnyWidget} the first child for which the given function returns true.\n   */\n  findChild(predicate) {\n    let foundChild = null;\n    this.visitChildren(child => {\n      if (predicate(child)) {\n        foundChild = child;\n        return true;\n      }\n    });\n    return foundChild;\n  }\n\n  setTrackFocus(trackFocus) {\n    this.setProperty('trackFocus', trackFocus);\n  }\n\n  _renderTrackFocus() {\n    if (!this.$container) {\n      return;\n    }\n    if (this.trackFocus) {\n      this.$container.on('focusin', this._focusInListener);\n    } else {\n      this.$container.off('focusin', this._focusInListener);\n    }\n  }\n\n  restoreFocus() {\n    if (this._$lastFocusedElement) {\n      this.session.focusManager.requestFocus(this._$lastFocusedElement);\n    } else if (this._storedFocusedWidget) {\n      this._storedFocusedWidget.focus();\n      this._storedFocusedWidget = null;\n    }\n  }\n\n  /**\n   * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusIn(event) {\n    // do not track focus events during rendering to avoid initial focus to be restored.\n    if (this.rendering) {\n      return;\n    }\n    let $target = $(event.target);\n    if (this.$container.has($target)) {\n      this._$lastFocusedElement = $target;\n    }\n  }\n\n  /**\n   * Tries to set the focus on the widget.\n   * <p>\n   * By default the focus is set on the container but this may vary from widget to widget.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   * @returns {boolean} true if the element could be focused, false if not\n   */\n  focus(options) {\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.focus.bind(this, options));\n      return false;\n    }\n    return this.session.focusManager.requestFocus(this.getFocusableElement(), null, options);\n  }\n\n  /**\n   * Calls {@link focus()} and prevents the default behavior of the event if the focusing was successful.\n   */\n  focusAndPreventDefault(event) {\n    if (this.focus()) {\n      // Preventing blur is bad for touch devices because it prevents that the keyboard can close.\n      // In that case focus() will return false because focus manager is disabled.\n      event.preventDefault();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether the widget is the currently active element\n   */\n  isFocused() {\n    return this.rendered && focusUtils.isActiveElement(this.getFocusableElement());\n  }\n\n  /**\n   * @param {boolean} [checkTabbable=true] if true, the widget has to be tabbable, not only focusable.\n   * @return {boolean} true if the element is focusable (and tabbable, unless checkTabbable is set to false), false if not.\n   */\n  isFocusable(checkTabbable) {\n    if (!this.rendered || !this.visible) {\n      return false;\n    }\n    let elem = this.getFocusableElement();\n    if (!elem) {\n      return false;\n    }\n    let $elem = $.ensure(elem);\n    if (!$elem.is(':focusable')) {\n      return false;\n    }\n    if (scout.nvl(checkTabbable, true)) {\n      return $elem.is(':tabbable');\n    }\n    return true;\n  }\n\n  /**\n   * This method returns the HtmlElement to be used when {@link #focus()} is called.\n   * It can be overridden, in case the widget needs to return something other than this.$container[0].\n   */\n  getFocusableElement() {\n    if (this.rendered && this.$container) {\n      return this.$container[0];\n    }\n    return null;\n  }\n\n  /**\n   * @param {object} [options]\n   */\n  _installScrollbars(options) {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      throw new Error('Scrollable is not defined, cannot install scrollbars');\n    }\n    if ($scrollable.data('scrollable')) {\n      // already installed\n      return;\n    }\n    options = options || {};\n    let defaults = {\n      parent: this\n    };\n    options = $.extend({}, defaults, options);\n    scrollbars.install($scrollable, options);\n    $scrollable.on('scroll', this._scrollHandler);\n  }\n\n  _uninstallScrollbars() {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable || !$scrollable.data('scrollable')) {\n      return;\n    }\n    scrollbars.uninstall($scrollable, this.session);\n    $scrollable.off('scroll', this._scrollHandler);\n    if (!this.removing) {\n      // If scrollbars are removed on the fly and not because the widget is removing, reset scroll positions to initial state\n      // Only reset if position is 0 to preserve the position (uninstalling does not reset the position of the scrollable either)\n      if ($scrollable[0].scrollTop === 0) {\n        this.scrollTop = null;\n      }\n      if ($scrollable[0].scrollLeft === 0) {\n        this.scrollLeft = null;\n      }\n    }\n  }\n\n  _onScroll() {\n    let $scrollable = this.get$Scrollable();\n    this._setProperty('scrollTop', $scrollable[0].scrollTop);\n    this._setProperty('scrollLeft', $scrollable[0].scrollLeft);\n  }\n\n  setScrollTop(scrollTop) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().setScrollTop(scrollTop);\n      return;\n    }\n    this.setProperty('scrollTop', scrollTop);\n  }\n\n  _renderScrollTop() {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable || this.scrollTop === null) {\n      // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollTop must not be done while rendering because it would provoke a reflow\n      return;\n    }\n    if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n      // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n      // If scroll top is set while layouting, layout obviously wants to set it -> do it\n      this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollTop.bind(this));\n      return;\n    }\n    scrollbars.scrollTop($scrollable, this.scrollTop);\n  }\n\n  setScrollLeft(scrollLeft) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().setScrollLeft(scrollLeft);\n      return;\n    }\n    this.setProperty('scrollLeft', scrollLeft);\n  }\n\n  _renderScrollLeft() {\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable || this.scrollLeft === null) {\n      // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollLeft must not be done while rendering because it would provoke a reflow\n      return;\n    }\n    if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n      // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n      // If scroll left is set while layouting, layout obviously wants to set it -> do it\n      this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollLeft.bind(this));\n      return;\n    }\n    scrollbars.scrollLeft($scrollable, this.scrollLeft);\n  }\n\n  /**\n   * Returns the jQuery element which is supposed to be scrollable. This element will be used by the scroll functions like {@link #_installScrollbars}, {@link #setScrollTop}, {@link #setScrollLeft}, {@link #scrollToBottom} etc..\n   * The element won't be used unless {@link #_installScrollbars} is called.\n   * If the widget is mainly a wrapper for a scrollable widget and does not have a scrollable element by itself, you can use @{link #getDelegateScrollable} instead.\n   * @return {$}\n   */\n  get$Scrollable() {\n    return this.$container;\n  }\n\n  hasScrollShadow(position) {\n    return scrollbars.hasScrollShadow(this.get$Scrollable(), position);\n  }\n\n  /**\n   * If the widget is mainly a wrapper for another widget, it is often the case that the other widget is scrollable and not the wrapper.\n   * In that case implement this method and return the other widget so that the calls to the scroll functions can be delegated.\n   * @return {Widget}\n   */\n  getDelegateScrollable() {\n    return null;\n  }\n\n  scrollToTop(options) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().scrollToTop();\n      return;\n    }\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      return;\n    }\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.scrollToTop.bind(this));\n      return;\n    }\n    scrollbars.scrollTop($scrollable, 0, options);\n  }\n\n  scrollToBottom(options) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().scrollToBottom();\n      return;\n    }\n    let $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      return;\n    }\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.scrollToBottom.bind(this));\n      return;\n    }\n    scrollbars.scrollToBottom($scrollable, options);\n  }\n\n  /**\n   * Brings the widget into view by scrolling the first scrollable parent.\n   */\n  reveal(options) {\n    if (!this.rendered) {\n      return;\n    }\n    let $scrollParent = this.$container.scrollParent();\n    if ($scrollParent.length === 0) {\n      // No scrollable parent found -> scrolling is not possible\n      return;\n    }\n    scrollbars.scrollTo($scrollParent, this.$container, options);\n  }\n\n  /**\n   * Visits every child of this widget in pre-order (top-down).<br>\n   * This widget itself is not visited! Only child widgets are visited recursively.\n   * <p>\n   * The children with a different parent are excluded.<br>\n   * This makes sure the child is not visited twice if the owner and the parent are not the same\n   * (in that case the widget would be in the children list of the owner and of the parent).\n   * <p>\n   * In order to abort visiting, the visitor can return true.\n   *\n   * @param {function(AnyWidget):boolean|TreeVisitResult|null} visitor\n   * @returns {boolean} true if the visitor aborted the visiting, false if the visiting completed without aborting\n   */\n  visitChildren(visitor) {\n    for (let i = 0; i < this.children.length; i++) {\n      let child = this.children[i];\n      if (child.parent === this) {\n        let treeVisitResult = visitor(child);\n        if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n          // Visitor wants to abort the visiting\n          return TreeVisitResult.TERMINATE;\n        } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n          treeVisitResult = child.visitChildren(visitor);\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            return TreeVisitResult.TERMINATE;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {boolean} Whether or not the widget is rendered (or rendering) and the DOM $container isAttached()\n   */\n  isAttachedAndRendered() {\n    return (this.rendered || this.rendering) && this.$container.isAttached();\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  static cssClassAsArray(cssClass) {\n    let cssClasses = [],\n      cssClassesStr = cssClass || '';\n\n    cssClassesStr = cssClassesStr.trim();\n    if (cssClassesStr.length > 0) {\n      cssClasses = cssClassesStr.split(' ');\n    }\n    return cssClasses;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}