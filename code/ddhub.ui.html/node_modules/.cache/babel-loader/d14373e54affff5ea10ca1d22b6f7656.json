{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { CollapseHandle, CompositeField, graphics, GroupBox, HtmlComponent, HtmlEnvironment, KeyStroke, scout, SplitBoxCollapseKeyStroke, SplitBoxFirstCollapseKeyStroke, SplitBoxLayout, SplitBoxSecondCollapseKeyStroke } from '../../../index';\nimport $ from 'jquery';\nexport default class SplitBox extends CompositeField {\n  // noinspection DuplicatedCode\n  constructor() {\n    super();\n    this._addWidgetProperties(['firstField', 'secondField', 'collapsibleField']);\n    this._addPreserveOnPropertyChangeProperties(['collapsibleField']);\n    this.firstField = null;\n    this.secondField = null;\n    this.collapsibleField = null;\n    this.collapseKeyStroke = null;\n    this.fieldCollapsed = false;\n    this.toggleCollapseKeyStroke = null;\n    this.firstCollapseKeyStroke = null;\n    this.secondCollapseKeyStroke = null;\n    this.splitHorizontal = true; // true = split x-axis, false = split y-axis\n    this.splitterEnabled = true;\n    this.splitterPosition = 0.5;\n    this.minSplitterPosition = 0;\n    this.splitterPositionType = SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST;\n    this.fieldMinimized = false;\n    this.minimizeEnabled = true;\n    this._$splitArea = null;\n    this._$splitter = null;\n  }\n  _init(model) {\n    super._init(model);\n    this._setToggleCollapseKeyStroke(this.toggleCollapseKeyStroke);\n    this._setFirstCollapseKeyStroke(this.firstCollapseKeyStroke);\n    this._setSecondCollapseKeyStroke(this.secondCollapseKeyStroke);\n    this._updateCollapseHandle();\n    this._initResponsive();\n  }\n\n  /**\n   * Set the group boxes of the split box to responsive if not set otherwise.\n   */\n  _initResponsive() {\n    this.getFields().forEach(field => {\n      if (field instanceof GroupBox && field.responsive === null) {\n        field.setResponsive(true);\n      }\n    });\n  }\n  _render() {\n    this.addContainer(this.$parent, 'split-box');\n    // This widget does not support label, mandatoryIndicator and status\n\n    // Create split area\n    this._$splitArea = this.$parent.makeDiv('split-area');\n    this.addField(this._$splitArea);\n    this.htmlSplitArea = HtmlComponent.install(this._$splitArea, this.session);\n    this.htmlSplitArea.setLayout(new SplitBoxLayout(this));\n    this._$window = this.$parent.window();\n    this._$body = this.$parent.body();\n\n    // Add fields and splitter\n    if (this.firstField) {\n      this.firstField.render(this._$splitArea);\n      this.firstField.$container.addClass('first-field').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n      this.firstField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n      if (this.secondField) {\n        this.secondField.render(this._$splitArea);\n        this.secondField.$container.addClass('second-field').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        this.secondField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n        this._$splitter = this._$splitArea.appendDiv('splitter').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis').on('mousedown', resizeSplitter.bind(this));\n      }\n    }\n    this._updateFieldVisibilityClasses();\n\n    // --- Helper functions ---\n\n    function resizeSplitter(event) {\n      if (event.which !== 1) {\n        return; // only handle left mouse button\n      }\n\n      let mousePosition, splitAreaPosition, splitAreaSize, splitterSize, splitterPosition, $tempSplitter;\n      if (this.splitterEnabled) {\n        // Update mouse position (see resizeMove() for details)\n        mousePosition = {\n          x: event.pageX,\n          y: event.pageY\n        };\n\n        // Add listeners (we add them to the window to make sure we get the mouseup event even when the cursor it outside the window)\n        this._$window.on('mousemove.splitbox', resizeMove.bind(this)).on('mouseup.splitbox', resizeEnd.bind(this));\n        // Ensure the correct cursor is always shown while moving\n        this._$body.addClass(this.splitHorizontal ? 'col-resize' : 'row-resize');\n        $('iframe').addClass('dragging-in-progress');\n\n        // Get initial area and splitter bounds\n        splitAreaPosition = this._$splitArea.offset();\n        splitAreaSize = graphics.size(this._$splitArea, true);\n        splitterPosition = this._$splitter.offset();\n        splitterSize = graphics.size(this._$splitter, true);\n\n        // Create temporary splitter\n        $tempSplitter = this._$splitArea.appendDiv('temp-splitter').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        if (this.splitHorizontal) {\n          // \"|\"\n          $tempSplitter.cssLeft(splitterPosition.left - splitAreaPosition.left);\n        } else {\n          // \"--\"\n          $tempSplitter.cssTop(splitterPosition.top - splitAreaPosition.top);\n        }\n        this._$splitter.addClass('dragging');\n      }\n      let newSplitterPosition = this.splitterPosition;\n      let SNAP_SIZE = 10;\n      function resizeMove(event) {\n        if (event.pageX === mousePosition.x && event.pageY === mousePosition.y) {\n          // Chrome bug: https://code.google.com/p/chromium/issues/detail?id=161464\n          // When holding the mouse, but not moving it, a 'mousemove' event is fired every second nevertheless.\n          return;\n        }\n        mousePosition = {\n          x: event.pageX,\n          y: event.pageY\n        };\n        if (this.splitHorizontal) {\n          // \"|\"\n          // Calculate target splitter position (in area)\n          let targetSplitterPositionLeft = event.pageX - splitAreaPosition.left;\n\n          // De-normalize minimum splitter position to allowed splitter range in pixel [minSplitterPositionLeft, maxSplitterPositionLeft]\n          let minSplitterPositionLeft;\n          let maxSplitterPositionLeft;\n\n          // Splitter width plus margin on right side, if temporary splitter position is x, the splitter div position is x-splitterOffset\n          let splitterOffset = Math.floor((splitterSize.width + HtmlEnvironment.get().fieldMandatoryIndicatorWidth) / 2);\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST) {\n            minSplitterPositionLeft = scout.nvl(this.minSplitterPosition, 0);\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            minSplitterPositionLeft = (splitAreaSize.width - splitterSize.width) * scout.nvl(this.minSplitterPosition, 0);\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            minSplitterPositionLeft = 0;\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - scout.nvl(this.minSplitterPosition, 0);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            minSplitterPositionLeft = 0;\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - Math.floor(scout.nvl(this.minSplitterPosition, 0) * (splitAreaSize.width - splitterSize.width));\n          }\n\n          // Snap to begin and end\n          let tempSplitterOffsetX = splitterOffset;\n          if (targetSplitterPositionLeft < minSplitterPositionLeft + splitterOffset + SNAP_SIZE) {\n            // snap left if minimum position is reached (+ snap range)\n            targetSplitterPositionLeft = minSplitterPositionLeft; // set splitter directly to left minimal bound\n            tempSplitterOffsetX = 0; // setting splitter to left minimal bound, does not require an additional offset\n          } else if (targetSplitterPositionLeft > maxSplitterPositionLeft - SNAP_SIZE) {\n            targetSplitterPositionLeft = maxSplitterPositionLeft;\n          }\n\n          // Update temporary splitter\n          $tempSplitter.cssLeft(targetSplitterPositionLeft - tempSplitterOffsetX);\n\n          // Normalize target position (available splitter area is (splitAreaSize.width - splitterSize.width))\n          newSplitterPosition = targetSplitterPositionLeft - tempSplitterOffsetX;\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            newSplitterPosition = newSplitterPosition / (splitAreaSize.width - splitterSize.width);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            newSplitterPosition = 1 - newSplitterPosition / (splitAreaSize.width - splitterSize.width);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            newSplitterPosition = splitAreaSize.width - splitterSize.width - newSplitterPosition;\n          }\n        } else {\n          // \"--\"\n          // Calculate target splitter position (in area)\n          let targetSplitterPositionTop = event.pageY - splitAreaPosition.top;\n\n          // Snap to begin and end\n          let tempSplitterOffsetY = Math.floor(splitterSize.height / 2);\n          if (targetSplitterPositionTop < SNAP_SIZE) {\n            targetSplitterPositionTop = 0;\n            tempSplitterOffsetY = 0;\n          } else if (splitAreaSize.height - targetSplitterPositionTop < SNAP_SIZE) {\n            targetSplitterPositionTop = splitAreaSize.height;\n            tempSplitterOffsetY = splitterSize.height;\n          }\n\n          // Update temporary splitter\n          $tempSplitter.cssTop(targetSplitterPositionTop - tempSplitterOffsetY);\n          // Normalize target position\n          newSplitterPosition = targetSplitterPositionTop - tempSplitterOffsetY;\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            newSplitterPosition = newSplitterPosition / (splitAreaSize.height - splitterSize.height);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            newSplitterPosition = 1 - newSplitterPosition / (splitAreaSize.height - splitterSize.height);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            newSplitterPosition = splitAreaSize.height - newSplitterPosition - splitterSize.height;\n          }\n        }\n      }\n      function resizeEnd(event) {\n        if (event.which !== 1) {\n          return; // only handle left mouse button\n        }\n        // Remove listeners and reset cursor\n        this._$window.off('mousemove.splitbox').off('mouseup.splitbox');\n        if ($tempSplitter) {\n          // instead of check for this.splitterEnabled, if splitter is currently moving it must be finished correctly\n          this._$body.removeClass(this.splitHorizontal ? 'col-resize' : 'row-resize');\n          $('iframe').removeClass('dragging-in-progress');\n\n          // Remove temporary splitter\n          $tempSplitter.remove();\n          this._$splitter.removeClass('dragging');\n\n          // Update split box\n          this.newSplitterPosition(newSplitterPosition, true);\n        }\n      }\n      return false;\n    }\n    function onInnerFieldPropertyChange(event) {\n      if (event.propertyName === 'visible') {\n        this._updateFieldVisibilityClasses();\n        // Mark layout as invalid\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderSplitterPosition();\n    this._renderSplitterEnabled();\n    this._renderCollapsibleField(); // renders collapsibleField _and_ fieldCollapsed\n    this._renderCollapseHandle(); // renders collapseHandle _and_ toggleCollapseKeyStroke _and_ firstCollapseKeyStroke _and_ secondCollapseKeyStroke\n    this._renderFieldMinimized();\n  }\n  _remove() {\n    this._$splitArea = null;\n    this._$splitter = null;\n    super._remove();\n  }\n  _setSplitterPosition(splitterPosition) {\n    this._setProperty('splitterPosition', splitterPosition);\n    // If splitter position is explicitly set by an event, no recalculation is necessary\n    this._oldSplitterPositionType = null;\n  }\n  _renderSplitterPosition() {\n    this.newSplitterPosition(this.splitterPosition, false); // do not update (override) field minimized if new position is set by model\n  }\n\n  _setSplitterPositionType(splitterPositionType) {\n    if (this.rendered && !this._oldSplitterPositionType) {\n      this._oldSplitterPositionType = this.splitterPositionType;\n      // We need to recalculate the splitter position. Because this requires the proper\n      // size of the split box, this can only be done in _renderSplitterPositionType().\n    }\n\n    this._setProperty('splitterPositionType', splitterPositionType);\n  }\n  _renderSplitterPositionType() {\n    if (this._oldSplitterPositionType) {\n      // splitterPositionType changed while the split box was rendered --> convert splitterPosition\n      // to the target type such that the current position in screen does not change.\n      let splitAreaSize = this.htmlSplitArea.size(),\n        splitterPosition = this.splitterPosition,\n        splitterSize = graphics.size(this._$splitter, true),\n        minSplitterPosition = this.minSplitterPosition,\n        totalSize = 0;\n      if (this.splitHorizontal) {\n        // \"|\"\n        totalSize = splitAreaSize.width - splitterSize.width;\n      } else {\n        // \"--\"\n        totalSize = splitAreaSize.height - splitterSize.height;\n      }\n\n      // Convert value depending on the old and new type system\n      let oldIsRelative = this._isSplitterPositionTypeRelative(this._oldSplitterPositionType);\n      let newIsRelative = this._isSplitterPositionTypeRelative(this.splitterPositionType);\n      let oldIsAbsolute = !oldIsRelative;\n      let newIsAbsolute = !newIsRelative;\n      if (oldIsRelative && newIsAbsolute) {\n        // From relative to absolute\n        if (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND || this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST) {\n          splitterPosition = totalSize - totalSize * splitterPosition; // changed from first to second field or from second to first field, invert splitter position\n        } else {\n          splitterPosition = totalSize * splitterPosition;\n        }\n        // convert minimum splitter position\n        if (minSplitterPosition) {\n          minSplitterPosition = totalSize * minSplitterPosition;\n        }\n      } else if (oldIsAbsolute && newIsRelative) {\n        // From absolute to relative\n        if (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND || this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n          splitterPosition = (totalSize - splitterPosition) / totalSize; // changed from first to second field or from second to first field, invert splitter position\n        } else {\n          splitterPosition = splitterPosition / totalSize;\n        }\n\n        // convert minimum splitter position\n        if (minSplitterPosition) {\n          minSplitterPosition = minSplitterPosition / totalSize;\n        }\n      } else if (oldIsAbsolute && newIsAbsolute) {\n        splitterPosition = totalSize - splitterPosition;\n        // do not convert minimum splitter position, unit did not change\n      } else {\n        // oldIsRelative && newIsRelative\n        splitterPosition = 1 - splitterPosition;\n        // do not convert minimum splitter position, unit did not change\n      }\n      // set new minimum splitter position\n      this.setMinSplitterPosition(minSplitterPosition);\n\n      // Set as new splitter position\n      this._oldSplitterPositionType = null;\n      this.newSplitterPosition(splitterPosition, true);\n    }\n  }\n  _isSplitterPositionTypeRelative(positionType) {\n    return positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST || positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND;\n  }\n  _renderSplitterEnabled() {\n    if (this._$splitter) {\n      this._$splitter.setEnabled(this.splitterEnabled);\n    }\n  }\n  setFieldCollapsed(collapsed) {\n    this.setProperty('fieldCollapsed', collapsed);\n    this._updateCollapseHandleButtons();\n  }\n  _renderFieldCollapsed() {\n    this._renderCollapsibleField();\n  }\n  setCollapsibleField(field) {\n    this.setProperty('collapsibleField', field);\n    this._updateCollapseHandle();\n  }\n  _updateCollapseHandle() {\n    // always unregister key stroke first (although it may have been added by _setToggleCollapseKeyStroke before)\n    if (this.toggleCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.toggleCollapseKeyStroke);\n    }\n    if (this.firstCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n    }\n    if (this.secondCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n    }\n    if (this.collapsibleField) {\n      let horizontalAlignment = CollapseHandle.HorizontalAlignment.LEFT;\n      if (this.collapsibleField !== this.firstField) {\n        horizontalAlignment = CollapseHandle.HorizontalAlignment.RIGHT;\n      }\n      if (!this._collapseHandle) {\n        // create new collapse handle\n        this._collapseHandle = scout.create('CollapseHandle', {\n          parent: this,\n          horizontalAlignment: horizontalAlignment\n        });\n        this._collapseHandle.on('action', this.collapseHandleButtonPressed.bind(this));\n        if (this.toggleCollapseKeyStroke) {\n          this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n        }\n        if (this.firstCollapseKeyStroke) {\n          this.registerKeyStrokes(this.firstCollapseKeyStroke);\n        }\n        if (this.secondCollapseKeyStroke) {\n          this.registerKeyStrokes(this.secondCollapseKeyStroke);\n        }\n        if (this.rendered) {\n          this._renderCollapseHandle();\n        }\n      } else {\n        // update existing collapse handle\n        this._collapseHandle.setHorizontalAlignment(horizontalAlignment);\n      }\n      this._updateCollapseHandleButtons();\n    } else {\n      if (this._collapseHandle) {\n        this._collapseHandle.destroy();\n        this._collapseHandle = null;\n      }\n    }\n  }\n  _updateCollapseHandleButtons() {\n    if (!this._collapseHandle) {\n      return;\n    }\n    let leftVisible,\n      rightVisible,\n      collapsed = this.fieldCollapsed,\n      minimized = this.fieldMinimized,\n      minimizable = this._isMinimizable(),\n      positionTypeFirstField = this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST || this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST,\n      positionNotAccordingCollapsibleField = positionTypeFirstField && this.collapsibleField === this.secondField || !positionTypeFirstField && this.collapsibleField === this.firstField;\n    if (positionTypeFirstField) {\n      if (positionNotAccordingCollapsibleField) {\n        leftVisible = !minimized && minimizable || collapsed; // left = decrease collapsible field size. Decrease field in this order [minimized <- default <- collapsed]\n        rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [minimized -> default -> collapsed]\n      } else {\n        leftVisible = !collapsed; // left = increase collapsible field size. Increase field in this order [default <- minimized <- collapsed]\n        rightVisible = collapsed || minimized && minimizable; // right = decrease collapsible field size. Decrease field in this order [default -> minimized -> collapsed]\n      }\n    } else {\n      if (positionNotAccordingCollapsibleField) {\n        leftVisible = !collapsed; // left = decrease collapsible field size. Decrease field in this order [collapsed <- default <- minimized]\n        rightVisible = !minimized && minimizable || collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> default -> minimized]\n      } else {\n        leftVisible = collapsed || minimized && minimizable; // left = decrease collapsible field size. Decrease field in this order [collapsed <- minimized <- default]\n        rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> minimized -> default]\n      }\n    }\n\n    this._collapseHandle.setLeftVisible(leftVisible);\n    this._collapseHandle.setRightVisible(rightVisible);\n\n    // update allowed keystrokes\n    if (this.firstCollapseKeyStroke) {\n      if (leftVisible) {\n        this.registerKeyStrokes(this.firstCollapseKeyStroke);\n      } else {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n    }\n    if (this.secondCollapseKeyStroke) {\n      if (rightVisible) {\n        this.registerKeyStrokes(this.secondCollapseKeyStroke);\n      } else {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n    }\n  }\n  getEffectiveSplitterPosition() {\n    if (this._isMinimizable() && this.fieldMinimized) {\n      return this.minSplitterPosition;\n    }\n    return this.splitterPosition;\n  }\n  setMinSplitterPosition(minSplitterPosition) {\n    this.setProperty('minSplitterPosition', minSplitterPosition);\n    this._updateCollapseHandleButtons();\n  }\n  _renderMinSplitterPosition() {\n    // minimum splitter position is considered automatically when layout is updated\n    if (this.rendered) {\n      // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n  setFieldMinimized(minimized) {\n    this.setProperty('fieldMinimized', minimized);\n    this._updateCollapseHandleButtons();\n  }\n  _renderFieldMinimized() {\n    this.$container.removeClass('first-field-minimized second-field-minimized');\n    if (this.firstField) {\n      this.firstField.$container.removeClass('minimized');\n    }\n    if (this.secondField) {\n      this.secondField.$container.removeClass('minimized');\n    }\n    if (this.collapsibleField && this.fieldMinimized) {\n      this.collapsibleField.$container.addClass('minimized');\n      this.$container.toggleClass('first-field-minimized', this.firstField === this.collapsibleField);\n      this.$container.toggleClass('second-field-minimized', this.secondField === this.collapsibleField);\n    }\n\n    // field minimized state is considered automatically when layout is updated\n    if (this.rendered) {\n      // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n  setMinimizeEnabled(enabled) {\n    this.setProperty('minimizeEnabled', enabled);\n    if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(this.splitterPosition)) {\n      this.setFieldMinimized(true);\n    }\n    this._updateCollapseHandleButtons();\n  }\n  _renderMinimizeEnabled() {\n    // minimize enabled is considered automatically when layout is updated\n    if (this.rendered) {\n      // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n  _isMinimizable() {\n    return !!this.minSplitterPosition && this.minimizeEnabled;\n  }\n  _renderCollapsibleField() {\n    this.$container.removeClass('first-field-collapsed second-field-collapsed');\n    if (this.firstField) {\n      this.firstField.$container.removeClass('collapsed');\n    }\n    if (this.secondField) {\n      this.secondField.$container.removeClass('collapsed');\n    }\n    if (this.collapsibleField && this.fieldCollapsed) {\n      this.collapsibleField.$container.addClass('collapsed');\n      this.$container.toggleClass('first-field-collapsed', this.firstField === this.collapsibleField);\n      this.$container.toggleClass('second-field-collapsed', this.secondField === this.collapsibleField);\n    }\n    if (this.rendered) {\n      // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n  _setToggleCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.toggleCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.collapseKeyStroke);\n      }\n      this.toggleCollapseKeyStroke = new SplitBoxCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n      }\n    }\n  }\n  _setFirstCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.firstCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n      this.firstCollapseKeyStroke = new SplitBoxFirstCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.firstCollapseKeyStroke);\n      }\n    }\n  }\n  _setSecondCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.secondCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n      this.secondCollapseKeyStroke = new SplitBoxSecondCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.secondCollapseKeyStroke);\n      }\n    }\n  }\n  _renderCollapseHandle() {\n    if (this._collapseHandle) {\n      this._collapseHandle.render();\n    }\n  }\n  newSplitterPosition(newSplitterPosition, updateFieldMinimizedState) {\n    if (this._isSplitterPositionTypeRelative(this.splitterPositionType)) {\n      // Ensure range 0..1\n      newSplitterPosition = Math.max(0, Math.min(1, newSplitterPosition));\n    } else {\n      // Ensure not negative\n      newSplitterPosition = Math.max(0, newSplitterPosition);\n    }\n\n    // Ensure splitter within allowed range, toggle field minimized state if new splitter position is within minimal range\n    if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(newSplitterPosition)) {\n      this.setFieldMinimized(true);\n      return;\n    }\n\n    // Set new value (send to server if changed\n    let positionChanged = this.splitterPosition !== newSplitterPosition;\n    this.splitterPosition = newSplitterPosition;\n    if (positionChanged) {\n      this.trigger('positionChange', {\n        position: newSplitterPosition\n      });\n      if (updateFieldMinimizedState) {\n        this._updateFieldMinimized();\n      }\n    }\n    this._updateCollapseHandleButtons();\n\n    // Mark layout as invalid\n    this.htmlSplitArea.invalidateLayoutTree(false);\n  }\n  _updateFieldMinimized() {\n    if (this._isMinimizable()) {\n      this.setFieldMinimized(this._isSplitterPositionInMinimalRange(this.splitterPosition));\n    } else {\n      this.setFieldMinimized(false);\n    }\n  }\n  _isSplitterPositionInMinimalRange(newSplitterPosition) {\n    if (!this._isMinimizable()) {\n      return false;\n    }\n    return newSplitterPosition <= this.minSplitterPosition;\n  }\n  toggleFieldCollapsed() {\n    this.setFieldCollapsed(!this.fieldCollapsed);\n  }\n  collapseHandleButtonPressed(event) {\n    let collapsed = this.fieldCollapsed,\n      minimized = this.fieldMinimized,\n      minimizable = this._isMinimizable(),\n      positionTypeFirstField = this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST || this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST,\n      increaseField = !!event.left && !positionTypeFirstField || !!event.right && positionTypeFirstField;\n    if (positionTypeFirstField && this.collapsibleField === this.secondField || !positionTypeFirstField && this.collapsibleField === this.firstField) {\n      // Splitter is not positioned according (absolute or relative) to collapsible field\n      // - Mode toggles to increase collapsible field size: field collapsed --> field default --> field minimized\n      // - Mode toggles to decrease collapsible field size: field collapsed <-- field default <-- field minimized\n      if (increaseField) {\n        if (collapsed) {\n          // not possible, button is not visible (field is collapsed and cannot further increase its size)\n        } else if (minimized && minimizable) {\n          this.setFieldMinimized(false);\n        } else {\n          this.setFieldCollapsed(true);\n        }\n      } else {\n        if (collapsed) {\n          this.setFieldCollapsed(false);\n        } else if (minimized) {\n          // not possible, button is not visible (field is minimized and cannot further decrease its size)\n        } else if (minimizable) {\n          this.setFieldMinimized(true);\n        }\n      }\n    } else {\n      // Splitter is positioned according (absolute or relative) to collapsible field\n      // - Mode toggles to increase collapsible field size: field collapsed --> field minimized --> field default\n      // - Mode toggles to decrease collapsible field size: field collapsed <-- field minimized <-- field default\n      if (increaseField) {\n        if (collapsed) {\n          this.setFieldCollapsed(false);\n        } else if (minimized) {\n          this.setFieldMinimized(false);\n        } else {\n          // not possible, button is not visible (field has default size and cannot further increase its size)\n        }\n      } else {\n        if (collapsed) {\n          // not possible, button is not visible (field is collapsed and cannot further decrease its size)\n        } else if (minimized || !minimizable) {\n          this.setFieldCollapsed(true);\n        } else {\n          this.setFieldMinimized(true);\n        }\n      }\n    }\n  }\n\n  /**\n   * @override CompositeField.js\n   */\n  getFields() {\n    let fields = [];\n    if (this.firstField) {\n      fields.push(this.firstField);\n    }\n    if (this.secondField) {\n      fields.push(this.secondField);\n    }\n    return fields;\n  }\n  _updateFieldVisibilityClasses() {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    let hasFirstField = this.firstField && this.firstField.isVisible();\n    let hasSecondField = this.secondField && this.secondField.isVisible();\n    let hasTwoFields = hasFirstField && hasSecondField;\n    let hasOneField = !hasTwoFields && (hasFirstField || hasSecondField);\n\n    // Mark container if only one field is visible (i.e. there is no splitter)\n    this.$container.toggleClass('single-field', hasOneField);\n  }\n}\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_RELATIVE_FIRST\", 'relativeFirst');\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_RELATIVE_SECOND\", 'relativeSecond');\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST\", 'absoluteFirst');\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND\", 'absoluteSecond');","map":{"version":3,"names":["CollapseHandle","CompositeField","graphics","GroupBox","HtmlComponent","HtmlEnvironment","KeyStroke","scout","SplitBoxCollapseKeyStroke","SplitBoxFirstCollapseKeyStroke","SplitBoxLayout","SplitBoxSecondCollapseKeyStroke","$","SplitBox","constructor","_addWidgetProperties","_addPreserveOnPropertyChangeProperties","firstField","secondField","collapsibleField","collapseKeyStroke","fieldCollapsed","toggleCollapseKeyStroke","firstCollapseKeyStroke","secondCollapseKeyStroke","splitHorizontal","splitterEnabled","splitterPosition","minSplitterPosition","splitterPositionType","SPLITTER_POSITION_TYPE_RELATIVE_FIRST","fieldMinimized","minimizeEnabled","_$splitArea","_$splitter","_init","model","_setToggleCollapseKeyStroke","_setFirstCollapseKeyStroke","_setSecondCollapseKeyStroke","_updateCollapseHandle","_initResponsive","getFields","forEach","field","responsive","setResponsive","_render","addContainer","$parent","makeDiv","addField","htmlSplitArea","install","session","setLayout","_$window","window","_$body","body","render","$container","addClass","on","onInnerFieldPropertyChange","bind","appendDiv","resizeSplitter","_updateFieldVisibilityClasses","event","which","mousePosition","splitAreaPosition","splitAreaSize","splitterSize","$tempSplitter","x","pageX","y","pageY","resizeMove","resizeEnd","offset","size","cssLeft","left","cssTop","top","newSplitterPosition","SNAP_SIZE","targetSplitterPositionLeft","minSplitterPositionLeft","maxSplitterPositionLeft","splitterOffset","Math","floor","width","get","fieldMandatoryIndicatorWidth","SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST","nvl","SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND","SPLITTER_POSITION_TYPE_RELATIVE_SECOND","tempSplitterOffsetX","targetSplitterPositionTop","tempSplitterOffsetY","height","off","removeClass","remove","propertyName","invalidateLayoutTree","_renderProperties","_renderSplitterPosition","_renderSplitterEnabled","_renderCollapsibleField","_renderCollapseHandle","_renderFieldMinimized","_remove","_setSplitterPosition","_setProperty","_oldSplitterPositionType","_setSplitterPositionType","rendered","_renderSplitterPositionType","totalSize","oldIsRelative","_isSplitterPositionTypeRelative","newIsRelative","oldIsAbsolute","newIsAbsolute","setMinSplitterPosition","positionType","setEnabled","setFieldCollapsed","collapsed","setProperty","_updateCollapseHandleButtons","_renderFieldCollapsed","setCollapsibleField","unregisterKeyStrokes","horizontalAlignment","HorizontalAlignment","LEFT","RIGHT","_collapseHandle","create","parent","collapseHandleButtonPressed","registerKeyStrokes","setHorizontalAlignment","destroy","leftVisible","rightVisible","minimized","minimizable","_isMinimizable","positionTypeFirstField","positionNotAccordingCollapsibleField","setLeftVisible","setRightVisible","getEffectiveSplitterPosition","_renderMinSplitterPosition","setFieldMinimized","toggleClass","setMinimizeEnabled","enabled","_isSplitterPositionInMinimalRange","_renderMinimizeEnabled","keyStroke","updateFieldMinimizedState","max","min","positionChanged","trigger","position","_updateFieldMinimized","toggleFieldCollapsed","increaseField","right","fields","push","rendering","hasFirstField","isVisible","hasSecondField","hasTwoFields","hasOneField"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/splitbox/SplitBox.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  CollapseHandle,\n  CompositeField,\n  graphics,\n  GroupBox,\n  HtmlComponent,\n  HtmlEnvironment,\n  KeyStroke,\n  scout,\n  SplitBoxCollapseKeyStroke,\n  SplitBoxFirstCollapseKeyStroke,\n  SplitBoxLayout,\n  SplitBoxSecondCollapseKeyStroke\n} from '../../../index';\nimport $ from 'jquery';\n\nexport default class SplitBox extends CompositeField {\n\n  // noinspection DuplicatedCode\n  constructor() {\n    super();\n    this._addWidgetProperties(['firstField', 'secondField', 'collapsibleField']);\n    this._addPreserveOnPropertyChangeProperties(['collapsibleField']);\n\n    this.firstField = null;\n    this.secondField = null;\n    this.collapsibleField = null;\n    this.collapseKeyStroke = null;\n    this.fieldCollapsed = false;\n    this.toggleCollapseKeyStroke = null;\n    this.firstCollapseKeyStroke = null;\n    this.secondCollapseKeyStroke = null;\n    this.splitHorizontal = true; // true = split x-axis, false = split y-axis\n    this.splitterEnabled = true;\n    this.splitterPosition = 0.5;\n    this.minSplitterPosition = 0;\n    this.splitterPositionType = SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST;\n    this.fieldMinimized = false;\n    this.minimizeEnabled = true;\n\n    this._$splitArea = null;\n    this._$splitter = null;\n  }\n\n  static SPLITTER_POSITION_TYPE_RELATIVE_FIRST = 'relativeFirst';\n  static SPLITTER_POSITION_TYPE_RELATIVE_SECOND = 'relativeSecond';\n  static SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST = 'absoluteFirst';\n  static SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND = 'absoluteSecond';\n\n  _init(model) {\n    super._init(model);\n    this._setToggleCollapseKeyStroke(this.toggleCollapseKeyStroke);\n    this._setFirstCollapseKeyStroke(this.firstCollapseKeyStroke);\n    this._setSecondCollapseKeyStroke(this.secondCollapseKeyStroke);\n    this._updateCollapseHandle();\n    this._initResponsive();\n  }\n\n  /**\n   * Set the group boxes of the split box to responsive if not set otherwise.\n   */\n  _initResponsive() {\n    this.getFields().forEach(field => {\n      if (field instanceof GroupBox && field.responsive === null) {\n        field.setResponsive(true);\n      }\n    });\n  }\n\n  _render() {\n    this.addContainer(this.$parent, 'split-box');\n    // This widget does not support label, mandatoryIndicator and status\n\n    // Create split area\n    this._$splitArea = this.$parent.makeDiv('split-area');\n    this.addField(this._$splitArea);\n    this.htmlSplitArea = HtmlComponent.install(this._$splitArea, this.session);\n    this.htmlSplitArea.setLayout(new SplitBoxLayout(this));\n    this._$window = this.$parent.window();\n    this._$body = this.$parent.body();\n\n    // Add fields and splitter\n    if (this.firstField) {\n      this.firstField.render(this._$splitArea);\n      this.firstField.$container\n        .addClass('first-field')\n        .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n      this.firstField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n\n      if (this.secondField) {\n        this.secondField.render(this._$splitArea);\n        this.secondField.$container\n          .addClass('second-field')\n          .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        this.secondField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n\n        this._$splitter = this._$splitArea.appendDiv('splitter')\n          .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis')\n          .on('mousedown', resizeSplitter.bind(this));\n      }\n    }\n    this._updateFieldVisibilityClasses();\n\n    // --- Helper functions ---\n\n    function resizeSplitter(event) {\n      if (event.which !== 1) {\n        return; // only handle left mouse button\n      }\n      let mousePosition, splitAreaPosition, splitAreaSize, splitterSize, splitterPosition, $tempSplitter;\n      if (this.splitterEnabled) {\n        // Update mouse position (see resizeMove() for details)\n        mousePosition = {\n          x: event.pageX,\n          y: event.pageY\n        };\n\n        // Add listeners (we add them to the window to make sure we get the mouseup event even when the cursor it outside the window)\n        this._$window\n          .on('mousemove.splitbox', resizeMove.bind(this))\n          .on('mouseup.splitbox', resizeEnd.bind(this));\n        // Ensure the correct cursor is always shown while moving\n        this._$body.addClass(this.splitHorizontal ? 'col-resize' : 'row-resize');\n        $('iframe').addClass('dragging-in-progress');\n\n        // Get initial area and splitter bounds\n        splitAreaPosition = this._$splitArea.offset();\n        splitAreaSize = graphics.size(this._$splitArea, true);\n        splitterPosition = this._$splitter.offset();\n        splitterSize = graphics.size(this._$splitter, true);\n\n        // Create temporary splitter\n        $tempSplitter = this._$splitArea.appendDiv('temp-splitter')\n          .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        if (this.splitHorizontal) { // \"|\"\n          $tempSplitter.cssLeft(splitterPosition.left - splitAreaPosition.left);\n        } else { // \"--\"\n          $tempSplitter.cssTop(splitterPosition.top - splitAreaPosition.top);\n        }\n        this._$splitter.addClass('dragging');\n      }\n\n      let newSplitterPosition = this.splitterPosition;\n      let SNAP_SIZE = 10;\n\n      function resizeMove(event) {\n        if (event.pageX === mousePosition.x && event.pageY === mousePosition.y) {\n          // Chrome bug: https://code.google.com/p/chromium/issues/detail?id=161464\n          // When holding the mouse, but not moving it, a 'mousemove' event is fired every second nevertheless.\n          return;\n        }\n        mousePosition = {\n          x: event.pageX,\n          y: event.pageY\n        };\n\n        if (this.splitHorizontal) { // \"|\"\n          // Calculate target splitter position (in area)\n          let targetSplitterPositionLeft = event.pageX - splitAreaPosition.left;\n\n          // De-normalize minimum splitter position to allowed splitter range in pixel [minSplitterPositionLeft, maxSplitterPositionLeft]\n          let minSplitterPositionLeft;\n          let maxSplitterPositionLeft;\n\n          // Splitter width plus margin on right side, if temporary splitter position is x, the splitter div position is x-splitterOffset\n          let splitterOffset = Math.floor((splitterSize.width + HtmlEnvironment.get().fieldMandatoryIndicatorWidth) / 2);\n\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST) {\n            minSplitterPositionLeft = scout.nvl(this.minSplitterPosition, 0);\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            minSplitterPositionLeft = (splitAreaSize.width - splitterSize.width) * scout.nvl(this.minSplitterPosition, 0);\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            minSplitterPositionLeft = 0;\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - scout.nvl(this.minSplitterPosition, 0);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            minSplitterPositionLeft = 0;\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - Math.floor(scout.nvl(this.minSplitterPosition, 0) * (splitAreaSize.width - splitterSize.width));\n          }\n\n          // Snap to begin and end\n          let tempSplitterOffsetX = splitterOffset;\n\n          if (targetSplitterPositionLeft < (minSplitterPositionLeft + splitterOffset + SNAP_SIZE)) { // snap left if minimum position is reached (+ snap range)\n            targetSplitterPositionLeft = minSplitterPositionLeft; // set splitter directly to left minimal bound\n            tempSplitterOffsetX = 0; // setting splitter to left minimal bound, does not require an additional offset\n          } else if (targetSplitterPositionLeft > (maxSplitterPositionLeft - SNAP_SIZE)) {\n            targetSplitterPositionLeft = maxSplitterPositionLeft;\n          }\n\n          // Update temporary splitter\n          $tempSplitter.cssLeft(targetSplitterPositionLeft - tempSplitterOffsetX);\n\n          // Normalize target position (available splitter area is (splitAreaSize.width - splitterSize.width))\n          newSplitterPosition = (targetSplitterPositionLeft - tempSplitterOffsetX);\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            newSplitterPosition = newSplitterPosition / (splitAreaSize.width - splitterSize.width);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            newSplitterPosition = 1 - (newSplitterPosition / (splitAreaSize.width - splitterSize.width));\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            newSplitterPosition = splitAreaSize.width - splitterSize.width - newSplitterPosition;\n          }\n        } else { // \"--\"\n          // Calculate target splitter position (in area)\n          let targetSplitterPositionTop = event.pageY - splitAreaPosition.top;\n\n          // Snap to begin and end\n          let tempSplitterOffsetY = Math.floor(splitterSize.height / 2);\n          if (targetSplitterPositionTop < SNAP_SIZE) {\n            targetSplitterPositionTop = 0;\n            tempSplitterOffsetY = 0;\n          } else if (splitAreaSize.height - targetSplitterPositionTop < SNAP_SIZE) {\n            targetSplitterPositionTop = splitAreaSize.height;\n            tempSplitterOffsetY = splitterSize.height;\n          }\n\n          // Update temporary splitter\n          $tempSplitter.cssTop(targetSplitterPositionTop - tempSplitterOffsetY);\n          // Normalize target position\n          newSplitterPosition = targetSplitterPositionTop - tempSplitterOffsetY;\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            newSplitterPosition = newSplitterPosition / (splitAreaSize.height - splitterSize.height);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            newSplitterPosition = 1 - (newSplitterPosition / (splitAreaSize.height - splitterSize.height));\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            newSplitterPosition = splitAreaSize.height - newSplitterPosition - splitterSize.height;\n          }\n        }\n      }\n\n      function resizeEnd(event) {\n        if (event.which !== 1) {\n          return; // only handle left mouse button\n        }\n        // Remove listeners and reset cursor\n        this._$window\n          .off('mousemove.splitbox')\n          .off('mouseup.splitbox');\n        if ($tempSplitter) { // instead of check for this.splitterEnabled, if splitter is currently moving it must be finished correctly\n          this._$body.removeClass((this.splitHorizontal ? 'col-resize' : 'row-resize'));\n          $('iframe').removeClass('dragging-in-progress');\n\n          // Remove temporary splitter\n          $tempSplitter.remove();\n          this._$splitter.removeClass('dragging');\n\n          // Update split box\n          this.newSplitterPosition(newSplitterPosition, true);\n        }\n      }\n\n      return false;\n    }\n\n    function onInnerFieldPropertyChange(event) {\n      if (event.propertyName === 'visible') {\n        this._updateFieldVisibilityClasses();\n        // Mark layout as invalid\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderSplitterPosition();\n    this._renderSplitterEnabled();\n    this._renderCollapsibleField(); // renders collapsibleField _and_ fieldCollapsed\n    this._renderCollapseHandle(); // renders collapseHandle _and_ toggleCollapseKeyStroke _and_ firstCollapseKeyStroke _and_ secondCollapseKeyStroke\n    this._renderFieldMinimized();\n  }\n\n  _remove() {\n    this._$splitArea = null;\n    this._$splitter = null;\n    super._remove();\n  }\n\n  _setSplitterPosition(splitterPosition) {\n    this._setProperty('splitterPosition', splitterPosition);\n    // If splitter position is explicitly set by an event, no recalculation is necessary\n    this._oldSplitterPositionType = null;\n  }\n\n  _renderSplitterPosition() {\n    this.newSplitterPosition(this.splitterPosition, false); // do not update (override) field minimized if new position is set by model\n  }\n\n  _setSplitterPositionType(splitterPositionType) {\n    if (this.rendered && !this._oldSplitterPositionType) {\n      this._oldSplitterPositionType = this.splitterPositionType;\n      // We need to recalculate the splitter position. Because this requires the proper\n      // size of the split box, this can only be done in _renderSplitterPositionType().\n    }\n    this._setProperty('splitterPositionType', splitterPositionType);\n  }\n\n  _renderSplitterPositionType() {\n    if (this._oldSplitterPositionType) {\n      // splitterPositionType changed while the split box was rendered --> convert splitterPosition\n      // to the target type such that the current position in screen does not change.\n      let splitAreaSize = this.htmlSplitArea.size(),\n        splitterPosition = this.splitterPosition,\n        splitterSize = graphics.size(this._$splitter, true),\n        minSplitterPosition = this.minSplitterPosition,\n        totalSize = 0;\n      if (this.splitHorizontal) { // \"|\"\n        totalSize = splitAreaSize.width - splitterSize.width;\n      } else { // \"--\"\n        totalSize = splitAreaSize.height - splitterSize.height;\n      }\n\n      // Convert value depending on the old and new type system\n      let oldIsRelative = this._isSplitterPositionTypeRelative(this._oldSplitterPositionType);\n      let newIsRelative = this._isSplitterPositionTypeRelative(this.splitterPositionType);\n      let oldIsAbsolute = !oldIsRelative;\n      let newIsAbsolute = !newIsRelative;\n      if (oldIsRelative && newIsAbsolute) {\n        // From relative to absolute\n        if ((this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) ||\n          (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST)) {\n          splitterPosition = totalSize - (totalSize * splitterPosition); // changed from first to second field or from second to first field, invert splitter position\n        } else {\n          splitterPosition = totalSize * splitterPosition;\n        }\n        // convert minimum splitter position\n        if (minSplitterPosition) {\n          minSplitterPosition = totalSize * minSplitterPosition;\n        }\n      } else if (oldIsAbsolute && newIsRelative) {\n        // From absolute to relative\n        if ((this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) ||\n          (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST)) {\n          splitterPosition = (totalSize - splitterPosition) / totalSize; // changed from first to second field or from second to first field, invert splitter position\n        } else {\n          splitterPosition = splitterPosition / totalSize;\n        }\n\n        // convert minimum splitter position\n        if (minSplitterPosition) {\n          minSplitterPosition = minSplitterPosition / totalSize;\n        }\n      } else if (oldIsAbsolute && newIsAbsolute) {\n        splitterPosition = (totalSize - splitterPosition);\n        // do not convert minimum splitter position, unit did not change\n      } else { // oldIsRelative && newIsRelative\n        splitterPosition = 1 - splitterPosition;\n        // do not convert minimum splitter position, unit did not change\n      }\n      // set new minimum splitter position\n      this.setMinSplitterPosition(minSplitterPosition);\n\n      // Set as new splitter position\n      this._oldSplitterPositionType = null;\n      this.newSplitterPosition(splitterPosition, true);\n    }\n  }\n\n  _isSplitterPositionTypeRelative(positionType) {\n    return (positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) || (positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND);\n  }\n\n  _renderSplitterEnabled() {\n    if (this._$splitter) {\n      this._$splitter.setEnabled(this.splitterEnabled);\n    }\n  }\n\n  setFieldCollapsed(collapsed) {\n    this.setProperty('fieldCollapsed', collapsed);\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderFieldCollapsed() {\n    this._renderCollapsibleField();\n  }\n\n  setCollapsibleField(field) {\n    this.setProperty('collapsibleField', field);\n    this._updateCollapseHandle();\n  }\n\n  _updateCollapseHandle() {\n    // always unregister key stroke first (although it may have been added by _setToggleCollapseKeyStroke before)\n    if (this.toggleCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.toggleCollapseKeyStroke);\n    }\n    if (this.firstCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n    }\n    if (this.secondCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n    }\n\n    if (this.collapsibleField) {\n      let horizontalAlignment = CollapseHandle.HorizontalAlignment.LEFT;\n      if (this.collapsibleField !== this.firstField) {\n        horizontalAlignment = CollapseHandle.HorizontalAlignment.RIGHT;\n      }\n\n      if (!this._collapseHandle) {\n        // create new collapse handle\n        this._collapseHandle = scout.create('CollapseHandle', {\n          parent: this,\n          horizontalAlignment: horizontalAlignment\n        });\n        this._collapseHandle.on('action', this.collapseHandleButtonPressed.bind(this));\n        if (this.toggleCollapseKeyStroke) {\n          this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n        }\n        if (this.firstCollapseKeyStroke) {\n          this.registerKeyStrokes(this.firstCollapseKeyStroke);\n        }\n        if (this.secondCollapseKeyStroke) {\n          this.registerKeyStrokes(this.secondCollapseKeyStroke);\n        }\n        if (this.rendered) {\n          this._renderCollapseHandle();\n        }\n      } else {\n        // update existing collapse handle\n        this._collapseHandle.setHorizontalAlignment(horizontalAlignment);\n      }\n\n      this._updateCollapseHandleButtons();\n    } else {\n      if (this._collapseHandle) {\n        this._collapseHandle.destroy();\n        this._collapseHandle = null;\n      }\n    }\n  }\n\n  _updateCollapseHandleButtons() {\n    if (!this._collapseHandle) {\n      return;\n    }\n    let leftVisible, rightVisible,\n      collapsed = this.fieldCollapsed,\n      minimized = this.fieldMinimized,\n      minimizable = this._isMinimizable(),\n      positionTypeFirstField = ((this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) || (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST)),\n      positionNotAccordingCollapsibleField = (positionTypeFirstField && this.collapsibleField === this.secondField) || (!positionTypeFirstField && this.collapsibleField === this.firstField);\n\n    if (positionTypeFirstField) {\n      if (positionNotAccordingCollapsibleField) {\n        leftVisible = (!minimized && minimizable) || collapsed; // left = decrease collapsible field size. Decrease field in this order [minimized <- default <- collapsed]\n        rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [minimized -> default -> collapsed]\n      } else {\n        leftVisible = !collapsed; // left = increase collapsible field size. Increase field in this order [default <- minimized <- collapsed]\n        rightVisible = collapsed || (minimized && minimizable); // right = decrease collapsible field size. Decrease field in this order [default -> minimized -> collapsed]\n      }\n    } else {\n      if (positionNotAccordingCollapsibleField) {\n        leftVisible = !collapsed; // left = decrease collapsible field size. Decrease field in this order [collapsed <- default <- minimized]\n        rightVisible = (!minimized && minimizable) || collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> default -> minimized]\n      } else {\n        leftVisible = collapsed || (minimized && minimizable); // left = decrease collapsible field size. Decrease field in this order [collapsed <- minimized <- default]\n        rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> minimized -> default]\n      }\n    }\n\n    this._collapseHandle.setLeftVisible(leftVisible);\n    this._collapseHandle.setRightVisible(rightVisible);\n\n    // update allowed keystrokes\n    if (this.firstCollapseKeyStroke) {\n      if (leftVisible) {\n        this.registerKeyStrokes(this.firstCollapseKeyStroke);\n      } else {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n    }\n    if (this.secondCollapseKeyStroke) {\n      if (rightVisible) {\n        this.registerKeyStrokes(this.secondCollapseKeyStroke);\n      } else {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n    }\n  }\n\n  getEffectiveSplitterPosition() {\n    if (this._isMinimizable() && this.fieldMinimized) {\n      return this.minSplitterPosition;\n    }\n    return this.splitterPosition;\n  }\n\n  setMinSplitterPosition(minSplitterPosition) {\n    this.setProperty('minSplitterPosition', minSplitterPosition);\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderMinSplitterPosition() {\n    // minimum splitter position is considered automatically when layout is updated\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  setFieldMinimized(minimized) {\n    this.setProperty('fieldMinimized', minimized);\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderFieldMinimized() {\n    this.$container.removeClass('first-field-minimized second-field-minimized');\n    if (this.firstField) {\n      this.firstField.$container.removeClass('minimized');\n    }\n    if (this.secondField) {\n      this.secondField.$container.removeClass('minimized');\n    }\n    if (this.collapsibleField && this.fieldMinimized) {\n      this.collapsibleField.$container.addClass('minimized');\n      this.$container.toggleClass('first-field-minimized', this.firstField === this.collapsibleField);\n      this.$container.toggleClass('second-field-minimized', this.secondField === this.collapsibleField);\n    }\n\n    // field minimized state is considered automatically when layout is updated\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  setMinimizeEnabled(enabled) {\n    this.setProperty('minimizeEnabled', enabled);\n    if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(this.splitterPosition)) {\n      this.setFieldMinimized(true);\n    }\n\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderMinimizeEnabled() {\n    // minimize enabled is considered automatically when layout is updated\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  _isMinimizable() {\n    return !!this.minSplitterPosition && this.minimizeEnabled;\n  }\n\n  _renderCollapsibleField() {\n    this.$container.removeClass('first-field-collapsed second-field-collapsed');\n    if (this.firstField) {\n      this.firstField.$container.removeClass('collapsed');\n    }\n    if (this.secondField) {\n      this.secondField.$container.removeClass('collapsed');\n    }\n    if (this.collapsibleField && this.fieldCollapsed) {\n      this.collapsibleField.$container.addClass('collapsed');\n      this.$container.toggleClass('first-field-collapsed', this.firstField === this.collapsibleField);\n      this.$container.toggleClass('second-field-collapsed', this.secondField === this.collapsibleField);\n    }\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  _setToggleCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.toggleCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.collapseKeyStroke);\n      }\n      this.toggleCollapseKeyStroke = new SplitBoxCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n      }\n    }\n  }\n\n  _setFirstCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.firstCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n      this.firstCollapseKeyStroke = new SplitBoxFirstCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.firstCollapseKeyStroke);\n      }\n    }\n  }\n\n  _setSecondCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.secondCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n      this.secondCollapseKeyStroke = new SplitBoxSecondCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.secondCollapseKeyStroke);\n      }\n    }\n  }\n\n  _renderCollapseHandle() {\n    if (this._collapseHandle) {\n      this._collapseHandle.render();\n    }\n  }\n\n  newSplitterPosition(newSplitterPosition, updateFieldMinimizedState) {\n    if (this._isSplitterPositionTypeRelative(this.splitterPositionType)) {\n      // Ensure range 0..1\n      newSplitterPosition = Math.max(0, Math.min(1, newSplitterPosition));\n    } else {\n      // Ensure not negative\n      newSplitterPosition = Math.max(0, newSplitterPosition);\n    }\n\n    // Ensure splitter within allowed range, toggle field minimized state if new splitter position is within minimal range\n    if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(newSplitterPosition)) {\n      this.setFieldMinimized(true);\n      return;\n    }\n\n    // Set new value (send to server if changed\n    let positionChanged = (this.splitterPosition !== newSplitterPosition);\n    this.splitterPosition = newSplitterPosition;\n\n    if (positionChanged) {\n      this.trigger('positionChange', {\n        position: newSplitterPosition\n      });\n\n      if (updateFieldMinimizedState) {\n        this._updateFieldMinimized();\n      }\n    }\n\n    this._updateCollapseHandleButtons();\n\n    // Mark layout as invalid\n    this.htmlSplitArea.invalidateLayoutTree(false);\n  }\n\n  _updateFieldMinimized() {\n    if (this._isMinimizable()) {\n      this.setFieldMinimized(this._isSplitterPositionInMinimalRange(this.splitterPosition));\n    } else {\n      this.setFieldMinimized(false);\n    }\n  }\n\n  _isSplitterPositionInMinimalRange(newSplitterPosition) {\n    if (!this._isMinimizable()) {\n      return false;\n    }\n    return newSplitterPosition <= this.minSplitterPosition;\n  }\n\n  toggleFieldCollapsed() {\n    this.setFieldCollapsed(!this.fieldCollapsed);\n  }\n\n  collapseHandleButtonPressed(event) {\n    let collapsed = this.fieldCollapsed,\n      minimized = this.fieldMinimized,\n      minimizable = this._isMinimizable(),\n      positionTypeFirstField = ((this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) || (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST)),\n      increaseField = (!!event.left && !positionTypeFirstField) || (!!event.right && positionTypeFirstField);\n\n    if ((positionTypeFirstField && this.collapsibleField === this.secondField) || (!positionTypeFirstField && this.collapsibleField === this.firstField)) {\n      // Splitter is not positioned according (absolute or relative) to collapsible field\n      // - Mode toggles to increase collapsible field size: field collapsed --> field default --> field minimized\n      // - Mode toggles to decrease collapsible field size: field collapsed <-- field default <-- field minimized\n      if (increaseField) {\n        if (collapsed) {\n          // not possible, button is not visible (field is collapsed and cannot further increase its size)\n        } else if (minimized && minimizable) {\n          this.setFieldMinimized(false);\n        } else {\n          this.setFieldCollapsed(true);\n        }\n      } else {\n        if (collapsed) {\n          this.setFieldCollapsed(false);\n        } else if (minimized) {\n          // not possible, button is not visible (field is minimized and cannot further decrease its size)\n        } else if (minimizable) {\n          this.setFieldMinimized(true);\n        }\n      }\n    } else {\n      // Splitter is positioned according (absolute or relative) to collapsible field\n      // - Mode toggles to increase collapsible field size: field collapsed --> field minimized --> field default\n      // - Mode toggles to decrease collapsible field size: field collapsed <-- field minimized <-- field default\n      if (increaseField) {\n        if (collapsed) {\n          this.setFieldCollapsed(false);\n        } else if (minimized) {\n          this.setFieldMinimized(false);\n        } else {\n          // not possible, button is not visible (field has default size and cannot further increase its size)\n        }\n      } else {\n        if (collapsed) {\n          // not possible, button is not visible (field is collapsed and cannot further decrease its size)\n        } else if (minimized || !minimizable) {\n          this.setFieldCollapsed(true);\n        } else {\n          this.setFieldMinimized(true);\n        }\n      }\n    }\n  }\n\n  /**\n   * @override CompositeField.js\n   */\n  getFields() {\n    let fields = [];\n    if (this.firstField) {\n      fields.push(this.firstField);\n    }\n    if (this.secondField) {\n      fields.push(this.secondField);\n    }\n    return fields;\n  }\n\n  _updateFieldVisibilityClasses() {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    let hasFirstField = (this.firstField && this.firstField.isVisible());\n    let hasSecondField = (this.secondField && this.secondField.isVisible());\n    let hasTwoFields = hasFirstField && hasSecondField;\n    let hasOneField = !hasTwoFields && (hasFirstField || hasSecondField);\n\n    // Mark container if only one field is visible (i.e. there is no splitter)\n    this.$container.toggleClass('single-field', hasOneField);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}