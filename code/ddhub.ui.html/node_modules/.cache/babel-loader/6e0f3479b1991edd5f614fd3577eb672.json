{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, QueryBy, scout } from '../index';\nimport $ from 'jquery';\n\n/**\n * Base class for lookup calls. A concrete implementation of LookupCall.js which uses resources over a network\n * must deal with I/O errors and set, in case of an error, the 'exception' property on the returned lookup result.\n * The lookup call must _always_ return a result, otherwise the SmartField cannot work properly.\n */\nexport default class LookupCall {\n  constructor() {\n    this.session = null;\n    this.hierarchical = false;\n    this.loadIncremental = false;\n    this.batch = false; // indicates if the lookup call implements 'getByKeys' and therefore supports 'textsByKeys'\n\n    this.queryBy = null;\n    this.searchText = null; // used on QueryBy.TEXT\n    this.key = null; // used on QueryBy.KEY\n    this.keys = null; // used on QueryBy.KEYS\n    this.parentKey = null; // used on QueryBy.REC\n    this.active = null;\n    this.maxRowCount = 100; // A positive number, _not_ null or undefined! This value is not directly used by this class but a child class my use it to limit the returned row count.\n  }\n\n  init(model) {\n    scout.assertParameter('session', model.session);\n    this._init(model);\n  }\n  _init(model) {\n    $.extend(this, model);\n  }\n  setLoadIncremental(loadIncremental) {\n    this.loadIncremental = loadIncremental;\n  }\n  setHierarchical(hierarchical) {\n    this.hierarchical = hierarchical;\n  }\n  setBatch(batch) {\n    this.batch = batch;\n  }\n\n  /**\n   * @param {number} maxRowCount - a positive number, _not_ null or undefined!\n   */\n  setMaxRowCount(maxRowCount) {\n    this.maxRowCount = maxRowCount;\n  }\n\n  /**\n   * This method may be called directly on any LookupCall. For the key lookup an internal clone is created automatically.\n   *\n   * You should not override this function. Instead override <code>_textByKey</code>.\n   *\n   * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n   */\n  textByKey(key) {\n    if (objects.isNullOrUndefined(key)) {\n      return $.resolvedPromise('');\n    }\n    return this._textByKey(key);\n  }\n\n  /**\n   * Override this function to provide your own textByKey implementation.\n   *\n   * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n   */\n  _textByKey(key) {\n    return this.cloneForKey(key).execute().then(result => {\n      let lookupRow = LookupCall.firstLookupRow(result);\n      return lookupRow ? lookupRow.text : '';\n    });\n  }\n\n  /**\n   * This method may be called directly on any LookupCall. For the keys lookup an internal clone is created automatically.\n   *\n   * You should not override this function. Instead override <code>_textsByKeys</code>.\n   *\n   * @returns {Promise} which returns an object that maps every key to the text of the resolved lookup row\n   */\n  textsByKeys(keys) {\n    if (arrays.empty(keys)) {\n      return $.resolvedPromise({});\n    }\n    return this._textsByKeys(keys);\n  }\n\n  /**\n   * Override this function to provide your own textsByKeys implementation.\n   *\n   * @returns {Promise} which returns an object that maps every key to the text of the lookup row\n   */\n  _textsByKeys(keys) {\n    return this.cloneForKeys(keys).execute().then(result => {\n      if (!result || !objects.isArray(result.lookupRows)) {\n        return {};\n      }\n      const textMap = {};\n      result.lookupRows.forEach(row => {\n        textMap[objects.ensureValidKey(row.key)] = row.text;\n      });\n      return textMap;\n    });\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForAll().execute()</code> or <code>.clone().getAll()</code>.\n   *\n   * You should not override this function. Instead override <code>_getAll</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   */\n  getAll() {\n    this.queryBy = QueryBy.ALL;\n    return this._getAll();\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getAll() {\n    throw new Error('getAll() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForText(text).execute()</code> or <code>.clone().getByText(text)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByText</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   */\n  getByText(text) {\n    this.queryBy = QueryBy.TEXT;\n    this.searchText = text;\n    return this._getByText(text);\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByText(text) {\n    throw new Error('getByText() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKey(key).execute()</code> or <code>.clone().getByKey(parentKey)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByKey</code>.\n   *\n   * @return {Promise} resolves to a result object with a single {LookupRow}\n   */\n  getByKey(key) {\n    this.queryBy = QueryBy.KEY;\n    this.key = key;\n    return this._getByKey(key);\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByKey(key) {\n    throw new Error('getByKey() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKeys(keys).execute()</code> or <code>.clone().getByKeys(keys)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByKeys</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {scout.LookupRow}s\n   */\n  getByKeys(keys) {\n    this.queryBy = QueryBy.KEYS;\n    this.keys = keys;\n    return this._getByKeys(keys);\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByKeys(keys) {\n    throw new Error('getByKeys() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForRec(parentKey).execute()</code> or <code>.clone().getByRec(parentKey)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByRec</code>.\n   *\n   * Returns a result with lookup rows for the given parent key. This is used for incremental lookups.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   * @param {object} parentKey references the parent key\n   */\n  getByRec(parentKey) {\n    this.queryBy = QueryBy.REC;\n    this.parentKey = parentKey;\n    if (objects.isNullOrUndefined(parentKey)) {\n      // Lookup rows with key = null cannot act as parent since lookup rows with parentKey = null are always top level\n      return this._emptyRecResult(parentKey);\n    }\n    return this._getByRec(parentKey);\n  }\n  _emptyRecResult(rec) {\n    return $.resolvedPromise({\n      queryBy: QueryBy.REC,\n      rec: rec,\n      lookupRows: []\n    });\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByRec(rec) {\n    throw new Error('getByRec() not implemented');\n  }\n\n  /**\n   * Executes this LookupCall. For this method to work this LookupCall must be a clone created with one of the following methods:\n   * <code>cloneForAll()</code>, <code>cloneForText(text)</code>, <code>cloneForKey(key)</code>, <code>cloneForRec(parentKey)</code>\n   */\n  execute() {\n    if (QueryBy.KEY === this.queryBy) {\n      return this._getByKey(this.key);\n    }\n    if (QueryBy.ALL === this.queryBy) {\n      return this._getAll();\n    }\n    if (QueryBy.KEYS === this.queryBy) {\n      return this._getByKeys(this.keys);\n    }\n    if (QueryBy.TEXT === this.queryBy) {\n      return this._getByText(this.searchText);\n    }\n    if (QueryBy.REC === this.queryBy) {\n      if (objects.isNullOrUndefined(this.parentKey)) {\n        // Lookup rows with key = null cannot act as parent since lookup rows with parentKey = null are always top level\n        return this._emptyRecResult(this.parentKey);\n      }\n      return this._getByRec(this.parentKey);\n    }\n    throw new Error('cannot execute a non-clone LookupCall. Use one of the cloneFor*-methods before executing.');\n  }\n  clone(properties) {\n    // Warning: This is _not_ a deep clone! (Because otherwise the entire session would be duplicated.)\n    // Non-primitive properties must _only_ be added to the resulting clone during the 'prepareLookupCall' event!\n    return scout.cloneShallow(this, properties, true);\n  }\n  cloneForAll() {\n    return this.clone({\n      queryBy: QueryBy.ALL\n    });\n  }\n  cloneForText(text) {\n    return this.clone({\n      queryBy: QueryBy.TEXT,\n      searchText: text\n    });\n  }\n  cloneForKey(key) {\n    return this.clone({\n      queryBy: QueryBy.KEY,\n      key: key\n    });\n  }\n  cloneForKeys(keys) {\n    return this.clone({\n      queryBy: QueryBy.KEYS,\n      keys: keys\n    });\n  }\n  cloneForRec(parentKey) {\n    return this.clone({\n      queryBy: QueryBy.REC,\n      parentKey: parentKey\n    });\n  }\n  abort() {\n    // NOP. Implement in subclasses if necessary.\n  }\n\n  // ---- static helpers ----\n\n  static ensure(lookupCall, session) {\n    if (lookupCall instanceof LookupCall) {\n      // NOP - required to distinct instance from plain object (=model)\n    } else if (objects.isPlainObject(lookupCall)) {\n      lookupCall.session = session;\n      lookupCall = scout.create(lookupCall);\n    } else if (typeof lookupCall === 'string') {\n      lookupCall = scout.create(lookupCall, {\n        session: session\n      });\n    }\n    return lookupCall;\n  }\n  static firstLookupRow(result) {\n    if (!result) {\n      return null;\n    }\n    if (!objects.isArray(result.lookupRows)) {\n      return null;\n    }\n    if (result.lookupRows.length === 0) {\n      return null;\n    }\n    return result.lookupRows[0];\n  }\n\n  /**\n   * @typedef LookupResult\n   * @property {LookupRow[]} lookupRows\n   * @property {string} queryBy a value of the QueryBy object\n   * @property {boolean} byAll\n   * @property {boolean} byText\n   * @property {boolean} byKey\n   * @property {boolean} byKeys\n   * @property {boolean} byRec\n   * @property {boolean} rec\n   * @property {boolean} appendResult\n   * @property {boolean} uniqueMatch\n   * @property {number} seqNo\n   */\n}","map":{"version":3,"names":["arrays","objects","QueryBy","scout","$","LookupCall","constructor","session","hierarchical","loadIncremental","batch","queryBy","searchText","key","keys","parentKey","active","maxRowCount","init","model","assertParameter","_init","extend","setLoadIncremental","setHierarchical","setBatch","setMaxRowCount","textByKey","isNullOrUndefined","resolvedPromise","_textByKey","cloneForKey","execute","then","result","lookupRow","firstLookupRow","text","textsByKeys","empty","_textsByKeys","cloneForKeys","isArray","lookupRows","textMap","forEach","row","ensureValidKey","getAll","ALL","_getAll","Error","getByText","TEXT","_getByText","getByKey","KEY","_getByKey","getByKeys","KEYS","_getByKeys","getByRec","REC","_emptyRecResult","_getByRec","rec","clone","properties","cloneShallow","cloneForAll","cloneForText","cloneForRec","abort","ensure","lookupCall","isPlainObject","create","length"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/lookup/LookupCall.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, QueryBy, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * Base class for lookup calls. A concrete implementation of LookupCall.js which uses resources over a network\n * must deal with I/O errors and set, in case of an error, the 'exception' property on the returned lookup result.\n * The lookup call must _always_ return a result, otherwise the SmartField cannot work properly.\n */\nexport default class LookupCall {\n\n  constructor() {\n    this.session = null;\n    this.hierarchical = false;\n    this.loadIncremental = false;\n    this.batch = false; // indicates if the lookup call implements 'getByKeys' and therefore supports 'textsByKeys'\n\n    this.queryBy = null;\n    this.searchText = null; // used on QueryBy.TEXT\n    this.key = null; // used on QueryBy.KEY\n    this.keys = null; // used on QueryBy.KEYS\n    this.parentKey = null; // used on QueryBy.REC\n    this.active = null;\n    this.maxRowCount = 100; // A positive number, _not_ null or undefined! This value is not directly used by this class but a child class my use it to limit the returned row count.\n  }\n\n  init(model) {\n    scout.assertParameter('session', model.session);\n    this._init(model);\n  }\n\n  _init(model) {\n    $.extend(this, model);\n  }\n\n  setLoadIncremental(loadIncremental) {\n    this.loadIncremental = loadIncremental;\n  }\n\n  setHierarchical(hierarchical) {\n    this.hierarchical = hierarchical;\n  }\n\n  setBatch(batch) {\n    this.batch = batch;\n  }\n\n  /**\n   * @param {number} maxRowCount - a positive number, _not_ null or undefined!\n   */\n  setMaxRowCount(maxRowCount) {\n    this.maxRowCount = maxRowCount;\n  }\n\n  /**\n   * This method may be called directly on any LookupCall. For the key lookup an internal clone is created automatically.\n   *\n   * You should not override this function. Instead override <code>_textByKey</code>.\n   *\n   * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n   */\n  textByKey(key) {\n    if (objects.isNullOrUndefined(key)) {\n      return $.resolvedPromise('');\n    }\n    return this._textByKey(key);\n  }\n\n  /**\n   * Override this function to provide your own textByKey implementation.\n   *\n   * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n   */\n  _textByKey(key) {\n    return this\n      .cloneForKey(key)\n      .execute()\n      .then(result => {\n        let lookupRow = LookupCall.firstLookupRow(result);\n        return lookupRow ? lookupRow.text : '';\n      });\n  }\n\n  /**\n   * This method may be called directly on any LookupCall. For the keys lookup an internal clone is created automatically.\n   *\n   * You should not override this function. Instead override <code>_textsByKeys</code>.\n   *\n   * @returns {Promise} which returns an object that maps every key to the text of the resolved lookup row\n   */\n  textsByKeys(keys) {\n    if (arrays.empty(keys)) {\n      return $.resolvedPromise({});\n    }\n    return this._textsByKeys(keys);\n  }\n\n  /**\n   * Override this function to provide your own textsByKeys implementation.\n   *\n   * @returns {Promise} which returns an object that maps every key to the text of the lookup row\n   */\n  _textsByKeys(keys) {\n    return this\n      .cloneForKeys(keys)\n      .execute()\n      .then(result => {\n        if (!result || !objects.isArray(result.lookupRows)) {\n          return {};\n        }\n\n        const textMap = {};\n        result.lookupRows.forEach(row => {\n          textMap[objects.ensureValidKey(row.key)] = row.text;\n        });\n\n        return textMap;\n      });\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForAll().execute()</code> or <code>.clone().getAll()</code>.\n   *\n   * You should not override this function. Instead override <code>_getAll</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   */\n  getAll() {\n    this.queryBy = QueryBy.ALL;\n    return this._getAll();\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getAll() {\n    throw new Error('getAll() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForText(text).execute()</code> or <code>.clone().getByText(text)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByText</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   */\n  getByText(text) {\n    this.queryBy = QueryBy.TEXT;\n    this.searchText = text;\n    return this._getByText(text);\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByText(text) {\n    throw new Error('getByText() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKey(key).execute()</code> or <code>.clone().getByKey(parentKey)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByKey</code>.\n   *\n   * @return {Promise} resolves to a result object with a single {LookupRow}\n   */\n  getByKey(key) {\n    this.queryBy = QueryBy.KEY;\n    this.key = key;\n    return this._getByKey(key);\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByKey(key) {\n    throw new Error('getByKey() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKeys(keys).execute()</code> or <code>.clone().getByKeys(keys)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByKeys</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {scout.LookupRow}s\n   */\n  getByKeys(keys) {\n    this.queryBy = QueryBy.KEYS;\n    this.keys = keys;\n    return this._getByKeys(keys);\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByKeys(keys) {\n    throw new Error('getByKeys() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForRec(parentKey).execute()</code> or <code>.clone().getByRec(parentKey)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByRec</code>.\n   *\n   * Returns a result with lookup rows for the given parent key. This is used for incremental lookups.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   * @param {object} parentKey references the parent key\n   */\n  getByRec(parentKey) {\n    this.queryBy = QueryBy.REC;\n    this.parentKey = parentKey;\n    if (objects.isNullOrUndefined(parentKey)) {\n      // Lookup rows with key = null cannot act as parent since lookup rows with parentKey = null are always top level\n      return this._emptyRecResult(parentKey);\n    }\n    return this._getByRec(parentKey);\n  }\n\n  _emptyRecResult(rec) {\n    return $.resolvedPromise({\n      queryBy: QueryBy.REC,\n      rec: rec,\n      lookupRows: []\n    });\n  }\n\n  /**\n   * Override this method to implement.\n   * @returns {Promise}\n   */\n  _getByRec(rec) {\n    throw new Error('getByRec() not implemented');\n  }\n\n  /**\n   * Executes this LookupCall. For this method to work this LookupCall must be a clone created with one of the following methods:\n   * <code>cloneForAll()</code>, <code>cloneForText(text)</code>, <code>cloneForKey(key)</code>, <code>cloneForRec(parentKey)</code>\n   */\n  execute() {\n    if (QueryBy.KEY === this.queryBy) {\n      return this._getByKey(this.key);\n    }\n    if (QueryBy.ALL === this.queryBy) {\n      return this._getAll();\n    }\n    if (QueryBy.KEYS === this.queryBy) {\n      return this._getByKeys(this.keys);\n    }\n    if (QueryBy.TEXT === this.queryBy) {\n      return this._getByText(this.searchText);\n    }\n    if (QueryBy.REC === this.queryBy) {\n      if (objects.isNullOrUndefined(this.parentKey)) {\n        // Lookup rows with key = null cannot act as parent since lookup rows with parentKey = null are always top level\n        return this._emptyRecResult(this.parentKey);\n      }\n      return this._getByRec(this.parentKey);\n    }\n    throw new Error('cannot execute a non-clone LookupCall. Use one of the cloneFor*-methods before executing.');\n  }\n\n  clone(properties) {\n    // Warning: This is _not_ a deep clone! (Because otherwise the entire session would be duplicated.)\n    // Non-primitive properties must _only_ be added to the resulting clone during the 'prepareLookupCall' event!\n    return scout.cloneShallow(this, properties, true);\n  }\n\n  cloneForAll() {\n    return this.clone({\n      queryBy: QueryBy.ALL\n    });\n  }\n\n  cloneForText(text) {\n    return this.clone({\n      queryBy: QueryBy.TEXT,\n      searchText: text\n    });\n  }\n\n  cloneForKey(key) {\n    return this.clone({\n      queryBy: QueryBy.KEY,\n      key: key\n    });\n  }\n\n  cloneForKeys(keys) {\n    return this.clone({\n      queryBy: QueryBy.KEYS,\n      keys: keys\n    });\n  }\n\n  cloneForRec(parentKey) {\n    return this.clone({\n      queryBy: QueryBy.REC,\n      parentKey: parentKey\n    });\n  }\n\n  abort() {\n    // NOP. Implement in subclasses if necessary.\n  }\n\n  // ---- static helpers ----\n\n  static ensure(lookupCall, session) {\n    if (lookupCall instanceof LookupCall) {\n      // NOP - required to distinct instance from plain object (=model)\n    } else if (objects.isPlainObject(lookupCall)) {\n      lookupCall.session = session;\n      lookupCall = scout.create(lookupCall);\n    } else if (typeof lookupCall === 'string') {\n      lookupCall = scout.create(lookupCall, {\n        session: session\n      });\n    }\n    return lookupCall;\n  }\n\n  static firstLookupRow(result) {\n    if (!result) {\n      return null;\n    }\n    if (!objects.isArray(result.lookupRows)) {\n      return null;\n    }\n    if (result.lookupRows.length === 0) {\n      return null;\n    }\n    return result.lookupRows[0];\n  }\n\n  /**\n   * @typedef LookupResult\n   * @property {LookupRow[]} lookupRows\n   * @property {string} queryBy a value of the QueryBy object\n   * @property {boolean} byAll\n   * @property {boolean} byText\n   * @property {boolean} byKey\n   * @property {boolean} byKeys\n   * @property {boolean} byRec\n   * @property {boolean} rec\n   * @property {boolean} appendResult\n   * @property {boolean} uniqueMatch\n   * @property {number} seqNo\n   */\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}