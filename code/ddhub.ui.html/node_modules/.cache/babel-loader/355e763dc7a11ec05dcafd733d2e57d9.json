{"ast":null,"code":"/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AbstractGrid, LogicalGridMatrix, LogicalGridMatrixCell, LogicalGridMatrixCursor } from '../../../index';\nexport default class VerticalGridMatrix extends LogicalGridMatrix {\n  constructor(columnCount, rowCount, x, y) {\n    super(new LogicalGridMatrixCursor(x || 0, y || 0, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL));\n    this._widgets = [];\n    this._widgetGridDatas = [];\n  }\n  resetAll(columnCount, rowCount) {\n    this._widgetGridDatas = [];\n    this._assignedCells = [];\n    this._widgetIndexes = [];\n    this._cursor = new LogicalGridMatrixCursor(this._cursor.startX, this._cursor.startY, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL);\n  }\n  computeGridData(widgets) {\n    this._widgets = widgets;\n    return widgets.every((f, i) => {\n      this._widgetGridDatas[i] = AbstractGrid.getGridDataFromHints(f, this._cursor.columnCount);\n      return this._add(f, this._widgetGridDatas[i]);\n    });\n  }\n  getGridData(f) {\n    return this._widgetGridDatas[this._widgets.indexOf(f)];\n  }\n  _addAssignedCells(cells) {\n    cells.forEach((v, i) => {\n      if (v) {\n        v.forEach((w, j) => {\n          if (w) {\n            this._setAssignedCell({\n              x: i,\n              y: j\n            }, w);\n          }\n        });\n      }\n    });\n  }\n  _getAssignedCells() {\n    return this._assignedCells;\n  }\n  _add(f, gd) {\n    let idx = this._cursor.currentIndex();\n    if (gd.w > 1) {\n      // try to reorganize widgets above\n      let x = idx.x,\n        y = idx.y;\n      // try to move left if the right border of the widget is outside the column range\n      while (x + gd.w > this._cursor.startX + this._cursor.columnCount) {\n        // shift left and bottom\n        x--;\n        y = this._cursor.rowCount - 1;\n      }\n      this._reorganizeGridAbove(x, y, gd.w);\n    }\n    if (!this._nextFree(gd.w, gd.h)) {\n      return false;\n    }\n    idx = this._cursor.currentIndex();\n    gd.x = idx.x;\n    gd.y = idx.y;\n    // add widget\n    for (let xx = idx.x; xx < idx.x + gd.w; xx++) {\n      for (let yy = idx.y; yy < idx.y + gd.h; yy++) {\n        this._setAssignedCell({\n          x: xx,\n          y: yy\n        }, new LogicalGridMatrixCell(f, gd));\n      }\n    }\n    return true;\n  }\n  _reorganizeGridAbove(x, y, w) {\n    let widgetsToReorganize = [];\n    let addWidgetToReorganize = f => {\n      if (widgetsToReorganize.indexOf(f) === -1) {\n        widgetsToReorganize.push(f);\n      }\n    };\n    let occupiedCells = [];\n    let setOccupiedCell = (x, y, val) => {\n      if (!occupiedCells[x]) {\n        occupiedCells[x] = [];\n      }\n      occupiedCells[x][y] = val;\n    };\n    let reorgBounds = {\n      x: x,\n      y: 0,\n      w: w,\n      h: y + 1\n    }; // x, y, w, h\n\n    let minY = y;\n    let usedCells = 0;\n    let continueLoop = true;\n    for (let yi = y; yi >= 0 && continueLoop; yi--) {\n      for (let xi = x; xi < x + w && continueLoop; xi++) {\n        let idx = {\n          x: xi,\n          y: yi\n        };\n        let cell = this._getAssignedCell(idx);\n        if (cell && !cell.isEmpty()) {\n          let gd = cell.data;\n          if (this._horizontalMatchesOrOverlaps(reorgBounds, gd)) {\n            continueLoop = false;\n          } else if (this._horizontalOverlapsOnSide(reorgBounds, gd)) {\n            // freeze the cells for reorganization\n            setOccupiedCell(idx.x, idx.y, cell);\n            usedCells++;\n            minY = Math.min(idx.y, minY);\n          } else {\n            // add widget to reorganization\n            this._setAssignedCell(idx, null);\n            addWidgetToReorganize(cell.widget);\n            usedCells++;\n            minY = Math.min(idx.y, minY);\n          }\n        }\n      }\n    }\n    if (widgetsToReorganize.length === 0) {\n      return;\n    }\n    widgetsToReorganize.sort((a, b) => {\n      return this._widgets.indexOf(a) < this._widgets.indexOf(b) ? -1 : 1;\n    });\n    reorgBounds.y = minY;\n    let reorgMatrix = new VerticalGridMatrix(reorgBounds.w, Math.floor((usedCells + reorgBounds.w - 1) / reorgBounds.w), reorgBounds.x, reorgBounds.y);\n    reorgMatrix._addAssignedCells(occupiedCells);\n    while (!reorgMatrix.computeGridData(widgetsToReorganize)) {\n      reorgMatrix.resetAll(reorgMatrix.getColumnCount(), reorgMatrix.getRowCount() + 1);\n    }\n    this._cursor.reset();\n    this._addAssignedCells(reorgMatrix._getAssignedCells());\n    reorgMatrix._widgetGridDatas.forEach((v, i) => {\n      this._widgetGridDatas[this._widgets.indexOf(reorgMatrix._widgets[i])] = v;\n    });\n  }\n  _horizontalMatchesOrOverlaps(bounds, gd) {\n    return bounds.x >= gd.x && bounds.x + bounds.w <= gd.x + gd.w;\n  }\n  _horizontalOverlapsOnSide(bounds, gd) {\n    return bounds.x > gd.x || bounds.x + bounds.w < gd.x + gd.w;\n  }\n}","map":{"version":3,"names":["AbstractGrid","LogicalGridMatrix","LogicalGridMatrixCell","LogicalGridMatrixCursor","VerticalGridMatrix","constructor","columnCount","rowCount","x","y","VERTICAL","_widgets","_widgetGridDatas","resetAll","_assignedCells","_widgetIndexes","_cursor","startX","startY","computeGridData","widgets","every","f","i","getGridDataFromHints","_add","getGridData","indexOf","_addAssignedCells","cells","forEach","v","w","j","_setAssignedCell","_getAssignedCells","gd","idx","currentIndex","_reorganizeGridAbove","_nextFree","h","xx","yy","widgetsToReorganize","addWidgetToReorganize","push","occupiedCells","setOccupiedCell","val","reorgBounds","minY","usedCells","continueLoop","yi","xi","cell","_getAssignedCell","isEmpty","data","_horizontalMatchesOrOverlaps","_horizontalOverlapsOnSide","Math","min","widget","length","sort","a","b","reorgMatrix","floor","getColumnCount","getRowCount","reset","bounds"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/layout/logicalgrid/matrix/VerticalGridMatrix.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {AbstractGrid, LogicalGridMatrix, LogicalGridMatrixCell, LogicalGridMatrixCursor} from '../../../index';\n\nexport default class VerticalGridMatrix extends LogicalGridMatrix {\n\n  constructor(columnCount, rowCount, x, y) {\n    super(new LogicalGridMatrixCursor(x || 0, y || 0, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL));\n\n    this._widgets = [];\n    this._widgetGridDatas = [];\n  }\n\n  resetAll(columnCount, rowCount) {\n    this._widgetGridDatas = [];\n    this._assignedCells = [];\n    this._widgetIndexes = [];\n    this._cursor = new LogicalGridMatrixCursor(this._cursor.startX, this._cursor.startY, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL);\n  }\n\n  computeGridData(widgets) {\n    this._widgets = widgets;\n    return widgets.every((f, i) => {\n      this._widgetGridDatas[i] = AbstractGrid.getGridDataFromHints(f, this._cursor.columnCount);\n      return this._add(f, this._widgetGridDatas[i]);\n    });\n  }\n\n  getGridData(f) {\n    return this._widgetGridDatas[this._widgets.indexOf(f)];\n  }\n\n  _addAssignedCells(cells) {\n    cells.forEach((v, i) => {\n      if (v) {\n        v.forEach((w, j) => {\n          if (w) {\n            this._setAssignedCell({\n              x: i,\n              y: j\n            }, w);\n          }\n        });\n      }\n    });\n  }\n\n  _getAssignedCells() {\n    return this._assignedCells;\n  }\n\n  _add(f, gd) {\n    let idx = this._cursor.currentIndex();\n    if (gd.w > 1) {\n      // try to reorganize widgets above\n      let x = idx.x,\n        y = idx.y;\n      // try to move left if the right border of the widget is outside the column range\n      while (x + gd.w > this._cursor.startX + this._cursor.columnCount) {\n        // shift left and bottom\n        x--;\n        y = this._cursor.rowCount - 1;\n      }\n      this._reorganizeGridAbove(x, y, gd.w);\n    }\n    if (!this._nextFree(gd.w, gd.h)) {\n      return false;\n    }\n    idx = this._cursor.currentIndex();\n    gd.x = idx.x;\n    gd.y = idx.y;\n    // add widget\n    for (let xx = idx.x; xx < idx.x + gd.w; xx++) {\n      for (let yy = idx.y; yy < idx.y + gd.h; yy++) {\n        this._setAssignedCell({\n          x: xx,\n          y: yy\n        }, new LogicalGridMatrixCell(f, gd));\n      }\n    }\n    return true;\n  }\n\n  _reorganizeGridAbove(x, y, w) {\n    let widgetsToReorganize = [];\n    let addWidgetToReorganize = f => {\n      if (widgetsToReorganize.indexOf(f) === -1) {\n        widgetsToReorganize.push(f);\n      }\n    };\n    let occupiedCells = [];\n    let setOccupiedCell = (x, y, val) => {\n      if (!occupiedCells[x]) {\n        occupiedCells[x] = [];\n      }\n      occupiedCells[x][y] = val;\n    };\n    let reorgBounds = {\n      x: x,\n      y: 0,\n      w: w,\n      h: y + 1\n    }; // x, y, w, h\n\n    let minY = y;\n    let usedCells = 0;\n    let continueLoop = true;\n    for (let yi = y; yi >= 0 && continueLoop; yi--) {\n      for (let xi = x; xi < x + w && continueLoop; xi++) {\n        let idx = {\n          x: xi,\n          y: yi\n        };\n        let cell = this._getAssignedCell(idx);\n        if (cell && !cell.isEmpty()) {\n          let gd = cell.data;\n          if (this._horizontalMatchesOrOverlaps(reorgBounds, gd)) {\n            continueLoop = false;\n          } else if (this._horizontalOverlapsOnSide(reorgBounds, gd)) {\n            // freeze the cells for reorganization\n            setOccupiedCell(idx.x, idx.y, cell);\n            usedCells++;\n            minY = Math.min(idx.y, minY);\n          } else {\n            // add widget to reorganization\n            this._setAssignedCell(idx, null);\n            addWidgetToReorganize(cell.widget);\n            usedCells++;\n            minY = Math.min(idx.y, minY);\n          }\n        }\n      }\n    }\n    if (widgetsToReorganize.length === 0) {\n      return;\n    }\n    widgetsToReorganize.sort((a, b) => {\n      return this._widgets.indexOf(a) < this._widgets.indexOf(b) ? -1 : 1;\n    });\n    reorgBounds.y = minY;\n\n    let reorgMatrix = new VerticalGridMatrix(reorgBounds.w, Math.floor((usedCells + reorgBounds.w - 1) / reorgBounds.w), reorgBounds.x, reorgBounds.y);\n    reorgMatrix._addAssignedCells(occupiedCells);\n    while (!reorgMatrix.computeGridData(widgetsToReorganize)) {\n      reorgMatrix.resetAll(reorgMatrix.getColumnCount(), reorgMatrix.getRowCount() + 1);\n    }\n    this._cursor.reset();\n    this._addAssignedCells(reorgMatrix._getAssignedCells());\n    reorgMatrix._widgetGridDatas.forEach((v, i) => {\n      this._widgetGridDatas[this._widgets.indexOf(reorgMatrix._widgets[i])] = v;\n    });\n  }\n\n  _horizontalMatchesOrOverlaps(bounds, gd) {\n    return bounds.x >= gd.x && bounds.x + bounds.w <= gd.x + gd.w;\n  }\n\n  _horizontalOverlapsOnSide(bounds, gd) {\n    return bounds.x > gd.x || bounds.x + bounds.w < gd.x + gd.w;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}