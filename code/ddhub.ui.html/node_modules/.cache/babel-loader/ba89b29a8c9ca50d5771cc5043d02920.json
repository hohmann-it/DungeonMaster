{"ast":null,"code":"/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ObjectFactory, scout, strings } from './index';\n\n/**\n * This class contains a structured type description for a Scout class.\n * The model variant is optional.\n *\n * @param {string} typeDescriptor a string in the format '[namespace(s).]objectType[[:namespace(s).]modelVariant]'\n * @param {object} objectType\n * @param {object} [modelVariant]\n * @constructor\n */\nexport default class TypeDescriptor {\n  constructor(typeDescriptor, objectType, modelVariant) {\n    this.typeDescriptor = typeDescriptor;\n    this.objectType = objectType;\n    this.modelVariant = modelVariant;\n  }\n  createInstance(options) {\n    let i,\n      namespaces,\n      className,\n      namespace = window.scout; // default namespace\n\n    if (this.modelVariant) {\n      className = this.modelVariant.name + this.objectType.name;\n      namespaces = this.modelVariant.namespaces;\n    } else {\n      className = this.objectType.name;\n      namespaces = this.objectType.namespaces;\n    }\n    if (namespaces.length) {\n      namespace = window;\n      for (i = 0; i < namespaces.length; i++) {\n        namespace = namespace[namespaces[i]];\n        if (!namespace) {\n          throw this.error('Could not resolve namespace \"' + namespaces[i] + '\"');\n        }\n      }\n    }\n    if (!namespace[className]) {\n      // Try without variant if variantLenient is true\n      if (options.variantLenient && this.modelVariant) {\n        let infoWithoutVariant = new TypeDescriptor(this.typeDescriptor, this.objectType, null);\n        return infoWithoutVariant.createInstance(options);\n      }\n      throw this.error('Could not find \"' + className + '\" in namespace \"' + namespaces.join('.') + '\"');\n    }\n    return new namespace[className](options.model);\n  }\n  error(details) {\n    return new Error('Failed to create object for objectType \"' + this.typeDescriptor + '\": ' + details);\n  }\n  static newInstance(typeDescriptor, options) {\n    let info = TypeDescriptor.parse(typeDescriptor);\n    return info.createInstance(options);\n  }\n\n  /**\n   * @param {string} typeDescriptor\n   * @returns {TypeDescriptor}\n   * @static\n   */\n  static parse(typeDescriptor) {\n    let typePart = null,\n      variantPart = null;\n    if (strings.contains(typeDescriptor, ObjectFactory.MODEL_VARIANT_SEPARATOR)) {\n      let tmp = typeDescriptor.split(ObjectFactory.MODEL_VARIANT_SEPARATOR);\n      typePart = parseDescriptorPart(tmp[0]);\n      variantPart = parseDescriptorPart(tmp[1]);\n\n      // when type has namespaces but the variant has not, use type namespaces for variant too\n      if (arrays.empty(variantPart.namespaces) && !arrays.empty(typePart.namespaces)) {\n        variantPart.namespaces = typePart.namespaces;\n      }\n    } else {\n      typePart = parseDescriptorPart(typeDescriptor);\n    }\n    return new TypeDescriptor(typeDescriptor, typePart, variantPart);\n    function createInfo(name, namespaces) {\n      return {\n        name: name,\n        namespaces: scout.nvl(namespaces, []),\n        toString: () => {\n          let parts = namespaces.slice();\n          parts.push(name);\n          return strings.join(ObjectFactory.NAMESPACE_SEPARATOR, parts);\n        }\n      };\n    }\n    function parseDescriptorPart(descriptorPart) {\n      let namespaces = [];\n      if (strings.contains(descriptorPart, ObjectFactory.NAMESPACE_SEPARATOR)) {\n        let namespaceParts = descriptorPart.split(ObjectFactory.NAMESPACE_SEPARATOR);\n        namespaces = namespaceParts.slice(0, namespaceParts.length - 1);\n        descriptorPart = arrays.last(namespaceParts);\n      }\n      return createInfo(descriptorPart, namespaces);\n    }\n  }\n}","map":{"version":3,"names":["arrays","ObjectFactory","scout","strings","TypeDescriptor","constructor","typeDescriptor","objectType","modelVariant","createInstance","options","i","namespaces","className","namespace","window","name","length","error","variantLenient","infoWithoutVariant","join","model","details","Error","newInstance","info","parse","typePart","variantPart","contains","MODEL_VARIANT_SEPARATOR","tmp","split","parseDescriptorPart","empty","createInfo","nvl","toString","parts","slice","push","NAMESPACE_SEPARATOR","descriptorPart","namespaceParts","last"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/TypeDescriptor.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, ObjectFactory, scout, strings} from './index';\n\n/**\n * This class contains a structured type description for a Scout class.\n * The model variant is optional.\n *\n * @param {string} typeDescriptor a string in the format '[namespace(s).]objectType[[:namespace(s).]modelVariant]'\n * @param {object} objectType\n * @param {object} [modelVariant]\n * @constructor\n */\nexport default class TypeDescriptor {\n\n  constructor(typeDescriptor, objectType, modelVariant) {\n    this.typeDescriptor = typeDescriptor;\n    this.objectType = objectType;\n    this.modelVariant = modelVariant;\n  }\n\n  createInstance(options) {\n    let i, namespaces, className,\n      namespace = window.scout; // default namespace\n\n    if (this.modelVariant) {\n      className = this.modelVariant.name + this.objectType.name;\n      namespaces = this.modelVariant.namespaces;\n    } else {\n      className = this.objectType.name;\n      namespaces = this.objectType.namespaces;\n    }\n\n    if (namespaces.length) {\n      namespace = window;\n      for (i = 0; i < namespaces.length; i++) {\n        namespace = namespace[namespaces[i]];\n        if (!namespace) {\n          throw this.error('Could not resolve namespace \"' + namespaces[i] + '\"');\n        }\n      }\n    }\n\n    if (!namespace[className]) { // Try without variant if variantLenient is true\n      if (options.variantLenient && this.modelVariant) {\n        let infoWithoutVariant = new TypeDescriptor(this.typeDescriptor, this.objectType, null);\n        return infoWithoutVariant.createInstance(options);\n      }\n      throw this.error('Could not find \"' + className + '\" in namespace \"' + namespaces.join('.') + '\"');\n    }\n\n    return new namespace[className](options.model);\n  }\n\n  error(details) {\n    return new Error('Failed to create object for objectType \"' + this.typeDescriptor + '\": ' + details);\n  }\n\n  static newInstance(typeDescriptor, options) {\n    let info = TypeDescriptor.parse(typeDescriptor);\n    return info.createInstance(options);\n  }\n\n  /**\n   * @param {string} typeDescriptor\n   * @returns {TypeDescriptor}\n   * @static\n   */\n  static parse(typeDescriptor) {\n    let typePart = null,\n      variantPart = null;\n\n    if (strings.contains(typeDescriptor, ObjectFactory.MODEL_VARIANT_SEPARATOR)) {\n      let tmp = typeDescriptor.split(ObjectFactory.MODEL_VARIANT_SEPARATOR);\n      typePart = parseDescriptorPart(tmp[0]);\n      variantPart = parseDescriptorPart(tmp[1]);\n\n      // when type has namespaces but the variant has not, use type namespaces for variant too\n      if (arrays.empty(variantPart.namespaces) && !arrays.empty(typePart.namespaces)) {\n        variantPart.namespaces = typePart.namespaces;\n      }\n    } else {\n      typePart = parseDescriptorPart(typeDescriptor);\n    }\n\n    return new TypeDescriptor(typeDescriptor, typePart, variantPart);\n\n    function createInfo(name, namespaces) {\n      return {\n        name: name,\n        namespaces: scout.nvl(namespaces, []),\n        toString: () => {\n          let parts = namespaces.slice();\n          parts.push(name);\n          return strings.join(ObjectFactory.NAMESPACE_SEPARATOR, parts);\n        }\n      };\n    }\n\n    function parseDescriptorPart(descriptorPart) {\n      let namespaces = [];\n\n      if (strings.contains(descriptorPart, ObjectFactory.NAMESPACE_SEPARATOR)) {\n        let namespaceParts = descriptorPart.split(ObjectFactory.NAMESPACE_SEPARATOR);\n        namespaces = namespaceParts.slice(0, namespaceParts.length - 1);\n        descriptorPart = arrays.last(namespaceParts);\n      }\n\n      return createInfo(descriptorPart, namespaces);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}