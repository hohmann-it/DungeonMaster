{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { CloseKeyStroke, DialogLayout, Dimension, Event, FocusRule, GlassPaneRenderer, graphics, HtmlComponent, Insets, KeyStrokeContext, Point, PopupLayout, Rectangle, scout, scrollbars, strings, Widget, widgets } from '../index';\nimport $ from 'jquery';\nexport default class Popup extends Widget {\n  constructor() {\n    super();\n    this._documentMouseDownHandler = null;\n    this._anchorScrollHandler = null;\n    this._anchorLocationChangeHandler = null;\n    this._popupOpenHandler = null;\n    this._glassPaneRenderer = null;\n    this.anchorBounds = null;\n    this.animateOpening = false;\n    this.animateResize = false;\n    this.anchor = null;\n    this.$anchor = null;\n    this.windowPaddingX = 10;\n    this.windowPaddingY = 5;\n    this.withGlassPane = false;\n    this._withGlassPane = null;\n    this.withFocusContext = true;\n    this.initialFocus = () => FocusRule.AUTO;\n    this.focusableContainer = false;\n\n    // The alignment defines how the popup is positioned around the anchor.\n    // If there is no anchor or anchor bounds the alignment has no effect.\n    this.horizontalAlignment = Popup.Alignment.LEFTEDGE;\n    this.verticalAlignment = Popup.Alignment.BOTTOM;\n\n    // Gives the current alignment after applying horizontal and vertical switch options\n    this.calculatedHorizontalAlignment = this.horizontalAlignment;\n    this.calculatedVerticalAlignment = this.verticalAlignment;\n\n    // If switch is enabled, the alignment will be changed if the popup overlaps a window border.\n    this.horizontalSwitch = false;\n    this.verticalSwitch = true;\n\n    // Hints for the layout to control whether the size should be adjusted if the popup does not fit into the window.\n    // Before trimming is applied the popup will be switched, if the switch option is enabled.\n    // If neither switch nor trim is enabled, the popup will be moved until its right border is visible.\n    this.trimWidth = false;\n    this.trimHeight = true;\n\n    // Defines what should happen when the scroll parent is scrolled. It is also used if the anchor changes its location (needs to support the locationChange event)\n    this.scrollType = 'remove';\n    this.windowResizeType = null;\n\n    // If true, the anchor is considered when computing the position and size of the popup\n    this.boundToAnchor = true;\n\n    // If true, an arrow is shown pointing to the anchor. If there is no anchor, no arrow will be visible.\n    // Please note: some alignment combinations are not supported, which are: LEFT or RIGHT + BOTTOM or TOP\n    this.withArrow = false;\n\n    // If false, the attached mouse down handler will NOT close the popup if the anchor was clicked, the anchor is responsible to close it.\n    // This is necessary because the mousedown listener is attached to the capture phase and therefore executed before any other.\n    // If anchor was clicked, popup would already be closed and then opened again -> popup could never be closed by clicking the anchor\n    this.closeOnAnchorMouseDown = true;\n    this._closeOnAnchorMouseDown = null;\n\n    // Defines whether the popup should be closed on a mouse click outside of the popup\n    this.closeOnMouseDownOutside = true;\n    this._closeOnMouseDownOutside = null;\n\n    // Defines whether the popup should be closed whenever another popup opens.\n    this.closeOnOtherPopupOpen = true;\n    this._closeOnOtherPopupOpen = null;\n\n    // Defines whether the popup should behave like a modal form. If true, the properties closeOnAnchorMouseDown, closeOnMouseDownOutside\n    // and closeOnOtherPopupOpen ore overruled and set to false. The property withGlassPane is overruled too and set to true.\n    this.modal = false;\n    this._openLater = false;\n    this.$arrow = null;\n    this.$arrowOverlay = null;\n    this._windowResizeHandler = this._onWindowResize.bind(this);\n    this._anchorRenderHandler = this._onAnchorRender.bind(this);\n    this._addWidgetProperties(['anchor']);\n    this._addPreserveOnPropertyChangeProperties(['anchor']);\n  }\n\n  // Note that these strings are also used as CSS classes\n\n  /**\n   * @param options:\n   *          initialFocus: a function that returns the element to be focused or a <code>FocusRule</code>. Default returns <code>FocusRule.AUTO</code>\n   *          focusableContainer: a boolean whether or not the container of the Popup is focusable\n   */\n  _init(options) {\n    super._init(options);\n    if (options.location) {\n      this.anchorBounds = new Rectangle(options.location.x, options.location.y, 0, 0);\n    }\n    this._setAnchor(this.anchor);\n    this._setModal(this.modal);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke(this._createCloseKeyStroke());\n  }\n\n  /**\n   * Override this method to provide a key stroke which closes the popup.\n   * The default impl. returns a CloseKeyStroke which handles the ESC key.\n   * @return KeyStroke\n   */\n  _createCloseKeyStroke() {\n    return new CloseKeyStroke(this);\n  }\n\n  /**\n   * @return {PopupLayout|AbstractLayout}\n   */\n  _createLayout() {\n    return new PopupLayout(this);\n  }\n  _openWithoutParent() {\n    // resolve parent for entry-point (don't change the actual property)\n    if (this.parent.destroyed) {\n      return;\n    }\n    if (this.parent.rendered || this.parent.rendering) {\n      this.open(this._getDefaultOpen$Parent());\n      return;\n    }\n\n    // This is important for popups rendered in another (native) browser window. The DOM in the popup window\n    // is rendered later, so we must wait until that window is rendered and layouted. See popup-window.html.\n    this.parent.one('render', () => {\n      this.session.layoutValidator.schedulePostValidateFunction(() => {\n        if (this.destroyed || this.rendered) {\n          return;\n        }\n        this.open();\n      });\n    });\n  }\n\n  /**\n   * Only called if parent.rendered or parent.rendering\n   * @return {$}\n   */\n  _getDefaultOpen$Parent() {\n    return this.parent.entryPoint();\n  }\n  open($parent) {\n    if (!$parent) {\n      this._openWithoutParent();\n      return;\n    }\n    this._triggerPopupOpenEvent();\n    this._open($parent);\n    if (this._openLater) {\n      return;\n    }\n    if (!this.animateOpening) {\n      // It is important that focusing happens after layouting and positioning, otherwise we'd focus an element\n      // that is currently not on the screen. Which would cause the whole desktop to\n      // be shifted for a few pixels.\n      this.validateFocus();\n      return;\n    }\n    // Give the browser time to layout properly before starting the animation to make sure it will be smooth.\n    // The before-animate-open class will make the popup invisible (cannot use the invisible class because it is already used by _validateVisibility)\n    this.$container.addClass('before-animate-open');\n    setTimeout(() => {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n      this.$container.removeClass('before-animate-open');\n      this.validateFocus(); // Need to be done after popup is visible again because focus cannot be set on invisible elements.\n      this.$container.addClassForAnimation('animate-open');\n    });\n  }\n  validateFocus() {\n    if (!this.withFocusContext) {\n      return;\n    }\n    let context = this.session.focusManager.getFocusContext(this.$container);\n    context.ready();\n    if (!context.lastValidFocusedElement) {\n      // No widget requested focus -> try to determine the initial focus\n      this._requestInitialFocus();\n    }\n  }\n  _requestInitialFocus() {\n    let initialFocusElement = this.session.focusManager.evaluateFocusRule(this.$container, this.initialFocus());\n    if (!initialFocusElement) {\n      return;\n    }\n    this.session.focusManager.requestFocus(initialFocusElement);\n  }\n  _open($parent) {\n    this.render($parent);\n    if (this._openLater) {\n      return;\n    }\n    this.revalidateLayout();\n    this.position();\n  }\n  render($parent) {\n    let $popupParent = $parent || this.entryPoint();\n    // when the parent is detached it is not possible to render the popup -> do it later\n    if (!$popupParent || !$popupParent.length || !$popupParent.isAttached()) {\n      this._openLater = true;\n      return;\n    }\n    super.render($popupParent);\n  }\n  _render() {\n    this.$container = this.$parent.appendDiv('popup');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.validateRoot = true;\n    this.htmlComp.setLayout(this._createLayout());\n    this.$container.window().on('resize', this._windowResizeHandler);\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderAnchor();\n    this._renderWithArrow();\n    this._renderWithFocusContext();\n    this._renderWithGlassPane();\n    this._renderModal();\n  }\n  _postRender() {\n    super._postRender();\n    this._attachCloseHandlers();\n    this._attachAnchorHandlers();\n    this._handleGlassPanes();\n  }\n  _onAttach() {\n    super._onAttach();\n    if (this._openLater && !this.rendered) {\n      this._openLater = false;\n      // Don't animate the opening when parent is attached. It doesn't look right if popups \"pop up\" when they are not really opening but only displayed again.\n      // The same applies for detaching, see _renderOnDetach\n      let currentAnimateOpening = this.animateOpening;\n      this.animateOpening = false;\n      this.open();\n      this.animateOpening = currentAnimateOpening;\n    }\n  }\n  _renderOnDetach() {\n    this._openLater = true;\n    // If parent is detached, popup should be removed immediately, otherwise animation would still be visible even though parent has already gone.\n    super.removeImmediately();\n    super._renderOnDetach();\n  }\n  remove() {\n    let currentAnimateRemoval = this.animateRemoval;\n    if (this.boundToAnchor && this.$anchor && !this._isAnchorInView()) {\n      this.animateRemoval = false;\n    }\n    super.remove();\n    this.animateRemoval = currentAnimateRemoval;\n  }\n  _remove() {\n    this.$container.window().off('resize', this._windowResizeHandler);\n    if (this._glassPaneRenderer) {\n      this._glassPaneRenderer.removeGlassPanes();\n    }\n    if (this.withFocusContext) {\n      this.session.focusManager.uninstallFocusContext(this.$container);\n    }\n    if (this.$arrow) {\n      this.$arrow.remove();\n      this.$arrow = null;\n    }\n    if (this.anchor) {\n      // reopen when the anchor gets rendered again\n      this.anchor.one('render', this._anchorRenderHandler);\n    }\n\n    // remove all clean-up handlers\n    this._detachAnchorHandlers();\n    this._detachCloseHandlers();\n    super._remove();\n  }\n  _destroy() {\n    if (this.anchor) {\n      this.anchor.off('render', this._anchorRenderHandler);\n    }\n    super._destroy();\n  }\n  _renderWithFocusContext() {\n    if (!this.withFocusContext) {\n      return;\n    }\n    // Add programmatic 'tabindex' if the $container itself should be focusable (used by context menu popups with no focusable elements)\n    if (this.focusableContainer) {\n      this.$container.attr('tabindex', -1);\n    }\n    // Don't allow an element to be focused while the popup is opened.\n    // The popup will focus the element as soon as the opening is finished (see open());\n    // The context needs to be already installed so that child elements don't try to focus an element outside of this context\n    this.session.focusManager.installFocusContext(this.$container, FocusRule.PREPARE);\n  }\n  setModal(modal) {\n    this.setProperty('modal', modal);\n  }\n  _setModal(modal) {\n    this._setProperty('modal', modal);\n    if (modal) {\n      widgets.preserveAndSetProperty(() => this.setProperty('withGlassPane', true), () => this.withGlassPane, this, '_withGlassPane');\n      widgets.preserveAndSetProperty(() => this.setProperty('closeOnAnchorMouseDown', false), () => this.closeOnAnchorMouseDown, this, '_closeOnAnchorMouseDown');\n      widgets.preserveAndSetProperty(() => this.setProperty('closeOnMouseDownOutside', false), () => this.closeOnMouseDownOutside, this, '_closeOnMouseDownOutside');\n      widgets.preserveAndSetProperty(() => this.setProperty('closeOnOtherPopupOpen', false), () => this.closeOnOtherPopupOpen, this, '_closeOnOtherPopupOpen');\n    } else {\n      widgets.resetProperty(v => this.setWithGlassPane(v), this, '_withGlassPane');\n      widgets.resetProperty(v => this.setCloseOnAnchorMouseDown(v), this, '_closeOnAnchorMouseDown');\n      widgets.resetProperty(v => this.setCloseOnMouseDownOutside(v), this, '_closeOnMouseDownOutside');\n      widgets.resetProperty(v => this.setCloseOnOtherPopupOpen(v), this, '_closeOnOtherPopupOpen');\n    }\n  }\n  _renderModal() {\n    this.$container.toggleClass('modal', this.modal);\n  }\n  setWithGlassPane(withGlassPane) {\n    if (!this.modal) {\n      this.setProperty('withGlassPane', withGlassPane);\n    } else {\n      this._withGlassPane = withGlassPane;\n    }\n  }\n  _renderWithGlassPane() {\n    if (this.withGlassPane && !this._glassPaneRenderer) {\n      this._glassPaneRenderer = new GlassPaneRenderer(this);\n      this._glassPaneRenderer.renderGlassPanes();\n    } else if (!this.withGlassPane && this._glassPaneRenderer) {\n      this._glassPaneRenderer.removeGlassPanes();\n      this._glassPaneRenderer = null;\n    }\n  }\n  setCloseOnMouseDownOutside(closeOnMouseDownOutside) {\n    if (!this.modal) {\n      this.setProperty('closeOnMouseDownOutside', closeOnMouseDownOutside);\n    } else {\n      this._closeOnMouseDownOutside = closeOnMouseDownOutside;\n    }\n  }\n  _renderCloseOnMouseDownOutside() {\n    // The listener needs to be executed in the capturing phase -> prevents that _onDocumentMouseDown will be executed right after the popup gets opened using mouse down, otherwise the popup would be closed immediately\n    if (this.closeOnMouseDownOutside && !this._documentMouseDownHandler) {\n      this._documentMouseDownHandler = this._onDocumentMouseDown.bind(this);\n      this.$container.document(true).addEventListener('mousedown', this._documentMouseDownHandler, true); // true=the event handler is executed in the capturing phase\n    } else if (!this.closeOnMouseDownOutside && this._documentMouseDownHandler) {\n      this.$container.document(true).removeEventListener('mousedown', this._documentMouseDownHandler, true);\n      this._documentMouseDownHandler = null;\n    }\n  }\n  setCloseOnAnchorMouseDown(closeOnAnchorMouseDown) {\n    if (!this.modal) {\n      this.setProperty('closeOnAnchorMouseDown', closeOnAnchorMouseDown);\n    } else {\n      this._closeOnAnchorMouseDown = closeOnAnchorMouseDown;\n    }\n  }\n  setCloseOnOtherPopupOpen(closeOnOtherPopupOpen) {\n    if (!this.modal) {\n      this.setProperty('closeOnOtherPopupOpen', closeOnOtherPopupOpen);\n    } else {\n      this._closeOnOtherPopupOpen = closeOnOtherPopupOpen;\n    }\n  }\n  _renderCloseOnOtherPopupOpen() {\n    if (this.closeOnOtherPopupOpen && !this._popupOpenHandler) {\n      this._popupOpenHandler = this._onPopupOpen.bind(this);\n      this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    } else if (!this.closeOnOtherPopupOpen && this._popupOpenHandler) {\n      this.session.desktop.off('popupOpen', this._popupOpenHandler);\n      this._popupOpenHandler = null;\n    }\n  }\n  setWithArrow(withArrow) {\n    this.setProperty('withArrow', withArrow);\n  }\n  _renderWithArrow() {\n    if (this.$arrow) {\n      this.$arrow.remove();\n      this.$arrow = null;\n    }\n    if (this.$arrowOverlay) {\n      this.$arrowOverlay.remove();\n      this.$arrowOverlay = null;\n    }\n    if (this.withArrow) {\n      this.$arrowOverlay = this.$container.prependDiv('popup-arrow-overlay');\n      this.$arrow = this.$container.prependDiv('popup-arrow');\n      this._updateArrowClass();\n    }\n    this.$container.toggleClass('with-arrow', this.withArrow);\n    this.invalidateLayoutTree();\n  }\n  _updateArrowClass(verticalAlignment, horizontalAlignment) {\n    if (this.$arrow) {\n      this.$arrow.removeClass(this._alignClasses());\n      this.$arrow.addClass(this._computeArrowPositionClass(verticalAlignment, horizontalAlignment));\n    }\n  }\n  _computeArrowPositionClass(verticalAlignment, horizontalAlignment) {\n    let Alignment = Popup.Alignment;\n    let cssClass = '';\n    horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n    verticalAlignment = verticalAlignment || this.verticalAlignment;\n    switch (horizontalAlignment) {\n      case Alignment.LEFT:\n        cssClass = Alignment.RIGHT;\n        break;\n      case Alignment.RIGHT:\n        cssClass = Alignment.LEFT;\n        break;\n      default:\n        cssClass = horizontalAlignment;\n        break;\n    }\n    switch (verticalAlignment) {\n      case Alignment.BOTTOM:\n        cssClass += ' ' + Alignment.TOP;\n        break;\n      case Alignment.TOP:\n        cssClass += ' ' + Alignment.BOTTOM;\n        break;\n      default:\n        cssClass += ' ' + verticalAlignment;\n        break;\n    }\n    return cssClass;\n  }\n  _animateRemovalWhileRemovingParent() {\n    if (!this.$anchor) {\n      // Allow remove animations for popups without an anchor\n      return true;\n    }\n    // If parent is the anchor, prevent remove animation to ensure popup will be removed together with the anchor\n    return widgets.get(this.$anchor) !== this.parent;\n  }\n  _isRemovalPrevented() {\n    // If removal of a parent is pending due to an animation then don't return true to make sure popups are closed before the parent animation starts.\n    // However, if the popup itself is removed by an animation, removal should be prevented to ensure remove() won't run multiple times.\n    return this.removalPending;\n  }\n  close() {\n    if (this.destroyed || this.destroying) {\n      // Already closed, do nothing\n      return;\n    }\n    let event = new Event();\n    this.trigger('close', event);\n    if (!event.defaultPrevented) {\n      this.destroy();\n    }\n  }\n\n  /**\n   * Install listeners to close the popup once clicking outside the popup,\n   * or changing the anchor's scroll position, or another popup is opened.\n   */\n  _attachCloseHandlers() {\n    // Install mouse close handler\n    this._renderCloseOnMouseDownOutside();\n    // Install popup open close handler\n    this._renderCloseOnOtherPopupOpen();\n  }\n  _attachAnchorHandlers() {\n    if (!this.$anchor || !this.boundToAnchor || !this.scrollType) {\n      return;\n    }\n    // Attach a scroll handler to each scrollable parent of the anchor\n    this._anchorScrollHandler = this._onAnchorScroll.bind(this);\n    scrollbars.onScroll(this.$anchor, this._anchorScrollHandler);\n\n    // Attach a location change handler as well (will only work if the anchor is a widget which triggers a locationChange event, e.g. another Popup)\n    let anchor = scout.widget(this.$anchor);\n    if (anchor) {\n      this._anchorLocationChangeHandler = this._onAnchorLocationChange.bind(this);\n      anchor.on('locationChange', this._anchorLocationChangeHandler);\n    }\n  }\n  _detachAnchorHandlers() {\n    if (this._anchorScrollHandler) {\n      scrollbars.offScroll(this._anchorScrollHandler);\n      this._anchorScrollHandler = null;\n    }\n    if (this._anchorLocationChangeHandler) {\n      let anchor = scout.widget(this.$anchor);\n      if (anchor) {\n        anchor.off('locationChange', this._anchorLocationChangeHandler);\n        this._anchorLocationChangeHandler = null;\n      }\n    }\n  }\n  _detachCloseHandlers() {\n    // Uninstall popup open close handler\n    if (this._popupOpenHandler) {\n      this.session.desktop.off('popupOpen', this._popupOpenHandler);\n      this._popupOpenHandler = null;\n    }\n\n    // Uninstall mouse close handler\n    if (this._documentMouseDownHandler) {\n      this.$container.document(true).removeEventListener('mousedown', this._documentMouseDownHandler, true);\n      this._documentMouseDownHandler = null;\n    }\n  }\n  _onDocumentMouseDown(event) {\n    // in some cases the mousedown handler is executed although it has been already\n    // detached on the _remove() method. However, since we're in the middle of\n    // processing the mousedown event, it's too late to detach the event and we must\n    // deal with that situation by checking the rendered flag. Otherwise we would\n    // run into an error later, since the $container is not available anymore.\n    // Use the internal flag because popup should be closed even if the parent removal is pending due to a remove animation\n    if (!this._rendered) {\n      return;\n    }\n    if (this._isMouseDownOutside(event)) {\n      this._onMouseDownOutside(event);\n    }\n  }\n  _isMouseDownOutside(event) {\n    let $target = $(event.target),\n      targetWidget;\n    if (!this.closeOnAnchorMouseDown && this._isMouseDownOnAnchor(event)) {\n      // 1. Often times, click on the anchor opens and 2. click closes the popup\n      // If we were closing the popup here, it would not be possible to achieve the described behavior anymore -> let anchor handle open and close.\n      return false;\n    }\n    targetWidget = scout.widget($target);\n\n    // close the popup only if the click happened outside of the popup and its children\n    // It is not sufficient to check the dom hierarchy using $container.has($target)\n    // because the popup may open other popups which probably is not a dom child but a sibling\n    // Also ignore clicks if the popup is covert by a glasspane\n    return !this.isOrHas(targetWidget) && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n  }\n  _isMouseDownOnAnchor(event) {\n    return !!this.$anchor && this.$anchor.isOrHas(event.target);\n  }\n\n  /**\n   * Method invoked once a mouse down event occurs outside the popup.\n   */\n  _onMouseDownOutside(event) {\n    this.close();\n  }\n\n  /**\n   * Method invoked once the 'options.$anchor' is scrolled.\n   */\n  _onAnchorScroll(event) {\n    if (!this.rendered) {\n      // Scroll events may be fired delayed, even if scroll listeners are already removed.\n      return;\n    }\n    this._handleAnchorPositionChange();\n  }\n  _handleAnchorPositionChange(event) {\n    if (scout.isOneOf(this.scrollType, 'position', 'layoutAndPosition') && this.isOpeningAnimationRunning()) {\n      // If the popup is opened with an animation which transforms the popup the sizes used by prefSize and position will likely be wrong.\n      // In that case it is not possible to layout and position it correctly -> do nothing.\n      return;\n    }\n    if (this.scrollType === 'position') {\n      this.position();\n    } else if (this.scrollType === 'layoutAndPosition') {\n      this.revalidateLayout();\n      this.position();\n    } else if (this.scrollType === 'remove') {\n      this.close();\n    }\n  }\n  isOpeningAnimationRunning() {\n    return this.rendered && this.animateOpening && this.$container.hasClass('animate-open');\n  }\n  _onAnchorLocationChange(event) {\n    this._handleAnchorPositionChange();\n  }\n\n  /**\n   * Method invoked once a popup is opened.\n   */\n  _onPopupOpen(event) {\n    // Make sure child popups don't close the parent popup, we must check parent hierarchy in both directions\n    // Use case: Opening of a context menu or cell editor in a form popup\n    // Also, popups covered by a glass pane (a modal dialog is open) must never be closed\n    // Use case: popup opens a modal dialog. User clicks on a smartfield on this dialog -> underlying popup must not get closed\n    let closable = !this.isOrHas(event.popup) && !event.popup.isOrHas(this);\n    if (this.rendered) {\n      closable = closable && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n    }\n    if (closable) {\n      this.close();\n    }\n  }\n  setHorizontalAlignment(horizontalAlignment) {\n    this.setProperty('horizontalAlignment', horizontalAlignment);\n  }\n  _renderHorizontalAlignment() {\n    this._updateArrowClass();\n    this.invalidateLayoutTree();\n  }\n  setVerticalAlignment(verticalAlignment) {\n    this.setProperty('verticalAlignment', verticalAlignment);\n  }\n  _renderVerticalAlignment() {\n    this._updateArrowClass();\n    this.invalidateLayoutTree();\n  }\n  setHorizontalSwitch(horizontalSwitch) {\n    this.setProperty('horizontalSwitch', horizontalSwitch);\n  }\n  _renderHorizontalSwitch() {\n    this.invalidateLayoutTree();\n  }\n  setVerticalSwitch(verticalSwitch) {\n    this.setProperty('verticalSwitch', verticalSwitch);\n  }\n  _renderVerticalSwitch() {\n    this.invalidateLayoutTree();\n  }\n  setTrimWidth(trimWidth) {\n    this.setProperty('trimWidth', trimWidth);\n  }\n  _renderTrimWidth() {\n    this.invalidateLayoutTree();\n  }\n  setTrimHeight(trimHeight) {\n    this.setProperty('trimHeight', trimHeight);\n  }\n  _renderTrimHeight() {\n    this.invalidateLayoutTree();\n  }\n  prefLocation(verticalAlignment, horizontalAlignment) {\n    if (!this.boundToAnchor || !this.anchorBounds && !this.$anchor) {\n      return this._prefLocationWithoutAnchor();\n    }\n    return this._prefLocationWithAnchor(verticalAlignment, horizontalAlignment);\n  }\n  _prefLocationWithoutAnchor() {\n    return DialogLayout.positionContainerInWindow(this.$container);\n  }\n  _prefLocationWithAnchor(verticalAlignment, horizontalAlignment) {\n    let $container = this.$container;\n    horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n    verticalAlignment = verticalAlignment || this.verticalAlignment;\n    let anchorBounds = this.getAnchorBounds();\n    let size = graphics.size($container, {\n      exact: true\n    });\n    let margins = graphics.margins($container);\n    let Alignment = Popup.Alignment;\n    let arrowBounds = null;\n    if (this.$arrow) {\n      // Ensure the arrow has the correct class\n      this._updateArrowClass(verticalAlignment, horizontalAlignment);\n      // Remove margin added by moving logic, otherwise the bounds would not be correct\n      graphics.setMargins(this.$arrow, new Insets());\n      arrowBounds = graphics.bounds(this.$arrow);\n    }\n    $container.removeClass(this._alignClasses());\n    $container.addClass(verticalAlignment + ' ' + horizontalAlignment);\n    let widthWithMargin = size.width + margins.horizontal();\n    let width = size.width;\n    let x = anchorBounds.x;\n    if (horizontalAlignment === Alignment.LEFT) {\n      x -= widthWithMargin;\n    } else if (horizontalAlignment === Alignment.LEFTEDGE) {\n      if (this.withArrow) {\n        x += anchorBounds.width / 2 - arrowBounds.center().x - margins.left;\n      } else {\n        x = anchorBounds.x - margins.left;\n      }\n    } else if (horizontalAlignment === Alignment.CENTER) {\n      x += anchorBounds.width / 2 - width / 2 - margins.left;\n    } else if (horizontalAlignment === Alignment.RIGHT) {\n      x += anchorBounds.width;\n    } else if (horizontalAlignment === Alignment.RIGHTEDGE) {\n      if (this.withArrow) {\n        x += anchorBounds.width / 2 - arrowBounds.center().x - margins.right;\n      } else {\n        x = anchorBounds.x + anchorBounds.width - width - margins.right;\n      }\n    }\n    let heightWithMargin = size.height + margins.vertical();\n    let height = size.height;\n    let y = anchorBounds.y;\n    if (verticalAlignment === Alignment.TOP) {\n      y -= heightWithMargin;\n    } else if (verticalAlignment === Alignment.TOPEDGE) {\n      if (this.withArrow) {\n        y += anchorBounds.height / 2 - arrowBounds.center().y - margins.top;\n      } else {\n        y = anchorBounds.y - margins.top;\n      }\n    } else if (verticalAlignment === Alignment.CENTER) {\n      y += anchorBounds.height / 2 - height / 2 - margins.top;\n    } else if (verticalAlignment === Alignment.BOTTOM) {\n      y += anchorBounds.height;\n    } else if (verticalAlignment === Alignment.BOTTOMEDGE) {\n      if (this.withArrow) {\n        y += anchorBounds.height / 2 - arrowBounds.center().y - margins.bottom;\n      } else {\n        y = anchorBounds.y + anchorBounds.height - height - margins.bottom;\n      }\n    }\n\n    // this.$parent might not be at (0,0) of the document\n    let parentOffset = this.$parent.offset();\n    x -= parentOffset.left;\n    y -= parentOffset.top;\n    return new Point(x, y);\n  }\n  _alignClasses() {\n    let Alignment = Popup.Alignment;\n    return strings.join(' ', Alignment.LEFT, Alignment.LEFTEDGE, Alignment.CENTER, Alignment.RIGHT, Alignment.RIGHTEDGE, Alignment.TOP, Alignment.TOPEDGE, Alignment.CENTER, Alignment.BOTTOM, Alignment.BOTTOMEDGE);\n  }\n  getAnchorBounds() {\n    let anchorBounds = this.anchorBounds;\n    if (!this.$anchor) {\n      // Use manually set anchor bounds\n      return anchorBounds;\n    }\n    let realAnchorBounds = graphics.offsetBounds(this.$anchor, {\n      exact: true\n    });\n    if (!anchorBounds) {\n      // Use measured anchor bounds\n      anchorBounds = realAnchorBounds;\n    } else {\n      // Fill incomplete anchorBounds from measured anchor bounds. This allows setting one\n      // coordinate to a fixed value (e.g. the current mouse cursor position) while still\n      // aligning the other coordinate to the $anchor element.\n      //\n      // Implementation note:\n      // A coordinate is considered \"undefined\", when it is 0. Technically, this is not 100%\n      // correct, but will give the desired result in most of the cases. If would require too\n      // many code changes to correctly set missing values to undefined/null.\n      if (!anchorBounds.x) {\n        anchorBounds.x = realAnchorBounds.x;\n        anchorBounds.width = realAnchorBounds.width;\n      }\n      if (!anchorBounds.y) {\n        anchorBounds.y = realAnchorBounds.y;\n        anchorBounds.height = realAnchorBounds.height;\n      }\n    }\n    return anchorBounds;\n  }\n  getWindowSize() {\n    let $window = this.$parent.window();\n    return new Dimension($window.width(), $window.height());\n  }\n\n  /**\n   * @returns Point the amount of overlap at the window borders.\n   * A positive value indicates that it is overlapping the right / bottom border, a negative value indicates that it is overlapping the left / top border.\n   * Prefers the right and bottom over the left and top border, meaning if a positive value is returned it does not mean that the left border is overlapping as well.\n   */\n  overlap(location, includeMargin) {\n    let $container = this.$container;\n    if (!$container || !location) {\n      return null;\n    }\n    includeMargin = scout.nvl(includeMargin, true);\n    let containerSize = graphics.size($container, {\n      exact: true,\n      includeMargin: includeMargin\n    });\n    let width = containerSize.width;\n    let height = containerSize.height;\n    let popupBounds = new Rectangle(location.x, location.y, width, height);\n    let bounds = graphics.offsetBounds($container.entryPoint(), true);\n    let overlapX = popupBounds.right() + this.windowPaddingX - bounds.width;\n    if (overlapX < 0) {\n      overlapX = Math.min(popupBounds.x - this.windowPaddingX - bounds.x, 0);\n    }\n    let overlapY = popupBounds.bottom() + this.windowPaddingY - bounds.height;\n    if (overlapY < 0) {\n      overlapY = Math.min(popupBounds.y - this.windowPaddingY - bounds.y, 0);\n    }\n    return new Point(overlapX, overlapY);\n  }\n  adjustLocation(location, switchIfNecessary) {\n    this.calculatedVerticalAlignment = this.verticalAlignment;\n    this.calculatedHorizontalAlignment = this.horizontalAlignment;\n    let overlap = this.overlap(location);\n\n    // Reset arrow style\n    if (this.$arrow) {\n      this._updateArrowClass(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment);\n      graphics.setMargins(this.$arrow, new Insets());\n    }\n    location = location.clone();\n    // Ignore very small overlaps (e.g. 0.3px). This could happen if anchor position is fractional and popup has a margin that is not\n    // Example: anchor has top: 10px and margin-top: 10px, browser renders it at 9.984px (due to zoom) but margin stays at 10px\n    // -> location.y would be -0.16px resulting in a popup switch so that the popup will be displayed outside of the window\n    if (Math.abs(overlap.y) >= 1) {\n      let verticalSwitch = scout.nvl(switchIfNecessary, this.verticalSwitch);\n      if (verticalSwitch) {\n        // Switch vertical alignment\n        this.calculatedVerticalAlignment = Popup.SwitchRule[this.calculatedVerticalAlignment];\n        location.y = this.prefLocation(this.calculatedVerticalAlignment).y;\n      } else {\n        // Move popup to the top until it gets fully visible (if switch is disabled)\n        location.y -= overlap.y;\n      }\n    }\n    // Reason for >= 1 see above\n    if (Math.abs(overlap.x) >= 1) {\n      let horizontalSwitch = scout.nvl(switchIfNecessary, this.horizontalSwitch);\n      if (horizontalSwitch) {\n        // Switch horizontal alignment\n        this.calculatedHorizontalAlignment = Popup.SwitchRule[this.calculatedHorizontalAlignment];\n        location.x = this.prefLocation(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment).x;\n      } else {\n        // Move popup to the left until it gets fully visible (if switch is disabled)\n        location.x -= overlap.x;\n      }\n    }\n\n    // Also move arrow so that it still points to the center of the anchor\n    if (this.$arrow) {\n      if (overlap.y !== 0 && (this.$arrow.hasClass(Popup.Alignment.LEFT) || this.$arrow.hasClass(Popup.Alignment.RIGHT))) {\n        if (overlap.y > 0) {\n          this.$arrow.cssMarginTop(overlap.y);\n        } else {\n          this.$arrow.cssMarginBottom(-overlap.y);\n        }\n      }\n      if (overlap.x !== 0 && (this.$arrow.hasClass(Popup.Alignment.TOP) || this.$arrow.hasClass(Popup.Alignment.BOTTOM))) {\n        if (overlap.x > 0) {\n          this.$arrow.cssMarginLeft(overlap.x);\n        } else {\n          this.$arrow.cssMarginRight(-overlap.x);\n        }\n      }\n    }\n    return location;\n  }\n  position(switchIfNecessary) {\n    if (!this.rendered) {\n      return;\n    }\n    this._validateVisibility();\n    this._position(switchIfNecessary);\n  }\n  _position(switchIfNecessary) {\n    let location = this.prefLocation();\n    if (!location) {\n      return;\n    }\n    location = this.adjustLocation(location, switchIfNecessary);\n    this.setLocation(location);\n  }\n  setLocation(location) {\n    if (!this.rendered) {\n      return;\n    }\n    this.$container.css('left', location.x).css('top', location.y);\n    this._triggerLocationChange();\n  }\n\n  /**\n   * Popups with an anchor must only be visible if the anchor is in view (prevents that the popup points at an invisible anchor)\n   */\n  _validateVisibility() {\n    if (!this.boundToAnchor || !this.$anchor) {\n      return;\n    }\n    let inView = this._isAnchorInView();\n    let needsLayouting = this.$container.hasClass('invisible') === inView && inView;\n    this.$container.toggleClass('invisible', !inView); // Use visibility: hidden to not break layouting / size measurement\n    if (needsLayouting) {\n      let currentAnimateResize = this.animateResize;\n      this.animateResize = false;\n      this.revalidateLayout();\n      this.animateResize = currentAnimateResize;\n      if (this.withFocusContext) {\n        this.session.focusManager.validateFocus();\n      }\n    }\n  }\n  _isAnchorInView() {\n    if (!this.boundToAnchor || !this.$anchor) {\n      return;\n    }\n    let anchorBounds = this.getAnchorBounds();\n    return scrollbars.isLocationInView(anchorBounds.center(), this.$anchor.scrollParents());\n  }\n  _triggerLocationChange() {\n    this.trigger('locationChange');\n  }\n\n  /**\n   * Fire event that this popup is about to open.\n   */\n  _triggerPopupOpenEvent() {\n    this.session.desktop.trigger('popupOpen', {\n      popup: this\n    });\n  }\n  belongsTo($anchor) {\n    return this.$anchor[0] === $anchor[0];\n  }\n  set$Anchor($anchor) {\n    if (this.$anchor) {\n      this._detachAnchorHandlers();\n    }\n    this.setProperty('$anchor', $anchor);\n    if (this.rendered) {\n      this._attachAnchorHandlers();\n      this.revalidateLayout();\n      if (!this.animateResize) {\n        // PopupLayout will move it -> don't break move animation\n        this.position();\n      }\n    }\n  }\n  isOpen() {\n    return this.rendered;\n  }\n  ensureOpen() {\n    if (!this.isOpen()) {\n      this.open();\n    }\n  }\n  setAnchor(anchor) {\n    this.setProperty('anchor', anchor);\n  }\n  _setAnchor(anchor) {\n    if (anchor) {\n      this.setParent(anchor);\n    }\n    this._setProperty('anchor', anchor);\n  }\n  _onAnchorRender() {\n    this.session.layoutValidator.schedulePostValidateFunction(() => {\n      if (this.rendered || this.destroyed) {\n        return;\n      }\n      if (this.anchor && !this.anchor.rendered) {\n        // Anchor was removed again while this function was scheduled -> wait again for rendering\n        this.anchor.one('render', this._anchorRenderHandler);\n        return;\n      }\n      let currentAnimateOpening = this.animateOpening;\n      this.animateOpening = false;\n      this.open();\n      this.animateOpening = currentAnimateOpening;\n    });\n  }\n  _renderAnchor() {\n    if (this.anchor) {\n      this.set$Anchor(this.anchor.$container);\n    }\n  }\n  _onWindowResize() {\n    if (!this.rendered) {\n      // may already be removed if a parent popup is closed during the resize event\n      return;\n    }\n    if (this.windowResizeType === 'position') {\n      this.position();\n    } else if (this.windowResizeType === 'layoutAndPosition') {\n      this.revalidateLayoutTree(false);\n      this.position();\n    } else if (this.windowResizeType === 'remove') {\n      this.close();\n    }\n  }\n  _handleGlassPanes() {\n    let parentCoveredByGlassPane = this.session.focusManager.isElementCovertByGlassPane(this.parent.$container);\n    // if a popup is covered by a glass pane the glass pane's need to be re-rendered to ensure a glass pane is also painted over the popup\n    if (parentCoveredByGlassPane) {\n      this.session.focusManager.rerenderGlassPanes();\n    }\n  }\n}\n_defineProperty(Popup, \"Alignment\", {\n  /**\n   * The entire popup is positioned horizontally left of the anchor.\n   */\n  LEFT: 'left',\n  /**\n   * With arrow: The arrow at the left edge of the popup is aligned horizontally with the center of the anchor.\n   * <p>\n   * Without arrow: The left edges of both the popup and the anchor are aligned horizontally.\n   */\n  LEFTEDGE: 'leftedge',\n  /**\n   * The entire popup is positioned vertically above the anchor.\n   */\n  TOP: 'top',\n  /**\n   * With arrow: The arrow at the top edge of the popup is aligned vertically with the center of the anchor.\n   * <p>\n   * Without arrow: The top edges of both the popup and the anchor are aligned vertically.\n   */\n  TOPEDGE: 'topedge',\n  /**\n   * The centers of both the popup and the anchor are aligned in the respective dimension.\n   */\n  CENTER: 'center',\n  /**\n   * The entire popup is positioned horizontally to the right of the anchor.\n   */\n  RIGHT: 'right',\n  /**\n   * With arrow: The arrow at the right edge of the popup is aligned horizontally with the center of the anchor.\n   * <p>\n   * Without arrow: The right edges of both the popup and the anchor are aligned horizontally.\n   */\n  RIGHTEDGE: 'rightedge',\n  /**\n   * The entire popup is positioned vertically below the anchor.\n   */\n  BOTTOM: 'bottom',\n  /**\n   * With arrow: The arrow at the bottom edge of the popup is aligned vertically with the center of the anchor.\n   * <p>\n   * Without arrow: The bottom edges of both the popup and the anchor are aligned vertically.\n   */\n  BOTTOMEDGE: 'bottomedge'\n});\n_defineProperty(Popup, \"SwitchRule\", {});\n(() => {\n  // Initialize switch rules (wrapped in IIFE to have local function scope for the variables)\n  let SwitchRule = Popup.SwitchRule;\n  let Alignment = Popup.Alignment;\n  SwitchRule[Alignment.LEFT] = Alignment.RIGHT;\n  SwitchRule[Alignment.LEFTEDGE] = Alignment.RIGHTEDGE;\n  SwitchRule[Alignment.TOP] = Alignment.BOTTOM;\n  SwitchRule[Alignment.TOPEDGE] = Alignment.BOTTOMEDGE;\n  SwitchRule[Alignment.CENTER] = Alignment.CENTER;\n  SwitchRule[Alignment.RIGHT] = Alignment.LEFT;\n  SwitchRule[Alignment.RIGHTEDGE] = Alignment.LEFTEDGE;\n  SwitchRule[Alignment.BOTTOM] = Alignment.TOP;\n  SwitchRule[Alignment.BOTTOMEDGE] = Alignment.TOPEDGE;\n})();","map":{"version":3,"names":["CloseKeyStroke","DialogLayout","Dimension","Event","FocusRule","GlassPaneRenderer","graphics","HtmlComponent","Insets","KeyStrokeContext","Point","PopupLayout","Rectangle","scout","scrollbars","strings","Widget","widgets","$","Popup","constructor","_documentMouseDownHandler","_anchorScrollHandler","_anchorLocationChangeHandler","_popupOpenHandler","_glassPaneRenderer","anchorBounds","animateOpening","animateResize","anchor","$anchor","windowPaddingX","windowPaddingY","withGlassPane","_withGlassPane","withFocusContext","initialFocus","AUTO","focusableContainer","horizontalAlignment","Alignment","LEFTEDGE","verticalAlignment","BOTTOM","calculatedHorizontalAlignment","calculatedVerticalAlignment","horizontalSwitch","verticalSwitch","trimWidth","trimHeight","scrollType","windowResizeType","boundToAnchor","withArrow","closeOnAnchorMouseDown","_closeOnAnchorMouseDown","closeOnMouseDownOutside","_closeOnMouseDownOutside","closeOnOtherPopupOpen","_closeOnOtherPopupOpen","modal","_openLater","$arrow","$arrowOverlay","_windowResizeHandler","_onWindowResize","bind","_anchorRenderHandler","_onAnchorRender","_addWidgetProperties","_addPreserveOnPropertyChangeProperties","_init","options","location","x","y","_setAnchor","_setModal","_createKeyStrokeContext","_initKeyStrokeContext","keyStrokeContext","registerKeyStroke","_createCloseKeyStroke","_createLayout","_openWithoutParent","parent","destroyed","rendered","rendering","open","_getDefaultOpen$Parent","one","session","layoutValidator","schedulePostValidateFunction","entryPoint","$parent","_triggerPopupOpenEvent","_open","validateFocus","$container","addClass","setTimeout","removing","removeClass","addClassForAnimation","context","focusManager","getFocusContext","ready","lastValidFocusedElement","_requestInitialFocus","initialFocusElement","evaluateFocusRule","requestFocus","render","revalidateLayout","position","$popupParent","length","isAttached","_render","appendDiv","htmlComp","install","validateRoot","setLayout","window","on","_renderProperties","_renderAnchor","_renderWithArrow","_renderWithFocusContext","_renderWithGlassPane","_renderModal","_postRender","_attachCloseHandlers","_attachAnchorHandlers","_handleGlassPanes","_onAttach","currentAnimateOpening","_renderOnDetach","removeImmediately","remove","currentAnimateRemoval","animateRemoval","_isAnchorInView","_remove","off","removeGlassPanes","uninstallFocusContext","_detachAnchorHandlers","_detachCloseHandlers","_destroy","attr","installFocusContext","PREPARE","setModal","setProperty","_setProperty","preserveAndSetProperty","resetProperty","v","setWithGlassPane","setCloseOnAnchorMouseDown","setCloseOnMouseDownOutside","setCloseOnOtherPopupOpen","toggleClass","renderGlassPanes","_renderCloseOnMouseDownOutside","_onDocumentMouseDown","document","addEventListener","removeEventListener","_renderCloseOnOtherPopupOpen","_onPopupOpen","desktop","setWithArrow","prependDiv","_updateArrowClass","invalidateLayoutTree","_alignClasses","_computeArrowPositionClass","cssClass","LEFT","RIGHT","TOP","_animateRemovalWhileRemovingParent","get","_isRemovalPrevented","removalPending","close","destroying","event","trigger","defaultPrevented","destroy","_onAnchorScroll","onScroll","widget","_onAnchorLocationChange","offScroll","_rendered","_isMouseDownOutside","_onMouseDownOutside","$target","target","targetWidget","_isMouseDownOnAnchor","isOrHas","isElementCovertByGlassPane","_handleAnchorPositionChange","isOneOf","isOpeningAnimationRunning","hasClass","closable","popup","setHorizontalAlignment","_renderHorizontalAlignment","setVerticalAlignment","_renderVerticalAlignment","setHorizontalSwitch","_renderHorizontalSwitch","setVerticalSwitch","_renderVerticalSwitch","setTrimWidth","_renderTrimWidth","setTrimHeight","_renderTrimHeight","prefLocation","_prefLocationWithoutAnchor","_prefLocationWithAnchor","positionContainerInWindow","getAnchorBounds","size","exact","margins","arrowBounds","setMargins","bounds","widthWithMargin","width","horizontal","center","left","CENTER","RIGHTEDGE","right","heightWithMargin","height","vertical","TOPEDGE","top","BOTTOMEDGE","bottom","parentOffset","offset","join","realAnchorBounds","offsetBounds","getWindowSize","$window","overlap","includeMargin","nvl","containerSize","popupBounds","overlapX","Math","min","overlapY","adjustLocation","switchIfNecessary","clone","abs","SwitchRule","cssMarginTop","cssMarginBottom","cssMarginLeft","cssMarginRight","_validateVisibility","_position","setLocation","css","_triggerLocationChange","inView","needsLayouting","currentAnimateResize","isLocationInView","scrollParents","belongsTo","set$Anchor","isOpen","ensureOpen","setAnchor","setParent","revalidateLayoutTree","parentCoveredByGlassPane","rerenderGlassPanes"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/popup/Popup.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {CloseKeyStroke, DialogLayout, Dimension, Event, FocusRule, GlassPaneRenderer, graphics, HtmlComponent, Insets, KeyStrokeContext, Point, PopupLayout, Rectangle, scout, scrollbars, strings, Widget, widgets} from '../index';\nimport $ from 'jquery';\n\nexport default class Popup extends Widget {\n\n  constructor() {\n    super();\n\n    this._documentMouseDownHandler = null;\n    this._anchorScrollHandler = null;\n    this._anchorLocationChangeHandler = null;\n    this._popupOpenHandler = null;\n    this._glassPaneRenderer = null;\n    this.anchorBounds = null;\n    this.animateOpening = false;\n    this.animateResize = false;\n    this.anchor = null;\n    this.$anchor = null;\n    this.windowPaddingX = 10;\n    this.windowPaddingY = 5;\n    this.withGlassPane = false;\n    this._withGlassPane = null;\n    this.withFocusContext = true;\n    this.initialFocus = () => FocusRule.AUTO;\n    this.focusableContainer = false;\n\n    // The alignment defines how the popup is positioned around the anchor.\n    // If there is no anchor or anchor bounds the alignment has no effect.\n    this.horizontalAlignment = Popup.Alignment.LEFTEDGE;\n    this.verticalAlignment = Popup.Alignment.BOTTOM;\n\n    // Gives the current alignment after applying horizontal and vertical switch options\n    this.calculatedHorizontalAlignment = this.horizontalAlignment;\n    this.calculatedVerticalAlignment = this.verticalAlignment;\n\n    // If switch is enabled, the alignment will be changed if the popup overlaps a window border.\n    this.horizontalSwitch = false;\n    this.verticalSwitch = true;\n\n    // Hints for the layout to control whether the size should be adjusted if the popup does not fit into the window.\n    // Before trimming is applied the popup will be switched, if the switch option is enabled.\n    // If neither switch nor trim is enabled, the popup will be moved until its right border is visible.\n    this.trimWidth = false;\n    this.trimHeight = true;\n\n    // Defines what should happen when the scroll parent is scrolled. It is also used if the anchor changes its location (needs to support the locationChange event)\n    this.scrollType = 'remove';\n    this.windowResizeType = null;\n\n    // If true, the anchor is considered when computing the position and size of the popup\n    this.boundToAnchor = true;\n\n    // If true, an arrow is shown pointing to the anchor. If there is no anchor, no arrow will be visible.\n    // Please note: some alignment combinations are not supported, which are: LEFT or RIGHT + BOTTOM or TOP\n    this.withArrow = false;\n\n    // If false, the attached mouse down handler will NOT close the popup if the anchor was clicked, the anchor is responsible to close it.\n    // This is necessary because the mousedown listener is attached to the capture phase and therefore executed before any other.\n    // If anchor was clicked, popup would already be closed and then opened again -> popup could never be closed by clicking the anchor\n    this.closeOnAnchorMouseDown = true;\n    this._closeOnAnchorMouseDown = null;\n\n    // Defines whether the popup should be closed on a mouse click outside of the popup\n    this.closeOnMouseDownOutside = true;\n    this._closeOnMouseDownOutside = null;\n\n    // Defines whether the popup should be closed whenever another popup opens.\n    this.closeOnOtherPopupOpen = true;\n    this._closeOnOtherPopupOpen = null;\n\n    // Defines whether the popup should behave like a modal form. If true, the properties closeOnAnchorMouseDown, closeOnMouseDownOutside\n    // and closeOnOtherPopupOpen ore overruled and set to false. The property withGlassPane is overruled too and set to true.\n    this.modal = false;\n\n    this._openLater = false;\n\n    this.$arrow = null;\n    this.$arrowOverlay = null;\n    this._windowResizeHandler = this._onWindowResize.bind(this);\n    this._anchorRenderHandler = this._onAnchorRender.bind(this);\n    this._addWidgetProperties(['anchor']);\n    this._addPreserveOnPropertyChangeProperties(['anchor']);\n  }\n\n  // Note that these strings are also used as CSS classes\n  static Alignment = {\n    /**\n     * The entire popup is positioned horizontally left of the anchor.\n     */\n    LEFT: 'left',\n    /**\n     * With arrow: The arrow at the left edge of the popup is aligned horizontally with the center of the anchor.\n     * <p>\n     * Without arrow: The left edges of both the popup and the anchor are aligned horizontally.\n     */\n    LEFTEDGE: 'leftedge',\n    /**\n     * The entire popup is positioned vertically above the anchor.\n     */\n    TOP: 'top',\n    /**\n     * With arrow: The arrow at the top edge of the popup is aligned vertically with the center of the anchor.\n     * <p>\n     * Without arrow: The top edges of both the popup and the anchor are aligned vertically.\n     */\n    TOPEDGE: 'topedge',\n    /**\n     * The centers of both the popup and the anchor are aligned in the respective dimension.\n     */\n    CENTER: 'center',\n    /**\n     * The entire popup is positioned horizontally to the right of the anchor.\n     */\n    RIGHT: 'right',\n    /**\n     * With arrow: The arrow at the right edge of the popup is aligned horizontally with the center of the anchor.\n     * <p>\n     * Without arrow: The right edges of both the popup and the anchor are aligned horizontally.\n     */\n    RIGHTEDGE: 'rightedge',\n    /**\n     * The entire popup is positioned vertically below the anchor.\n     */\n    BOTTOM: 'bottom',\n    /**\n     * With arrow: The arrow at the bottom edge of the popup is aligned vertically with the center of the anchor.\n     * <p>\n     * Without arrow: The bottom edges of both the popup and the anchor are aligned vertically.\n     */\n    BOTTOMEDGE: 'bottomedge'\n  };\n\n  static SwitchRule = {};\n\n  /**\n   * @param options:\n   *          initialFocus: a function that returns the element to be focused or a <code>FocusRule</code>. Default returns <code>FocusRule.AUTO</code>\n   *          focusableContainer: a boolean whether or not the container of the Popup is focusable\n   */\n  _init(options) {\n    super._init(options);\n\n    if (options.location) {\n      this.anchorBounds = new Rectangle(options.location.x, options.location.y, 0, 0);\n    }\n    this._setAnchor(this.anchor);\n    this._setModal(this.modal);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke(this._createCloseKeyStroke());\n  }\n\n  /**\n   * Override this method to provide a key stroke which closes the popup.\n   * The default impl. returns a CloseKeyStroke which handles the ESC key.\n   * @return KeyStroke\n   */\n  _createCloseKeyStroke() {\n    return new CloseKeyStroke(this);\n  }\n\n  /**\n   * @return {PopupLayout|AbstractLayout}\n   */\n  _createLayout() {\n    return new PopupLayout(this);\n  }\n\n  _openWithoutParent() {\n    // resolve parent for entry-point (don't change the actual property)\n    if (this.parent.destroyed) {\n      return;\n    }\n    if (this.parent.rendered || this.parent.rendering) {\n      this.open(this._getDefaultOpen$Parent());\n      return;\n    }\n\n    // This is important for popups rendered in another (native) browser window. The DOM in the popup window\n    // is rendered later, so we must wait until that window is rendered and layouted. See popup-window.html.\n    this.parent.one('render', () => {\n      this.session.layoutValidator.schedulePostValidateFunction(() => {\n        if (this.destroyed || this.rendered) {\n          return;\n        }\n        this.open();\n      });\n    });\n  }\n\n  /**\n   * Only called if parent.rendered or parent.rendering\n   * @return {$}\n   */\n  _getDefaultOpen$Parent() {\n    return this.parent.entryPoint();\n  }\n\n  open($parent) {\n    if (!$parent) {\n      this._openWithoutParent();\n      return;\n    }\n\n    this._triggerPopupOpenEvent();\n\n    this._open($parent);\n    if (this._openLater) {\n      return;\n    }\n\n    if (!this.animateOpening) {\n      // It is important that focusing happens after layouting and positioning, otherwise we'd focus an element\n      // that is currently not on the screen. Which would cause the whole desktop to\n      // be shifted for a few pixels.\n      this.validateFocus();\n      return;\n    }\n    // Give the browser time to layout properly before starting the animation to make sure it will be smooth.\n    // The before-animate-open class will make the popup invisible (cannot use the invisible class because it is already used by _validateVisibility)\n    this.$container.addClass('before-animate-open');\n    setTimeout(() => {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n      this.$container.removeClass('before-animate-open');\n      this.validateFocus(); // Need to be done after popup is visible again because focus cannot be set on invisible elements.\n      this.$container.addClassForAnimation('animate-open');\n    });\n  }\n\n  validateFocus() {\n    if (!this.withFocusContext) {\n      return;\n    }\n    let context = this.session.focusManager.getFocusContext(this.$container);\n    context.ready();\n    if (!context.lastValidFocusedElement) {\n      // No widget requested focus -> try to determine the initial focus\n      this._requestInitialFocus();\n    }\n  }\n\n  _requestInitialFocus() {\n    let initialFocusElement = this.session.focusManager.evaluateFocusRule(this.$container, this.initialFocus());\n    if (!initialFocusElement) {\n      return;\n    }\n    this.session.focusManager.requestFocus(initialFocusElement);\n  }\n\n  _open($parent) {\n    this.render($parent);\n    if (this._openLater) {\n      return;\n    }\n    this.revalidateLayout();\n    this.position();\n  }\n\n  render($parent) {\n    let $popupParent = $parent || this.entryPoint();\n    // when the parent is detached it is not possible to render the popup -> do it later\n    if (!$popupParent || !$popupParent.length || !$popupParent.isAttached()) {\n      this._openLater = true;\n      return;\n    }\n    super.render($popupParent);\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('popup');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.validateRoot = true;\n    this.htmlComp.setLayout(this._createLayout());\n    this.$container.window().on('resize', this._windowResizeHandler);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderAnchor();\n    this._renderWithArrow();\n    this._renderWithFocusContext();\n    this._renderWithGlassPane();\n    this._renderModal();\n  }\n\n  _postRender() {\n    super._postRender();\n\n    this._attachCloseHandlers();\n    this._attachAnchorHandlers();\n    this._handleGlassPanes();\n  }\n\n  _onAttach() {\n    super._onAttach();\n    if (this._openLater && !this.rendered) {\n      this._openLater = false;\n      // Don't animate the opening when parent is attached. It doesn't look right if popups \"pop up\" when they are not really opening but only displayed again.\n      // The same applies for detaching, see _renderOnDetach\n      let currentAnimateOpening = this.animateOpening;\n      this.animateOpening = false;\n      this.open();\n      this.animateOpening = currentAnimateOpening;\n    }\n  }\n\n  _renderOnDetach() {\n    this._openLater = true;\n    // If parent is detached, popup should be removed immediately, otherwise animation would still be visible even though parent has already gone.\n    super.removeImmediately();\n    super._renderOnDetach();\n  }\n\n  remove() {\n    let currentAnimateRemoval = this.animateRemoval;\n    if ((this.boundToAnchor && this.$anchor) && !this._isAnchorInView()) {\n      this.animateRemoval = false;\n    }\n    super.remove();\n    this.animateRemoval = currentAnimateRemoval;\n  }\n\n  _remove() {\n    this.$container.window().off('resize', this._windowResizeHandler);\n    if (this._glassPaneRenderer) {\n      this._glassPaneRenderer.removeGlassPanes();\n    }\n    if (this.withFocusContext) {\n      this.session.focusManager.uninstallFocusContext(this.$container);\n    }\n    if (this.$arrow) {\n      this.$arrow.remove();\n      this.$arrow = null;\n    }\n\n    if (this.anchor) {\n      // reopen when the anchor gets rendered again\n      this.anchor.one('render', this._anchorRenderHandler);\n    }\n\n    // remove all clean-up handlers\n    this._detachAnchorHandlers();\n    this._detachCloseHandlers();\n    super._remove();\n  }\n\n  _destroy() {\n    if (this.anchor) {\n      this.anchor.off('render', this._anchorRenderHandler);\n    }\n    super._destroy();\n  }\n\n  _renderWithFocusContext() {\n    if (!this.withFocusContext) {\n      return;\n    }\n    // Add programmatic 'tabindex' if the $container itself should be focusable (used by context menu popups with no focusable elements)\n    if (this.focusableContainer) {\n      this.$container.attr('tabindex', -1);\n    }\n    // Don't allow an element to be focused while the popup is opened.\n    // The popup will focus the element as soon as the opening is finished (see open());\n    // The context needs to be already installed so that child elements don't try to focus an element outside of this context\n    this.session.focusManager.installFocusContext(this.$container, FocusRule.PREPARE);\n  }\n\n  setModal(modal) {\n    this.setProperty('modal', modal);\n  }\n\n  _setModal(modal) {\n    this._setProperty('modal', modal);\n    if (modal) {\n      widgets.preserveAndSetProperty(() => this.setProperty('withGlassPane', true), () => this.withGlassPane, this, '_withGlassPane');\n      widgets.preserveAndSetProperty(() => this.setProperty('closeOnAnchorMouseDown', false), () => this.closeOnAnchorMouseDown, this, '_closeOnAnchorMouseDown');\n      widgets.preserveAndSetProperty(() => this.setProperty('closeOnMouseDownOutside', false), () => this.closeOnMouseDownOutside, this, '_closeOnMouseDownOutside');\n      widgets.preserveAndSetProperty(() => this.setProperty('closeOnOtherPopupOpen', false), () => this.closeOnOtherPopupOpen, this, '_closeOnOtherPopupOpen');\n    } else {\n      widgets.resetProperty(v => this.setWithGlassPane(v), this, '_withGlassPane');\n      widgets.resetProperty(v => this.setCloseOnAnchorMouseDown(v), this, '_closeOnAnchorMouseDown');\n      widgets.resetProperty(v => this.setCloseOnMouseDownOutside(v), this, '_closeOnMouseDownOutside');\n      widgets.resetProperty(v => this.setCloseOnOtherPopupOpen(v), this, '_closeOnOtherPopupOpen');\n    }\n  }\n\n  _renderModal() {\n    this.$container.toggleClass('modal', this.modal);\n  }\n\n  setWithGlassPane(withGlassPane) {\n    if (!this.modal) {\n      this.setProperty('withGlassPane', withGlassPane);\n    } else {\n      this._withGlassPane = withGlassPane;\n    }\n  }\n\n  _renderWithGlassPane() {\n    if (this.withGlassPane && !this._glassPaneRenderer) {\n      this._glassPaneRenderer = new GlassPaneRenderer(this);\n      this._glassPaneRenderer.renderGlassPanes();\n    } else if (!this.withGlassPane && this._glassPaneRenderer) {\n      this._glassPaneRenderer.removeGlassPanes();\n      this._glassPaneRenderer = null;\n    }\n  }\n\n  setCloseOnMouseDownOutside(closeOnMouseDownOutside) {\n    if (!this.modal) {\n      this.setProperty('closeOnMouseDownOutside', closeOnMouseDownOutside);\n    } else {\n      this._closeOnMouseDownOutside = closeOnMouseDownOutside;\n    }\n  }\n\n  _renderCloseOnMouseDownOutside() {\n    // The listener needs to be executed in the capturing phase -> prevents that _onDocumentMouseDown will be executed right after the popup gets opened using mouse down, otherwise the popup would be closed immediately\n    if (this.closeOnMouseDownOutside && !this._documentMouseDownHandler) {\n      this._documentMouseDownHandler = this._onDocumentMouseDown.bind(this);\n      this.$container.document(true).addEventListener('mousedown', this._documentMouseDownHandler, true); // true=the event handler is executed in the capturing phase\n    } else if (!this.closeOnMouseDownOutside && this._documentMouseDownHandler) {\n      this.$container.document(true).removeEventListener('mousedown', this._documentMouseDownHandler, true);\n      this._documentMouseDownHandler = null;\n    }\n  }\n\n  setCloseOnAnchorMouseDown(closeOnAnchorMouseDown) {\n    if (!this.modal) {\n      this.setProperty('closeOnAnchorMouseDown', closeOnAnchorMouseDown);\n    } else {\n      this._closeOnAnchorMouseDown = closeOnAnchorMouseDown;\n    }\n  }\n\n  setCloseOnOtherPopupOpen(closeOnOtherPopupOpen) {\n    if (!this.modal) {\n      this.setProperty('closeOnOtherPopupOpen', closeOnOtherPopupOpen);\n    } else {\n      this._closeOnOtherPopupOpen = closeOnOtherPopupOpen;\n    }\n  }\n\n  _renderCloseOnOtherPopupOpen() {\n    if (this.closeOnOtherPopupOpen && !this._popupOpenHandler) {\n      this._popupOpenHandler = this._onPopupOpen.bind(this);\n      this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    } else if (!this.closeOnOtherPopupOpen && this._popupOpenHandler) {\n      this.session.desktop.off('popupOpen', this._popupOpenHandler);\n      this._popupOpenHandler = null;\n    }\n  }\n\n  setWithArrow(withArrow) {\n    this.setProperty('withArrow', withArrow);\n  }\n\n  _renderWithArrow() {\n    if (this.$arrow) {\n      this.$arrow.remove();\n      this.$arrow = null;\n    }\n    if (this.$arrowOverlay) {\n      this.$arrowOverlay.remove();\n      this.$arrowOverlay = null;\n    }\n    if (this.withArrow) {\n      this.$arrowOverlay = this.$container.prependDiv('popup-arrow-overlay');\n      this.$arrow = this.$container.prependDiv('popup-arrow');\n      this._updateArrowClass();\n    }\n    this.$container.toggleClass('with-arrow', this.withArrow);\n    this.invalidateLayoutTree();\n  }\n\n  _updateArrowClass(verticalAlignment, horizontalAlignment) {\n    if (this.$arrow) {\n      this.$arrow.removeClass(this._alignClasses());\n      this.$arrow.addClass(this._computeArrowPositionClass(verticalAlignment, horizontalAlignment));\n    }\n  }\n\n  _computeArrowPositionClass(verticalAlignment, horizontalAlignment) {\n    let Alignment = Popup.Alignment;\n    let cssClass = '';\n    horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n    verticalAlignment = verticalAlignment || this.verticalAlignment;\n    switch (horizontalAlignment) {\n      case Alignment.LEFT:\n        cssClass = Alignment.RIGHT;\n        break;\n      case Alignment.RIGHT:\n        cssClass = Alignment.LEFT;\n        break;\n      default:\n        cssClass = horizontalAlignment;\n        break;\n    }\n\n    switch (verticalAlignment) {\n      case Alignment.BOTTOM:\n        cssClass += ' ' + Alignment.TOP;\n        break;\n      case Alignment.TOP:\n        cssClass += ' ' + Alignment.BOTTOM;\n        break;\n      default:\n        cssClass += ' ' + verticalAlignment;\n        break;\n    }\n    return cssClass;\n  }\n\n  _animateRemovalWhileRemovingParent() {\n    if (!this.$anchor) {\n      // Allow remove animations for popups without an anchor\n      return true;\n    }\n    // If parent is the anchor, prevent remove animation to ensure popup will be removed together with the anchor\n    return widgets.get(this.$anchor) !== this.parent;\n  }\n\n  _isRemovalPrevented() {\n    // If removal of a parent is pending due to an animation then don't return true to make sure popups are closed before the parent animation starts.\n    // However, if the popup itself is removed by an animation, removal should be prevented to ensure remove() won't run multiple times.\n    return this.removalPending;\n  }\n\n  close() {\n    if (this.destroyed || this.destroying) {\n      // Already closed, do nothing\n      return;\n    }\n    let event = new Event();\n    this.trigger('close', event);\n    if (!event.defaultPrevented) {\n      this.destroy();\n    }\n  }\n\n  /**\n   * Install listeners to close the popup once clicking outside the popup,\n   * or changing the anchor's scroll position, or another popup is opened.\n   */\n  _attachCloseHandlers() {\n    // Install mouse close handler\n    this._renderCloseOnMouseDownOutside();\n    // Install popup open close handler\n    this._renderCloseOnOtherPopupOpen();\n  }\n\n  _attachAnchorHandlers() {\n    if (!this.$anchor || !this.boundToAnchor || !this.scrollType) {\n      return;\n    }\n    // Attach a scroll handler to each scrollable parent of the anchor\n    this._anchorScrollHandler = this._onAnchorScroll.bind(this);\n    scrollbars.onScroll(this.$anchor, this._anchorScrollHandler);\n\n    // Attach a location change handler as well (will only work if the anchor is a widget which triggers a locationChange event, e.g. another Popup)\n    let anchor = scout.widget(this.$anchor);\n    if (anchor) {\n      this._anchorLocationChangeHandler = this._onAnchorLocationChange.bind(this);\n      anchor.on('locationChange', this._anchorLocationChangeHandler);\n    }\n  }\n\n  _detachAnchorHandlers() {\n    if (this._anchorScrollHandler) {\n      scrollbars.offScroll(this._anchorScrollHandler);\n      this._anchorScrollHandler = null;\n    }\n    if (this._anchorLocationChangeHandler) {\n      let anchor = scout.widget(this.$anchor);\n      if (anchor) {\n        anchor.off('locationChange', this._anchorLocationChangeHandler);\n        this._anchorLocationChangeHandler = null;\n      }\n    }\n  }\n\n  _detachCloseHandlers() {\n    // Uninstall popup open close handler\n    if (this._popupOpenHandler) {\n      this.session.desktop.off('popupOpen', this._popupOpenHandler);\n      this._popupOpenHandler = null;\n    }\n\n    // Uninstall mouse close handler\n    if (this._documentMouseDownHandler) {\n      this.$container.document(true).removeEventListener('mousedown', this._documentMouseDownHandler, true);\n      this._documentMouseDownHandler = null;\n    }\n  }\n\n  _onDocumentMouseDown(event) {\n    // in some cases the mousedown handler is executed although it has been already\n    // detached on the _remove() method. However, since we're in the middle of\n    // processing the mousedown event, it's too late to detach the event and we must\n    // deal with that situation by checking the rendered flag. Otherwise we would\n    // run into an error later, since the $container is not available anymore.\n    // Use the internal flag because popup should be closed even if the parent removal is pending due to a remove animation\n    if (!this._rendered) {\n      return;\n    }\n    if (this._isMouseDownOutside(event)) {\n      this._onMouseDownOutside(event);\n    }\n  }\n\n  _isMouseDownOutside(event) {\n    let $target = $(event.target),\n      targetWidget;\n\n    if (!this.closeOnAnchorMouseDown && this._isMouseDownOnAnchor(event)) {\n      // 1. Often times, click on the anchor opens and 2. click closes the popup\n      // If we were closing the popup here, it would not be possible to achieve the described behavior anymore -> let anchor handle open and close.\n      return false;\n    }\n\n    targetWidget = scout.widget($target);\n\n    // close the popup only if the click happened outside of the popup and its children\n    // It is not sufficient to check the dom hierarchy using $container.has($target)\n    // because the popup may open other popups which probably is not a dom child but a sibling\n    // Also ignore clicks if the popup is covert by a glasspane\n    return !this.isOrHas(targetWidget) && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n  }\n\n  _isMouseDownOnAnchor(event) {\n    return !!this.$anchor && this.$anchor.isOrHas(event.target);\n  }\n\n  /**\n   * Method invoked once a mouse down event occurs outside the popup.\n   */\n  _onMouseDownOutside(event) {\n    this.close();\n  }\n\n  /**\n   * Method invoked once the 'options.$anchor' is scrolled.\n   */\n  _onAnchorScroll(event) {\n    if (!this.rendered) {\n      // Scroll events may be fired delayed, even if scroll listeners are already removed.\n      return;\n    }\n    this._handleAnchorPositionChange();\n  }\n\n  _handleAnchorPositionChange(event) {\n    if (scout.isOneOf(this.scrollType, 'position', 'layoutAndPosition') && this.isOpeningAnimationRunning()) {\n      // If the popup is opened with an animation which transforms the popup the sizes used by prefSize and position will likely be wrong.\n      // In that case it is not possible to layout and position it correctly -> do nothing.\n      return;\n    }\n\n    if (this.scrollType === 'position') {\n      this.position();\n    } else if (this.scrollType === 'layoutAndPosition') {\n      this.revalidateLayout();\n      this.position();\n    } else if (this.scrollType === 'remove') {\n      this.close();\n    }\n  }\n\n  isOpeningAnimationRunning() {\n    return this.rendered && this.animateOpening && this.$container.hasClass('animate-open');\n  }\n\n  _onAnchorLocationChange(event) {\n    this._handleAnchorPositionChange();\n  }\n\n  /**\n   * Method invoked once a popup is opened.\n   */\n  _onPopupOpen(event) {\n    // Make sure child popups don't close the parent popup, we must check parent hierarchy in both directions\n    // Use case: Opening of a context menu or cell editor in a form popup\n    // Also, popups covered by a glass pane (a modal dialog is open) must never be closed\n    // Use case: popup opens a modal dialog. User clicks on a smartfield on this dialog -> underlying popup must not get closed\n    let closable = !this.isOrHas(event.popup) && !event.popup.isOrHas(this);\n    if (this.rendered) {\n      closable = closable && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n    }\n    if (closable) {\n      this.close();\n    }\n  }\n\n  setHorizontalAlignment(horizontalAlignment) {\n    this.setProperty('horizontalAlignment', horizontalAlignment);\n  }\n\n  _renderHorizontalAlignment() {\n    this._updateArrowClass();\n    this.invalidateLayoutTree();\n  }\n\n  setVerticalAlignment(verticalAlignment) {\n    this.setProperty('verticalAlignment', verticalAlignment);\n  }\n\n  _renderVerticalAlignment() {\n    this._updateArrowClass();\n    this.invalidateLayoutTree();\n  }\n\n  setHorizontalSwitch(horizontalSwitch) {\n    this.setProperty('horizontalSwitch', horizontalSwitch);\n  }\n\n  _renderHorizontalSwitch() {\n    this.invalidateLayoutTree();\n  }\n\n  setVerticalSwitch(verticalSwitch) {\n    this.setProperty('verticalSwitch', verticalSwitch);\n  }\n\n  _renderVerticalSwitch() {\n    this.invalidateLayoutTree();\n  }\n\n  setTrimWidth(trimWidth) {\n    this.setProperty('trimWidth', trimWidth);\n  }\n\n  _renderTrimWidth() {\n    this.invalidateLayoutTree();\n  }\n\n  setTrimHeight(trimHeight) {\n    this.setProperty('trimHeight', trimHeight);\n  }\n\n  _renderTrimHeight() {\n    this.invalidateLayoutTree();\n  }\n\n  prefLocation(verticalAlignment, horizontalAlignment) {\n    if (!this.boundToAnchor || (!this.anchorBounds && !this.$anchor)) {\n      return this._prefLocationWithoutAnchor();\n    }\n    return this._prefLocationWithAnchor(verticalAlignment, horizontalAlignment);\n  }\n\n  _prefLocationWithoutAnchor() {\n    return DialogLayout.positionContainerInWindow(this.$container);\n  }\n\n  _prefLocationWithAnchor(verticalAlignment, horizontalAlignment) {\n    let $container = this.$container;\n    horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n    verticalAlignment = verticalAlignment || this.verticalAlignment;\n    let anchorBounds = this.getAnchorBounds();\n    let size = graphics.size($container, {exact: true});\n    let margins = graphics.margins($container);\n    let Alignment = Popup.Alignment;\n\n    let arrowBounds = null;\n    if (this.$arrow) {\n      // Ensure the arrow has the correct class\n      this._updateArrowClass(verticalAlignment, horizontalAlignment);\n      // Remove margin added by moving logic, otherwise the bounds would not be correct\n      graphics.setMargins(this.$arrow, new Insets());\n      arrowBounds = graphics.bounds(this.$arrow);\n    }\n\n    $container.removeClass(this._alignClasses());\n    $container.addClass(verticalAlignment + ' ' + horizontalAlignment);\n\n    let widthWithMargin = size.width + margins.horizontal();\n    let width = size.width;\n    let x = anchorBounds.x;\n    if (horizontalAlignment === Alignment.LEFT) {\n      x -= widthWithMargin;\n    } else if (horizontalAlignment === Alignment.LEFTEDGE) {\n      if (this.withArrow) {\n        x += anchorBounds.width / 2 - arrowBounds.center().x - margins.left;\n      } else {\n        x = anchorBounds.x - margins.left;\n      }\n    } else if (horizontalAlignment === Alignment.CENTER) {\n      x += anchorBounds.width / 2 - width / 2 - margins.left;\n    } else if (horizontalAlignment === Alignment.RIGHT) {\n      x += anchorBounds.width;\n    } else if (horizontalAlignment === Alignment.RIGHTEDGE) {\n      if (this.withArrow) {\n        x += anchorBounds.width / 2 - arrowBounds.center().x - margins.right;\n      } else {\n        x = anchorBounds.x + anchorBounds.width - width - margins.right;\n      }\n    }\n\n    let heightWithMargin = size.height + margins.vertical();\n    let height = size.height;\n    let y = anchorBounds.y;\n    if (verticalAlignment === Alignment.TOP) {\n      y -= heightWithMargin;\n    } else if (verticalAlignment === Alignment.TOPEDGE) {\n      if (this.withArrow) {\n        y += anchorBounds.height / 2 - arrowBounds.center().y - margins.top;\n      } else {\n        y = anchorBounds.y - margins.top;\n      }\n    } else if (verticalAlignment === Alignment.CENTER) {\n      y += anchorBounds.height / 2 - height / 2 - margins.top;\n    } else if (verticalAlignment === Alignment.BOTTOM) {\n      y += anchorBounds.height;\n    } else if (verticalAlignment === Alignment.BOTTOMEDGE) {\n      if (this.withArrow) {\n        y += anchorBounds.height / 2 - arrowBounds.center().y - margins.bottom;\n      } else {\n        y = anchorBounds.y + anchorBounds.height - height - margins.bottom;\n      }\n    }\n\n    // this.$parent might not be at (0,0) of the document\n    let parentOffset = this.$parent.offset();\n    x -= parentOffset.left;\n    y -= parentOffset.top;\n\n    return new Point(x, y);\n  }\n\n  _alignClasses() {\n    let Alignment = Popup.Alignment;\n    return strings.join(' ', Alignment.LEFT, Alignment.LEFTEDGE, Alignment.CENTER, Alignment.RIGHT, Alignment.RIGHTEDGE,\n      Alignment.TOP, Alignment.TOPEDGE, Alignment.CENTER, Alignment.BOTTOM, Alignment.BOTTOMEDGE);\n  }\n\n  getAnchorBounds() {\n    let anchorBounds = this.anchorBounds;\n    if (!this.$anchor) {\n      // Use manually set anchor bounds\n      return anchorBounds;\n    }\n    let realAnchorBounds = graphics.offsetBounds(this.$anchor, {\n      exact: true\n    });\n    if (!anchorBounds) {\n      // Use measured anchor bounds\n      anchorBounds = realAnchorBounds;\n    } else {\n      // Fill incomplete anchorBounds from measured anchor bounds. This allows setting one\n      // coordinate to a fixed value (e.g. the current mouse cursor position) while still\n      // aligning the other coordinate to the $anchor element.\n      //\n      // Implementation note:\n      // A coordinate is considered \"undefined\", when it is 0. Technically, this is not 100%\n      // correct, but will give the desired result in most of the cases. If would require too\n      // many code changes to correctly set missing values to undefined/null.\n      if (!anchorBounds.x) {\n        anchorBounds.x = realAnchorBounds.x;\n        anchorBounds.width = realAnchorBounds.width;\n      }\n      if (!anchorBounds.y) {\n        anchorBounds.y = realAnchorBounds.y;\n        anchorBounds.height = realAnchorBounds.height;\n      }\n    }\n    return anchorBounds;\n  }\n\n  getWindowSize() {\n    let $window = this.$parent.window();\n    return new Dimension($window.width(), $window.height());\n  }\n\n  /**\n   * @returns Point the amount of overlap at the window borders.\n   * A positive value indicates that it is overlapping the right / bottom border, a negative value indicates that it is overlapping the left / top border.\n   * Prefers the right and bottom over the left and top border, meaning if a positive value is returned it does not mean that the left border is overlapping as well.\n   */\n  overlap(location, includeMargin) {\n    let $container = this.$container;\n    if (!$container || !location) {\n      return null;\n    }\n    includeMargin = scout.nvl(includeMargin, true);\n    let containerSize = graphics.size($container, {exact: true, includeMargin: includeMargin});\n    let width = containerSize.width;\n    let height = containerSize.height;\n    let popupBounds = new Rectangle(location.x, location.y, width, height);\n    let bounds = graphics.offsetBounds($container.entryPoint(), true);\n\n    let overlapX = popupBounds.right() + this.windowPaddingX - bounds.width;\n    if (overlapX < 0) {\n      overlapX = Math.min(popupBounds.x - this.windowPaddingX - bounds.x, 0);\n    }\n    let overlapY = popupBounds.bottom() + this.windowPaddingY - bounds.height;\n    if (overlapY < 0) {\n      overlapY = Math.min(popupBounds.y - this.windowPaddingY - bounds.y, 0);\n    }\n    return new Point(overlapX, overlapY);\n  }\n\n  adjustLocation(location, switchIfNecessary) {\n    this.calculatedVerticalAlignment = this.verticalAlignment;\n    this.calculatedHorizontalAlignment = this.horizontalAlignment;\n    let overlap = this.overlap(location);\n\n    // Reset arrow style\n    if (this.$arrow) {\n      this._updateArrowClass(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment);\n      graphics.setMargins(this.$arrow, new Insets());\n    }\n\n    location = location.clone();\n    // Ignore very small overlaps (e.g. 0.3px). This could happen if anchor position is fractional and popup has a margin that is not\n    // Example: anchor has top: 10px and margin-top: 10px, browser renders it at 9.984px (due to zoom) but margin stays at 10px\n    // -> location.y would be -0.16px resulting in a popup switch so that the popup will be displayed outside of the window\n    if (Math.abs(overlap.y) >= 1) {\n      let verticalSwitch = scout.nvl(switchIfNecessary, this.verticalSwitch);\n      if (verticalSwitch) {\n        // Switch vertical alignment\n        this.calculatedVerticalAlignment = Popup.SwitchRule[this.calculatedVerticalAlignment];\n        location.y = this.prefLocation(this.calculatedVerticalAlignment).y;\n      } else {\n        // Move popup to the top until it gets fully visible (if switch is disabled)\n        location.y -= overlap.y;\n      }\n    }\n    // Reason for >= 1 see above\n    if (Math.abs(overlap.x) >= 1) {\n      let horizontalSwitch = scout.nvl(switchIfNecessary, this.horizontalSwitch);\n      if (horizontalSwitch) {\n        // Switch horizontal alignment\n        this.calculatedHorizontalAlignment = Popup.SwitchRule[this.calculatedHorizontalAlignment];\n        location.x = this.prefLocation(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment).x;\n      } else {\n        // Move popup to the left until it gets fully visible (if switch is disabled)\n        location.x -= overlap.x;\n      }\n    }\n\n    // Also move arrow so that it still points to the center of the anchor\n    if (this.$arrow) {\n      if (overlap.y !== 0 && (this.$arrow.hasClass(Popup.Alignment.LEFT) || this.$arrow.hasClass(Popup.Alignment.RIGHT))) {\n        if (overlap.y > 0) {\n          this.$arrow.cssMarginTop(overlap.y);\n        } else {\n          this.$arrow.cssMarginBottom(-overlap.y);\n        }\n      }\n      if (overlap.x !== 0 && (this.$arrow.hasClass(Popup.Alignment.TOP) || this.$arrow.hasClass(Popup.Alignment.BOTTOM))) {\n        if (overlap.x > 0) {\n          this.$arrow.cssMarginLeft(overlap.x);\n        } else {\n          this.$arrow.cssMarginRight(-overlap.x);\n        }\n      }\n    }\n\n    return location;\n  }\n\n  position(switchIfNecessary) {\n    if (!this.rendered) {\n      return;\n    }\n    this._validateVisibility();\n    this._position(switchIfNecessary);\n  }\n\n  _position(switchIfNecessary) {\n    let location = this.prefLocation();\n    if (!location) {\n      return;\n    }\n    location = this.adjustLocation(location, switchIfNecessary);\n    this.setLocation(location);\n  }\n\n  setLocation(location) {\n    if (!this.rendered) {\n      return;\n    }\n    this.$container\n      .css('left', location.x)\n      .css('top', location.y);\n    this._triggerLocationChange();\n  }\n\n  /**\n   * Popups with an anchor must only be visible if the anchor is in view (prevents that the popup points at an invisible anchor)\n   */\n  _validateVisibility() {\n    if (!this.boundToAnchor || !this.$anchor) {\n      return;\n    }\n    let inView = this._isAnchorInView();\n    let needsLayouting = this.$container.hasClass('invisible') === inView && inView;\n    this.$container.toggleClass('invisible', !inView); // Use visibility: hidden to not break layouting / size measurement\n    if (needsLayouting) {\n      let currentAnimateResize = this.animateResize;\n      this.animateResize = false;\n      this.revalidateLayout();\n      this.animateResize = currentAnimateResize;\n      if (this.withFocusContext) {\n        this.session.focusManager.validateFocus();\n      }\n    }\n  }\n\n  _isAnchorInView() {\n    if (!this.boundToAnchor || !this.$anchor) {\n      return;\n    }\n    let anchorBounds = this.getAnchorBounds();\n    return scrollbars.isLocationInView(anchorBounds.center(), this.$anchor.scrollParents());\n  }\n\n  _triggerLocationChange() {\n    this.trigger('locationChange');\n  }\n\n  /**\n   * Fire event that this popup is about to open.\n   */\n  _triggerPopupOpenEvent() {\n    this.session.desktop.trigger('popupOpen', {\n      popup: this\n    });\n  }\n\n  belongsTo($anchor) {\n    return this.$anchor[0] === $anchor[0];\n  }\n\n  set$Anchor($anchor) {\n    if (this.$anchor) {\n      this._detachAnchorHandlers();\n    }\n    this.setProperty('$anchor', $anchor);\n    if (this.rendered) {\n      this._attachAnchorHandlers();\n      this.revalidateLayout();\n      if (!this.animateResize) { // PopupLayout will move it -> don't break move animation\n        this.position();\n      }\n    }\n  }\n\n  isOpen() {\n    return this.rendered;\n  }\n\n  ensureOpen() {\n    if (!this.isOpen()) {\n      this.open();\n    }\n  }\n\n  setAnchor(anchor) {\n    this.setProperty('anchor', anchor);\n  }\n\n  _setAnchor(anchor) {\n    if (anchor) {\n      this.setParent(anchor);\n    }\n    this._setProperty('anchor', anchor);\n  }\n\n  _onAnchorRender() {\n    this.session.layoutValidator.schedulePostValidateFunction(() => {\n      if (this.rendered || this.destroyed) {\n        return;\n      }\n      if (this.anchor && !this.anchor.rendered) {\n        // Anchor was removed again while this function was scheduled -> wait again for rendering\n        this.anchor.one('render', this._anchorRenderHandler);\n        return;\n      }\n      let currentAnimateOpening = this.animateOpening;\n      this.animateOpening = false;\n      this.open();\n      this.animateOpening = currentAnimateOpening;\n    });\n  }\n\n  _renderAnchor() {\n    if (this.anchor) {\n      this.set$Anchor(this.anchor.$container);\n    }\n  }\n\n  _onWindowResize() {\n    if (!this.rendered) {\n      // may already be removed if a parent popup is closed during the resize event\n      return;\n    }\n    if (this.windowResizeType === 'position') {\n      this.position();\n    } else if (this.windowResizeType === 'layoutAndPosition') {\n      this.revalidateLayoutTree(false);\n      this.position();\n    } else if (this.windowResizeType === 'remove') {\n      this.close();\n    }\n  }\n\n  _handleGlassPanes() {\n    let parentCoveredByGlassPane = this.session.focusManager.isElementCovertByGlassPane(this.parent.$container);\n    // if a popup is covered by a glass pane the glass pane's need to be re-rendered to ensure a glass pane is also painted over the popup\n    if (parentCoveredByGlassPane) {\n      this.session.focusManager.rerenderGlassPanes();\n    }\n  }\n}\n\n((() => {\n  // Initialize switch rules (wrapped in IIFE to have local function scope for the variables)\n  let SwitchRule = Popup.SwitchRule;\n  let Alignment = Popup.Alignment;\n  SwitchRule[Alignment.LEFT] = Alignment.RIGHT;\n  SwitchRule[Alignment.LEFTEDGE] = Alignment.RIGHTEDGE;\n  SwitchRule[Alignment.TOP] = Alignment.BOTTOM;\n  SwitchRule[Alignment.TOPEDGE] = Alignment.BOTTOMEDGE;\n  SwitchRule[Alignment.CENTER] = Alignment.CENTER;\n  SwitchRule[Alignment.RIGHT] = Alignment.LEFT;\n  SwitchRule[Alignment.RIGHTEDGE] = Alignment.LEFTEDGE;\n  SwitchRule[Alignment.BOTTOM] = Alignment.TOP;\n  SwitchRule[Alignment.BOTTOMEDGE] = Alignment.TOPEDGE;\n})());\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}