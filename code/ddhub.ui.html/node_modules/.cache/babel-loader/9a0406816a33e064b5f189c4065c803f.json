{"ast":null,"code":"/*\n * Copyright (c) 2014-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { codes, Column, LookupCall, LookupRow, scout, SmartField, strings } from '../../index';\nimport objects from '../../util/objects';\n\n/**\n * Column where each cell fetches its value using a lookup call.\n *\n * A 'prepareLookupCall' event gets triggered before executing the lookup call and contains two properties, 'lookupCall' and 'row'. Here, 'lookupCall' is the\n * lookup call which is used to fetch one ore more values for a cell. 'row' is the row containing the cell and usually corresponds to the selected row.\n * It should be used instead of the property selectedRows from Table.js which must not be used here.\n * 'row' can be null or undefined in some cases. Hence some care is needed when listening to this event.\n */\nexport default class SmartColumn extends Column {\n  constructor() {\n    super();\n    this.codeType = null;\n    this.lookupCall = null;\n    this.browseHierarchy = false;\n    this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    this.browseAutoExpandAll = true;\n    this.browseLoadIncremental = false;\n    this.activeFilterEnabled = false;\n    this._lookupCallBatchContext = null;\n  }\n\n  /**\n   * @override\n   */\n  _init(model) {\n    super._init(model);\n    this._setLookupCall(this.lookupCall);\n    this._setCodeType(this.codeType);\n  }\n  _initCell(cell) {\n    super._initCell(cell);\n    cell.sortCode = this._calculateCellSortCode(cell);\n    return cell;\n  }\n  _calculateCellSortCode(cell) {\n    if (!this.codeType) {\n      return null;\n    }\n    let code = codes.get(this.codeType, cell.value);\n    return code ? code.sortCode : null;\n  }\n  _updateAllCellSortCodes() {\n    this.table.rows.map(row => this.cell(row)).forEach(cell => cell.setSortCode(this._calculateCellSortCode(cell)));\n  }\n  setLookupCall(lookupCall) {\n    if (this.lookupCall === lookupCall) {\n      return;\n    }\n    this._setLookupCall(lookupCall);\n    this._updateAllCellSortCodes();\n  }\n  _setLookupCall(lookupCall) {\n    this.lookupCall = LookupCall.ensure(lookupCall, this.session);\n  }\n  setCodeType(codeType) {\n    if (this.codeType === codeType) {\n      return;\n    }\n    this._setCodeType(codeType);\n    this._updateAllCellSortCodes();\n  }\n  _setCodeType(codeType) {\n    this.codeType = codeType;\n    if (!codeType) {\n      return;\n    }\n    this.lookupCall = scout.create('CodeLookupCall', {\n      session: this.session,\n      codeType: codeType\n    });\n  }\n  setBrowseHierarchy(browseHierarchy) {\n    this.browseHierarchy = browseHierarchy;\n  }\n  setBrowseMaxRowCount(browseMaxRowCount) {\n    this.browseMaxRowCount = browseMaxRowCount;\n  }\n  setBrowseAutoExpandAll(browseAutoExpandAll) {\n    this.browseAutoExpandAll = browseAutoExpandAll;\n  }\n  setBrowseLoadIncremental(browseLoadIncremental) {\n    this.browseLoadIncremental = browseLoadIncremental;\n  }\n  setActiveFilterEnabled(activeFilterEnabled) {\n    this.activeFilterEnabled = activeFilterEnabled;\n  }\n  _formatValue(value, row) {\n    if (!this.lookupCall) {\n      return strings.nvl(value) + '';\n    }\n    if (this.lookupCall.batch) {\n      return this._batchFormatValue(value);\n    }\n    let lookupCall = this.lookupCall.clone();\n    this.trigger('prepareLookupCall', {\n      lookupCall: lookupCall,\n      row: row\n    });\n    return lookupCall.textByKey(value);\n  }\n\n  /**\n   * Defers all invocations of the lookup call for the duration of the current event handler.\n   * Once the current event handler completes, all lookup calls are resolved in a single batch.\n   */\n  _batchFormatValue(key) {\n    if (objects.isNullOrUndefined(key)) {\n      return $.resolvedPromise('');\n    }\n    let currentBatchContext = this._lookupCallBatchContext;\n    if (!currentBatchContext) {\n      // create new batch context for this column\n      const batchResult = $.Deferred();\n      currentBatchContext = {\n        keySet: new Set(),\n        result: batchResult.promise()\n      };\n      this._lookupCallBatchContext = currentBatchContext;\n      setTimeout(() => {\n        // reset batch context for next batch run\n        this._lookupCallBatchContext = null;\n        let lookupCall = this.lookupCall.clone();\n        this.trigger('prepareLookupCall', {\n          lookupCall: lookupCall\n        });\n\n        // batch lookup texts\n        lookupCall.textsByKeys([...currentBatchContext.keySet]).then(textMap => batchResult.resolve(textMap)) // resolve result in current batch context\n        .catch(e => batchResult.reject(e)); // reject any errors\n      });\n    }\n\n    // add key to current batch\n    currentBatchContext.keySet.add(key);\n\n    // return text for current key\n    return currentBatchContext.result.then(textMap => textMap[objects.ensureValidKey(key)] || '');\n  }\n\n  /**\n   * Create and set the lookup-row instead of call setValue() as this would execute a lookup by key\n   * which is not necessary, since the cell already contains text and value. This also avoids a problem\n   * with multiple lookups running at once, see ticket 236960.\n   */\n  _updateEditorFromValidCell(field, cell) {\n    if (objects.isNullOrUndefined(cell.value)) {\n      field.setValue(null);\n      return;\n    }\n    let lookupRow = new LookupRow();\n    lookupRow.key = cell.value;\n    lookupRow.text = cell.text;\n    field.setLookupRow(lookupRow);\n  }\n  _createEditor(row) {\n    let field = scout.create('SmartField', {\n      parent: this.table,\n      codeType: this.codeType,\n      lookupCall: this.lookupCall ? this.lookupCall.clone() : null,\n      browseHierarchy: this.browseHierarchy,\n      browseMaxRowCount: this.browseMaxRowCount,\n      browseAutoExpandAll: this.browseAutoExpandAll,\n      browseLoadIncremental: this.browseLoadIncremental,\n      activeFilterEnabled: this.activeFilterEnabled\n    });\n    field.on('prepareLookupCall', event => {\n      this.trigger('prepareLookupCall', {\n        lookupCall: event.lookupCall,\n        row: row\n      });\n    });\n    field.on('lookupCallDone', event => {\n      this.trigger('lookupCallDone', {\n        result: event.result\n      });\n    });\n    return field;\n  }\n  _updateCellFromValidEditor(row, field) {\n    // The following code is only necessary to prevent flickering because the text is updated async.\n    // Instead of only calling setCellValue which itself would update the display text, we set the text manually before calling setCellValue.\n    // This works because in most of the cases the text computed by the column will be the same as the one computed by the editor field.\n\n    // Clear error status first (regular behavior)\n    this.setCellErrorStatus(row, null);\n\n    // Update cell text\n    // We cannot use setCellText to not trigger updateRows yet -> it has to be done after the value and row.status are updated correctly.\n    let cell = this.cell(row);\n    let oldText = cell.text;\n    let newText = field.displayText;\n    cell.setText(newText);\n\n    // Update cell value\n    // We cannot use setCellValue since it would add the update event to the updateBuffer but we need the row update to be sync to prevent the flickering\n    this._setCellValue(row, field.value, cell);\n\n    // Update row -> Render row, trigger update event\n    // Only trigger update row event if text has changed (same as setCellText would do)\n    if (row.initialized && oldText !== newText && cell.text === newText) {\n      this.table.updateRow(row);\n    }\n\n    // Ensure display text is correct (for the rare case that the column computes a different text than the editor field).\n    this._updateCellText(row, cell);\n  }\n\n  /**\n   * Since we don't know the type of the key from the lookup-row we must deal with numeric and string types here.\n   */\n  _hasCellValue(cell) {\n    let value = cell.value;\n    if (objects.isNumber(value)) {\n      return !objects.isNullOrUndefined(value); // Zero (0) is valid too\n    }\n\n    return !!value;\n  }\n  _setCellValue(row, value, cell) {\n    super._setCellValue(row, value, cell);\n    cell.setSortCode(this._calculateCellSortCode(cell));\n  }\n}","map":{"version":3,"names":["codes","Column","LookupCall","LookupRow","scout","SmartField","strings","objects","SmartColumn","constructor","codeType","lookupCall","browseHierarchy","browseMaxRowCount","DEFAULT_BROWSE_MAX_COUNT","browseAutoExpandAll","browseLoadIncremental","activeFilterEnabled","_lookupCallBatchContext","_init","model","_setLookupCall","_setCodeType","_initCell","cell","sortCode","_calculateCellSortCode","code","get","value","_updateAllCellSortCodes","table","rows","map","row","forEach","setSortCode","setLookupCall","ensure","session","setCodeType","create","setBrowseHierarchy","setBrowseMaxRowCount","setBrowseAutoExpandAll","setBrowseLoadIncremental","setActiveFilterEnabled","_formatValue","nvl","batch","_batchFormatValue","clone","trigger","textByKey","key","isNullOrUndefined","$","resolvedPromise","currentBatchContext","batchResult","Deferred","keySet","Set","result","promise","setTimeout","textsByKeys","then","textMap","resolve","catch","e","reject","add","ensureValidKey","_updateEditorFromValidCell","field","setValue","lookupRow","text","setLookupRow","_createEditor","parent","on","event","_updateCellFromValidEditor","setCellErrorStatus","oldText","newText","displayText","setText","_setCellValue","initialized","updateRow","_updateCellText","_hasCellValue","isNumber"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/columns/SmartColumn.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {codes, Column, LookupCall, LookupRow, scout, SmartField, strings} from '../../index';\nimport objects from '../../util/objects';\n\n/**\n * Column where each cell fetches its value using a lookup call.\n *\n * A 'prepareLookupCall' event gets triggered before executing the lookup call and contains two properties, 'lookupCall' and 'row'. Here, 'lookupCall' is the\n * lookup call which is used to fetch one ore more values for a cell. 'row' is the row containing the cell and usually corresponds to the selected row.\n * It should be used instead of the property selectedRows from Table.js which must not be used here.\n * 'row' can be null or undefined in some cases. Hence some care is needed when listening to this event.\n */\nexport default class SmartColumn extends Column {\n\n  constructor() {\n    super();\n    this.codeType = null;\n    this.lookupCall = null;\n    this.browseHierarchy = false;\n    this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    this.browseAutoExpandAll = true;\n    this.browseLoadIncremental = false;\n    this.activeFilterEnabled = false;\n    this._lookupCallBatchContext = null;\n  }\n\n  /**\n   * @override\n   */\n  _init(model) {\n    super._init(model);\n    this._setLookupCall(this.lookupCall);\n    this._setCodeType(this.codeType);\n  }\n\n  _initCell(cell) {\n    super._initCell(cell);\n    cell.sortCode = this._calculateCellSortCode(cell);\n    return cell;\n  }\n\n  _calculateCellSortCode(cell) {\n    if (!this.codeType) {\n      return null;\n    }\n    let code = codes.get(this.codeType, cell.value);\n    return code ? code.sortCode : null;\n  }\n\n  _updateAllCellSortCodes() {\n    this.table.rows.map(row => this.cell(row)).forEach(cell => cell.setSortCode(this._calculateCellSortCode(cell)));\n  }\n\n  setLookupCall(lookupCall) {\n    if (this.lookupCall === lookupCall) {\n      return;\n    }\n    this._setLookupCall(lookupCall);\n    this._updateAllCellSortCodes();\n  }\n\n  _setLookupCall(lookupCall) {\n    this.lookupCall = LookupCall.ensure(lookupCall, this.session);\n  }\n\n  setCodeType(codeType) {\n    if (this.codeType === codeType) {\n      return;\n    }\n    this._setCodeType(codeType);\n    this._updateAllCellSortCodes();\n  }\n\n  _setCodeType(codeType) {\n    this.codeType = codeType;\n    if (!codeType) {\n      return;\n    }\n    this.lookupCall = scout.create('CodeLookupCall', {\n      session: this.session,\n      codeType: codeType\n    });\n  }\n\n  setBrowseHierarchy(browseHierarchy) {\n    this.browseHierarchy = browseHierarchy;\n  }\n\n  setBrowseMaxRowCount(browseMaxRowCount) {\n    this.browseMaxRowCount = browseMaxRowCount;\n  }\n\n  setBrowseAutoExpandAll(browseAutoExpandAll) {\n    this.browseAutoExpandAll = browseAutoExpandAll;\n  }\n\n  setBrowseLoadIncremental(browseLoadIncremental) {\n    this.browseLoadIncremental = browseLoadIncremental;\n  }\n\n  setActiveFilterEnabled(activeFilterEnabled) {\n    this.activeFilterEnabled = activeFilterEnabled;\n  }\n\n  _formatValue(value, row) {\n    if (!this.lookupCall) {\n      return strings.nvl(value) + '';\n    }\n\n    if (this.lookupCall.batch) {\n      return this._batchFormatValue(value);\n    }\n\n    let lookupCall = this.lookupCall.clone();\n    this.trigger('prepareLookupCall', {\n      lookupCall: lookupCall,\n      row: row\n    });\n\n    return lookupCall.textByKey(value);\n  }\n\n  /**\n   * Defers all invocations of the lookup call for the duration of the current event handler.\n   * Once the current event handler completes, all lookup calls are resolved in a single batch.\n   */\n  _batchFormatValue(key) {\n    if (objects.isNullOrUndefined(key)) {\n      return $.resolvedPromise('');\n    }\n\n    let currentBatchContext = this._lookupCallBatchContext;\n    if (!currentBatchContext) {\n      // create new batch context for this column\n      const batchResult = $.Deferred();\n      currentBatchContext = {\n        keySet: new Set(),\n        result: batchResult.promise()\n      };\n      this._lookupCallBatchContext = currentBatchContext;\n\n      setTimeout(() => {\n        // reset batch context for next batch run\n        this._lookupCallBatchContext = null;\n\n        let lookupCall = this.lookupCall.clone();\n        this.trigger('prepareLookupCall', {\n          lookupCall: lookupCall\n        });\n\n        // batch lookup texts\n        lookupCall.textsByKeys([...currentBatchContext.keySet])\n          .then(textMap => batchResult.resolve(textMap)) // resolve result in current batch context\n          .catch(e => batchResult.reject(e)); // reject any errors\n      });\n    }\n\n    // add key to current batch\n    currentBatchContext.keySet.add(key);\n\n    // return text for current key\n    return currentBatchContext.result.then(textMap => textMap[objects.ensureValidKey(key)] || '');\n  }\n\n  /**\n   * Create and set the lookup-row instead of call setValue() as this would execute a lookup by key\n   * which is not necessary, since the cell already contains text and value. This also avoids a problem\n   * with multiple lookups running at once, see ticket 236960.\n   */\n  _updateEditorFromValidCell(field, cell) {\n    if (objects.isNullOrUndefined(cell.value)) {\n      field.setValue(null);\n      return;\n    }\n\n    let lookupRow = new LookupRow();\n    lookupRow.key = cell.value;\n    lookupRow.text = cell.text;\n    field.setLookupRow(lookupRow);\n  }\n\n  _createEditor(row) {\n    let field = scout.create('SmartField', {\n      parent: this.table,\n      codeType: this.codeType,\n      lookupCall: this.lookupCall ? this.lookupCall.clone() : null,\n      browseHierarchy: this.browseHierarchy,\n      browseMaxRowCount: this.browseMaxRowCount,\n      browseAutoExpandAll: this.browseAutoExpandAll,\n      browseLoadIncremental: this.browseLoadIncremental,\n      activeFilterEnabled: this.activeFilterEnabled\n    });\n\n    field.on('prepareLookupCall', event => {\n      this.trigger('prepareLookupCall', {\n        lookupCall: event.lookupCall,\n        row: row\n      });\n    });\n    field.on('lookupCallDone', event => {\n      this.trigger('lookupCallDone', {\n        result: event.result\n      });\n    });\n\n    return field;\n  }\n\n  _updateCellFromValidEditor(row, field) {\n    // The following code is only necessary to prevent flickering because the text is updated async.\n    // Instead of only calling setCellValue which itself would update the display text, we set the text manually before calling setCellValue.\n    // This works because in most of the cases the text computed by the column will be the same as the one computed by the editor field.\n\n    // Clear error status first (regular behavior)\n    this.setCellErrorStatus(row, null);\n\n    // Update cell text\n    // We cannot use setCellText to not trigger updateRows yet -> it has to be done after the value and row.status are updated correctly.\n    let cell = this.cell(row);\n    let oldText = cell.text;\n    let newText = field.displayText;\n    cell.setText(newText);\n\n    // Update cell value\n    // We cannot use setCellValue since it would add the update event to the updateBuffer but we need the row update to be sync to prevent the flickering\n    this._setCellValue(row, field.value, cell);\n\n    // Update row -> Render row, trigger update event\n    // Only trigger update row event if text has changed (same as setCellText would do)\n    if (row.initialized && oldText !== newText && cell.text === newText) {\n      this.table.updateRow(row);\n    }\n\n    // Ensure display text is correct (for the rare case that the column computes a different text than the editor field).\n    this._updateCellText(row, cell);\n  }\n\n  /**\n   * Since we don't know the type of the key from the lookup-row we must deal with numeric and string types here.\n   */\n  _hasCellValue(cell) {\n    let value = cell.value;\n    if (objects.isNumber(value)) {\n      return !objects.isNullOrUndefined(value); // Zero (0) is valid too\n    }\n    return !!value;\n  }\n\n  _setCellValue(row, value, cell) {\n    super._setCellValue(row, value, cell);\n    cell.setSortCode(this._calculateCellSortCode(cell));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}