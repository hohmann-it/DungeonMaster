{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport $ from 'jquery';\nimport { scout } from '../index';\n\n/**\n * Enhances the table with selection behaviour.<p>\n *\n * If mouseMoveSelectionEnabled is set to true, the user can select the rows by moving the mouse with pressed left mouse button.\n *\n */\nexport default class TableSelectionHandler {\n  constructor(table) {\n    this.table = table;\n    this.mouseMoveSelectionEnabled = true;\n    this._mouseDown = false;\n    this.lastActionRow = null;\n    this.mouseOverHandler = null;\n    this.select = true;\n    this.counterDebug = 0;\n    this.fromIndex = -1;\n    this.toIndex = -1;\n    // Index of the row that got a 'mouseover' event previously (needed to determine if the user is going up or down)\n    this._prevSelectedRowIndex = -1;\n    // The index of the selected row with the greatest distance to fromIndex (needed to efficiently clear the selection)\n    this._maxSelectedRowIndex = -1;\n  }\n  clearLastSelectedRowMarker() {\n    this.lastActionRow = null;\n  }\n\n  // TODO [7.0] bsh: Table Selection | Try to merge this with TableKeystrokeContext\n  onMouseDown(event) {\n    let $row = $(event.currentTarget);\n    let row = $row.data('row');\n    let oldSelectedState = $row.isSelected();\n    let rows = this.table.visibleRows;\n    this._mouseDown = true;\n    this.select = true;\n    if (this.table.multiSelect && event.shiftKey) {\n      // when a selected row in the middle of a selection-block has\n      // been clicked while shift is pressed -> do nothing\n      if (this.table.selectedRows.indexOf(row) > -1) {\n        return;\n      }\n      if (this.table.selectedRows.length === 0) {\n        // Shift-click was pressed without selection -> behave like normal click\n        this.lastActionRow = row;\n      }\n      if (!this.lastActionRow) {\n        // The last action row may have been cleared, e.g. when rows have been replaced. In that case, simply assume\n        // the first or the last of the currently selected rows as being the last action row to make shift-click\n        // behave as expected (depending on which row is nearer from the clicked row).\n        let thisRowIndex = rows.indexOf(row);\n        let firstSelectedRow = this.table.selectedRows[0];\n        let lastSelectedRow = this.table.selectedRows[this.table.selectedRows.length - 1];\n        if (thisRowIndex <= (rows.indexOf(firstSelectedRow) + rows.indexOf(lastSelectedRow)) / 2) {\n          this.lastActionRow = firstSelectedRow;\n        } else {\n          this.lastActionRow = lastSelectedRow;\n        }\n        this._maxSelectedRowIndex = rows.indexOf(lastSelectedRow);\n        this._prevSelectedRowIndex = rows.indexOf(this.lastActionRow);\n      }\n      this.fromIndex = rows.indexOf(this.lastActionRow);\n    } else if (event.ctrlKey) {\n      this.select = !oldSelectedState;\n    } else {\n      // Click on the already selected row must not clear the selection it to avoid another selection event sent to the server\n      // Right click on already selected rows must not clear the selection\n      if (!oldSelectedState || this.table.selectedRows.length > 1 && event.which !== 3) {\n        this.table._removeSelection();\n        this.table.selectedRows = [];\n      }\n    }\n    if (this.fromIndex < 0) {\n      this.fromIndex = rows.indexOf(row);\n    }\n    if (event.which !== 3 || !oldSelectedState) {\n      this.toIndex = rows.indexOf(row);\n      this.handleSelection(event);\n      this.table.notifyRowSelectionFinished();\n    }\n    if (this.mouseMoveSelectionEnabled && event.which !== 3) {\n      this.table.$data.off('mouseover', this.mouseOverHandler);\n      this.mouseOverHandler = this.onMouseOver.bind(this);\n      this.table.$data.on('mouseover', '.table-row', this.mouseOverHandler);\n      // This additionally window listener is necessary to track the clicks outside of a table row.\n      // If the mouse is released on a table row, onMouseUp gets called by the table's mouseUp listener.\n    }\n\n    $row.window().one('mouseup.selectionHandler', this.onMouseUp.bind(this));\n    this.lastActionRow = row;\n  }\n  onMouseOver(event) {\n    let $row = $(event.currentTarget);\n    let row = $row.data('row');\n    let rows = this.table.visibleRows;\n    this.toIndex = rows.indexOf(row);\n    this.handleSelection(event);\n    this.lastActionRow = row;\n  }\n  handleSelection(event) {\n    let rowsToUnselect;\n    let rows = this.table.visibleRows;\n    if (this.table.multiSelect) {\n      // Multi-selection -> expand/shrink selection\n      let thisIndex = this.toIndex;\n      let goingUp = thisIndex < this._prevSelectedRowIndex;\n      let goingDown = thisIndex > this._prevSelectedRowIndex;\n      let beforeFromSelection = this._prevSelectedRowIndex < this.fromIndex;\n      let afterFromSelection = this._prevSelectedRowIndex > this.fromIndex;\n\n      // In 'ctrlKey' mode, the unselection is done via 'select=false'\n      // Also prevent unselect in shiftKey mode, because otherwise we'd could\n      // possibly have unwanted gaps within the selection block (see #172929).\n      if (!event.ctrlKey) {\n        // If we are going _towards_ the startIndex, unselect all rows between the current row and the\n        // selected row with the greatest distance (this._maxSelectedRowIndex).\n        if (goingUp && afterFromSelection) {\n          rowsToUnselect = rows.slice(thisIndex + 1, this._maxSelectedRowIndex + 1);\n        } else if (goingDown && beforeFromSelection) {\n          rowsToUnselect = rows.slice(this._maxSelectedRowIndex, thisIndex);\n        }\n\n        // when shift is pressed: only unselect when first or last row (but not in the middle of the selection, see #172929)\n        if (rowsToUnselect && event.shiftKey) {\n          let selectionIndizes = this.getMinMaxSelectionIndizes();\n          rowsToUnselect = rowsToUnselect.reduce((aggr, row) => {\n            let rowIndex = rows.indexOf(row);\n            if (scout.isOneOf(rowIndex, selectionIndizes[0], selectionIndizes[1])) {\n              aggr.push(row);\n            }\n            return aggr;\n          }, []);\n        }\n        if (rowsToUnselect) {\n          rowsToUnselect.forEach(function (row) {\n            this.table.removeRowFromSelection(row, true);\n          }, this);\n        }\n      }\n      // Adjust the indexes\n      this._maxSelectedRowIndex = goingUp ? Math.min(this._maxSelectedRowIndex, thisIndex) : goingDown ? Math.max(this._maxSelectedRowIndex, thisIndex) : thisIndex;\n      this._prevSelectedRowIndex = thisIndex;\n    } else {\n      // Single selection -> unselect previously selected row\n      if (this.select) {\n        this.table._removeSelection();\n        this.table.selectedRows = [];\n      }\n\n      // Adjust the indexes\n      this.fromIndex = this.toIndex;\n    }\n\n    // Set the new selection\n    this._selectRange(this.fromIndex, this.toIndex, this.select);\n  }\n  _selectRange(fromIndex, toIndex, select) {\n    let rows = this.table.visibleRows;\n    let startIndex = Math.min(fromIndex, toIndex);\n    let endIndex = Math.max(fromIndex, toIndex) + 1;\n    let actionRows = rows.slice(startIndex, endIndex);\n\n    // set/remove selection\n    if (select) {\n      actionRows.forEach(function (row) {\n        this.table.addRowToSelection(row, true);\n      }, this);\n    } else {\n      actionRows.forEach(function (row) {\n        this.table.removeRowFromSelection(row, true);\n      }, this);\n    }\n  }\n  getMinMaxSelectionIndizes() {\n    let selectedRows = this.table.selectedRows,\n      allRows = this.table.visibleRows;\n    if (!selectedRows || selectedRows.length === 0) {\n      return [-1, -1];\n    }\n    let min = -1,\n      max = -1;\n    selectedRows.forEach(row => {\n      let index = allRows.indexOf(row);\n      if (min === -1 || index < min) {\n        min = index;\n      }\n      if (max === -1 || index > max) {\n        max = index;\n      }\n    });\n    return [min, max];\n  }\n  onMouseUp(event) {\n    if (!this._mouseDown) {\n      // May happen when selecting elements with chrome dev tools\n      return;\n    }\n    if (!this.table.rendered) {\n      // May happen when the table is removed between the mouse down and the mouse up event\n      // (e.g. when the user clicks 3 times very fast --> table is removed after double click).\n      return;\n    }\n    this._mouseDown = false;\n    this.table.$data.off('mouseover', this.mouseOverHandler);\n    this.fromIndex = -1;\n    this.toIndex = -1;\n    this.select = true;\n    this.table.notifyRowSelectionFinished();\n  }\n}","map":{"version":3,"names":["$","scout","TableSelectionHandler","constructor","table","mouseMoveSelectionEnabled","_mouseDown","lastActionRow","mouseOverHandler","select","counterDebug","fromIndex","toIndex","_prevSelectedRowIndex","_maxSelectedRowIndex","clearLastSelectedRowMarker","onMouseDown","event","$row","currentTarget","row","data","oldSelectedState","isSelected","rows","visibleRows","multiSelect","shiftKey","selectedRows","indexOf","length","thisRowIndex","firstSelectedRow","lastSelectedRow","ctrlKey","which","_removeSelection","handleSelection","notifyRowSelectionFinished","$data","off","onMouseOver","bind","on","window","one","onMouseUp","rowsToUnselect","thisIndex","goingUp","goingDown","beforeFromSelection","afterFromSelection","slice","selectionIndizes","getMinMaxSelectionIndizes","reduce","aggr","rowIndex","isOneOf","push","forEach","removeRowFromSelection","Math","min","max","_selectRange","startIndex","endIndex","actionRows","addRowToSelection","allRows","index","rendered"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/TableSelectionHandler.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport $ from 'jquery';\nimport {scout} from '../index';\n\n/**\n * Enhances the table with selection behaviour.<p>\n *\n * If mouseMoveSelectionEnabled is set to true, the user can select the rows by moving the mouse with pressed left mouse button.\n *\n */\nexport default class TableSelectionHandler {\n\n  constructor(table) {\n    this.table = table;\n    this.mouseMoveSelectionEnabled = true;\n    this._mouseDown = false;\n    this.lastActionRow = null;\n    this.mouseOverHandler = null;\n    this.select = true;\n    this.counterDebug = 0;\n\n    this.fromIndex = -1;\n    this.toIndex = -1;\n    // Index of the row that got a 'mouseover' event previously (needed to determine if the user is going up or down)\n    this._prevSelectedRowIndex = -1;\n    // The index of the selected row with the greatest distance to fromIndex (needed to efficiently clear the selection)\n    this._maxSelectedRowIndex = -1;\n  }\n\n  clearLastSelectedRowMarker() {\n    this.lastActionRow = null;\n  }\n\n  // TODO [7.0] bsh: Table Selection | Try to merge this with TableKeystrokeContext\n  onMouseDown(event) {\n    let $row = $(event.currentTarget);\n    let row = $row.data('row');\n    let oldSelectedState = $row.isSelected();\n    let rows = this.table.visibleRows;\n\n    this._mouseDown = true;\n    this.select = true;\n    if (this.table.multiSelect && event.shiftKey) {\n      // when a selected row in the middle of a selection-block has\n      // been clicked while shift is pressed -> do nothing\n      if (this.table.selectedRows.indexOf(row) > -1) {\n        return;\n      }\n      if (this.table.selectedRows.length === 0) {\n        // Shift-click was pressed without selection -> behave like normal click\n        this.lastActionRow = row;\n      }\n      if (!this.lastActionRow) {\n        // The last action row may have been cleared, e.g. when rows have been replaced. In that case, simply assume\n        // the first or the last of the currently selected rows as being the last action row to make shift-click\n        // behave as expected (depending on which row is nearer from the clicked row).\n        let thisRowIndex = rows.indexOf(row);\n        let firstSelectedRow = this.table.selectedRows[0];\n        let lastSelectedRow = this.table.selectedRows[this.table.selectedRows.length - 1];\n        if (thisRowIndex <= (rows.indexOf(firstSelectedRow) + rows.indexOf(lastSelectedRow)) / 2) {\n          this.lastActionRow = firstSelectedRow;\n        } else {\n          this.lastActionRow = lastSelectedRow;\n        }\n        this._maxSelectedRowIndex = rows.indexOf(lastSelectedRow);\n        this._prevSelectedRowIndex = rows.indexOf(this.lastActionRow);\n      }\n      this.fromIndex = rows.indexOf(this.lastActionRow);\n    } else if (event.ctrlKey) {\n      this.select = !oldSelectedState;\n    } else {\n      // Click on the already selected row must not clear the selection it to avoid another selection event sent to the server\n      // Right click on already selected rows must not clear the selection\n      if (!oldSelectedState || (this.table.selectedRows.length > 1 && event.which !== 3)) {\n        this.table._removeSelection();\n        this.table.selectedRows = [];\n      }\n    }\n    if (this.fromIndex < 0) {\n      this.fromIndex = rows.indexOf(row);\n    }\n\n    if (event.which !== 3 || !oldSelectedState) {\n      this.toIndex = rows.indexOf(row);\n      this.handleSelection(event);\n      this.table.notifyRowSelectionFinished();\n    }\n\n    if (this.mouseMoveSelectionEnabled && event.which !== 3) {\n      this.table.$data.off('mouseover', this.mouseOverHandler);\n      this.mouseOverHandler = this.onMouseOver.bind(this);\n      this.table.$data.on('mouseover', '.table-row', this.mouseOverHandler);\n      // This additionally window listener is necessary to track the clicks outside of a table row.\n      // If the mouse is released on a table row, onMouseUp gets called by the table's mouseUp listener.\n    }\n\n    $row.window().one('mouseup.selectionHandler', this.onMouseUp.bind(this));\n    this.lastActionRow = row;\n  }\n\n  onMouseOver(event) {\n    let $row = $(event.currentTarget);\n    let row = $row.data('row');\n    let rows = this.table.visibleRows;\n\n    this.toIndex = rows.indexOf(row);\n    this.handleSelection(event);\n    this.lastActionRow = row;\n  }\n\n  handleSelection(event) {\n    let rowsToUnselect;\n    let rows = this.table.visibleRows;\n    if (this.table.multiSelect) {\n      // Multi-selection -> expand/shrink selection\n      let thisIndex = this.toIndex;\n      let goingUp = (thisIndex < this._prevSelectedRowIndex);\n      let goingDown = (thisIndex > this._prevSelectedRowIndex);\n      let beforeFromSelection = (this._prevSelectedRowIndex < this.fromIndex);\n      let afterFromSelection = (this._prevSelectedRowIndex > this.fromIndex);\n\n      // In 'ctrlKey' mode, the unselection is done via 'select=false'\n      // Also prevent unselect in shiftKey mode, because otherwise we'd could\n      // possibly have unwanted gaps within the selection block (see #172929).\n      if (!event.ctrlKey) {\n\n        // If we are going _towards_ the startIndex, unselect all rows between the current row and the\n        // selected row with the greatest distance (this._maxSelectedRowIndex).\n        if (goingUp && afterFromSelection) {\n          rowsToUnselect = rows.slice(thisIndex + 1, this._maxSelectedRowIndex + 1);\n        } else if (goingDown && beforeFromSelection) {\n          rowsToUnselect = rows.slice(this._maxSelectedRowIndex, thisIndex);\n        }\n\n        // when shift is pressed: only unselect when first or last row (but not in the middle of the selection, see #172929)\n        if (rowsToUnselect && event.shiftKey) {\n          let selectionIndizes = this.getMinMaxSelectionIndizes();\n          rowsToUnselect = rowsToUnselect.reduce((aggr, row) => {\n            let rowIndex = rows.indexOf(row);\n            if (scout.isOneOf(rowIndex, selectionIndizes[0], selectionIndizes[1])) {\n              aggr.push(row);\n            }\n            return aggr;\n          }, []);\n        }\n\n        if (rowsToUnselect) {\n          rowsToUnselect.forEach(function(row) {\n            this.table.removeRowFromSelection(row, true);\n          }, this);\n        }\n      }\n      // Adjust the indexes\n      this._maxSelectedRowIndex = (goingUp ? Math.min(this._maxSelectedRowIndex, thisIndex) : (goingDown ? Math.max(this._maxSelectedRowIndex, thisIndex) : thisIndex));\n      this._prevSelectedRowIndex = thisIndex;\n    } else {\n      // Single selection -> unselect previously selected row\n      if (this.select) {\n        this.table._removeSelection();\n        this.table.selectedRows = [];\n      }\n\n      // Adjust the indexes\n      this.fromIndex = this.toIndex;\n    }\n\n    // Set the new selection\n    this._selectRange(this.fromIndex, this.toIndex, this.select);\n  }\n\n  _selectRange(fromIndex, toIndex, select) {\n    let rows = this.table.visibleRows;\n    let startIndex = Math.min(fromIndex, toIndex);\n    let endIndex = Math.max(fromIndex, toIndex) + 1;\n    let actionRows = rows.slice(startIndex, endIndex);\n\n    // set/remove selection\n    if (select) {\n      actionRows.forEach(function(row) {\n        this.table.addRowToSelection(row, true);\n      }, this);\n    } else {\n      actionRows.forEach(function(row) {\n        this.table.removeRowFromSelection(row, true);\n      }, this);\n    }\n  }\n\n  getMinMaxSelectionIndizes() {\n    let\n      selectedRows = this.table.selectedRows,\n      allRows = this.table.visibleRows;\n\n    if (!selectedRows || selectedRows.length === 0) {\n      return [-1, -1];\n    }\n\n    let min = -1,\n      max = -1;\n    selectedRows.forEach(row => {\n      let index = allRows.indexOf(row);\n      if (min === -1 || index < min) {\n        min = index;\n      }\n      if (max === -1 || index > max) {\n        max = index;\n      }\n    });\n    return [min, max];\n  }\n\n  onMouseUp(event) {\n    if (!this._mouseDown) {\n      // May happen when selecting elements with chrome dev tools\n      return;\n    }\n    if (!this.table.rendered) {\n      // May happen when the table is removed between the mouse down and the mouse up event\n      // (e.g. when the user clicks 3 times very fast --> table is removed after double click).\n      return;\n    }\n\n    this._mouseDown = false;\n    this.table.$data.off('mouseover', this.mouseOverHandler);\n    this.fromIndex = -1;\n    this.toIndex = -1;\n    this.select = true;\n    this.table.notifyRowSelectionFinished();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}