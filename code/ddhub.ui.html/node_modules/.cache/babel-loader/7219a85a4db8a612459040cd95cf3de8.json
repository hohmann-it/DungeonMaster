{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Event, focusUtils, FormField, objects, ParsingFailedStatus, scout, Status, strings, ValidationFailedStatus } from '../../index';\nimport $ from 'jquery';\n\n/**\n * @abstract\n */\nexport default class ValueField extends FormField {\n  constructor() {\n    super();\n    this.clearable = ValueField.Clearable.FOCUSED;\n    this.displayText = null;\n    this.formatter = this._formatValue.bind(this);\n    this.hasText = false;\n    this.initialValue = null;\n    this.invalidValueMessageKey = 'InvalidValueMessageX';\n    this.parser = this._parseValue.bind(this);\n    this.value = null;\n    this.validators = [];\n    this.validators.push(this._validateValue.bind(this));\n    this._updateDisplayTextPending = false;\n    this.$clearIcon = null;\n    this._addCloneProperties(['value', 'displayText', 'clearable']);\n  }\n  _init(model) {\n    super._init(model);\n    if (this.validator) {\n      // Validators are kept in a list, allow a single validator to be set in the model, similar to parser and formatter.\n      // setValidator will add the new validator to this.validators and remove the other ones.\n      this.setValidator(this.validator);\n      delete this.validator;\n    }\n    this._initValue(this.value);\n  }\n\n  /**\n   * Override this method if you need to influence the value initialization (e.g. do something before the value is initially set)\n   */\n  _initValue(value) {\n    // Delete value first, value may be invalid and must not be set\n    this.value = null;\n    this._setValue(value);\n    this._updateEmpty();\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderDisplayText();\n    this._renderClearable();\n    this._renderHasText();\n  }\n  _remove() {\n    super._remove();\n    this.$clearIcon = null;\n  }\n\n  /**\n   * The default impl. is a NOP, because not every ValueField has a sensible display text.\n   */\n  _renderDisplayText() {\n    this._updateHasText();\n  }\n\n  /**\n   * The default impl. returns an empty string, because not every ValueField has a sensible display text.\n   */\n  _readDisplayText() {\n    return '';\n  }\n  _onClearIconMouseDown(event) {\n    this.clear();\n    event.preventDefault();\n  }\n  _onFieldBlur() {\n    super._onFieldBlur();\n    this.acceptInput(false);\n  }\n\n  /**\n   * Accepts the current input and writes it to the model.\n   * <p>\n   * This method is typically called by the _onBlur() function of the field, but may actually be called from anywhere (e.g. button, actions, cell editor, etc).\n   * It is also called by the _aboutToBlurByMouseDown() function, which is required because our Ok- and Cancel-buttons are not focusable (thus _onBlur() is\n   * never called) but changes in the value-field must be sent to the server anyway when a button is clicked.\n   * <p>\n   * The default reads the display text using this._readDisplayText() and writes it to the model by calling _triggerAcceptInput().\n   * If subclasses don't have a display-text or want to write another state to the server, they may override this method.\n   */\n  acceptInput(whileTyping) {\n    whileTyping = !!whileTyping; // cast to boolean\n    let displayText = scout.nvl(this._readDisplayText(), '');\n\n    // trigger only if displayText has really changed\n    if (this._checkDisplayTextChanged(displayText, whileTyping)) {\n      // Don't call setDisplayText() to prevent re-rendering of display text (which is unnecessary and\n      // might change the cursor position). Don't call _callSetProperty() as well, as this eventually\n      // executes this._setDisplayText(), which updates the value.\n      this._setProperty('displayText', displayText);\n      if (!whileTyping) {\n        this.parseAndSetValue(displayText);\n      }\n      // Display text may be formatted -> Use this.displayText\n      this._triggerAcceptInput(whileTyping);\n    }\n  }\n  parseAndSetValue(displayText) {\n    this.removeErrorStatus(ParsingFailedStatus);\n    try {\n      let event = new Event({\n        displayText: displayText\n      });\n      this.trigger('parse', event);\n      if (!event.defaultPrevented) {\n        let parsedValue = this.parseValue(displayText);\n        this.setValue(parsedValue);\n      }\n    } catch (error) {\n      this._parsingFailed(displayText, error);\n    }\n  }\n  _parsingFailed(displayText, error) {\n    $.log.isDebugEnabled() && $.log.debug('Parsing failed for field with id ' + this.id, error);\n    let event = new Event({\n      displayText: displayText,\n      error: error\n    });\n    this.trigger('parseError', event);\n    if (!event.defaultPrevented) {\n      this._addParsingFailedErrorStatus(displayText, error);\n    }\n  }\n  _addParsingFailedErrorStatus(displayText, error) {\n    let status = this._createParsingFailedStatus(displayText, error);\n    this.addErrorStatus(status);\n  }\n  _createParsingFailedStatus(displayText, error) {\n    return this._createInvalidValueStatus('ParsingFailedStatus', displayText, error);\n  }\n\n  /**\n   * Replaces the existing parser. The parser is called during {@link #parseValue(displayText)}.\n   * <p>\n   * Remember calling the default parser passed as parameter to the parse function, if needed.\n   * @param {function} parser the new parser. If null, the default parser is used.\n   */\n  setParser(parser) {\n    this.setProperty('parser', parser);\n    if (this.initialized) {\n      this.parseAndSetValue(this.displayText);\n    }\n  }\n  _setParser(parser) {\n    if (!parser) {\n      parser = this._parseValue.bind(this);\n    }\n    this._setProperty('parser', parser);\n  }\n\n  /**\n   * @returns {*} the parsed value\n   * @throws a message, a Status or an error if the parsing fails\n   */\n  parseValue(displayText) {\n    let defaultParser = this._parseValue.bind(this);\n    return this.parser(displayText, defaultParser);\n  }\n\n  /**\n   * @throws a message, a Status or an error if the parsing fails\n   */\n  _parseValue(displayText) {\n    return displayText;\n  }\n  _checkDisplayTextChanged(displayText, whileTyping) {\n    let oldDisplayText = scout.nvl(this.displayText, '');\n    return displayText !== oldDisplayText;\n  }\n\n  /**\n   * Method invoked upon a mousedown click with this field as the currently focused control, and is invoked just before the mousedown click will be interpreted.\n   * However, the mousedown target must not be this control, but any other control instead.\n   *\n   * The default implementation checks, whether the click occurred outside this control, and if so invokes 'ValueField.acceptInput'.\n   *\n   * @param target\n   *        the DOM target where the mouse down event occurred.\n   */\n  aboutToBlurByMouseDown(target) {\n    let eventOnField = this.isFocusOnField(target);\n    if (!eventOnField) {\n      this.acceptInput(); // event outside this value field.\n    }\n  }\n\n  /**\n   * @override\n   */\n  isFocused() {\n    return this.rendered && focusUtils.isActiveElement(this.$field);\n  }\n  isFocusOnField(target) {\n    return this.$field.isOrHas(target) || this.$clearIcon && this.$clearIcon.isOrHas(target);\n  }\n  _triggerAcceptInput(whileTyping) {\n    let event = {\n      displayText: this.displayText,\n      whileTyping: !!whileTyping\n    };\n    this.trigger('acceptInput', event);\n  }\n  setDisplayText(displayText) {\n    this.setProperty('displayText', displayText);\n  }\n  _updateHasText() {\n    this.setHasText(strings.hasText(this._readDisplayText()));\n  }\n  setHasText(hasText) {\n    this.setProperty('hasText', hasText);\n  }\n  _renderHasText() {\n    if (this.$field) {\n      this.$field.toggleClass('has-text', this.hasText);\n    }\n    this.$container.toggleClass('has-text', this.hasText);\n  }\n  setClearable(clearableStyle) {\n    this.setProperty('clearable', clearableStyle);\n  }\n  _renderClearable() {\n    if (this.isClearable()) {\n      if (!this.$clearIcon) {\n        this.addClearIcon();\n      }\n    } else {\n      if (this.$clearIcon) {\n        this.$clearIcon.remove();\n        this.$clearIcon = null;\n      }\n    }\n    this.invalidateLayoutTree(false);\n    this._updateClearableStyles();\n  }\n  _updateClearableStyles() {\n    this.$container.removeClass('clearable-always clearable-focused');\n    if (this.isClearable()) {\n      if (this.clearable === ValueField.Clearable.ALWAYS) {\n        this.$container.addClass('clearable-always');\n      } else if (this.clearable === ValueField.Clearable.FOCUSED) {\n        this.$container.addClass('clearable-focused');\n      }\n    }\n  }\n  isClearable() {\n    return this.clearable === ValueField.Clearable.ALWAYS || this.clearable === ValueField.Clearable.FOCUSED;\n  }\n\n  /**\n   * Clears the display text and the value to null.\n   */\n  clear() {\n    this._clear();\n    this._updateHasText();\n    this.acceptInput();\n    this._triggerClear();\n  }\n  _clear() {\n    // to be implemented by sub-classes\n  }\n  _triggerClear() {\n    this.trigger('clear');\n  }\n  setValue(value) {\n    // Same code as in Widget#setProperty expect for the equals check\n    // -> _setValue has to be called even if the value is equal so that update display text will be executed\n    value = this._prepareProperty('value', value);\n    if (this.rendered) {\n      this._callRemoveProperty('value');\n    }\n    this._callSetProperty('value', value);\n    if (this.rendered) {\n      this._callRenderProperty('value');\n    }\n  }\n\n  /**\n   * Resets the value to its initial value.\n   */\n  resetValue() {\n    this.setValue(this.initialValue);\n  }\n\n  /**\n   * Default does nothing because the value field does not know which type the concrete field uses.\n   * May be overridden to cast the value to the required type.\n   * @returns {*} the value with the correct type.\n   */\n  _ensureValue(value) {\n    return value;\n  }\n  _setValue(value) {\n    // When widget is initialized with a given errorStatus and a value -> don't remove the error\n    // status. This is a typical case for Scout Classic: field has a ParsingFailedError and user\n    // hits reload.\n    if (this.initialized) {\n      this.removeErrorStatus(ParsingFailedStatus);\n      this.removeErrorStatus(ValidationFailedStatus);\n    }\n    let oldValue = this.value;\n    let typedValue = null;\n    try {\n      typedValue = this._ensureValue(value);\n      this.value = this.validateValue(typedValue);\n    } catch (error) {\n      typedValue = typedValue || value;\n      this._validationFailed(typedValue, error);\n      return;\n    }\n    this._updateDisplayText();\n    if (this._valueEquals(oldValue, this.value)) {\n      return;\n    }\n    this._valueChanged();\n    this._updateTouched();\n    this._updateEmpty();\n    this.triggerPropertyChange('value', oldValue, this.value);\n  }\n  _valueEquals(valueA, valueB) {\n    return objects.equals(valueA, valueB);\n  }\n\n  /**\n   * Is called after a value is changed. May be implemented by subclasses. The default does nothing.\n   */\n  _valueChanged() {\n    // NOP\n  }\n\n  /**\n   * Validates the value by executing the validators. If a new value is the result, it will be set.\n   */\n  validate() {\n    this._setValue(this.value);\n  }\n\n  /**\n   * @param {function} validator the validator to be added.\n   *     A validator is a function that accepts a raw value and either returns the validated value or\n   *     throws an Error, a Status or an error message (string) if the value is invalid.\n   * @param {boolean} [revalidate] True, to revalidate the value, false to just add the validator and do nothing else. Default is true.\n   */\n  addValidator(validator, revalidate) {\n    let validators = this.validators.slice();\n    validators.push(validator);\n    this.setValidators(validators, revalidate);\n  }\n\n  /**\n   * @param {function} validator the validator to be removed\n   * @param {boolean} [revalidate] True, to revalidate the value, false to just remove the validator and do nothing else. Default is true.\n   */\n  removeValidator(validator, revalidate) {\n    let validators = this.validators.slice();\n    arrays.remove(validators, validator);\n    this.setValidators(validators, revalidate);\n  }\n\n  /**\n   * Replaces all existing validators with the given one. If you want to add multiple validators, use {@link #addValidator}.\n   * <p>\n   * Remember calling the default validator which is passed as parameter to the validate function, if needed.\n   *\n   * @param {function} validator the new validator which replaces every other. If null, the default validator is used.\n   *     A validator is a function that accepts a raw value and either returns the validated value or\n   *     throws an Error, a Status or an error message (string) if the value is invalid.\n   */\n  setValidator(validator, revalidate) {\n    if (!validator) {\n      validator = this._validateValue.bind(this);\n    }\n    let validators = [];\n    if (validator) {\n      validators = [validator];\n    }\n    this.setValidators(validators, revalidate);\n  }\n  setValidators(validators, revalidate) {\n    this.setProperty('validators', validators);\n    if (this.initialized && scout.nvl(revalidate, true)) {\n      this.validate();\n    }\n  }\n\n  /**\n   * @param the value to be validated\n   * @returns {*} the validated value\n   * @throws a message, a Status or an error if the validation fails\n   */\n  validateValue(value) {\n    let defaultValidator = this._validateValue.bind(this);\n    this.validators.forEach(validator => {\n      value = validator(value, defaultValidator);\n    });\n    value = scout.nvl(value, null); // Ensure value is never undefined (necessary for _updateTouched and should make it easier generally)\n    return value;\n  }\n\n  /**\n   * @returns {*} the validated value\n   * @throws a message, a Status or an error if the validation fails\n   */\n  _validateValue(value) {\n    if (typeof value === 'string' && value === '') {\n      // Convert empty string to null.\n      // Not using strings.nullIfEmpty is by purpose because it also removes white space characters which may not be desired here\n      value = null;\n    }\n    return value;\n  }\n  _validationFailed(value, error) {\n    $.log.isDebugEnabled() && $.log.debug('Validation failed for field with id ' + this.id, error);\n    let status = this._createValidationFailedStatus(value, error);\n    this.addErrorStatus(status);\n    this._updateDisplayText(value);\n  }\n  _createValidationFailedStatus(value, error) {\n    return this._createInvalidValueStatus('ValidationFailedStatus', value, error);\n  }\n\n  /**\n   * @param {string} statusType\n   * @returns {Status}\n   */\n  _createInvalidValueStatus(statusType, value, error) {\n    let statusFunc = Status.classForName(statusType);\n    // type of status is correct\n    if (error instanceof statusFunc) {\n      return error;\n    }\n    let message,\n      severity = Status.Severity.ERROR;\n    if (error instanceof Status) {\n      // its a Status, but it has the wrong specific type\n      message = error.message;\n      severity = error.severity;\n    } else if (typeof error === 'string') {\n      // convert string to status\n      message = error;\n    } else {\n      // create status with default message\n      message = this.session.text(this.invalidValueMessageKey, value);\n    }\n    return scout.create(statusType, {\n      message: message,\n      severity: severity\n    });\n  }\n  _updateDisplayText(value) {\n    if (!this.initialized && !objects.isNullOrUndefined(this.displayText)) {\n      // If a displayText is provided initially, use that text instead of using formatValue to generate a text based on the value\n      return;\n    }\n    value = scout.nvl(value, this.value);\n    let returned = this.formatValue(value);\n    if (objects.isPromise(returned)) {\n      this._updateDisplayTextPending = true;\n      // Promise is returned -> set display text later\n      returned.done(this.setDisplayText.bind(this)).fail(() => {\n        // If display text was updated in the meantime, don't override the text with an empty string\n        if (this._updateDisplayTextPending) {\n          this.setDisplayText('');\n        }\n        $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + value);\n      }).always(() => {\n        this._updateDisplayTextPending = false;\n      });\n    } else {\n      this.setDisplayText(returned);\n      this._updateDisplayTextPending = false;\n    }\n  }\n\n  /**\n   * Replaces the existing formatter. The formatter is called during {@link #formatValue(value)}.\n   * <p>\n   * Remember calling the default formatter which is passed as parameter to the format function, if needed.\n   * @param {function} formatter the new formatter. If null, the default formatter is used.\n   */\n  setFormatter(formatter) {\n    this.setProperty('formatter', formatter);\n    if (this.initialized) {\n      this.validate();\n    }\n  }\n  _setFormatter(formatter) {\n    if (!formatter) {\n      formatter = this._formatValue.bind(this);\n    }\n    this._setProperty('formatter', formatter);\n  }\n\n  /**\n   * @returns {string|Promise} the formatted display text\n   */\n  formatValue(value) {\n    let defaultFormatter = this._formatValue.bind(this);\n    return this.formatter(value, defaultFormatter);\n  }\n\n  /**\n   * @returns {string|Promise} the formatted string or a promise\n   */\n  _formatValue(value) {\n    return scout.nvl(value, '') + '';\n  }\n  _updateTouched() {\n    this.touched = !this._valueEquals(this.value, this.initialValue);\n  }\n  addClearIcon($parent) {\n    if (!$parent) {\n      $parent = this.$container;\n    }\n    this.$clearIcon = $parent.appendSpan('clear-icon unfocusable text-field-icon action').on('mousedown', this._onClearIconMouseDown.bind(this));\n  }\n  addContainer($parent, cssClass, layout) {\n    super.addContainer($parent, cssClass, layout);\n    this.$container.addClass('value-field');\n  }\n  addField($field) {\n    super.addField($field);\n    this.$field.data('valuefield', this);\n  }\n  markAsSaved() {\n    super.markAsSaved();\n    this.initialValue = this.value;\n  }\n\n  /**\n   * @override\n   */\n  _updateEmpty() {\n    this.empty = this.value === null || this.value === undefined;\n  }\n\n  // ==== static helper methods ==== //\n\n  /**\n   * Invokes 'ValueField.aboutToBlurByMouseDown' on the currently active value field.\n   * This method has no effect if another element is the focus owner.\n   */\n  static invokeValueFieldAboutToBlurByMouseDown(target) {\n    let activeValueField = this._getActiveValueField(target);\n    if (activeValueField) {\n      activeValueField.aboutToBlurByMouseDown(target);\n    }\n  }\n\n  /**\n   * Invokes 'ValueField.acceptInput' on the currently active value field.\n   * This method has no effect if another element is the focus owner.\n   */\n  static invokeValueFieldAcceptInput(target) {\n    let activeValueField = this._getActiveValueField(target);\n    if (activeValueField) {\n      activeValueField.acceptInput();\n    }\n  }\n\n  /**\n   * Returns the currently active value field, or null if another element is active.\n   * Also, if no value field currently owns the focus, its parent is checked to be a value field and is returned accordingly.\n   * That is used in DateField.js with multiple input elements.\n   */\n  static _getActiveValueField(target) {\n    let $activeElement = $(target).activeElement(),\n      activeWidget = scout.widget($activeElement);\n    if (activeWidget instanceof ValueField && activeWidget.enabledComputed) {\n      return activeWidget;\n    }\n    return null;\n  }\n}\n_defineProperty(ValueField, \"Clearable\", {\n  /**\n   * The clear icon is showed when the field has text.\n   */\n  ALWAYS: 'always',\n  /**\n   * The clear icon will be showed when the field is focused and has text.\n   */\n  FOCUSED: 'focused',\n  /**\n   * Never show the clear icon.\n   */\n  NEVER: 'never'\n});","map":{"version":3,"names":["arrays","Event","focusUtils","FormField","objects","ParsingFailedStatus","scout","Status","strings","ValidationFailedStatus","$","ValueField","constructor","clearable","Clearable","FOCUSED","displayText","formatter","_formatValue","bind","hasText","initialValue","invalidValueMessageKey","parser","_parseValue","value","validators","push","_validateValue","_updateDisplayTextPending","$clearIcon","_addCloneProperties","_init","model","validator","setValidator","_initValue","_setValue","_updateEmpty","_renderProperties","_renderDisplayText","_renderClearable","_renderHasText","_remove","_updateHasText","_readDisplayText","_onClearIconMouseDown","event","clear","preventDefault","_onFieldBlur","acceptInput","whileTyping","nvl","_checkDisplayTextChanged","_setProperty","parseAndSetValue","_triggerAcceptInput","removeErrorStatus","trigger","defaultPrevented","parsedValue","parseValue","setValue","error","_parsingFailed","log","isDebugEnabled","debug","id","_addParsingFailedErrorStatus","status","_createParsingFailedStatus","addErrorStatus","_createInvalidValueStatus","setParser","setProperty","initialized","_setParser","defaultParser","oldDisplayText","aboutToBlurByMouseDown","target","eventOnField","isFocusOnField","isFocused","rendered","isActiveElement","$field","isOrHas","setDisplayText","setHasText","toggleClass","$container","setClearable","clearableStyle","isClearable","addClearIcon","remove","invalidateLayoutTree","_updateClearableStyles","removeClass","ALWAYS","addClass","_clear","_triggerClear","_prepareProperty","_callRemoveProperty","_callSetProperty","_callRenderProperty","resetValue","_ensureValue","oldValue","typedValue","validateValue","_validationFailed","_updateDisplayText","_valueEquals","_valueChanged","_updateTouched","triggerPropertyChange","valueA","valueB","equals","validate","addValidator","revalidate","slice","setValidators","removeValidator","defaultValidator","forEach","_createValidationFailedStatus","statusType","statusFunc","classForName","message","severity","Severity","ERROR","session","text","create","isNullOrUndefined","returned","formatValue","isPromise","done","fail","isInfoEnabled","info","always","setFormatter","_setFormatter","defaultFormatter","touched","$parent","appendSpan","on","addContainer","cssClass","layout","addField","data","markAsSaved","empty","undefined","invokeValueFieldAboutToBlurByMouseDown","activeValueField","_getActiveValueField","invokeValueFieldAcceptInput","$activeElement","activeElement","activeWidget","widget","enabledComputed","NEVER"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/ValueField.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Event, focusUtils, FormField, objects, ParsingFailedStatus, scout, Status, strings, ValidationFailedStatus} from '../../index';\nimport $ from 'jquery';\n\n/**\n * @abstract\n */\nexport default class ValueField extends FormField {\n\n  constructor() {\n    super();\n    this.clearable = ValueField.Clearable.FOCUSED;\n    this.displayText = null;\n    this.formatter = this._formatValue.bind(this);\n    this.hasText = false;\n    this.initialValue = null;\n    this.invalidValueMessageKey = 'InvalidValueMessageX';\n    this.parser = this._parseValue.bind(this);\n    this.value = null;\n    this.validators = [];\n    this.validators.push(this._validateValue.bind(this));\n    this._updateDisplayTextPending = false;\n\n    this.$clearIcon = null;\n\n    this._addCloneProperties(['value', 'displayText', 'clearable']);\n  }\n\n  static Clearable = {\n    /**\n     * The clear icon is showed when the field has text.\n     */\n    ALWAYS: 'always',\n    /**\n     * The clear icon will be showed when the field is focused and has text.\n     */\n    FOCUSED: 'focused',\n    /**\n     * Never show the clear icon.\n     */\n    NEVER: 'never'\n  };\n\n  _init(model) {\n    super._init(model);\n    if (this.validator) {\n      // Validators are kept in a list, allow a single validator to be set in the model, similar to parser and formatter.\n      // setValidator will add the new validator to this.validators and remove the other ones.\n      this.setValidator(this.validator);\n      delete this.validator;\n    }\n    this._initValue(this.value);\n  }\n\n  /**\n   * Override this method if you need to influence the value initialization (e.g. do something before the value is initially set)\n   */\n  _initValue(value) {\n    // Delete value first, value may be invalid and must not be set\n    this.value = null;\n    this._setValue(value);\n    this._updateEmpty();\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderDisplayText();\n    this._renderClearable();\n    this._renderHasText();\n  }\n\n  _remove() {\n    super._remove();\n    this.$clearIcon = null;\n  }\n\n  /**\n   * The default impl. is a NOP, because not every ValueField has a sensible display text.\n   */\n  _renderDisplayText() {\n    this._updateHasText();\n  }\n\n  /**\n   * The default impl. returns an empty string, because not every ValueField has a sensible display text.\n   */\n  _readDisplayText() {\n    return '';\n  }\n\n  _onClearIconMouseDown(event) {\n    this.clear();\n    event.preventDefault();\n  }\n\n  _onFieldBlur() {\n    super._onFieldBlur();\n    this.acceptInput(false);\n  }\n\n  /**\n   * Accepts the current input and writes it to the model.\n   * <p>\n   * This method is typically called by the _onBlur() function of the field, but may actually be called from anywhere (e.g. button, actions, cell editor, etc).\n   * It is also called by the _aboutToBlurByMouseDown() function, which is required because our Ok- and Cancel-buttons are not focusable (thus _onBlur() is\n   * never called) but changes in the value-field must be sent to the server anyway when a button is clicked.\n   * <p>\n   * The default reads the display text using this._readDisplayText() and writes it to the model by calling _triggerAcceptInput().\n   * If subclasses don't have a display-text or want to write another state to the server, they may override this method.\n   */\n  acceptInput(whileTyping) {\n    whileTyping = !!whileTyping; // cast to boolean\n    let displayText = scout.nvl(this._readDisplayText(), '');\n\n    // trigger only if displayText has really changed\n    if (this._checkDisplayTextChanged(displayText, whileTyping)) {\n      // Don't call setDisplayText() to prevent re-rendering of display text (which is unnecessary and\n      // might change the cursor position). Don't call _callSetProperty() as well, as this eventually\n      // executes this._setDisplayText(), which updates the value.\n      this._setProperty('displayText', displayText);\n      if (!whileTyping) {\n        this.parseAndSetValue(displayText);\n      }\n      // Display text may be formatted -> Use this.displayText\n      this._triggerAcceptInput(whileTyping);\n    }\n  }\n\n  parseAndSetValue(displayText) {\n    this.removeErrorStatus(ParsingFailedStatus);\n    try {\n      let event = new Event({\n        displayText: displayText\n      });\n      this.trigger('parse', event);\n      if (!event.defaultPrevented) {\n        let parsedValue = this.parseValue(displayText);\n        this.setValue(parsedValue);\n      }\n    } catch (error) {\n      this._parsingFailed(displayText, error);\n    }\n  }\n\n  _parsingFailed(displayText, error) {\n    $.log.isDebugEnabled() && $.log.debug('Parsing failed for field with id ' + this.id, error);\n    let event = new Event({\n      displayText: displayText,\n      error: error\n    });\n    this.trigger('parseError', event);\n    if (!event.defaultPrevented) {\n      this._addParsingFailedErrorStatus(displayText, error);\n    }\n  }\n\n  _addParsingFailedErrorStatus(displayText, error) {\n    let status = this._createParsingFailedStatus(displayText, error);\n    this.addErrorStatus(status);\n  }\n\n  _createParsingFailedStatus(displayText, error) {\n    return this._createInvalidValueStatus('ParsingFailedStatus', displayText, error);\n  }\n\n  /**\n   * Replaces the existing parser. The parser is called during {@link #parseValue(displayText)}.\n   * <p>\n   * Remember calling the default parser passed as parameter to the parse function, if needed.\n   * @param {function} parser the new parser. If null, the default parser is used.\n   */\n  setParser(parser) {\n    this.setProperty('parser', parser);\n    if (this.initialized) {\n      this.parseAndSetValue(this.displayText);\n    }\n  }\n\n  _setParser(parser) {\n    if (!parser) {\n      parser = this._parseValue.bind(this);\n    }\n    this._setProperty('parser', parser);\n  }\n\n  /**\n   * @returns {*} the parsed value\n   * @throws a message, a Status or an error if the parsing fails\n   */\n  parseValue(displayText) {\n    let defaultParser = this._parseValue.bind(this);\n    return this.parser(displayText, defaultParser);\n  }\n\n  /**\n   * @throws a message, a Status or an error if the parsing fails\n   */\n  _parseValue(displayText) {\n    return displayText;\n  }\n\n  _checkDisplayTextChanged(displayText, whileTyping) {\n    let oldDisplayText = scout.nvl(this.displayText, '');\n    return displayText !== oldDisplayText;\n  }\n\n  /**\n   * Method invoked upon a mousedown click with this field as the currently focused control, and is invoked just before the mousedown click will be interpreted.\n   * However, the mousedown target must not be this control, but any other control instead.\n   *\n   * The default implementation checks, whether the click occurred outside this control, and if so invokes 'ValueField.acceptInput'.\n   *\n   * @param target\n   *        the DOM target where the mouse down event occurred.\n   */\n  aboutToBlurByMouseDown(target) {\n    let eventOnField = this.isFocusOnField(target);\n    if (!eventOnField) {\n      this.acceptInput(); // event outside this value field.\n    }\n  }\n\n  /**\n   * @override\n   */\n  isFocused() {\n    return this.rendered && focusUtils.isActiveElement(this.$field);\n  }\n\n  isFocusOnField(target) {\n    return this.$field.isOrHas(target) || (this.$clearIcon && this.$clearIcon.isOrHas(target));\n  }\n\n  _triggerAcceptInput(whileTyping) {\n    let event = {\n      displayText: this.displayText,\n      whileTyping: !!whileTyping\n    };\n    this.trigger('acceptInput', event);\n  }\n\n  setDisplayText(displayText) {\n    this.setProperty('displayText', displayText);\n  }\n\n  _updateHasText() {\n    this.setHasText(strings.hasText(this._readDisplayText()));\n  }\n\n  setHasText(hasText) {\n    this.setProperty('hasText', hasText);\n  }\n\n  _renderHasText() {\n    if (this.$field) {\n      this.$field.toggleClass('has-text', this.hasText);\n    }\n    this.$container.toggleClass('has-text', this.hasText);\n  }\n\n  setClearable(clearableStyle) {\n    this.setProperty('clearable', clearableStyle);\n  }\n\n  _renderClearable() {\n    if (this.isClearable()) {\n      if (!this.$clearIcon) {\n        this.addClearIcon();\n      }\n    } else {\n      if (this.$clearIcon) {\n        this.$clearIcon.remove();\n        this.$clearIcon = null;\n      }\n    }\n    this.invalidateLayoutTree(false);\n    this._updateClearableStyles();\n  }\n\n  _updateClearableStyles() {\n    this.$container.removeClass('clearable-always clearable-focused');\n    if (this.isClearable()) {\n      if (this.clearable === ValueField.Clearable.ALWAYS) {\n        this.$container.addClass('clearable-always');\n      } else if (this.clearable === ValueField.Clearable.FOCUSED) {\n        this.$container.addClass('clearable-focused');\n      }\n    }\n  }\n\n  isClearable() {\n    return this.clearable === ValueField.Clearable.ALWAYS || this.clearable === ValueField.Clearable.FOCUSED;\n  }\n\n  /**\n   * Clears the display text and the value to null.\n   */\n  clear() {\n    this._clear();\n    this._updateHasText();\n    this.acceptInput();\n    this._triggerClear();\n  }\n\n  _clear() {\n    // to be implemented by sub-classes\n  }\n\n  _triggerClear() {\n    this.trigger('clear');\n  }\n\n  setValue(value) {\n    // Same code as in Widget#setProperty expect for the equals check\n    // -> _setValue has to be called even if the value is equal so that update display text will be executed\n    value = this._prepareProperty('value', value);\n    if (this.rendered) {\n      this._callRemoveProperty('value');\n    }\n    this._callSetProperty('value', value);\n    if (this.rendered) {\n      this._callRenderProperty('value');\n    }\n  }\n\n  /**\n   * Resets the value to its initial value.\n   */\n  resetValue() {\n    this.setValue(this.initialValue);\n  }\n\n  /**\n   * Default does nothing because the value field does not know which type the concrete field uses.\n   * May be overridden to cast the value to the required type.\n   * @returns {*} the value with the correct type.\n   */\n  _ensureValue(value) {\n    return value;\n  }\n\n  _setValue(value) {\n    // When widget is initialized with a given errorStatus and a value -> don't remove the error\n    // status. This is a typical case for Scout Classic: field has a ParsingFailedError and user\n    // hits reload.\n    if (this.initialized) {\n      this.removeErrorStatus(ParsingFailedStatus);\n      this.removeErrorStatus(ValidationFailedStatus);\n    }\n    let oldValue = this.value;\n    let typedValue = null;\n    try {\n      typedValue = this._ensureValue(value);\n      this.value = this.validateValue(typedValue);\n    } catch (error) {\n      typedValue = typedValue || value;\n      this._validationFailed(typedValue, error);\n      return;\n    }\n\n    this._updateDisplayText();\n    if (this._valueEquals(oldValue, this.value)) {\n      return;\n    }\n\n    this._valueChanged();\n    this._updateTouched();\n    this._updateEmpty();\n    this.triggerPropertyChange('value', oldValue, this.value);\n  }\n\n  _valueEquals(valueA, valueB) {\n    return objects.equals(valueA, valueB);\n  }\n\n  /**\n   * Is called after a value is changed. May be implemented by subclasses. The default does nothing.\n   */\n  _valueChanged() {\n    // NOP\n  }\n\n  /**\n   * Validates the value by executing the validators. If a new value is the result, it will be set.\n   */\n  validate() {\n    this._setValue(this.value);\n  }\n\n  /**\n   * @param {function} validator the validator to be added.\n   *     A validator is a function that accepts a raw value and either returns the validated value or\n   *     throws an Error, a Status or an error message (string) if the value is invalid.\n   * @param {boolean} [revalidate] True, to revalidate the value, false to just add the validator and do nothing else. Default is true.\n   */\n  addValidator(validator, revalidate) {\n    let validators = this.validators.slice();\n    validators.push(validator);\n    this.setValidators(validators, revalidate);\n  }\n\n  /**\n   * @param {function} validator the validator to be removed\n   * @param {boolean} [revalidate] True, to revalidate the value, false to just remove the validator and do nothing else. Default is true.\n   */\n  removeValidator(validator, revalidate) {\n    let validators = this.validators.slice();\n    arrays.remove(validators, validator);\n    this.setValidators(validators, revalidate);\n  }\n\n  /**\n   * Replaces all existing validators with the given one. If you want to add multiple validators, use {@link #addValidator}.\n   * <p>\n   * Remember calling the default validator which is passed as parameter to the validate function, if needed.\n   *\n   * @param {function} validator the new validator which replaces every other. If null, the default validator is used.\n   *     A validator is a function that accepts a raw value and either returns the validated value or\n   *     throws an Error, a Status or an error message (string) if the value is invalid.\n   */\n  setValidator(validator, revalidate) {\n    if (!validator) {\n      validator = this._validateValue.bind(this);\n    }\n    let validators = [];\n    if (validator) {\n      validators = [validator];\n    }\n    this.setValidators(validators, revalidate);\n  }\n\n  setValidators(validators, revalidate) {\n    this.setProperty('validators', validators);\n    if (this.initialized && scout.nvl(revalidate, true)) {\n      this.validate();\n    }\n  }\n\n  /**\n   * @param the value to be validated\n   * @returns {*} the validated value\n   * @throws a message, a Status or an error if the validation fails\n   */\n  validateValue(value) {\n    let defaultValidator = this._validateValue.bind(this);\n    this.validators.forEach(validator => {\n      value = validator(value, defaultValidator);\n    });\n    value = scout.nvl(value, null); // Ensure value is never undefined (necessary for _updateTouched and should make it easier generally)\n    return value;\n  }\n\n  /**\n   * @returns {*} the validated value\n   * @throws a message, a Status or an error if the validation fails\n   */\n  _validateValue(value) {\n    if (typeof value === 'string' && value === '') {\n      // Convert empty string to null.\n      // Not using strings.nullIfEmpty is by purpose because it also removes white space characters which may not be desired here\n      value = null;\n    }\n    return value;\n  }\n\n  _validationFailed(value, error) {\n    $.log.isDebugEnabled() && $.log.debug('Validation failed for field with id ' + this.id, error);\n    let status = this._createValidationFailedStatus(value, error);\n    this.addErrorStatus(status);\n    this._updateDisplayText(value);\n  }\n\n  _createValidationFailedStatus(value, error) {\n    return this._createInvalidValueStatus('ValidationFailedStatus', value, error);\n  }\n\n  /**\n   * @param {string} statusType\n   * @returns {Status}\n   */\n  _createInvalidValueStatus(statusType, value, error) {\n    let statusFunc = Status.classForName(statusType);\n    // type of status is correct\n    if (error instanceof statusFunc) {\n      return error;\n    }\n    let message, severity = Status.Severity.ERROR;\n    if (error instanceof Status) {\n      // its a Status, but it has the wrong specific type\n      message = error.message;\n      severity = error.severity;\n    } else if (typeof error === 'string') {\n      // convert string to status\n      message = error;\n    } else {\n      // create status with default message\n      message = this.session.text(this.invalidValueMessageKey, value);\n    }\n    return scout.create(statusType, {\n      message: message,\n      severity: severity\n    });\n  }\n\n  _updateDisplayText(value) {\n    if (!this.initialized && !objects.isNullOrUndefined(this.displayText)) {\n      // If a displayText is provided initially, use that text instead of using formatValue to generate a text based on the value\n      return;\n    }\n    value = scout.nvl(value, this.value);\n    let returned = this.formatValue(value);\n    if (objects.isPromise(returned)) {\n      this._updateDisplayTextPending = true;\n      // Promise is returned -> set display text later\n      returned\n        .done(this.setDisplayText.bind(this))\n        .fail(() => {\n          // If display text was updated in the meantime, don't override the text with an empty string\n          if (this._updateDisplayTextPending) {\n            this.setDisplayText('');\n          }\n          $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + value);\n        })\n        .always(() => {\n          this._updateDisplayTextPending = false;\n        });\n    } else {\n      this.setDisplayText(returned);\n      this._updateDisplayTextPending = false;\n    }\n  }\n\n  /**\n   * Replaces the existing formatter. The formatter is called during {@link #formatValue(value)}.\n   * <p>\n   * Remember calling the default formatter which is passed as parameter to the format function, if needed.\n   * @param {function} formatter the new formatter. If null, the default formatter is used.\n   */\n  setFormatter(formatter) {\n    this.setProperty('formatter', formatter);\n    if (this.initialized) {\n      this.validate();\n    }\n  }\n\n  _setFormatter(formatter) {\n    if (!formatter) {\n      formatter = this._formatValue.bind(this);\n    }\n    this._setProperty('formatter', formatter);\n  }\n\n  /**\n   * @returns {string|Promise} the formatted display text\n   */\n  formatValue(value) {\n    let defaultFormatter = this._formatValue.bind(this);\n    return this.formatter(value, defaultFormatter);\n  }\n\n  /**\n   * @returns {string|Promise} the formatted string or a promise\n   */\n  _formatValue(value) {\n    return scout.nvl(value, '') + '';\n  }\n\n  _updateTouched() {\n    this.touched = !this._valueEquals(this.value, this.initialValue);\n  }\n\n  addClearIcon($parent) {\n    if (!$parent) {\n      $parent = this.$container;\n    }\n    this.$clearIcon = $parent.appendSpan('clear-icon unfocusable text-field-icon action')\n      .on('mousedown', this._onClearIconMouseDown.bind(this));\n  }\n\n  addContainer($parent, cssClass, layout) {\n    super.addContainer($parent, cssClass, layout);\n    this.$container.addClass('value-field');\n  }\n\n  addField($field) {\n    super.addField($field);\n    this.$field.data('valuefield', this);\n  }\n\n  markAsSaved() {\n    super.markAsSaved();\n    this.initialValue = this.value;\n  }\n\n  /**\n   * @override\n   */\n  _updateEmpty() {\n    this.empty = this.value === null || this.value === undefined;\n  }\n\n  // ==== static helper methods ==== //\n\n  /**\n   * Invokes 'ValueField.aboutToBlurByMouseDown' on the currently active value field.\n   * This method has no effect if another element is the focus owner.\n   */\n  static invokeValueFieldAboutToBlurByMouseDown(target) {\n    let activeValueField = this._getActiveValueField(target);\n    if (activeValueField) {\n      activeValueField.aboutToBlurByMouseDown(target);\n    }\n  }\n\n  /**\n   * Invokes 'ValueField.acceptInput' on the currently active value field.\n   * This method has no effect if another element is the focus owner.\n   */\n  static invokeValueFieldAcceptInput(target) {\n    let activeValueField = this._getActiveValueField(target);\n    if (activeValueField) {\n      activeValueField.acceptInput();\n    }\n  }\n\n  /**\n   * Returns the currently active value field, or null if another element is active.\n   * Also, if no value field currently owns the focus, its parent is checked to be a value field and is returned accordingly.\n   * That is used in DateField.js with multiple input elements.\n   */\n  static _getActiveValueField(target) {\n    let $activeElement = $(target).activeElement(),\n      activeWidget = scout.widget($activeElement);\n    if (activeWidget instanceof ValueField && activeWidget.enabledComputed) {\n      return activeWidget;\n    }\n    return null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}