{"ast":null,"code":"/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, arrays, ContextMenuPopupLayout, graphics, HtmlComponent, MenuDestinations, menuNavigationKeyStrokes, Popup, Rectangle, RowLayout } from '../index';\nimport $ from 'jquery';\nexport default class ContextMenuPopup extends Popup {\n  constructor() {\n    super();\n    this.animateOpening = true;\n    this.animateRemoval = true;\n    this.menuItems = [];\n    this.cloneMenuItems = true;\n    this.bodyAnimating = false;\n    this._toggleSubMenuQueue = [];\n    this.animationDuration = 300;\n  }\n  _init(options) {\n    options.focusableContainer = true; // In order to allow keyboard navigation, the popup must gain focus. Because menu-items are not focusable, make the container focusable instead.\n\n    // If menu items are cloned, don't link the original menus with the popup, otherwise they would be removed when the context menu is removed\n    if (options.cloneMenuItems === false) {\n      this._addWidgetProperties('menuItems');\n    }\n    super._init(options);\n  }\n\n  /**\n   * @override Popup.js\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    menuNavigationKeyStrokes.registerKeyStrokes(this.keyStrokeContext, this, 'menu-item');\n  }\n  _createLayout() {\n    return new ContextMenuPopupLayout(this);\n  }\n\n  /**\n   * @return {RowLayout}\n   */\n  _createBodyLayout() {\n    return new RowLayout({\n      pixelBasedSizing: false\n    });\n  }\n  _render() {\n    super._render();\n    this.$container.addClass('context-menu-popup');\n    this._renderBody();\n    this._installScrollbars();\n    this._renderMenuItems();\n  }\n  _remove() {\n    this._toggleSubMenuQueue = [];\n    super._remove();\n  }\n  _renderBody() {\n    this.$body = this.$container.appendDiv('context-menu');\n    // Complete the layout hierarchy between the popup and the menu items\n    let htmlBody = HtmlComponent.install(this.$body, this.session);\n    htmlBody.setLayout(this._createBodyLayout());\n  }\n  _installScrollbars(options) {\n    super._installScrollbars({\n      axis: 'y',\n      scrollShadow: 'none'\n    });\n  }\n  _checkRemoveSubMenuItemsPossible(parentMenu, animated) {\n    if (!this.rendered && !this.rendering) {\n      return false;\n    }\n    let openingAnimationRunning = this.isOpeningAnimationRunning();\n    let resizeAnimationRunning = this.htmlComp.layout.resizeAnimationRunning;\n    if (this.bodyAnimating || openingAnimationRunning || resizeAnimationRunning) {\n      // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n      this._toggleSubMenuQueue.push(this.removeSubMenuItems.bind(this, parentMenu, animated));\n      if (openingAnimationRunning) {\n        this.$container.oneAnimationEnd(() => this._processSubMenuQueue());\n      }\n      return false;\n    }\n    return true;\n  }\n  removeSubMenuItems(parentMenu, animated) {\n    if (!this._checkRemoveSubMenuItemsPossible(parentMenu, animated)) {\n      return false;\n    }\n    this.$body = parentMenu.__originalParent.$subMenuBody;\n    // move new body to back\n    this.$body.insertBefore(parentMenu.$subMenuBody);\n    if (parentMenu.__originalParent._doActionTogglesSubMenu) {\n      parentMenu.__originalParent._doActionTogglesSubMenu();\n    }\n    let popupBounds = this.htmlComp.bounds();\n    this._adjustTextAlignment();\n    HtmlComponent.get(this.$body).invalidateLayoutTree();\n    this.validateLayoutTree();\n    this.position();\n    if (animated) {\n      this._animateRemoveSubmenuItems(parentMenu, popupBounds);\n    }\n  }\n  _animateRemoveSubmenuItems(parentMenu, popupBounds) {\n    let parentMenuPosition = parentMenu.$placeHolder.position();\n    let popupInsets = this.htmlComp.insets();\n    let endPopupBounds = this.htmlComp.bounds();\n    let oldBodyBounds = HtmlComponent.get(parentMenu.$subMenuBody).bounds();\n    let bodyBounds = HtmlComponent.get(this.$body).bounds();\n    let startBodyBounds = new Rectangle(0, popupInsets.top, oldBodyBounds.width, oldBodyBounds.height);\n    let endBodyBounds = new Rectangle(0, popupInsets.top + parentMenuPosition.top, bodyBounds.width, parentMenu.$container.cssHeight());\n    this.bodyAnimating = true;\n    this.$container.addClass('animating');\n    this.htmlComp.layout.disableAutoPosition();\n    this._animateResizePopup(this.htmlComp.$comp, popupBounds, endPopupBounds);\n    this._animateTextOffset(parentMenu.$subMenuBody, parentMenu.$subMenuBody.data('text-offset'));\n\n    // Collapse old body\n    parentMenu.$subMenuBody.cssWidthAnimated(startBodyBounds.width, endBodyBounds.width, {\n      duration: this.animationDuration,\n      progress: this.revalidateLayout.bind(this),\n      complete: () => this._completeAnimateRemoveSubMenuItems(parentMenu),\n      queue: false\n    }).cssHeightAnimated(startBodyBounds.height, endBodyBounds.height, {\n      duration: this.animationDuration,\n      queue: false\n    }).cssTopAnimated(startBodyBounds.y, endBodyBounds.y, {\n      duration: this.animationDuration,\n      queue: false\n    });\n\n    // Resize new body so that it doesn't increase the popup height and shows unnecessary scrollbars if new body will be bigger\n    // It also ensures correct text ellipsis during animation, position is already correct\n    this.$body.cssWidthAnimated(oldBodyBounds.width, bodyBounds.width, {\n      duration: this.animationDuration,\n      queue: false\n    }).cssHeightAnimated(oldBodyBounds.height, bodyBounds.height, {\n      duration: this.animationDuration,\n      queue: false\n    });\n  }\n  _completeAnimateRemoveSubMenuItems(parentMenu) {\n    this.bodyAnimating = false;\n    if (!this.rendered || !parentMenu.$container) {\n      return;\n    }\n    this.$container.removeClass('animating');\n    parentMenu.$placeHolder.replaceWith(parentMenu.$container);\n    parentMenu.$container.toggleClass('expanded', false);\n    this._updateFirstLastClass();\n    this.updateNextToSelected('menu-item', parentMenu.$container);\n    parentMenu.$subMenuBody.detach();\n    this._processSubMenuQueue();\n  }\n  _processSubMenuQueue() {\n    let next = this._toggleSubMenuQueue.shift();\n    if (next) {\n      next();\n    }\n  }\n  _checkRenderSubMenuItemsPossible(parentMenu, menus, animated, initialSubMenuRendering) {\n    if (!this.session.desktop.rendered && !initialSubMenuRendering) {\n      this.initialSubMenusToRender = {\n        parentMenu: parentMenu,\n        menus: menus\n      };\n      return false;\n    }\n    if (!this.rendered && !this.rendering) {\n      return false;\n    }\n    let openingAnimationRunning = this.isOpeningAnimationRunning();\n    let resizeAnimationRunning = this.htmlComp.layout.resizeAnimationRunning;\n    if (this.bodyAnimating || openingAnimationRunning || resizeAnimationRunning) {\n      // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n      this._toggleSubMenuQueue.push(this.renderSubMenuItems.bind(this, parentMenu, menus, animated, initialSubMenuRendering));\n      if (openingAnimationRunning) {\n        this.$container.oneAnimationEnd(() => this._processSubMenuQueue());\n      }\n      return false;\n    }\n    return true;\n  }\n  renderSubMenuItems(parentMenu, menus, animated, initialSubMenuRendering) {\n    if (!this._checkRenderSubMenuItemsPossible(parentMenu, menus, animated, initialSubMenuRendering)) {\n      return false;\n    }\n    let popupBounds = this.htmlComp.bounds();\n    let $oldBody = this.$body;\n    parentMenu.__originalParent.$subMenuBody = $oldBody;\n    let $menuItems = this.$body.find('.menu-item');\n    $menuItems.removeClass('next-to-selected');\n    if (!parentMenu.$subMenuBody) {\n      this._renderBody();\n      parentMenu.$subMenuBody = this.$body;\n      this._renderMenuItems(menus, initialSubMenuRendering);\n    } else {\n      // append $body\n      this.$body = parentMenu.$subMenuBody;\n    }\n    let $insertAfterElement = parentMenu.$container.prev();\n    let parentMenuPosition = parentMenu.$container.position();\n    parentMenu.$placeHolder = parentMenu.$container.clone();\n    // HtmlComponent is necessary for the row layout (it would normally be installed by Menu.js, but $placeholder is just a jquery clone of parentMenu.$container and is not managed by a real widget)\n    HtmlComponent.install(parentMenu.$placeHolder, this.session);\n    if ($insertAfterElement.length) {\n      parentMenu.$placeHolder.insertAfter($insertAfterElement);\n    } else {\n      $oldBody.prepend(parentMenu.$placeHolder);\n    }\n    this.$body.insertAfter($oldBody);\n    this.$body.prepend(parentMenu.$container);\n    parentMenu.$container.toggleClass('expanded');\n    this._adjustTextAlignment();\n    HtmlComponent.get(this.$body).invalidateLayoutTree();\n    this.validateLayoutTree();\n    this.position();\n    this.updateNextToSelected();\n    if (animated) {\n      this._animateRenderSubMenuItems(parentMenu, popupBounds, parentMenuPosition);\n    } else {\n      $oldBody.detach();\n      this._updateFirstLastClass();\n    }\n  }\n  _animateRenderSubMenuItems(parentMenu, popupBounds, parentMenuPosition) {\n    let $oldBody = parentMenu.__originalParent.$subMenuBody;\n    let endPopupBounds = this.htmlComp.bounds();\n    let popupInsets = this.htmlComp.insets();\n    let oldBodyBounds = graphics.bounds($oldBody);\n    let bodyBounds = HtmlComponent.get(this.$body).bounds();\n    let startBodyBounds = new Rectangle(0, popupInsets.top + parentMenuPosition.top, oldBodyBounds.width, parentMenu.$container.cssHeight());\n    let endBodyBounds = new Rectangle(0, popupInsets.top, bodyBounds.width, bodyBounds.height);\n    this.bodyAnimating = true;\n    this.$container.addClass('animating');\n    this.htmlComp.layout.disableAutoPosition();\n    this._animateResizePopup(this.htmlComp.$comp, popupBounds, endPopupBounds);\n    this._animateTextOffset(this.$body, $oldBody.data('text-offset'));\n\n    // Expand new body\n    this.$body.cssWidthAnimated(startBodyBounds.width, endBodyBounds.width, {\n      duration: this.animationDuration,\n      progress: this.revalidateLayout.bind(this),\n      complete: () => this._completeAnimateRenderSubMenuItems($oldBody),\n      queue: false\n    }).cssHeightAnimated(startBodyBounds.height, endBodyBounds.height, {\n      duration: this.animationDuration,\n      queue: false\n    }).cssTopAnimated(startBodyBounds.y, endBodyBounds.y, {\n      duration: this.animationDuration,\n      queue: false\n    });\n\n    // Resize old body so that it doesn't increase the popup height and shows unnecessary scrollbars if new body will be smaller\n    // It also ensures correct text ellipsis during animation, position is already correct\n    $oldBody.cssWidthAnimated(oldBodyBounds.width, endBodyBounds.width, {\n      duration: this.animationDuration,\n      queue: false\n    }).cssHeightAnimated(oldBodyBounds.height, endBodyBounds.height, {\n      duration: this.animationDuration,\n      queue: false\n    });\n  }\n  _completeAnimateRenderSubMenuItems($oldBody) {\n    this.bodyAnimating = false;\n    if (!this.rendered) {\n      return;\n    }\n    this.$container.removeClass('animating');\n    if ($oldBody) {\n      $oldBody.detach();\n      this.$body.cssTop('');\n      this._updateFirstLastClass();\n    }\n    this.htmlComp.layout.resetAutoPosition();\n    this._processSubMenuQueue();\n  }\n  _animateResizePopup($comp, popupBounds, targetBounds) {\n    let options = {\n      duration: this.animationDuration,\n      queue: false\n    };\n    $comp.cssTopAnimated(popupBounds.y, targetBounds.y, options).cssLeftAnimated(popupBounds.x, targetBounds.x, options).cssWidthAnimated(popupBounds.width, targetBounds.width, options).cssHeightAnimated(popupBounds.height, targetBounds.height, options);\n  }\n  _animateTextOffset($body, textOffset, targetOffset) {\n    targetOffset = scout.nvl(targetOffset, this.$body.data('text-offset'));\n    let $menuItems = this.$visibleMenuItems($body);\n    $menuItems.each((index, menuItem) => {\n      let $menuItem = $(menuItem);\n      let $text = $menuItem.children('.text');\n      let padding = this._calcTextPaddingLeft($menuItem, textOffset);\n      let targetPadding = this._calcTextPaddingLeft($menuItem, targetOffset);\n      $text.cssAnimated({\n        paddingLeft: padding\n      }, {\n        paddingLeft: targetPadding\n      }, {\n        duration: this.animationDuration\n      });\n    });\n  }\n  _renderMenuItems(menus, initialSubMenuRendering) {\n    menus = menus ? menus : this._getMenuItems();\n    if (this.menuFilter) {\n      menus = this.menuFilter(menus, MenuDestinations.CONTEXT_MENU);\n    }\n    if (!menus || menus.length === 0) {\n      return;\n    }\n    menus.forEach(function (menu) {\n      // Invisible menus are rendered as well because their visibility might change dynamically\n      if (menu.separator) {\n        return;\n      }\n\n      // prevent loosing original parent\n      let originalParent = menu.parent;\n      // Clone menu items but only clone once unless it is for a different context menu (e.g. a context menu of a combo menu inside a context menu)\n      // Clone will recursively also clone all child actions.\n      if (this.cloneMenuItems && !menu.cloneOf || !this.has(menu)) {\n        menu = menu.clone({\n          parent: this,\n          textPosition: Action.TextPosition.DEFAULT\n        }, {\n          delegateEventsToOriginal: ['acceptInput', 'action', 'click'],\n          delegateAllPropertiesToClone: true,\n          delegateAllPropertiesToOriginal: true,\n          excludePropertiesToOriginal: ['selected', 'logicalGrid', 'tabbable']\n        });\n        menu.setTabbable(false);\n        // attach listener\n        this._attachCloneMenuListeners(menu);\n      }\n\n      // just set once because on second execution of this menu.parent is set to a popup\n      if (!menu.__originalParent) {\n        menu.__originalParent = originalParent;\n      }\n      menu.render(this.$body);\n      menu.$container.removeClass('menu-button');\n      this._attachMenuListeners(menu);\n    }, this);\n    this._handleInitialSubMenus(initialSubMenuRendering);\n    this._updateFirstLastClass();\n    this._adjustTextAlignment();\n  }\n  _attachCloneMenuListeners(menu) {\n    menu.on('propertyChange', this._onCloneMenuPropertyChange.bind(this));\n    menu.childActions.forEach(this._attachCloneMenuListeners.bind(this));\n  }\n  _onCloneMenuPropertyChange(event) {\n    if (event.propertyName === 'selected') {\n      let menu = event.source;\n      // Only trigger property change, setSelected would try to render the selected state which must not happen for the original menu\n      menu.cloneOf.triggerPropertyChange('selected', event.oldValue, event.newValue);\n    }\n  }\n  _handleInitialSubMenus(initialSubMenuRendering) {\n    if (initialSubMenuRendering) {\n      return;\n    }\n    let menusObj;\n    while (this.initialSubMenusToRender) {\n      menusObj = this.initialSubMenusToRender;\n      this.initialSubMenusToRender = undefined;\n      this.renderSubMenuItems(menusObj.parentMenu, menusObj.menus, false, true);\n    }\n  }\n  _attachMenuListeners(menu) {\n    let menuItemActionHandler = this._onMenuItemAction.bind(this);\n    let menuItemPropertyChange = this._onMenuItemPropertyChange.bind(this);\n    menu.on('action', menuItemActionHandler);\n    menu.on('propertyChange', menuItemPropertyChange);\n    this.one('remove', () => {\n      menu.off('action', menuItemActionHandler);\n      menu.off('propertyChange', menuItemPropertyChange);\n    });\n  }\n  updateMenuItems(menuItems) {\n    menuItems = arrays.ensure(menuItems);\n    // Only update if list of menus changed. Don't compare this.menuItems, because that list\n    // may contain additional UI separators, and may not be in the same order\n    if (!arrays.equals(this.menuItems, menuItems)) {\n      this.close();\n    }\n  }\n\n  /**\n   * Override this method to return menu items or actions used to render menu items.\n   */\n  _getMenuItems() {\n    return this.menuItems;\n  }\n\n  /**\n   * Currently rendered $menuItems\n   */\n  $menuItems() {\n    return this.$body.children('.menu-item');\n  }\n  $visibleMenuItems($body) {\n    $body = $body || this.$body;\n    return $body.children('.menu-item:visible');\n  }\n\n  /**\n   * Updates the first and last visible menu items with the according css classes.\n   * Necessary because invisible menu-items are rendered.\n   */\n  _updateFirstLastClass(event) {\n    let $firstMenuItem, $lastMenuItem;\n    this.$body.children('.menu-item').each(function () {\n      let $menuItem = $(this);\n      $menuItem.removeClass('first last');\n      if ($menuItem.isVisible()) {\n        if (!$firstMenuItem) {\n          $firstMenuItem = $menuItem;\n        }\n        $lastMenuItem = $menuItem;\n      }\n    });\n    if ($firstMenuItem) {\n      $firstMenuItem.addClass('first');\n    }\n    if ($lastMenuItem) {\n      $lastMenuItem.addClass('last');\n    }\n  }\n  updateNextToSelected(menuItemClass, $selectedItem) {\n    menuItemClass = menuItemClass ? menuItemClass : 'menu-item';\n    let $all = this.$body.find('.' + menuItemClass);\n    $selectedItem = $selectedItem ? $selectedItem : this.$body.find('.' + menuItemClass + '.selected');\n    $all.removeClass('next-to-selected');\n    if ($selectedItem.hasClass('selected')) {\n      $selectedItem.nextAll(':visible').first().addClass('next-to-selected');\n    }\n  }\n  _onMenuItemAction(event) {\n    if (event.source.isToggleAction()) {\n      return;\n    }\n    this.close();\n  }\n  _onMenuItemPropertyChange(event) {\n    if (!this.rendered) {\n      return;\n    }\n    if (event.propertyName === 'visible') {\n      this._updateFirstLastClass();\n    } else if (event.propertyName === 'selected') {\n      // Key stroke navigation marks the currently focused item as selected.\n      // When a sub menu item is opened while another element is selected (focused), make sure the other element gets unselected.\n      // Otherwise two items would be selected when the sub menu is closed again.\n      this._deselectSiblings(event.source);\n    }\n    // Make sure menu is positioned correctly afterwards (if it is opened upwards hiding/showing a menu item makes it necessary to reposition)\n    this.position();\n  }\n\n  /**\n   * Deselects the visible siblings of the given menu item. It just removes the CSS class and does not modify the selected property.\n   */\n  _deselectSiblings(menuItem) {\n    menuItem.$container.siblings('.menu-item').each((i, elem) => {\n      let $menuItem = $(elem);\n      $menuItem.select(false);\n    }, this);\n  }\n  _adjustTextAlignment($body) {\n    $body = $body || this.$body;\n    let $menuItems = this.$visibleMenuItems($body);\n    let textOffset = this._calcTextOffset($menuItems);\n    $body.data('text-offset', textOffset);\n    this._updateTextOffset(textOffset, $menuItems);\n  }\n  _calcTextOffset($menuItems) {\n    let textOffset = 0;\n    $menuItems = $menuItems || this.$visibleMenuItems();\n    $menuItems.each((index, menuItem) => {\n      let $menuItem = $(menuItem);\n      let $icon = $menuItem.children('.icon');\n      let iconWidth = 0;\n      if ($icon.length > 0) {\n        iconWidth = $icon.outerWidth(true);\n      }\n      textOffset = Math.max(textOffset, iconWidth);\n    });\n    return textOffset;\n  }\n  _updateTextOffset(textOffset, $menuItems) {\n    // Update the padding of each text such that the sum of icon width and the padding\n    // are the same for all items. This ensures that the texts are all aligned.\n    $menuItems = $menuItems || this.$visibleMenuItems();\n    $menuItems.each((index, menuItem) => {\n      let $menuItem = $(menuItem);\n      let $text = $menuItem.children('.text');\n      $text.css('padding-left', this._calcTextPaddingLeft($menuItem, textOffset));\n      let htmlComp = HtmlComponent.optGet($menuItem);\n      if (htmlComp) {\n        htmlComp.invalidateLayout();\n      }\n    });\n  }\n  _calcTextPaddingLeft($menuItem, textOffset) {\n    let $icon = $menuItem.children('.icon');\n    let iconWidth = 0;\n    if ($icon.length > 0) {\n      iconWidth = $icon.outerWidth(true);\n    }\n    return textOffset - iconWidth;\n  }\n}","map":{"version":3,"names":["Action","arrays","ContextMenuPopupLayout","graphics","HtmlComponent","MenuDestinations","menuNavigationKeyStrokes","Popup","Rectangle","RowLayout","$","ContextMenuPopup","constructor","animateOpening","animateRemoval","menuItems","cloneMenuItems","bodyAnimating","_toggleSubMenuQueue","animationDuration","_init","options","focusableContainer","_addWidgetProperties","_initKeyStrokeContext","registerKeyStrokes","keyStrokeContext","_createLayout","_createBodyLayout","pixelBasedSizing","_render","$container","addClass","_renderBody","_installScrollbars","_renderMenuItems","_remove","$body","appendDiv","htmlBody","install","session","setLayout","axis","scrollShadow","_checkRemoveSubMenuItemsPossible","parentMenu","animated","rendered","rendering","openingAnimationRunning","isOpeningAnimationRunning","resizeAnimationRunning","htmlComp","layout","push","removeSubMenuItems","bind","oneAnimationEnd","_processSubMenuQueue","__originalParent","$subMenuBody","insertBefore","_doActionTogglesSubMenu","popupBounds","bounds","_adjustTextAlignment","get","invalidateLayoutTree","validateLayoutTree","position","_animateRemoveSubmenuItems","parentMenuPosition","$placeHolder","popupInsets","insets","endPopupBounds","oldBodyBounds","bodyBounds","startBodyBounds","top","width","height","endBodyBounds","cssHeight","disableAutoPosition","_animateResizePopup","$comp","_animateTextOffset","data","cssWidthAnimated","duration","progress","revalidateLayout","complete","_completeAnimateRemoveSubMenuItems","queue","cssHeightAnimated","cssTopAnimated","y","removeClass","replaceWith","toggleClass","_updateFirstLastClass","updateNextToSelected","detach","next","shift","_checkRenderSubMenuItemsPossible","menus","initialSubMenuRendering","desktop","initialSubMenusToRender","renderSubMenuItems","$oldBody","$menuItems","find","$insertAfterElement","prev","clone","length","insertAfter","prepend","_animateRenderSubMenuItems","_completeAnimateRenderSubMenuItems","cssTop","resetAutoPosition","targetBounds","cssLeftAnimated","x","textOffset","targetOffset","scout","nvl","$visibleMenuItems","each","index","menuItem","$menuItem","$text","children","padding","_calcTextPaddingLeft","targetPadding","cssAnimated","paddingLeft","_getMenuItems","menuFilter","CONTEXT_MENU","forEach","menu","separator","originalParent","parent","cloneOf","has","textPosition","TextPosition","DEFAULT","delegateEventsToOriginal","delegateAllPropertiesToClone","delegateAllPropertiesToOriginal","excludePropertiesToOriginal","setTabbable","_attachCloneMenuListeners","render","_attachMenuListeners","_handleInitialSubMenus","on","_onCloneMenuPropertyChange","childActions","event","propertyName","source","triggerPropertyChange","oldValue","newValue","menusObj","undefined","menuItemActionHandler","_onMenuItemAction","menuItemPropertyChange","_onMenuItemPropertyChange","one","off","updateMenuItems","ensure","equals","close","$firstMenuItem","$lastMenuItem","isVisible","menuItemClass","$selectedItem","$all","hasClass","nextAll","first","isToggleAction","_deselectSiblings","siblings","i","elem","select","_calcTextOffset","_updateTextOffset","$icon","iconWidth","outerWidth","Math","max","css","optGet","invalidateLayout"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/menu/ContextMenuPopup.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, arrays, ContextMenuPopupLayout, graphics, HtmlComponent, MenuDestinations, menuNavigationKeyStrokes, Popup, Rectangle, RowLayout} from '../index';\nimport $ from 'jquery';\n\nexport default class ContextMenuPopup extends Popup {\n\n  constructor() {\n    super();\n\n    this.animateOpening = true;\n    this.animateRemoval = true;\n    this.menuItems = [];\n    this.cloneMenuItems = true;\n    this.bodyAnimating = false;\n    this._toggleSubMenuQueue = [];\n    this.animationDuration = 300;\n  }\n\n  _init(options) {\n    options.focusableContainer = true; // In order to allow keyboard navigation, the popup must gain focus. Because menu-items are not focusable, make the container focusable instead.\n\n    // If menu items are cloned, don't link the original menus with the popup, otherwise they would be removed when the context menu is removed\n    if (options.cloneMenuItems === false) {\n      this._addWidgetProperties('menuItems');\n    }\n\n    super._init(options);\n  }\n\n  /**\n   * @override Popup.js\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    menuNavigationKeyStrokes.registerKeyStrokes(this.keyStrokeContext, this, 'menu-item');\n  }\n\n  _createLayout() {\n    return new ContextMenuPopupLayout(this);\n  }\n\n  /**\n   * @return {RowLayout}\n   */\n  _createBodyLayout() {\n    return new RowLayout({\n      pixelBasedSizing: false\n    });\n  }\n\n  _render() {\n    super._render();\n    this.$container.addClass('context-menu-popup');\n    this._renderBody();\n    this._installScrollbars();\n    this._renderMenuItems();\n  }\n\n  _remove() {\n    this._toggleSubMenuQueue = [];\n    super._remove();\n  }\n\n  _renderBody() {\n    this.$body = this.$container.appendDiv('context-menu');\n    // Complete the layout hierarchy between the popup and the menu items\n    let htmlBody = HtmlComponent.install(this.$body, this.session);\n    htmlBody.setLayout(this._createBodyLayout());\n  }\n\n  _installScrollbars(options) {\n    super._installScrollbars({\n      axis: 'y',\n      scrollShadow: 'none'\n    });\n  }\n\n  _checkRemoveSubMenuItemsPossible(parentMenu, animated) {\n    if (!this.rendered && !this.rendering) {\n      return false;\n    }\n    let openingAnimationRunning = this.isOpeningAnimationRunning();\n    let resizeAnimationRunning = this.htmlComp.layout.resizeAnimationRunning;\n    if (this.bodyAnimating || openingAnimationRunning || resizeAnimationRunning) {\n      // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n      this._toggleSubMenuQueue.push(this.removeSubMenuItems.bind(this, parentMenu, animated));\n      if (openingAnimationRunning) {\n        this.$container.oneAnimationEnd(() => this._processSubMenuQueue());\n      }\n      return false;\n    }\n    return true;\n  }\n\n  removeSubMenuItems(parentMenu, animated) {\n    if (!this._checkRemoveSubMenuItemsPossible(parentMenu, animated)) {\n      return false;\n    }\n    this.$body = parentMenu.__originalParent.$subMenuBody;\n    // move new body to back\n    this.$body.insertBefore(parentMenu.$subMenuBody);\n\n    if (parentMenu.__originalParent._doActionTogglesSubMenu) {\n      parentMenu.__originalParent._doActionTogglesSubMenu();\n    }\n\n    let popupBounds = this.htmlComp.bounds();\n\n    this._adjustTextAlignment();\n    HtmlComponent.get(this.$body).invalidateLayoutTree();\n    this.validateLayoutTree();\n    this.position();\n\n    if (animated) {\n      this._animateRemoveSubmenuItems(parentMenu, popupBounds);\n    }\n  }\n\n  _animateRemoveSubmenuItems(parentMenu, popupBounds) {\n    let parentMenuPosition = parentMenu.$placeHolder.position();\n    let popupInsets = this.htmlComp.insets();\n    let endPopupBounds = this.htmlComp.bounds();\n    let oldBodyBounds = HtmlComponent.get(parentMenu.$subMenuBody).bounds();\n    let bodyBounds = HtmlComponent.get(this.$body).bounds();\n    let startBodyBounds = new Rectangle(0, popupInsets.top, oldBodyBounds.width, oldBodyBounds.height);\n    let endBodyBounds = new Rectangle(0, popupInsets.top + parentMenuPosition.top, bodyBounds.width, parentMenu.$container.cssHeight());\n\n    this.bodyAnimating = true;\n    this.$container.addClass('animating');\n    this.htmlComp.layout.disableAutoPosition();\n    this._animateResizePopup(this.htmlComp.$comp, popupBounds, endPopupBounds);\n    this._animateTextOffset(parentMenu.$subMenuBody, parentMenu.$subMenuBody.data('text-offset'));\n\n    // Collapse old body\n    parentMenu.$subMenuBody\n      .cssWidthAnimated(startBodyBounds.width, endBodyBounds.width, {\n        duration: this.animationDuration,\n        progress: this.revalidateLayout.bind(this),\n        complete: () => this._completeAnimateRemoveSubMenuItems(parentMenu),\n        queue: false\n      })\n      .cssHeightAnimated(startBodyBounds.height, endBodyBounds.height, {\n        duration: this.animationDuration,\n        queue: false\n      })\n      .cssTopAnimated(startBodyBounds.y, endBodyBounds.y, {\n        duration: this.animationDuration,\n        queue: false\n      });\n\n    // Resize new body so that it doesn't increase the popup height and shows unnecessary scrollbars if new body will be bigger\n    // It also ensures correct text ellipsis during animation, position is already correct\n    this.$body\n      .cssWidthAnimated(oldBodyBounds.width, bodyBounds.width, {\n        duration: this.animationDuration,\n        queue: false\n      })\n      .cssHeightAnimated(oldBodyBounds.height, bodyBounds.height, {\n        duration: this.animationDuration,\n        queue: false\n      });\n  }\n\n  _completeAnimateRemoveSubMenuItems(parentMenu) {\n    this.bodyAnimating = false;\n    if (!this.rendered || !parentMenu.$container) {\n      return;\n    }\n    this.$container.removeClass('animating');\n    parentMenu.$placeHolder.replaceWith(parentMenu.$container);\n    parentMenu.$container.toggleClass('expanded', false);\n    this._updateFirstLastClass();\n    this.updateNextToSelected('menu-item', parentMenu.$container);\n\n    parentMenu.$subMenuBody.detach();\n    this._processSubMenuQueue();\n  }\n\n  _processSubMenuQueue() {\n    let next = this._toggleSubMenuQueue.shift();\n    if (next) {\n      next();\n    }\n  }\n\n  _checkRenderSubMenuItemsPossible(parentMenu, menus, animated, initialSubMenuRendering) {\n    if (!this.session.desktop.rendered && !initialSubMenuRendering) {\n      this.initialSubMenusToRender = {\n        parentMenu: parentMenu,\n        menus: menus\n      };\n      return false;\n    }\n    if (!this.rendered && !this.rendering) {\n      return false;\n    }\n    let openingAnimationRunning = this.isOpeningAnimationRunning();\n    let resizeAnimationRunning = this.htmlComp.layout.resizeAnimationRunning;\n    if (this.bodyAnimating || openingAnimationRunning || resizeAnimationRunning) {\n      // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n      this._toggleSubMenuQueue.push(this.renderSubMenuItems.bind(this, parentMenu, menus, animated, initialSubMenuRendering));\n      if (openingAnimationRunning) {\n        this.$container.oneAnimationEnd(() => this._processSubMenuQueue());\n      }\n      return false;\n    }\n    return true;\n  }\n\n  renderSubMenuItems(parentMenu, menus, animated, initialSubMenuRendering) {\n    if (!this._checkRenderSubMenuItemsPossible(parentMenu, menus, animated, initialSubMenuRendering)) {\n      return false;\n    }\n\n    let popupBounds = this.htmlComp.bounds();\n    let $oldBody = this.$body;\n    parentMenu.__originalParent.$subMenuBody = $oldBody;\n    let $menuItems = this.$body.find('.menu-item');\n    $menuItems.removeClass('next-to-selected');\n\n    if (!parentMenu.$subMenuBody) {\n      this._renderBody();\n      parentMenu.$subMenuBody = this.$body;\n      this._renderMenuItems(menus, initialSubMenuRendering);\n    } else {\n      // append $body\n      this.$body = parentMenu.$subMenuBody;\n    }\n    let $insertAfterElement = parentMenu.$container.prev();\n    let parentMenuPosition = parentMenu.$container.position();\n    parentMenu.$placeHolder = parentMenu.$container.clone();\n    // HtmlComponent is necessary for the row layout (it would normally be installed by Menu.js, but $placeholder is just a jquery clone of parentMenu.$container and is not managed by a real widget)\n    HtmlComponent.install(parentMenu.$placeHolder, this.session);\n    if ($insertAfterElement.length) {\n      parentMenu.$placeHolder.insertAfter($insertAfterElement);\n    } else {\n      $oldBody.prepend(parentMenu.$placeHolder);\n    }\n\n    this.$body.insertAfter($oldBody);\n    this.$body.prepend(parentMenu.$container);\n    parentMenu.$container.toggleClass('expanded');\n    this._adjustTextAlignment();\n\n    HtmlComponent.get(this.$body).invalidateLayoutTree();\n    this.validateLayoutTree();\n    this.position();\n    this.updateNextToSelected();\n\n    if (animated) {\n      this._animateRenderSubMenuItems(parentMenu, popupBounds, parentMenuPosition);\n    } else {\n      $oldBody.detach();\n      this._updateFirstLastClass();\n    }\n  }\n\n  _animateRenderSubMenuItems(parentMenu, popupBounds, parentMenuPosition) {\n    let $oldBody = parentMenu.__originalParent.$subMenuBody;\n    let endPopupBounds = this.htmlComp.bounds();\n    let popupInsets = this.htmlComp.insets();\n    let oldBodyBounds = graphics.bounds($oldBody);\n    let bodyBounds = HtmlComponent.get(this.$body).bounds();\n    let startBodyBounds = new Rectangle(0, popupInsets.top + parentMenuPosition.top, oldBodyBounds.width, parentMenu.$container.cssHeight());\n    let endBodyBounds = new Rectangle(0, popupInsets.top, bodyBounds.width, bodyBounds.height);\n\n    this.bodyAnimating = true;\n    this.$container.addClass('animating');\n    this.htmlComp.layout.disableAutoPosition();\n    this._animateResizePopup(this.htmlComp.$comp, popupBounds, endPopupBounds);\n    this._animateTextOffset(this.$body, $oldBody.data('text-offset'));\n\n    // Expand new body\n    this.$body\n      .cssWidthAnimated(startBodyBounds.width, endBodyBounds.width, {\n        duration: this.animationDuration,\n        progress: this.revalidateLayout.bind(this),\n        complete: () => this._completeAnimateRenderSubMenuItems($oldBody),\n        queue: false\n      })\n      .cssHeightAnimated(startBodyBounds.height, endBodyBounds.height, {\n        duration: this.animationDuration,\n        queue: false\n      })\n      .cssTopAnimated(startBodyBounds.y, endBodyBounds.y, {\n        duration: this.animationDuration,\n        queue: false\n      });\n\n    // Resize old body so that it doesn't increase the popup height and shows unnecessary scrollbars if new body will be smaller\n    // It also ensures correct text ellipsis during animation, position is already correct\n    $oldBody\n      .cssWidthAnimated(oldBodyBounds.width, endBodyBounds.width, {\n        duration: this.animationDuration,\n        queue: false\n      })\n      .cssHeightAnimated(oldBodyBounds.height, endBodyBounds.height, {\n        duration: this.animationDuration,\n        queue: false\n      });\n  }\n\n  _completeAnimateRenderSubMenuItems($oldBody) {\n    this.bodyAnimating = false;\n    if (!this.rendered) {\n      return;\n    }\n    this.$container.removeClass('animating');\n    if ($oldBody) {\n      $oldBody.detach();\n      this.$body.cssTop('');\n      this._updateFirstLastClass();\n    }\n    this.htmlComp.layout.resetAutoPosition();\n    this._processSubMenuQueue();\n  }\n\n  _animateResizePopup($comp, popupBounds, targetBounds) {\n    let options = {\n      duration: this.animationDuration,\n      queue: false\n    };\n    $comp\n      .cssTopAnimated(popupBounds.y, targetBounds.y, options)\n      .cssLeftAnimated(popupBounds.x, targetBounds.x, options)\n      .cssWidthAnimated(popupBounds.width, targetBounds.width, options)\n      .cssHeightAnimated(popupBounds.height, targetBounds.height, options);\n  }\n\n  _animateTextOffset($body, textOffset, targetOffset) {\n    targetOffset = scout.nvl(targetOffset, this.$body.data('text-offset'));\n    let $menuItems = this.$visibleMenuItems($body);\n    $menuItems.each((index, menuItem) => {\n      let $menuItem = $(menuItem);\n      let $text = $menuItem.children('.text');\n      let padding = this._calcTextPaddingLeft($menuItem, textOffset);\n      let targetPadding = this._calcTextPaddingLeft($menuItem, targetOffset);\n      $text.cssAnimated({paddingLeft: padding}, {paddingLeft: targetPadding}, {duration: this.animationDuration});\n    });\n  }\n\n  _renderMenuItems(menus, initialSubMenuRendering) {\n    menus = menus ? menus : this._getMenuItems();\n    if (this.menuFilter) {\n      menus = this.menuFilter(menus, MenuDestinations.CONTEXT_MENU);\n    }\n\n    if (!menus || menus.length === 0) {\n      return;\n    }\n\n    menus.forEach(function(menu) {\n      // Invisible menus are rendered as well because their visibility might change dynamically\n      if (menu.separator) {\n        return;\n      }\n\n      // prevent loosing original parent\n      let originalParent = menu.parent;\n      // Clone menu items but only clone once unless it is for a different context menu (e.g. a context menu of a combo menu inside a context menu)\n      // Clone will recursively also clone all child actions.\n      if (this.cloneMenuItems && !menu.cloneOf || !this.has(menu)) {\n        menu = menu.clone({\n          parent: this,\n          textPosition: Action.TextPosition.DEFAULT\n        }, {\n          delegateEventsToOriginal: ['acceptInput', 'action', 'click'],\n          delegateAllPropertiesToClone: true,\n          delegateAllPropertiesToOriginal: true,\n          excludePropertiesToOriginal: ['selected', 'logicalGrid', 'tabbable']\n        });\n        menu.setTabbable(false);\n        // attach listener\n        this._attachCloneMenuListeners(menu);\n      }\n\n      // just set once because on second execution of this menu.parent is set to a popup\n      if (!menu.__originalParent) {\n        menu.__originalParent = originalParent;\n      }\n      menu.render(this.$body);\n      menu.$container.removeClass('menu-button');\n      this._attachMenuListeners(menu);\n    }, this);\n\n    this._handleInitialSubMenus(initialSubMenuRendering);\n    this._updateFirstLastClass();\n    this._adjustTextAlignment();\n  }\n\n  _attachCloneMenuListeners(menu) {\n    menu.on('propertyChange', this._onCloneMenuPropertyChange.bind(this));\n    menu.childActions.forEach(this._attachCloneMenuListeners.bind(this));\n  }\n\n  _onCloneMenuPropertyChange(event) {\n    if (event.propertyName === 'selected') {\n      let menu = event.source;\n      // Only trigger property change, setSelected would try to render the selected state which must not happen for the original menu\n      menu.cloneOf.triggerPropertyChange('selected', event.oldValue, event.newValue);\n    }\n  }\n\n  _handleInitialSubMenus(initialSubMenuRendering) {\n    if (initialSubMenuRendering) {\n      return;\n    }\n    let menusObj;\n    while (this.initialSubMenusToRender) {\n      menusObj = this.initialSubMenusToRender;\n      this.initialSubMenusToRender = undefined;\n      this.renderSubMenuItems(menusObj.parentMenu, menusObj.menus, false, true);\n    }\n  }\n\n  _attachMenuListeners(menu) {\n    let menuItemActionHandler = this._onMenuItemAction.bind(this);\n    let menuItemPropertyChange = this._onMenuItemPropertyChange.bind(this);\n    menu.on('action', menuItemActionHandler);\n    menu.on('propertyChange', menuItemPropertyChange);\n    this.one('remove', () => {\n      menu.off('action', menuItemActionHandler);\n      menu.off('propertyChange', menuItemPropertyChange);\n    });\n  }\n\n  updateMenuItems(menuItems) {\n    menuItems = arrays.ensure(menuItems);\n    // Only update if list of menus changed. Don't compare this.menuItems, because that list\n    // may contain additional UI separators, and may not be in the same order\n    if (!arrays.equals(this.menuItems, menuItems)) {\n      this.close();\n    }\n  }\n\n  /**\n   * Override this method to return menu items or actions used to render menu items.\n   */\n  _getMenuItems() {\n    return this.menuItems;\n  }\n\n  /**\n   * Currently rendered $menuItems\n   */\n  $menuItems() {\n    return this.$body.children('.menu-item');\n  }\n\n  $visibleMenuItems($body) {\n    $body = $body || this.$body;\n    return $body.children('.menu-item:visible');\n  }\n\n  /**\n   * Updates the first and last visible menu items with the according css classes.\n   * Necessary because invisible menu-items are rendered.\n   */\n  _updateFirstLastClass(event) {\n    let $firstMenuItem, $lastMenuItem;\n\n    this.$body.children('.menu-item').each(function() {\n      let $menuItem = $(this);\n      $menuItem.removeClass('first last');\n\n      if ($menuItem.isVisible()) {\n        if (!$firstMenuItem) {\n          $firstMenuItem = $menuItem;\n        }\n        $lastMenuItem = $menuItem;\n      }\n    });\n    if ($firstMenuItem) {\n      $firstMenuItem.addClass('first');\n    }\n    if ($lastMenuItem) {\n      $lastMenuItem.addClass('last');\n    }\n  }\n\n  updateNextToSelected(menuItemClass, $selectedItem) {\n    menuItemClass = menuItemClass ? menuItemClass : 'menu-item';\n    let $all = this.$body.find('.' + menuItemClass);\n    $selectedItem = $selectedItem ? $selectedItem : this.$body.find('.' + menuItemClass + '.selected');\n\n    $all.removeClass('next-to-selected');\n    if ($selectedItem.hasClass('selected')) {\n      $selectedItem.nextAll(':visible').first().addClass('next-to-selected');\n    }\n  }\n\n  _onMenuItemAction(event) {\n    if (event.source.isToggleAction()) {\n      return;\n    }\n    this.close();\n  }\n\n  _onMenuItemPropertyChange(event) {\n    if (!this.rendered) {\n      return;\n    }\n    if (event.propertyName === 'visible') {\n      this._updateFirstLastClass();\n    } else if (event.propertyName === 'selected') {\n      // Key stroke navigation marks the currently focused item as selected.\n      // When a sub menu item is opened while another element is selected (focused), make sure the other element gets unselected.\n      // Otherwise two items would be selected when the sub menu is closed again.\n      this._deselectSiblings(event.source);\n    }\n    // Make sure menu is positioned correctly afterwards (if it is opened upwards hiding/showing a menu item makes it necessary to reposition)\n    this.position();\n  }\n\n  /**\n   * Deselects the visible siblings of the given menu item. It just removes the CSS class and does not modify the selected property.\n   */\n  _deselectSiblings(menuItem) {\n    menuItem.$container.siblings('.menu-item').each((i, elem) => {\n      let $menuItem = $(elem);\n      $menuItem.select(false);\n    }, this);\n  }\n\n  _adjustTextAlignment($body) {\n    $body = $body || this.$body;\n    let $menuItems = this.$visibleMenuItems($body);\n    let textOffset = this._calcTextOffset($menuItems);\n    $body.data('text-offset', textOffset);\n    this._updateTextOffset(textOffset, $menuItems);\n  }\n\n  _calcTextOffset($menuItems) {\n    let textOffset = 0;\n    $menuItems = $menuItems || this.$visibleMenuItems();\n    $menuItems.each((index, menuItem) => {\n      let $menuItem = $(menuItem);\n      let $icon = $menuItem.children('.icon');\n      let iconWidth = 0;\n\n      if ($icon.length > 0) {\n        iconWidth = $icon.outerWidth(true);\n      }\n      textOffset = Math.max(textOffset, iconWidth);\n    });\n    return textOffset;\n  }\n\n  _updateTextOffset(textOffset, $menuItems) {\n    // Update the padding of each text such that the sum of icon width and the padding\n    // are the same for all items. This ensures that the texts are all aligned.\n    $menuItems = $menuItems || this.$visibleMenuItems();\n    $menuItems.each((index, menuItem) => {\n      let $menuItem = $(menuItem);\n      let $text = $menuItem.children('.text');\n      $text.css('padding-left', this._calcTextPaddingLeft($menuItem, textOffset));\n      let htmlComp = HtmlComponent.optGet($menuItem);\n      if (htmlComp) {\n        htmlComp.invalidateLayout();\n      }\n    });\n  }\n\n  _calcTextPaddingLeft($menuItem, textOffset) {\n    let $icon = $menuItem.children('.icon');\n    let iconWidth = 0;\n\n    if ($icon.length > 0) {\n      iconWidth = $icon.outerWidth(true);\n    }\n    return textOffset - iconWidth;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}