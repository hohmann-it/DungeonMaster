{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, arrays, EventSupport, filters as filters_1, keys, KeyStroke, ValueField, VirtualKeyStrokeEvent } from '../index';\nimport $ from 'jquery';\nexport default class KeyStrokeManager {\n  constructor() {\n    this.session = null;\n    this.helpKeyStroke = KeyStroke.parseKeyStroke('F1');\n    this.swallowF1 = true;\n    this._helpRendered = false;\n    this._renderedKeys = [];\n    this.events = this._createEventSupport();\n    this.filters = [];\n  }\n  init(model) {\n    this.session = model.session;\n    this.installTopLevelKeyStrokeHandlers(this.session.$entryPoint);\n  }\n  installTopLevelKeyStrokeHandlers($container) {\n    let myWindow = $container.window(true),\n      // Swallow F1 (online help) key stroke\n      helpHandler = event => event.which !== keys.F1,\n      // Swallow Backspace (browser navigation) key stroke\n      backspaceHandler = event => event.which !== keys.BACKSPACE;\n    if (this.swallowF1) {\n      $container.keydown(helpHandler).keyup(helpHandler);\n    }\n    $container.keydown(backspaceHandler).keyup(backspaceHandler);\n    if ('onhelp' in myWindow) {\n      myWindow.onhelp = filters_1.returnFalse;\n    }\n  }\n\n  /**\n   * Installs the given keystroke context. This method has no effect if the context is null, or already installed.\n   */\n  installKeyStrokeContext(keyStrokeContext) {\n    if (!keyStrokeContext) {\n      return;\n    }\n    if (keyStrokeContext._handler) {\n      return; // context already installed\n    }\n\n    if (!keyStrokeContext.$getBindTarget()) {\n      throw new Error('missing bind-target for KeyStrokeContext: ' + keyStrokeContext);\n    }\n    keyStrokeContext._handler = this._onKeyEvent.bind(this, keyStrokeContext);\n    keyStrokeContext._handler.$target = keyStrokeContext.$getBindTarget();\n    keyStrokeContext._handler.$target.on('keydown', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target.on('keyup', keyStrokeContext._handler);\n  }\n\n  /**\n   * Uninstalls the given keystroke context. This method has no effect if the context is null, or not installed.\n   */\n  uninstallKeyStrokeContext(keyStrokeContext) {\n    if (!keyStrokeContext) {\n      return;\n    }\n    if (!keyStrokeContext._handler) {\n      return; // context not installed\n    }\n\n    keyStrokeContext._handler.$target.off('keydown', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target.off('keyup', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target = null;\n    keyStrokeContext._handler = null;\n  }\n\n  /**\n   * Visualizes the keys supported by the given keyStrokeContext.\n   */\n  _renderKeys(keyStrokeContext, event) {\n    let descendantContexts = event.originalEvent.keyStrokeContexts || [];\n    let immediatePropagationStoppedKeys = [];\n    keyStrokeContext.keyStrokes.filter(keyStroke => {\n      let render = keyStroke.renderingHints.render;\n      return typeof render === 'function' ? render.call(keyStroke) : render;\n    }).forEach(function (keyStroke) {\n      keyStroke.enabledByFilter = this._filter(keyStroke);\n      let $drawingArea = (keyStroke.field ? keyStroke.field.$container : null) || keyStrokeContext.$getScopeTarget(); // Precedence: keystroke's field container, or the scope target otherwise.\n      let keys = keyStroke.keys(); // Get all keys which are handled by the keystroke. Typically, this is a single key.\n      keys.forEach(function (key) {\n        let virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, event.target);\n        if (immediatePropagationStoppedKeys.indexOf(key.toKeyStrokeString()) < 0 && keyStrokeContext.accept(virtualKeyStrokeEvent) && keyStroke.accept(virtualKeyStrokeEvent) && !this._isPreventedByDescendantContext(key, event.target, descendantContexts)) {\n          if (key.render($drawingArea, virtualKeyStrokeEvent)) {\n            this._renderedKeys.push(key);\n          }\n          // If immediate propagation is stopped, key strokes on the same level which react to the same key won't be executed -> make sure they won't be displayed either\n          if (virtualKeyStrokeEvent.isImmediatePropagationStopped()) {\n            immediatePropagationStoppedKeys.push(key.toKeyStrokeString());\n          }\n        }\n      }, this);\n    }, this);\n    descendantContexts.push(keyStrokeContext); // Register this keyStrokeContext within the event, so that superior keyStrokeContexts can validate their keys (e.g. not swallowed by a descendant keyStrokeContext).\n    event.originalEvent.keyStrokeContexts = descendantContexts;\n  }\n  _isPreventedByDescendantContext(key, target, descendantContexts) {\n    let virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, target);\n\n    // Check whether any descendant keyStrokeContext prevents this keystroke from execution.\n    return descendantContexts.some(function (descendantContext) {\n      // Ask descendant keyStrokeContext whether this event is swallowed.\n      descendantContext.accept(virtualKeyStrokeEvent);\n      if (virtualKeyStrokeEvent.isAnyPropagationStopped()) {\n        return true;\n      }\n\n      // Ask keystrokes of descendant keyStrokeContext whether this event is swallowed.\n      return descendantContext.keyStrokes.some(descendantKeyStroke => {\n        descendantKeyStroke.accept(virtualKeyStrokeEvent);\n        return virtualKeyStrokeEvent.isAnyPropagationStopped();\n      }, this);\n    }, this);\n  }\n\n  /**\n   * Handles the keystroke event by the keyStrokeContext's keystroke handlers, but returns immediately once a keystroke requests immediate stop of propagation.\n   */\n  _handleKeyStrokeEvent(keyStrokeContext, event) {\n    if (!keyStrokeContext.accept(event)) {\n      return;\n    }\n    if (keyStrokeContext.keyStrokes.length < 1) {\n      return;\n    }\n\n    // Handle numpad keystroke\n    if (event.which >= 96 && event.which <= 105) {\n      event.which = event.which - 48;\n    }\n\n    // We create a copy of the keyStrokes array, because when a widget is disposed in the handle function\n    // of a keystroke, all its keystrokes on the context are deleted. Which means no key stroke is processed\n    // anymore. However: creating a copy can be dangerous too, because the handle function must deal with\n    // the situation that the widget to which the keystroke belongs, is suddenly destroyed.\n    let keyStrokesCopy = keyStrokeContext.keyStrokes.slice();\n    keyStrokesCopy.some(function (keyStroke) {\n      if (!keyStroke.accept(event)) {\n        return false;\n      }\n\n      // Before handling the keystroke, accept the input of a potential active value field\n      if (this.invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext)) {\n        ValueField.invokeValueFieldAcceptInput(event.target);\n      }\n      if (!this._filter(keyStroke)) {\n        return true; // 'some-loop' breaks on true\n      }\n\n      this.trigger('keyStroke', {\n        keyStroke: keyStroke,\n        keyStrokeContext: keyStrokeContext\n      });\n\n      // Handle the keystroke\n      keyStroke.invokeHandle(event);\n\n      // Break on 'stopImmediate'.\n      return event.isImmediatePropagationStopped(); // 'some-loop' breaks on true\n    }, this);\n  }\n  _filter(keyStroke) {\n    for (let i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].filter(keyStroke)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext) {\n    return !keyStroke.preventInvokeAcceptInputOnActiveValueField && (keyStroke.invokeAcceptInputOnActiveValueField || keyStrokeContext.invokeAcceptInputOnActiveValueField);\n  }\n  _isHelpKeyStroke(event) {\n    return KeyStroke.acceptEvent(this.helpKeyStroke, event);\n  }\n  _installHelpDisposeListener(event) {\n    let helpDisposeHandler,\n      $currentTarget = $(event.currentTarget),\n      $myWindow = $currentTarget.window(),\n      $topLevelContainer = $currentTarget.entryPoint();\n    helpDisposeHandler = function () {\n      $topLevelContainer.off('keyup', helpDisposeHandler);\n      $myWindow.off('blur', helpDisposeHandler);\n      this._helpRendered = false;\n      this._renderedKeys.forEach(key => {\n        key.remove();\n      });\n      this._renderedKeys = [];\n    }.bind(this);\n    $topLevelContainer.on('keyup', helpDisposeHandler);\n    $myWindow.on('blur', helpDisposeHandler); // once the current browser tab/window is left\n\n    return false;\n  }\n  _onKeyEvent(keyStrokeContext, event) {\n    // check if scopeTarget is covered by glass pane\n    if (this.session.focusManager.isElementCovertByGlassPane(keyStrokeContext.$getScopeTarget())) {\n      // check if any action with 'keyStrokeFirePolicy=IAction.KeyStrokeFirePolicy.ALWAYS' is in keyStrokeContext\n      let keyStrokeFirePolicyAlways = $.grep(keyStrokeContext.keyStrokes, k => {\n        // (will at least return an empty array)\n        return k.keyStrokeFirePolicy === Action.KeyStrokeFirePolicy.ALWAYS;\n      });\n      if (keyStrokeFirePolicyAlways.length === 0) {\n        return;\n      }\n      // copy current keyStrokeContext and replace keyStrokes with filtered array 'keyStrokeFirePolicyAlways'\n      keyStrokeContext = keyStrokeContext.clone();\n      keyStrokeContext.keyStrokes = keyStrokeFirePolicyAlways;\n    }\n    if (this._isHelpKeyStroke(event)) {\n      if (event.originalEvent.renderingHelp || !this._helpRendered) {\n        event.originalEvent.renderingHelp = true; // flag to let superior keyStrokeContexts render their help keys\n        this._helpRendered = true; // flag to only render help once, if help key is held down\n        this._installHelpDisposeListener(event);\n        this._renderKeys(keyStrokeContext, event);\n      }\n    } else {\n      this._handleKeyStrokeEvent(keyStrokeContext, event);\n    }\n  }\n  addFilter(filter) {\n    arrays.pushSet(this.filters, filter);\n  }\n  removeFilter(filter) {\n    arrays.remove(this.filters, filter);\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n  one(type, func) {\n    this.events.one(type, func);\n  }\n  on(type, func) {\n    return this.events.on(type, func);\n  }\n  off(type, func) {\n    this.events.off(type, func);\n  }\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n}","map":{"version":3,"names":["Action","arrays","EventSupport","filters","filters_1","keys","KeyStroke","ValueField","VirtualKeyStrokeEvent","$","KeyStrokeManager","constructor","session","helpKeyStroke","parseKeyStroke","swallowF1","_helpRendered","_renderedKeys","events","_createEventSupport","init","model","installTopLevelKeyStrokeHandlers","$entryPoint","$container","myWindow","window","helpHandler","event","which","F1","backspaceHandler","BACKSPACE","keydown","keyup","onhelp","returnFalse","installKeyStrokeContext","keyStrokeContext","_handler","$getBindTarget","Error","_onKeyEvent","bind","$target","on","uninstallKeyStrokeContext","off","_renderKeys","descendantContexts","originalEvent","keyStrokeContexts","immediatePropagationStoppedKeys","keyStrokes","filter","keyStroke","render","renderingHints","call","forEach","enabledByFilter","_filter","$drawingArea","field","$getScopeTarget","key","virtualKeyStrokeEvent","ctrl","alt","shift","keyStrokeMode","target","indexOf","toKeyStrokeString","accept","_isPreventedByDescendantContext","push","isImmediatePropagationStopped","some","descendantContext","isAnyPropagationStopped","descendantKeyStroke","_handleKeyStrokeEvent","length","keyStrokesCopy","slice","invokeAcceptInputOnActiveValueField","invokeValueFieldAcceptInput","trigger","invokeHandle","i","preventInvokeAcceptInputOnActiveValueField","_isHelpKeyStroke","acceptEvent","_installHelpDisposeListener","helpDisposeHandler","$currentTarget","currentTarget","$myWindow","$topLevelContainer","entryPoint","remove","focusManager","isElementCovertByGlassPane","keyStrokeFirePolicyAlways","grep","k","keyStrokeFirePolicy","KeyStrokeFirePolicy","ALWAYS","clone","renderingHelp","addFilter","pushSet","removeFilter","type","source","one","func","addListener","listener","removeListener"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/keystroke/KeyStrokeManager.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, arrays, EventSupport, filters as filters_1, keys, KeyStroke, ValueField, VirtualKeyStrokeEvent} from '../index';\nimport $ from 'jquery';\n\nexport default class KeyStrokeManager {\n\n  constructor() {\n    this.session = null;\n    this.helpKeyStroke = KeyStroke.parseKeyStroke('F1');\n    this.swallowF1 = true;\n    this._helpRendered = false;\n    this._renderedKeys = [];\n    this.events = this._createEventSupport();\n    this.filters = [];\n  }\n\n  init(model) {\n    this.session = model.session;\n    this.installTopLevelKeyStrokeHandlers(this.session.$entryPoint);\n  }\n\n  installTopLevelKeyStrokeHandlers($container) {\n    let\n      myWindow = $container.window(true),\n      // Swallow F1 (online help) key stroke\n      helpHandler = event => event.which !== keys.F1,\n      // Swallow Backspace (browser navigation) key stroke\n      backspaceHandler = event => event.which !== keys.BACKSPACE;\n\n    if (this.swallowF1) {\n      $container\n        .keydown(helpHandler)\n        .keyup(helpHandler);\n    }\n    $container\n      .keydown(backspaceHandler)\n      .keyup(backspaceHandler);\n\n    if ('onhelp' in myWindow) {\n      myWindow.onhelp = filters_1.returnFalse;\n    }\n  }\n\n  /**\n   * Installs the given keystroke context. This method has no effect if the context is null, or already installed.\n   */\n  installKeyStrokeContext(keyStrokeContext) {\n    if (!keyStrokeContext) {\n      return;\n    }\n\n    if (keyStrokeContext._handler) {\n      return; // context already installed\n    }\n\n    if (!keyStrokeContext.$getBindTarget()) {\n      throw new Error('missing bind-target for KeyStrokeContext: ' + keyStrokeContext);\n    }\n\n    keyStrokeContext._handler = this._onKeyEvent.bind(this, keyStrokeContext);\n    keyStrokeContext._handler.$target = keyStrokeContext.$getBindTarget();\n    keyStrokeContext._handler.$target.on('keydown', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target.on('keyup', keyStrokeContext._handler);\n  }\n\n  /**\n   * Uninstalls the given keystroke context. This method has no effect if the context is null, or not installed.\n   */\n  uninstallKeyStrokeContext(keyStrokeContext) {\n    if (!keyStrokeContext) {\n      return;\n    }\n    if (!keyStrokeContext._handler) {\n      return; // context not installed\n    }\n\n    keyStrokeContext._handler.$target.off('keydown', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target.off('keyup', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target = null;\n    keyStrokeContext._handler = null;\n  }\n\n  /**\n   * Visualizes the keys supported by the given keyStrokeContext.\n   */\n  _renderKeys(keyStrokeContext, event) {\n    let descendantContexts = event.originalEvent.keyStrokeContexts || [];\n    let immediatePropagationStoppedKeys = [];\n\n    keyStrokeContext.keyStrokes\n      .filter(keyStroke => {\n        let render = keyStroke.renderingHints.render;\n        return (typeof render === 'function' ? render.call(keyStroke) : render);\n      })\n      .forEach(function(keyStroke) {\n        keyStroke.enabledByFilter = this._filter(keyStroke);\n        let $drawingArea = (keyStroke.field ? keyStroke.field.$container : null) || keyStrokeContext.$getScopeTarget(); // Precedence: keystroke's field container, or the scope target otherwise.\n        let keys = keyStroke.keys(); // Get all keys which are handled by the keystroke. Typically, this is a single key.\n        keys.forEach(function(key) {\n          let virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, event.target);\n\n          if (immediatePropagationStoppedKeys.indexOf(key.toKeyStrokeString()) < 0 && keyStrokeContext.accept(virtualKeyStrokeEvent) &&\n            keyStroke.accept(virtualKeyStrokeEvent) && !this._isPreventedByDescendantContext(key, event.target, descendantContexts)) {\n            if (key.render($drawingArea, virtualKeyStrokeEvent)) {\n              this._renderedKeys.push(key);\n            }\n            // If immediate propagation is stopped, key strokes on the same level which react to the same key won't be executed -> make sure they won't be displayed either\n            if (virtualKeyStrokeEvent.isImmediatePropagationStopped()) {\n              immediatePropagationStoppedKeys.push(key.toKeyStrokeString());\n            }\n          }\n        }, this);\n      }, this);\n\n    descendantContexts.push(keyStrokeContext); // Register this keyStrokeContext within the event, so that superior keyStrokeContexts can validate their keys (e.g. not swallowed by a descendant keyStrokeContext).\n    event.originalEvent.keyStrokeContexts = descendantContexts;\n  }\n\n  _isPreventedByDescendantContext(key, target, descendantContexts) {\n    let virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, target);\n\n    // Check whether any descendant keyStrokeContext prevents this keystroke from execution.\n    return descendantContexts.some(function(descendantContext) {\n      // Ask descendant keyStrokeContext whether this event is swallowed.\n      descendantContext.accept(virtualKeyStrokeEvent);\n      if (virtualKeyStrokeEvent.isAnyPropagationStopped()) {\n        return true;\n      }\n\n      // Ask keystrokes of descendant keyStrokeContext whether this event is swallowed.\n      return descendantContext.keyStrokes.some(descendantKeyStroke => {\n        descendantKeyStroke.accept(virtualKeyStrokeEvent);\n        return virtualKeyStrokeEvent.isAnyPropagationStopped();\n      }, this);\n    }, this);\n  }\n\n  /**\n   * Handles the keystroke event by the keyStrokeContext's keystroke handlers, but returns immediately once a keystroke requests immediate stop of propagation.\n   */\n  _handleKeyStrokeEvent(keyStrokeContext, event) {\n    if (!keyStrokeContext.accept(event)) {\n      return;\n    }\n\n    if (keyStrokeContext.keyStrokes.length < 1) {\n      return;\n    }\n\n    // Handle numpad keystroke\n    if (event.which >= 96 && event.which <= 105) {\n      event.which = event.which - 48;\n    }\n\n    // We create a copy of the keyStrokes array, because when a widget is disposed in the handle function\n    // of a keystroke, all its keystrokes on the context are deleted. Which means no key stroke is processed\n    // anymore. However: creating a copy can be dangerous too, because the handle function must deal with\n    // the situation that the widget to which the keystroke belongs, is suddenly destroyed.\n    let keyStrokesCopy = keyStrokeContext.keyStrokes.slice();\n    keyStrokesCopy.some(function(keyStroke) {\n      if (!keyStroke.accept(event)) {\n        return false;\n      }\n\n      // Before handling the keystroke, accept the input of a potential active value field\n      if (this.invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext)) {\n        ValueField.invokeValueFieldAcceptInput(event.target);\n      }\n\n      if (!this._filter(keyStroke)) {\n        return true; // 'some-loop' breaks on true\n      }\n\n      this.trigger('keyStroke', {\n        keyStroke: keyStroke,\n        keyStrokeContext: keyStrokeContext\n      });\n\n      // Handle the keystroke\n      keyStroke.invokeHandle(event);\n\n      // Break on 'stopImmediate'.\n      return event.isImmediatePropagationStopped(); // 'some-loop' breaks on true\n    }, this);\n  }\n\n  _filter(keyStroke) {\n    for (let i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].filter(keyStroke)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext) {\n    return !keyStroke.preventInvokeAcceptInputOnActiveValueField && (keyStroke.invokeAcceptInputOnActiveValueField || keyStrokeContext.invokeAcceptInputOnActiveValueField);\n  }\n\n  _isHelpKeyStroke(event) {\n    return KeyStroke.acceptEvent(this.helpKeyStroke, event);\n  }\n\n  _installHelpDisposeListener(event) {\n    let helpDisposeHandler,\n      $currentTarget = $(event.currentTarget),\n      $myWindow = $currentTarget.window(),\n      $topLevelContainer = $currentTarget.entryPoint();\n\n    helpDisposeHandler = function() {\n      $topLevelContainer.off('keyup', helpDisposeHandler);\n      $myWindow.off('blur', helpDisposeHandler);\n      this._helpRendered = false;\n      this._renderedKeys.forEach(key => {\n        key.remove();\n      });\n      this._renderedKeys = [];\n    }.bind(this);\n\n    $topLevelContainer.on('keyup', helpDisposeHandler);\n    $myWindow.on('blur', helpDisposeHandler); // once the current browser tab/window is left\n\n    return false;\n  }\n\n  _onKeyEvent(keyStrokeContext, event) {\n    // check if scopeTarget is covered by glass pane\n    if (this.session.focusManager.isElementCovertByGlassPane(keyStrokeContext.$getScopeTarget())) {\n      // check if any action with 'keyStrokeFirePolicy=IAction.KeyStrokeFirePolicy.ALWAYS' is in keyStrokeContext\n      let keyStrokeFirePolicyAlways = $.grep(keyStrokeContext.keyStrokes, k => { // (will at least return an empty array)\n        return k.keyStrokeFirePolicy === Action.KeyStrokeFirePolicy.ALWAYS;\n      });\n      if (keyStrokeFirePolicyAlways.length === 0) {\n        return;\n      }\n      // copy current keyStrokeContext and replace keyStrokes with filtered array 'keyStrokeFirePolicyAlways'\n      keyStrokeContext = keyStrokeContext.clone();\n      keyStrokeContext.keyStrokes = keyStrokeFirePolicyAlways;\n    }\n\n    if (this._isHelpKeyStroke(event)) {\n      if (event.originalEvent.renderingHelp || !this._helpRendered) {\n        event.originalEvent.renderingHelp = true; // flag to let superior keyStrokeContexts render their help keys\n        this._helpRendered = true; // flag to only render help once, if help key is held down\n        this._installHelpDisposeListener(event);\n        this._renderKeys(keyStrokeContext, event);\n      }\n    } else {\n      this._handleKeyStrokeEvent(keyStrokeContext, event);\n    }\n  }\n\n  addFilter(filter) {\n    arrays.pushSet(this.filters, filter);\n  }\n\n  removeFilter(filter) {\n    arrays.remove(this.filters, filter);\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n\n  one(type, func) {\n    this.events.one(type, func);\n  }\n\n  on(type, func) {\n    return this.events.on(type, func);\n  }\n\n  off(type, func) {\n    this.events.off(type, func);\n  }\n\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}