{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, GroupBoxMenuItemsOrder, HtmlComponent, keys, KeyStrokeContext, Menu, MenuBarLayout, MenuBarLeftKeyStroke, MenuBarRightKeyStroke, MenuDestinations, menus, scout, Widget, widgets } from '../../index';\nimport ComboMenu from '../ComboMenu';\nexport default class MenuBar extends Widget {\n  constructor() {\n    super();\n    this.menuSorter = null;\n    this.menuFilter = null;\n    this.position = MenuBar.Position.TOP;\n    this.tabbable = true;\n    this.menuboxLeft = null;\n    this.menuboxRight = null;\n    this.menuItems = []; // original list of menuItems that was passed to setMenuItems(), only used to check if menubar has changed\n    this.orderedMenuItems = {\n      left: [],\n      right: [],\n      all: []\n    };\n    this.defaultMenu = null;\n    this.visible = false;\n    this.ellipsisPosition = MenuBar.EllipsisPosition.RIGHT;\n    this._menuItemPropertyChangeHandler = this._onMenuItemPropertyChange.bind(this);\n    this._focusHandler = this._onMenuItemFocus.bind(this);\n    this.hiddenByUi = false;\n    this._addWidgetProperties('menuItems');\n  }\n  _init(options) {\n    super._init(options);\n    this.menuSorter = options.menuOrder || new GroupBoxMenuItemsOrder();\n    this.menuSorter.menuBar = this;\n    if (options.menuFilter) {\n      this.menuFilter = (menus, destination, onlyVisible, enableDisableKeyStroke) => options.menuFilter(menus, MenuDestinations.MENU_BAR, onlyVisible, enableDisableKeyStroke);\n    }\n    this.menuboxLeft = scout.create('MenuBarBox', {\n      parent: this,\n      cssClass: 'left',\n      tooltipPosition: this._oppositePosition()\n    });\n    this.menuboxRight = scout.create('MenuBarBox', {\n      parent: this,\n      cssClass: 'right',\n      tooltipPosition: this._oppositePosition()\n    });\n    this._setMenuItems(arrays.ensure(this.menuItems));\n    this.updateVisibility();\n  }\n  _destroy() {\n    super._destroy();\n    this._detachMenuHandlers();\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke([new MenuBarLeftKeyStroke(this), new MenuBarRightKeyStroke(this)]);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _render() {\n    this.$container = this.$parent.appendDiv('menubar');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(new MenuBarLayout(this));\n    this.menuboxRight.render(this.$container);\n    this.menuboxLeft.render(this.$container);\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderMenuItems();\n    this._renderPosition();\n  }\n  setPosition(position) {\n    this.setProperty('position', position);\n  }\n  _setPosition(position) {\n    this._setProperty('position', position);\n    this.menuboxLeft.setTooltipPosition(this._oppositePosition());\n    this.menuboxRight.setTooltipPosition(this._oppositePosition());\n  }\n  _renderPosition() {\n    this.$container.toggleClass('bottom', this.position === MenuBar.Position.BOTTOM);\n  }\n  _oppositePosition() {\n    return this.position === MenuBar.Position.TOP ? MenuBar.Position.BOTTOM : MenuBar.Position.TOP;\n  }\n  setEllipsisPosition(ellipsisPosition) {\n    this.setProperty('ellipsisPosition', ellipsisPosition);\n  }\n\n  /**\n   * Set the filter of the menu bar to all the menu items.\n   */\n  _setChildMenuFilters() {\n    this.orderedMenuItems.all.forEach(function (item) {\n      item.setMenuFilter(this.menuFilter);\n    }, this);\n  }\n\n  /**\n   * This function can be called multiple times. The function attaches the menu handlers only if they are not yet added.\n   */\n  _attachMenuHandlers() {\n    this.orderedMenuItems.all.forEach(function (item) {\n      if (item.events.count('propertyChange', this._menuItemPropertyChangeHandler) === 0) {\n        item.on('propertyChange', this._menuItemPropertyChangeHandler);\n      }\n      if (item.events.count('focus', this._focusHandler) === 0) {\n        item.on('focus', this._focusHandler);\n      }\n    }, this);\n  }\n  _detachMenuHandlers() {\n    this.orderedMenuItems.all.forEach(item => {\n      item.off('propertyChange', this._menuItemPropertyChangeHandler);\n      item.off('focus', this._focusHandler);\n    });\n  }\n  setMenuItems(menuItems) {\n    menuItems = arrays.ensure(menuItems);\n    if (arrays.equals(this.menuItems, menuItems)) {\n      // Ensure existing menus are correctly linked even if the given menuItems are the same (see TableSpec for reasons)\n      this.menuboxRight.link(this.menuboxRight.menuItems);\n      this.menuboxLeft.link(this.menuboxLeft.menuItems);\n      return;\n    }\n    this.setProperty('menuItems', menuItems);\n  }\n  _setMenuItems(menuItems, rightFirst) {\n    // remove property listeners of old menu items.\n    this._detachMenuHandlers();\n    this.orderedMenuItems = this._createOrderedMenus(menuItems);\n    if (rightFirst) {\n      this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n      this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n    } else {\n      this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n      this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n    }\n    this._setChildMenuFilters();\n    this._attachMenuHandlers();\n    this.updateVisibility();\n    this.updateDefaultMenu();\n    this._setProperty('menuItems', menuItems);\n  }\n  _renderMenuItems() {\n    widgets.updateFirstLastMarker(this.menuItems);\n    this.updateLeftOfButtonMarker();\n    this.invalidateLayoutTree();\n  }\n  _removeMenuItems() {\n    // NOP: by implementing this function we avoid the call to Widget.js#_internalRemoveWidgets\n    // which would remove our menuItems, because they are defined as widget-property (see constructor).\n  }\n  _createOrderedMenus(menuItems) {\n    let orderedMenuItems = this.menuSorter.order(menuItems, this),\n      ellipsisIndex = -1,\n      ellipsis;\n    orderedMenuItems.right.forEach(item => {\n      item.rightAligned = true;\n    });\n    if (orderedMenuItems.all.length > 0) {\n      if (this._ellipsis) {\n        // Disconnect existing child actions from ellipsis menu\n        this._ellipsis.setChildActions([]);\n        this._ellipsis.destroy();\n      }\n      ellipsis = scout.create('EllipsisMenu', {\n        parent: this,\n        cssClass: 'overflow-menu-item'\n      });\n      this._ellipsis = ellipsis;\n\n      // add ellipsis to the correct position\n      if (this.ellipsisPosition === MenuBar.EllipsisPosition.RIGHT) {\n        // try right\n        let reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.right.slice().reverse());\n        if (reverseIndexPosition > -1) {\n          ellipsisIndex = orderedMenuItems.right.length - reverseIndexPosition;\n          ellipsis.rightAligned = true;\n          orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n        } else {\n          // try left\n          reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.left.slice().reverse());\n          if (reverseIndexPosition > -1) {\n            ellipsisIndex = orderedMenuItems.left.length - reverseIndexPosition;\n            orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n          }\n        }\n      } else {\n        // try left\n        ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.left);\n        if (ellipsisIndex > -1) {\n          orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n        } else {\n          // try right\n          ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.right);\n          if (ellipsisIndex > -1) {\n            ellipsis.rightAligned = true;\n            orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n          }\n        }\n      }\n      orderedMenuItems.all = orderedMenuItems.left.concat(orderedMenuItems.right);\n    }\n    return orderedMenuItems;\n  }\n  _getFirstStackableIndexPosition(menuList) {\n    let foundIndex = -1;\n    menuList.some((menu, index) => {\n      if (menu.stackable && menu.visible) {\n        foundIndex = index;\n        return true;\n      }\n      return false;\n    }, this);\n    return foundIndex;\n  }\n  _updateTabbableMenu() {\n    // Make first valid MenuItem tabbable so that it can be focused. All other items\n    // are not tabbable. But they can be selected with the arrow keys.\n    if (this.tabbable) {\n      if (this.defaultMenu && this.defaultMenu.isTabTarget()) {\n        this.setTabbableMenu(this.defaultMenu);\n      } else {\n        this.setTabbableMenu(arrays.find(this.orderedMenuItems.all, item => item.isTabTarget()));\n      }\n    }\n  }\n  setTabbableMenu(menu) {\n    if (!this.tabbable || menu === this.tabbableMenu) {\n      return;\n    }\n    if (this.tabbableMenu) {\n      this.tabbableMenu.setTabbable(false);\n    }\n    this.tabbableMenu = menu;\n    if (menu) {\n      menu.setTabbable(true);\n    }\n  }\n\n  /**\n   * Sets the property hiddenByUi. This does not automatically update the visibility of the menus.\n   * We assume that #updateVisibility() is called later anyway.\n   *\n   * @param {boolean} hiddenByUi\n   */\n  setHiddenByUi(hiddenByUi) {\n    this.setProperty('hiddenByUi', hiddenByUi);\n  }\n  updateVisibility() {\n    menus.updateSeparatorVisibility(this.orderedMenuItems.left);\n    menus.updateSeparatorVisibility(this.orderedMenuItems.right);\n    this.setVisible(!this.hiddenByUi && this.orderedMenuItems.all.some(m => {\n      return m.visible && !m.ellipsis;\n    }));\n  }\n\n  /**\n   * First rendered item that is enabled and reacts to ENTER keystroke shall be marked as 'defaultMenu'\n   *\n   * @param {boolean} [updateTabbableMenu] if true (default), the \"tabbable menu\" is updated at the end of this method.\n   */\n  updateDefaultMenu(updateTabbableMenu) {\n    let defaultMenu = null;\n    for (let i = 0; i < this.orderedMenuItems.all.length; i++) {\n      let item = this.orderedMenuItems.all[i];\n      if (!item.visible || !item.enabled || item.defaultMenu === false) {\n        // Invisible or disabled menus and menus that explicitly have the \"defaultMenu\"\n        // property set to false cannot be the default menu.\n        continue;\n      }\n      if (item.defaultMenu) {\n        defaultMenu = item;\n        break;\n      }\n      if (!defaultMenu && this._isDefaultKeyStroke(item.actionKeyStroke)) {\n        defaultMenu = item;\n      }\n    }\n    this.setDefaultMenu(defaultMenu);\n    if (scout.nvl(updateTabbableMenu, true)) {\n      this._updateTabbableMenu();\n    }\n  }\n  _isDefaultKeyStroke(keyStroke) {\n    return scout.isOneOf(keys.ENTER, keyStroke.which) && !keyStroke.ctrl && !keyStroke.alt && !keyStroke.shift;\n  }\n  setDefaultMenu(defaultMenu) {\n    this.setProperty('defaultMenu', defaultMenu);\n  }\n  _setDefaultMenu(defaultMenu) {\n    if (this.defaultMenu) {\n      this.defaultMenu.setMenuStyle(Menu.MenuStyle.NONE);\n    }\n    if (defaultMenu) {\n      defaultMenu.setMenuStyle(Menu.MenuStyle.DEFAULT);\n    }\n    this._setProperty('defaultMenu', defaultMenu);\n  }\n\n  /**\n   * Add class 'left-of-button' to every menu item which is on the left of a button\n   */\n  updateLeftOfButtonMarker() {\n    this._updateLeftOfButtonMarker(this.orderedMenuItems.left);\n    this._updateLeftOfButtonMarker(this.orderedMenuItems.right);\n  }\n  _updateLeftOfButtonMarker(items) {\n    let item, previousItem;\n    items = items.filter(item => {\n      return item.visible && item.rendered;\n    });\n    for (let i = 0; i < items.length; i++) {\n      item = items[i];\n      item.$container.removeClass('left-of-button');\n      if (i > 0 && item.isButton()) {\n        previousItem = items[i - 1];\n        previousItem.$container.addClass('left-of-button');\n      }\n    }\n  }\n  _onMenuItemPropertyChange(event) {\n    // We do not update the items directly, because this listener may be fired many times in one\n    // user request (because many menus change one or more properties). Therefore, we just invalidate\n    // the MenuBarLayout. It will be updated automatically after the user request has finished,\n    // because the layout calls rebuildItemsInternal().\n    if (event.propertyName === 'overflown' || event.propertyName === 'enabledComputed' || event.propertyName === 'visible' || event.propertyName === 'hidden') {\n      if (!this.tabbableMenu || event.source === this.tabbableMenu) {\n        this._updateTabbableMenu();\n      }\n    }\n    if (event.propertyName === 'overflown' || event.propertyName === 'hidden') {\n      if (!this.defaultMenu || event.source === this.defaultMenu) {\n        this.updateDefaultMenu();\n      }\n    }\n    if (event.propertyName === 'horizontalAlignment') {\n      // reorder\n      this.reorderMenus(event.newValue <= 0);\n    }\n    if (event.propertyName === 'visible') {\n      let oldVisible = this.visible;\n      this.updateVisibility();\n      if (!oldVisible && this.visible) {\n        // If the menubar was previously invisible (because all menus were invisible) but\n        // is now visible, the menuboxes and the menus have to be rendered now. Otherwise,\n        // calculating the preferred size of the menubar, e.g. in the TableLayout, would\n        // return the wrong value (even if the menubar itself is visible).\n        this.revalidateLayout();\n      }\n      // recalculate position of ellipsis if any menu item changed visibility.\n      // separators may change visibility during reordering menu items. Since separators do not have any\n      // impact of right/left order of menu items they have not to be considered to enforce a reorder.\n      if (!event.source.separator) {\n        this.reorderMenus();\n      }\n    }\n    if (event.propertyName === 'keyStroke' || event.propertyName === 'enabledComputed' || event.propertyName === 'defaultMenu' || event.propertyName === 'visible') {\n      this.updateDefaultMenu();\n    }\n  }\n  _onMenuItemFocus(event) {\n    this.setTabbableMenu(event.source);\n  }\n  reorderMenus(rightFirst) {\n    let menuItems = this.menuItems;\n    this._setMenuItems(menuItems, rightFirst);\n    if (this.rendered) {\n      this.updateLeftOfButtonMarker();\n    }\n  }\n  _allMenusAsFlatList() {\n    return arrays.flatMap(this.orderedMenuItems.all, item => {\n      if (item instanceof ComboMenu) {\n        return item.childActions;\n      }\n      return [item];\n    });\n  }\n}\n_defineProperty(MenuBar, \"EllipsisPosition\", {\n  LEFT: 'left',\n  RIGHT: 'right'\n});\n_defineProperty(MenuBar, \"Position\", {\n  TOP: 'top',\n  BOTTOM: 'bottom'\n});","map":{"version":3,"names":["arrays","GroupBoxMenuItemsOrder","HtmlComponent","keys","KeyStrokeContext","Menu","MenuBarLayout","MenuBarLeftKeyStroke","MenuBarRightKeyStroke","MenuDestinations","menus","scout","Widget","widgets","ComboMenu","MenuBar","constructor","menuSorter","menuFilter","position","Position","TOP","tabbable","menuboxLeft","menuboxRight","menuItems","orderedMenuItems","left","right","all","defaultMenu","visible","ellipsisPosition","EllipsisPosition","RIGHT","_menuItemPropertyChangeHandler","_onMenuItemPropertyChange","bind","_focusHandler","_onMenuItemFocus","hiddenByUi","_addWidgetProperties","_init","options","menuOrder","menuBar","destination","onlyVisible","enableDisableKeyStroke","MENU_BAR","create","parent","cssClass","tooltipPosition","_oppositePosition","_setMenuItems","ensure","updateVisibility","_destroy","_detachMenuHandlers","_createKeyStrokeContext","_initKeyStrokeContext","keyStrokeContext","registerKeyStroke","_render","$container","$parent","appendDiv","htmlComp","install","session","setLayout","render","_renderProperties","_renderMenuItems","_renderPosition","setPosition","setProperty","_setPosition","_setProperty","setTooltipPosition","toggleClass","BOTTOM","setEllipsisPosition","_setChildMenuFilters","forEach","item","setMenuFilter","_attachMenuHandlers","events","count","on","off","setMenuItems","equals","link","rightFirst","_createOrderedMenus","updateDefaultMenu","updateFirstLastMarker","updateLeftOfButtonMarker","invalidateLayoutTree","_removeMenuItems","order","ellipsisIndex","ellipsis","rightAligned","length","_ellipsis","setChildActions","destroy","reverseIndexPosition","_getFirstStackableIndexPosition","slice","reverse","splice","concat","menuList","foundIndex","some","menu","index","stackable","_updateTabbableMenu","isTabTarget","setTabbableMenu","find","tabbableMenu","setTabbable","setHiddenByUi","updateSeparatorVisibility","setVisible","m","updateTabbableMenu","i","enabled","_isDefaultKeyStroke","actionKeyStroke","setDefaultMenu","nvl","keyStroke","isOneOf","ENTER","which","ctrl","alt","shift","_setDefaultMenu","setMenuStyle","MenuStyle","NONE","DEFAULT","_updateLeftOfButtonMarker","items","previousItem","filter","rendered","removeClass","isButton","addClass","event","propertyName","source","reorderMenus","newValue","oldVisible","revalidateLayout","separator","_allMenusAsFlatList","flatMap","childActions","LEFT"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/menu/menubar/MenuBar.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, GroupBoxMenuItemsOrder, HtmlComponent, keys, KeyStrokeContext, Menu, MenuBarLayout, MenuBarLeftKeyStroke, MenuBarRightKeyStroke, MenuDestinations, menus, scout, Widget, widgets} from '../../index';\nimport ComboMenu from '../ComboMenu';\n\nexport default class MenuBar extends Widget {\n\n  constructor() {\n    super();\n\n    this.menuSorter = null;\n    this.menuFilter = null;\n    this.position = MenuBar.Position.TOP;\n    this.tabbable = true;\n    this.menuboxLeft = null;\n    this.menuboxRight = null;\n    this.menuItems = []; // original list of menuItems that was passed to setMenuItems(), only used to check if menubar has changed\n    this.orderedMenuItems = {\n      left: [],\n      right: [],\n      all: []\n    };\n    this.defaultMenu = null;\n    this.visible = false;\n    this.ellipsisPosition = MenuBar.EllipsisPosition.RIGHT;\n    this._menuItemPropertyChangeHandler = this._onMenuItemPropertyChange.bind(this);\n    this._focusHandler = this._onMenuItemFocus.bind(this);\n    this.hiddenByUi = false;\n    this._addWidgetProperties('menuItems');\n  }\n\n  static EllipsisPosition = {\n    LEFT: 'left',\n    RIGHT: 'right'\n  };\n\n  static Position = {\n    TOP: 'top',\n    BOTTOM: 'bottom'\n  };\n\n  _init(options) {\n    super._init(options);\n\n    this.menuSorter = options.menuOrder || new GroupBoxMenuItemsOrder();\n    this.menuSorter.menuBar = this;\n    if (options.menuFilter) {\n      this.menuFilter = (menus, destination, onlyVisible, enableDisableKeyStroke) => options.menuFilter(menus, MenuDestinations.MENU_BAR, onlyVisible, enableDisableKeyStroke);\n    }\n\n    this.menuboxLeft = scout.create('MenuBarBox', {\n      parent: this,\n      cssClass: 'left',\n      tooltipPosition: this._oppositePosition()\n    });\n    this.menuboxRight = scout.create('MenuBarBox', {\n      parent: this,\n      cssClass: 'right',\n      tooltipPosition: this._oppositePosition()\n    });\n\n    this._setMenuItems(arrays.ensure(this.menuItems));\n    this.updateVisibility();\n  }\n\n  _destroy() {\n    super._destroy();\n    this._detachMenuHandlers();\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke([\n      new MenuBarLeftKeyStroke(this),\n      new MenuBarRightKeyStroke(this)\n    ]);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _render() {\n    this.$container = this.$parent.appendDiv('menubar');\n\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(new MenuBarLayout(this));\n\n    this.menuboxRight.render(this.$container);\n    this.menuboxLeft.render(this.$container);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderMenuItems();\n    this._renderPosition();\n  }\n\n  setPosition(position) {\n    this.setProperty('position', position);\n  }\n\n  _setPosition(position) {\n    this._setProperty('position', position);\n    this.menuboxLeft.setTooltipPosition(this._oppositePosition());\n    this.menuboxRight.setTooltipPosition(this._oppositePosition());\n  }\n\n  _renderPosition() {\n    this.$container.toggleClass('bottom', this.position === MenuBar.Position.BOTTOM);\n  }\n\n  _oppositePosition() {\n    return this.position === MenuBar.Position.TOP ?\n      MenuBar.Position.BOTTOM : MenuBar.Position.TOP;\n  }\n\n  setEllipsisPosition(ellipsisPosition) {\n    this.setProperty('ellipsisPosition', ellipsisPosition);\n  }\n\n  /**\n   * Set the filter of the menu bar to all the menu items.\n   */\n  _setChildMenuFilters() {\n    this.orderedMenuItems.all.forEach(function(item) {\n      item.setMenuFilter(this.menuFilter);\n    }, this);\n  }\n\n  /**\n   * This function can be called multiple times. The function attaches the menu handlers only if they are not yet added.\n   */\n  _attachMenuHandlers() {\n    this.orderedMenuItems.all.forEach(function(item) {\n      if (item.events.count('propertyChange', this._menuItemPropertyChangeHandler) === 0) {\n        item.on('propertyChange', this._menuItemPropertyChangeHandler);\n      }\n      if (item.events.count('focus', this._focusHandler) === 0) {\n        item.on('focus', this._focusHandler);\n      }\n    }, this);\n  }\n\n  _detachMenuHandlers() {\n    this.orderedMenuItems.all.forEach(item => {\n      item.off('propertyChange', this._menuItemPropertyChangeHandler);\n      item.off('focus', this._focusHandler);\n    });\n  }\n\n  setMenuItems(menuItems) {\n    menuItems = arrays.ensure(menuItems);\n    if (arrays.equals(this.menuItems, menuItems)) {\n      // Ensure existing menus are correctly linked even if the given menuItems are the same (see TableSpec for reasons)\n      this.menuboxRight.link(this.menuboxRight.menuItems);\n      this.menuboxLeft.link(this.menuboxLeft.menuItems);\n      return;\n    }\n    this.setProperty('menuItems', menuItems);\n  }\n\n  _setMenuItems(menuItems, rightFirst) {\n    // remove property listeners of old menu items.\n    this._detachMenuHandlers();\n    this.orderedMenuItems = this._createOrderedMenus(menuItems);\n\n    if (rightFirst) {\n      this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n      this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n\n    } else {\n      this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n      this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n    }\n\n    this._setChildMenuFilters();\n    this._attachMenuHandlers();\n\n    this.updateVisibility();\n    this.updateDefaultMenu();\n\n    this._setProperty('menuItems', menuItems);\n  }\n\n  _renderMenuItems() {\n    widgets.updateFirstLastMarker(this.menuItems);\n    this.updateLeftOfButtonMarker();\n    this.invalidateLayoutTree();\n  }\n\n  _removeMenuItems() {\n    // NOP: by implementing this function we avoid the call to Widget.js#_internalRemoveWidgets\n    // which would remove our menuItems, because they are defined as widget-property (see constructor).\n  }\n\n  _createOrderedMenus(menuItems) {\n    let orderedMenuItems = this.menuSorter.order(menuItems, this),\n      ellipsisIndex = -1,\n      ellipsis;\n    orderedMenuItems.right.forEach(item => {\n      item.rightAligned = true;\n    });\n\n    if (orderedMenuItems.all.length > 0) {\n      if (this._ellipsis) {\n        // Disconnect existing child actions from ellipsis menu\n        this._ellipsis.setChildActions([]);\n        this._ellipsis.destroy();\n      }\n      ellipsis = scout.create('EllipsisMenu', {\n        parent: this,\n        cssClass: 'overflow-menu-item'\n      });\n      this._ellipsis = ellipsis;\n\n      // add ellipsis to the correct position\n      if (this.ellipsisPosition === MenuBar.EllipsisPosition.RIGHT) {\n        // try right\n        let reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.right.slice().reverse());\n        if (reverseIndexPosition > -1) {\n          ellipsisIndex = orderedMenuItems.right.length - reverseIndexPosition;\n          ellipsis.rightAligned = true;\n          orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n        } else {\n          // try left\n          reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.left.slice().reverse());\n          if (reverseIndexPosition > -1) {\n            ellipsisIndex = orderedMenuItems.left.length - reverseIndexPosition;\n            orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n          }\n        }\n      } else {\n        // try left\n        ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.left);\n        if (ellipsisIndex > -1) {\n          orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n        } else {\n          // try right\n          ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.right);\n          if (ellipsisIndex > -1) {\n            ellipsis.rightAligned = true;\n            orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n          }\n        }\n      }\n      orderedMenuItems.all = orderedMenuItems.left.concat(orderedMenuItems.right);\n    }\n    return orderedMenuItems;\n  }\n\n  _getFirstStackableIndexPosition(menuList) {\n    let foundIndex = -1;\n    menuList.some((menu, index) => {\n      if (menu.stackable && menu.visible) {\n        foundIndex = index;\n        return true;\n      }\n      return false;\n    }, this);\n\n    return foundIndex;\n  }\n\n  _updateTabbableMenu() {\n    // Make first valid MenuItem tabbable so that it can be focused. All other items\n    // are not tabbable. But they can be selected with the arrow keys.\n    if (this.tabbable) {\n      if (this.defaultMenu && this.defaultMenu.isTabTarget()) {\n        this.setTabbableMenu(this.defaultMenu);\n      } else {\n        this.setTabbableMenu(arrays.find(this.orderedMenuItems.all, item => item.isTabTarget()));\n      }\n    }\n  }\n\n  setTabbableMenu(menu) {\n    if (!this.tabbable || menu === this.tabbableMenu) {\n      return;\n    }\n    if (this.tabbableMenu) {\n      this.tabbableMenu.setTabbable(false);\n    }\n    this.tabbableMenu = menu;\n    if (menu) {\n      menu.setTabbable(true);\n    }\n  }\n\n  /**\n   * Sets the property hiddenByUi. This does not automatically update the visibility of the menus.\n   * We assume that #updateVisibility() is called later anyway.\n   *\n   * @param {boolean} hiddenByUi\n   */\n  setHiddenByUi(hiddenByUi) {\n    this.setProperty('hiddenByUi', hiddenByUi);\n  }\n\n  updateVisibility() {\n    menus.updateSeparatorVisibility(this.orderedMenuItems.left);\n    menus.updateSeparatorVisibility(this.orderedMenuItems.right);\n    this.setVisible(!this.hiddenByUi && this.orderedMenuItems.all.some(m => {\n      return m.visible && !m.ellipsis;\n    }));\n  }\n\n  /**\n   * First rendered item that is enabled and reacts to ENTER keystroke shall be marked as 'defaultMenu'\n   *\n   * @param {boolean} [updateTabbableMenu] if true (default), the \"tabbable menu\" is updated at the end of this method.\n   */\n  updateDefaultMenu(updateTabbableMenu) {\n    let defaultMenu = null;\n    for (let i = 0; i < this.orderedMenuItems.all.length; i++) {\n      let item = this.orderedMenuItems.all[i];\n\n      if (!item.visible || !item.enabled || item.defaultMenu === false) {\n        // Invisible or disabled menus and menus that explicitly have the \"defaultMenu\"\n        // property set to false cannot be the default menu.\n        continue;\n      }\n      if (item.defaultMenu) {\n        defaultMenu = item;\n        break;\n      }\n      if (!defaultMenu && this._isDefaultKeyStroke(item.actionKeyStroke)) {\n        defaultMenu = item;\n      }\n    }\n\n    this.setDefaultMenu(defaultMenu);\n    if (scout.nvl(updateTabbableMenu, true)) {\n      this._updateTabbableMenu();\n    }\n  }\n\n  _isDefaultKeyStroke(keyStroke) {\n    return scout.isOneOf(keys.ENTER, keyStroke.which) &&\n      !keyStroke.ctrl &&\n      !keyStroke.alt &&\n      !keyStroke.shift;\n  }\n\n  setDefaultMenu(defaultMenu) {\n    this.setProperty('defaultMenu', defaultMenu);\n  }\n\n  _setDefaultMenu(defaultMenu) {\n    if (this.defaultMenu) {\n      this.defaultMenu.setMenuStyle(Menu.MenuStyle.NONE);\n    }\n    if (defaultMenu) {\n      defaultMenu.setMenuStyle(Menu.MenuStyle.DEFAULT);\n    }\n    this._setProperty('defaultMenu', defaultMenu);\n  }\n\n  /**\n   * Add class 'left-of-button' to every menu item which is on the left of a button\n   */\n  updateLeftOfButtonMarker() {\n    this._updateLeftOfButtonMarker(this.orderedMenuItems.left);\n    this._updateLeftOfButtonMarker(this.orderedMenuItems.right);\n  }\n\n  _updateLeftOfButtonMarker(items) {\n    let item, previousItem;\n\n    items = items.filter(item => {\n      return item.visible && item.rendered;\n    });\n\n    for (let i = 0; i < items.length; i++) {\n      item = items[i];\n      item.$container.removeClass('left-of-button');\n      if (i > 0 && item.isButton()) {\n        previousItem = items[i - 1];\n        previousItem.$container.addClass('left-of-button');\n      }\n    }\n  }\n\n  _onMenuItemPropertyChange(event) {\n    // We do not update the items directly, because this listener may be fired many times in one\n    // user request (because many menus change one or more properties). Therefore, we just invalidate\n    // the MenuBarLayout. It will be updated automatically after the user request has finished,\n    // because the layout calls rebuildItemsInternal().\n    if (event.propertyName === 'overflown' || event.propertyName === 'enabledComputed' || event.propertyName === 'visible' || event.propertyName === 'hidden') {\n      if (!this.tabbableMenu || event.source === this.tabbableMenu) {\n        this._updateTabbableMenu();\n      }\n    }\n    if (event.propertyName === 'overflown' || event.propertyName === 'hidden') {\n      if (!this.defaultMenu || event.source === this.defaultMenu) {\n        this.updateDefaultMenu();\n      }\n    }\n    if (event.propertyName === 'horizontalAlignment') {\n      // reorder\n      this.reorderMenus(event.newValue <= 0);\n    }\n    if (event.propertyName === 'visible') {\n      let oldVisible = this.visible;\n      this.updateVisibility();\n      if (!oldVisible && this.visible) {\n        // If the menubar was previously invisible (because all menus were invisible) but\n        // is now visible, the menuboxes and the menus have to be rendered now. Otherwise,\n        // calculating the preferred size of the menubar, e.g. in the TableLayout, would\n        // return the wrong value (even if the menubar itself is visible).\n        this.revalidateLayout();\n      }\n      // recalculate position of ellipsis if any menu item changed visibility.\n      // separators may change visibility during reordering menu items. Since separators do not have any\n      // impact of right/left order of menu items they have not to be considered to enforce a reorder.\n      if (!event.source.separator) {\n        this.reorderMenus();\n      }\n    }\n    if (event.propertyName === 'keyStroke' || event.propertyName === 'enabledComputed' || event.propertyName === 'defaultMenu' || event.propertyName === 'visible') {\n      this.updateDefaultMenu();\n    }\n  }\n\n  _onMenuItemFocus(event) {\n    this.setTabbableMenu(event.source);\n  }\n\n  reorderMenus(rightFirst) {\n    let menuItems = this.menuItems;\n    this._setMenuItems(menuItems, rightFirst);\n    if (this.rendered) {\n      this.updateLeftOfButtonMarker();\n    }\n  }\n\n  _allMenusAsFlatList() {\n    return arrays.flatMap(this.orderedMenuItems.all, item => {\n      if (item instanceof ComboMenu) {\n        return item.childActions;\n      }\n      return [item];\n    });\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}