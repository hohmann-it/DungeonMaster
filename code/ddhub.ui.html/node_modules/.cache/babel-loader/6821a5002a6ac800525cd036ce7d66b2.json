{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, HorizontalGrid, PlaceholderTile } from '../index';\nimport $ from 'jquery';\nexport default class TileGridSelectionHandler {\n  constructor(tileGrid) {\n    this.tileGrid = tileGrid;\n  }\n  selectTileOnMouseDown(event) {\n    if (!this.isSelectable()) {\n      return;\n    }\n    let $tile = $(event.currentTarget);\n    let tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    if (tile.selected && event.which === 3) {\n      // Do not toggle if context menus should be shown and tile already is selected\n      return;\n    }\n\n    // Clicking a tile selects it, CTRL-click toggles the selection\n    let selected = true;\n    if (event.ctrlKey) {\n      selected = !tile.selected;\n    }\n\n    // If multiSelect is enabled, CTRL-Click on a tile adds or removes that tile to or from the selection\n    if (event.ctrlKey && this.isMultiSelect()) {\n      if (selected) {\n        this.addTilesToSelection(tile);\n        this._checkAndSetFocusedTile(event, tile);\n      } else {\n        this.deselectTile(tile);\n        this._checkAndSetFocusedTile(event, null);\n      }\n      return;\n    }\n\n    // Shift-Click adds or removes the tiles between the last focused tile and the clicked tile to or from the selection\n    if (event.shiftKey && this.isMultiSelect()) {\n      if (!this.isHorizontalGridActive()) {\n        return;\n      }\n      let tiles = this.getVisibleTiles();\n      let focusedTile = this.getFocusedTile();\n      if (!focusedTile) {\n        focusedTile = tiles[0];\n      }\n      let result = this.computeSelectionBetween(tiles.indexOf(focusedTile), tiles.indexOf(tile), true);\n      if (result) {\n        this.selectTiles(result.selectedTiles);\n        this._checkAndSetFocusedTile(event, result.focusedTile);\n      }\n      return;\n    }\n\n    // If multi selection is disabled or no CTRL key is pressed, only the clicked tile may be selected\n    if (selected) {\n      this.selectTile(tile);\n      this._checkAndSetFocusedTile(event, tile);\n    } else {\n      this.deselectAllTiles();\n      this._checkAndSetFocusedTile(event, null);\n    }\n  }\n  getFilteredTiles() {\n    return this.tileGrid.filteredTiles;\n  }\n  getFilteredTileCount() {\n    return this.tileGrid.filteredTiles.length;\n  }\n  getVisibleTiles() {\n    return this.tileGrid.filteredTiles;\n  }\n  getVisibleTileCount() {\n    return this.tileGrid.filteredTiles.length;\n  }\n  getGridColumnCount() {\n    return this.tileGrid.gridColumnCount;\n  }\n  getVisibleGridRowCount() {\n    return this.tileGrid.logicalGrid.gridRows;\n  }\n  getVisibleGridX(tile) {\n    return tile.gridData.x;\n  }\n  getVisibleGridY(tile) {\n    return tile.gridData.y;\n  }\n  getSelectedTiles(event) {\n    return this.tileGrid.selectedTiles;\n  }\n  isSelectable() {\n    return this.tileGrid.selectable;\n  }\n  isMultiSelect() {\n    return this.tileGrid.multiSelect;\n  }\n  addTilesToSelection(tiles) {\n    this.tileGrid.addTilesToSelection(tiles);\n  }\n  selectTile(tile) {\n    this.tileGrid.selectTile(tile);\n  }\n  selectTiles(tiles) {\n    this.tileGrid.selectTiles(tiles);\n  }\n  deselectTile(tile) {\n    this.tileGrid.deselectTile(tile);\n  }\n  deselectTiles(tiles) {\n    this.tileGrid.deselectTiles(tiles);\n  }\n  deselectAllTiles() {\n    this.tileGrid.deselectAllTiles();\n  }\n  toggleSelection() {\n    this.tileGrid.toggleSelection();\n  }\n  getFocusedTile() {\n    return this.tileGrid.focusedTile;\n  }\n\n  /**\n   * Only sets the focus if event does not prevent the default and the tile does not have the class 'unfocusable'.\n   */\n  _checkAndSetFocusedTile(event, tile) {\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    if (tile && tile.rendered && tile.$container.hasClass('unfocusable')) {\n      return;\n    }\n    this.setFocusedTile(tile);\n  }\n  setFocusedTile(tile) {\n    this.tileGrid.setFocusedTile(tile);\n  }\n  scrollTo(tile) {\n    this.tileGrid.scrollTo(tile);\n  }\n  scrollToTop() {\n    this.tileGrid.scrollToTop();\n  }\n  scrollToBottom() {\n    this.tileGrid.scrollToBottom();\n  }\n  findVisibleTileIndexAt(x, y, startIndex, reverse) {\n    return this.tileGrid.findTileIndexAt(x, y, startIndex, reverse);\n  }\n  getTileGridByRow(rowIndex) {\n    if (rowIndex < 0 || rowIndex >= this.getVisibleGridRowCount()) {\n      return null;\n    }\n    return this.tileGrid;\n  }\n  isHorizontalGridActive() {\n    return this.tileGrid.logicalGrid instanceof HorizontalGrid;\n  }\n  computeSelectionX(xDiff, extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = null;\n    let focusedTileIndex = -1;\n    let result = this._computeFocusedTile(xDiff, extend);\n    if (result.selectedTiles !== null) {\n      // New selection could be determined already -> return it;\n      return result;\n    }\n    focusedTile = result.focusedTile;\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, focusedTileIndex + xDiff, extend);\n  }\n  computeSelectionY(yDiff, extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = null;\n    let focusedTileRow = -1;\n    let focusedTileColumn = -1;\n    let focusedTileIndex = -1;\n    let rowCount = this.getVisibleGridRowCount();\n    let result = this._computeFocusedTile(yDiff, extend);\n    if (result.selectedTiles !== null) {\n      // New selection could be determined already -> return it;\n      return result;\n    }\n    focusedTile = result.focusedTile;\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    focusedTileRow = this.getVisibleGridY(focusedTile);\n    focusedTileColumn = this.getVisibleGridX(focusedTile);\n    if (yDiff > 0 && focusedTileRow === rowCount - 1 || yDiff < 0 && focusedTileRow === 0) {\n      // Do nothing if focused tile is in the last row (navigate down) or first row (navigate up)\n      return;\n    }\n    let newFocusedTileIndex = this.findVisibleTileIndexAt(focusedTileColumn, focusedTileRow + yDiff, focusedTileIndex, yDiff < 0);\n    if (newFocusedTileIndex < 0) {\n      let tileGrid = this.getTileGridByRow(focusedTileRow + yDiff);\n      if (!tileGrid) {\n        return;\n      }\n      newFocusedTileIndex = tiles.indexOf(arrays.last(tileGrid.filteredTiles));\n    }\n    return this.computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend);\n  }\n  computeSelectionToFirst(extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = this.getFocusedTile();\n    let focusedTileIndex = -1;\n    let selectedTiles = this.getSelectedTiles();\n    if (selectedTiles.length === 0) {\n      // Select first tile if no tiles are selected\n      focusedTile = arrays.first(tiles);\n      return {\n        selectedTiles: [focusedTile],\n        focusedTile: focusedTile\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      focusedTile = arrays.last(selectedTiles);\n    }\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, 0, extend);\n  }\n  computeSelectionToLast(extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = this.getFocusedTile();\n    let focusedTileIndex = -1;\n    let selectedTiles = this.getSelectedTiles();\n    if (selectedTiles.length === 0) {\n      // Select last tile if no tiles are selected\n      focusedTile = arrays.last(tiles);\n      return {\n        selectedTiles: [focusedTile],\n        focusedTile: focusedTile\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      focusedTile = arrays.last(selectedTiles);\n    }\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, tiles.length - 1, extend);\n  }\n  _computeFocusedTile(diff, extend) {\n    let tiles = this.getVisibleTiles();\n    let selectedTiles = this.getSelectedTiles();\n    let focusedTile = this.getFocusedTile();\n    if (selectedTiles.length === 0) {\n      if (diff > 0) {\n        // Select first tile if no tiles are selected (navigate down/right)\n        focusedTile = arrays.first(tiles);\n      } else {\n        // Select first tile if no tiles are selected (navigate up/left)\n        focusedTile = arrays.last(tiles);\n      }\n      return {\n        focusedTile: focusedTile,\n        selectedTiles: [focusedTile]\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      if (diff > 0) {\n        // Navigate down/right\n        focusedTile = arrays.last(selectedTiles);\n      } else {\n        // Navigate up/left\n        focusedTile = arrays.first(selectedTiles);\n      }\n    }\n    return {\n      focusedTile: focusedTile,\n      selectedTiles: null\n    };\n  }\n  computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend) {\n    let tiles = this.getVisibleTiles();\n    let selectedTiles = this.getSelectedTiles();\n    let newFocusedTile = tiles[newFocusedTileIndex];\n    if (focusedTileIndex < 0 || focusedTileIndex > tiles.length - 1 || newFocusedTileIndex < 0 || newFocusedTileIndex > tiles.length - 1 || focusedTileIndex === newFocusedTileIndex) {\n      // Do nothing if indices are out of bounds or equal\n      return;\n    }\n    if (!extend) {\n      // Select only the tile at the newFocusedTileindex\n      return {\n        selectedTiles: [newFocusedTile],\n        focusedTile: newFocusedTile\n      };\n    }\n\n    // Adjust existing selection\n    let newSelectedTiles = [];\n    if (!newFocusedTile.selected) {\n      // Add all tiles between focused tile and newly focused tile to selection\n      if (newFocusedTileIndex > focusedTileIndex) {\n        newSelectedTiles = arrays.union(selectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex + 1));\n        newFocusedTile = this._findLastSelectedTileAfter(tiles, newFocusedTileIndex);\n      } else {\n        newSelectedTiles = arrays.union(tiles.slice(newFocusedTileIndex, focusedTileIndex + 1), selectedTiles);\n        newFocusedTile = this._findLastSelectedTileBefore(tiles, newFocusedTileIndex);\n      }\n    } else {\n      // TOOO CGU what is Bug #172929 about? Do we need to consider this as well?\n      if (newFocusedTileIndex > focusedTileIndex) {\n        // Remove all tiles between focused tile and newly focused tile from selection if newly focused tile already is selected\n        newSelectedTiles = selectedTiles.slice();\n        arrays.removeAll(newSelectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex));\n      } else {\n        newSelectedTiles = selectedTiles.slice();\n        arrays.removeAll(newSelectedTiles, tiles.slice(newFocusedTileIndex + 1, focusedTileIndex + 1));\n      }\n    }\n    return {\n      selectedTiles: newSelectedTiles,\n      focusedTile: newFocusedTile\n    };\n  }\n  executeSelection(instruction) {\n    if (!instruction) {\n      return;\n    }\n    if (instruction.selectedTiles.length > 0) {\n      this.selectTiles(instruction.selectedTiles);\n      this.scrollTo(instruction.focusedTile);\n\n      // Scroll to the very top or very bottom if newly focused tile is on top or on bottom\n      // Especially important for tile accordion because scrolling to top should reveal the group header as well\n      let focusedTileRow = this.getVisibleGridY(instruction.focusedTile);\n      let rowCount = this.getVisibleGridRowCount();\n      if (focusedTileRow === 0) {\n        this.scrollToTop();\n      } else if (focusedTileRow === rowCount - 1) {\n        this.scrollToBottom();\n      }\n    }\n    this.setFocusedTile(instruction.focusedTile);\n  }\n\n  /**\n   * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n   */\n  _findLastSelectedTileBefore(tiles, tileIndex) {\n    if (tileIndex === 0) {\n      return tiles[tileIndex];\n    }\n    let tile = arrays.findFromReverse(tiles, tileIndex, (tile, i) => {\n      let previousTile = tiles[i - 1];\n      if (!previousTile) {\n        return false;\n      }\n      return !previousTile.selected;\n    });\n    // when no tile has been found, use first tile in tileGrid\n    if (!tile) {\n      tile = tiles[0];\n    }\n    return tile;\n  }\n\n  /**\n   * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n   */\n  _findLastSelectedTileAfter(tiles, tileIndex) {\n    if (tileIndex === tiles.length - 1) {\n      return tiles[tileIndex];\n    }\n    let tile = arrays.findFrom(tiles, tileIndex, (tile, i) => {\n      let nextTile = tiles[i + 1];\n      if (!nextTile) {\n        return false;\n      }\n      return !nextTile.selected;\n    });\n    // when no tile has been found, use last tile in tileGrid\n    if (!tile) {\n      tile = tiles[tiles.length - 1];\n    }\n    return tile;\n  }\n}","map":{"version":3,"names":["arrays","HorizontalGrid","PlaceholderTile","$","TileGridSelectionHandler","constructor","tileGrid","selectTileOnMouseDown","event","isSelectable","$tile","currentTarget","tile","data","selected","which","ctrlKey","isMultiSelect","addTilesToSelection","_checkAndSetFocusedTile","deselectTile","shiftKey","isHorizontalGridActive","tiles","getVisibleTiles","focusedTile","getFocusedTile","result","computeSelectionBetween","indexOf","selectTiles","selectedTiles","selectTile","deselectAllTiles","getFilteredTiles","filteredTiles","getFilteredTileCount","length","getVisibleTileCount","getGridColumnCount","gridColumnCount","getVisibleGridRowCount","logicalGrid","gridRows","getVisibleGridX","gridData","x","getVisibleGridY","y","getSelectedTiles","selectable","multiSelect","deselectTiles","toggleSelection","isDefaultPrevented","rendered","$container","hasClass","setFocusedTile","scrollTo","scrollToTop","scrollToBottom","findVisibleTileIndexAt","startIndex","reverse","findTileIndexAt","getTileGridByRow","rowIndex","computeSelectionX","xDiff","extend","focusedTileIndex","_computeFocusedTile","computeSelectionY","yDiff","focusedTileRow","focusedTileColumn","rowCount","newFocusedTileIndex","last","computeSelectionToFirst","first","computeSelectionToLast","diff","newFocusedTile","newSelectedTiles","union","slice","_findLastSelectedTileAfter","_findLastSelectedTileBefore","removeAll","executeSelection","instruction","tileIndex","findFromReverse","i","previousTile","findFrom","nextTile"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/tile/TileGridSelectionHandler.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, HorizontalGrid, PlaceholderTile} from '../index';\nimport $ from 'jquery';\n\nexport default class TileGridSelectionHandler {\n\n  constructor(tileGrid) {\n    this.tileGrid = tileGrid;\n  }\n\n  selectTileOnMouseDown(event) {\n    if (!this.isSelectable()) {\n      return;\n    }\n\n    let $tile = $(event.currentTarget);\n    let tile = $tile.data('widget');\n\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    if (tile.selected && event.which === 3) {\n      // Do not toggle if context menus should be shown and tile already is selected\n      return;\n    }\n\n    // Clicking a tile selects it, CTRL-click toggles the selection\n    let selected = true;\n    if (event.ctrlKey) {\n      selected = !tile.selected;\n    }\n\n    // If multiSelect is enabled, CTRL-Click on a tile adds or removes that tile to or from the selection\n    if (event.ctrlKey && this.isMultiSelect()) {\n      if (selected) {\n        this.addTilesToSelection(tile);\n        this._checkAndSetFocusedTile(event, tile);\n      } else {\n        this.deselectTile(tile);\n        this._checkAndSetFocusedTile(event, null);\n      }\n      return;\n    }\n\n    // Shift-Click adds or removes the tiles between the last focused tile and the clicked tile to or from the selection\n    if (event.shiftKey && this.isMultiSelect()) {\n      if (!this.isHorizontalGridActive()) {\n        return;\n      }\n      let tiles = this.getVisibleTiles();\n      let focusedTile = this.getFocusedTile();\n      if (!focusedTile) {\n        focusedTile = tiles[0];\n      }\n      let result = this.computeSelectionBetween(tiles.indexOf(focusedTile), tiles.indexOf(tile), true);\n      if (result) {\n        this.selectTiles(result.selectedTiles);\n        this._checkAndSetFocusedTile(event, result.focusedTile);\n      }\n      return;\n    }\n\n    // If multi selection is disabled or no CTRL key is pressed, only the clicked tile may be selected\n    if (selected) {\n      this.selectTile(tile);\n      this._checkAndSetFocusedTile(event, tile);\n    } else {\n      this.deselectAllTiles();\n      this._checkAndSetFocusedTile(event, null);\n    }\n  }\n\n  getFilteredTiles() {\n    return this.tileGrid.filteredTiles;\n  }\n\n  getFilteredTileCount() {\n    return this.tileGrid.filteredTiles.length;\n  }\n\n  getVisibleTiles() {\n    return this.tileGrid.filteredTiles;\n  }\n\n  getVisibleTileCount() {\n    return this.tileGrid.filteredTiles.length;\n  }\n\n  getGridColumnCount() {\n    return this.tileGrid.gridColumnCount;\n  }\n\n  getVisibleGridRowCount() {\n    return this.tileGrid.logicalGrid.gridRows;\n  }\n\n  getVisibleGridX(tile) {\n    return tile.gridData.x;\n  }\n\n  getVisibleGridY(tile) {\n    return tile.gridData.y;\n  }\n\n  getSelectedTiles(event) {\n    return this.tileGrid.selectedTiles;\n  }\n\n  isSelectable() {\n    return this.tileGrid.selectable;\n  }\n\n  isMultiSelect() {\n    return this.tileGrid.multiSelect;\n  }\n\n  addTilesToSelection(tiles) {\n    this.tileGrid.addTilesToSelection(tiles);\n  }\n\n  selectTile(tile) {\n    this.tileGrid.selectTile(tile);\n  }\n\n  selectTiles(tiles) {\n    this.tileGrid.selectTiles(tiles);\n  }\n\n  deselectTile(tile) {\n    this.tileGrid.deselectTile(tile);\n  }\n\n  deselectTiles(tiles) {\n    this.tileGrid.deselectTiles(tiles);\n  }\n\n  deselectAllTiles() {\n    this.tileGrid.deselectAllTiles();\n  }\n\n  toggleSelection() {\n    this.tileGrid.toggleSelection();\n  }\n\n  getFocusedTile() {\n    return this.tileGrid.focusedTile;\n  }\n\n  /**\n   * Only sets the focus if event does not prevent the default and the tile does not have the class 'unfocusable'.\n   */\n  _checkAndSetFocusedTile(event, tile) {\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    if (tile && tile.rendered && tile.$container.hasClass('unfocusable')) {\n      return;\n    }\n    this.setFocusedTile(tile);\n  }\n\n  setFocusedTile(tile) {\n    this.tileGrid.setFocusedTile(tile);\n  }\n\n  scrollTo(tile) {\n    this.tileGrid.scrollTo(tile);\n  }\n\n  scrollToTop() {\n    this.tileGrid.scrollToTop();\n  }\n\n  scrollToBottom() {\n    this.tileGrid.scrollToBottom();\n  }\n\n  findVisibleTileIndexAt(x, y, startIndex, reverse) {\n    return this.tileGrid.findTileIndexAt(x, y, startIndex, reverse);\n  }\n\n  getTileGridByRow(rowIndex) {\n    if (rowIndex < 0 || rowIndex >= this.getVisibleGridRowCount()) {\n      return null;\n    }\n    return this.tileGrid;\n  }\n\n  isHorizontalGridActive() {\n    return this.tileGrid.logicalGrid instanceof HorizontalGrid;\n  }\n\n  computeSelectionX(xDiff, extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = null;\n    let focusedTileIndex = -1;\n    let result = this._computeFocusedTile(xDiff, extend);\n    if (result.selectedTiles !== null) {\n      // New selection could be determined already -> return it;\n      return result;\n    }\n    focusedTile = result.focusedTile;\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, focusedTileIndex + xDiff, extend);\n  }\n\n  computeSelectionY(yDiff, extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = null;\n    let focusedTileRow = -1;\n    let focusedTileColumn = -1;\n    let focusedTileIndex = -1;\n    let rowCount = this.getVisibleGridRowCount();\n    let result = this._computeFocusedTile(yDiff, extend);\n    if (result.selectedTiles !== null) {\n      // New selection could be determined already -> return it;\n      return result;\n    }\n    focusedTile = result.focusedTile;\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    focusedTileRow = this.getVisibleGridY(focusedTile);\n    focusedTileColumn = this.getVisibleGridX(focusedTile);\n    if (yDiff > 0 && focusedTileRow === rowCount - 1 ||\n      yDiff < 0 && focusedTileRow === 0) {\n      // Do nothing if focused tile is in the last row (navigate down) or first row (navigate up)\n      return;\n    }\n\n    let newFocusedTileIndex = this.findVisibleTileIndexAt(focusedTileColumn, focusedTileRow + yDiff, focusedTileIndex, yDiff < 0);\n    if (newFocusedTileIndex < 0) {\n      let tileGrid = this.getTileGridByRow(focusedTileRow + yDiff);\n      if (!tileGrid) {\n        return;\n      }\n      newFocusedTileIndex = tiles.indexOf(arrays.last(tileGrid.filteredTiles));\n    }\n    return this.computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend);\n  }\n\n  computeSelectionToFirst(extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = this.getFocusedTile();\n    let focusedTileIndex = -1;\n    let selectedTiles = this.getSelectedTiles();\n    if (selectedTiles.length === 0) {\n      // Select first tile if no tiles are selected\n      focusedTile = arrays.first(tiles);\n      return {\n        selectedTiles: [focusedTile],\n        focusedTile: focusedTile\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      focusedTile = arrays.last(selectedTiles);\n    }\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, 0, extend);\n  }\n\n  computeSelectionToLast(extend) {\n    let tiles = this.getVisibleTiles();\n    let focusedTile = this.getFocusedTile();\n    let focusedTileIndex = -1;\n    let selectedTiles = this.getSelectedTiles();\n    if (selectedTiles.length === 0) {\n      // Select last tile if no tiles are selected\n      focusedTile = arrays.last(tiles);\n      return {\n        selectedTiles: [focusedTile],\n        focusedTile: focusedTile\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      focusedTile = arrays.last(selectedTiles);\n    }\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, tiles.length - 1, extend);\n  }\n\n  _computeFocusedTile(diff, extend) {\n    let tiles = this.getVisibleTiles();\n    let selectedTiles = this.getSelectedTiles();\n    let focusedTile = this.getFocusedTile();\n    if (selectedTiles.length === 0) {\n      if (diff > 0) {\n        // Select first tile if no tiles are selected (navigate down/right)\n        focusedTile = arrays.first(tiles);\n      } else {\n        // Select first tile if no tiles are selected (navigate up/left)\n        focusedTile = arrays.last(tiles);\n      }\n      return {\n        focusedTile: focusedTile,\n        selectedTiles: [focusedTile]\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      if (diff > 0) {\n        // Navigate down/right\n        focusedTile = arrays.last(selectedTiles);\n      } else {\n        // Navigate up/left\n        focusedTile = arrays.first(selectedTiles);\n      }\n    }\n    return {\n      focusedTile: focusedTile,\n      selectedTiles: null\n    };\n  }\n\n  computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend) {\n    let tiles = this.getVisibleTiles();\n    let selectedTiles = this.getSelectedTiles();\n    let newFocusedTile = tiles[newFocusedTileIndex];\n\n    if (focusedTileIndex < 0 || focusedTileIndex > tiles.length - 1 ||\n      newFocusedTileIndex < 0 || newFocusedTileIndex > tiles.length - 1 ||\n      focusedTileIndex === newFocusedTileIndex) {\n      // Do nothing if indices are out of bounds or equal\n      return;\n    }\n\n    if (!extend) {\n      // Select only the tile at the newFocusedTileindex\n      return {\n        selectedTiles: [newFocusedTile],\n        focusedTile: newFocusedTile\n      };\n    }\n\n    // Adjust existing selection\n    let newSelectedTiles = [];\n    if (!newFocusedTile.selected) {\n      // Add all tiles between focused tile and newly focused tile to selection\n      if (newFocusedTileIndex > focusedTileIndex) {\n        newSelectedTiles = arrays.union(selectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex + 1));\n        newFocusedTile = this._findLastSelectedTileAfter(tiles, newFocusedTileIndex);\n      } else {\n        newSelectedTiles = arrays.union(tiles.slice(newFocusedTileIndex, focusedTileIndex + 1), selectedTiles);\n        newFocusedTile = this._findLastSelectedTileBefore(tiles, newFocusedTileIndex);\n      }\n    } else {\n      // TOOO CGU what is Bug #172929 about? Do we need to consider this as well?\n      if (newFocusedTileIndex > focusedTileIndex) {\n        // Remove all tiles between focused tile and newly focused tile from selection if newly focused tile already is selected\n        newSelectedTiles = selectedTiles.slice();\n        arrays.removeAll(newSelectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex));\n      } else {\n        newSelectedTiles = selectedTiles.slice();\n        arrays.removeAll(newSelectedTiles, tiles.slice(newFocusedTileIndex + 1, focusedTileIndex + 1));\n      }\n    }\n\n    return {\n      selectedTiles: newSelectedTiles,\n      focusedTile: newFocusedTile\n    };\n  }\n\n  executeSelection(instruction) {\n    if (!instruction) {\n      return;\n    }\n    if (instruction.selectedTiles.length > 0) {\n      this.selectTiles(instruction.selectedTiles);\n      this.scrollTo(instruction.focusedTile);\n\n      // Scroll to the very top or very bottom if newly focused tile is on top or on bottom\n      // Especially important for tile accordion because scrolling to top should reveal the group header as well\n      let focusedTileRow = this.getVisibleGridY(instruction.focusedTile);\n      let rowCount = this.getVisibleGridRowCount();\n      if (focusedTileRow === 0) {\n        this.scrollToTop();\n      } else if (focusedTileRow === rowCount - 1) {\n        this.scrollToBottom();\n      }\n    }\n    this.setFocusedTile(instruction.focusedTile);\n  }\n\n  /**\n   * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n   */\n  _findLastSelectedTileBefore(tiles, tileIndex) {\n    if (tileIndex === 0) {\n      return tiles[tileIndex];\n    }\n    let tile = arrays.findFromReverse(tiles, tileIndex, (tile, i) => {\n      let previousTile = tiles[i - 1];\n      if (!previousTile) {\n        return false;\n      }\n      return !previousTile.selected;\n    });\n    // when no tile has been found, use first tile in tileGrid\n    if (!tile) {\n      tile = tiles[0];\n    }\n    return tile;\n  }\n\n  /**\n   * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n   */\n  _findLastSelectedTileAfter(tiles, tileIndex) {\n    if (tileIndex === tiles.length - 1) {\n      return tiles[tileIndex];\n    }\n    let tile = arrays.findFrom(tiles, tileIndex, (tile, i) => {\n      let nextTile = tiles[i + 1];\n      if (!nextTile) {\n        return false;\n      }\n      return !nextTile.selected;\n    });\n    // when no tile has been found, use last tile in tileGrid\n    if (!tile) {\n      tile = tiles[tiles.length - 1];\n    }\n    return tile;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}