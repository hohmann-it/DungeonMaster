{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Dimension, HtmlComponent, LayoutConstants, LogicalGridData, Rectangle, TreeSet } from '../../index';\nimport $ from 'jquery';\n\n/**\n * JavaScript port of org.eclipse.scout.rt.ui.swing.LogicalGridLayoutInfo.\n */\nexport default class LogicalGridLayoutInfo {\n  constructor(model) {\n    this.gridDatas = [];\n    this.$components = null;\n    this.cols = 0;\n    this.compSize = [];\n    this.rows = 0;\n    this.width = [];\n    this.widthHints = [];\n    this.height = [];\n    this.weightX = [];\n    this.weightY = [];\n    this.hgap = 0;\n    this.vgap = 0;\n    this.rowHeight = 0;\n    this.columnWidth = 0;\n    this.cellBounds = [];\n    this.widthHint = null;\n    this.widthOnly = false;\n    $.extend(this, model);\n\n    // create a modifiable copy of the grid datas\n    let i, gd, x, y;\n    for (i = 0; i < this.cons.length; i++) {\n      this.gridDatas[i] = new LogicalGridData(this.cons[i]);\n    }\n    if (this.$components.length === 0) {\n      return;\n    }\n    // eliminate unused rows and columns\n    let usedCols = new TreeSet();\n    let usedRows = new TreeSet();\n    // ticket 86645 use member gridDatas instead of param cons\n    for (i = 0; i < this.gridDatas.length; i++) {\n      gd = this.gridDatas[i];\n      if (gd.gridx < 0) {\n        gd.gridx = 0;\n      }\n      if (gd.gridy < 0) {\n        gd.gridy = 0;\n      }\n      if (gd.gridw < 1) {\n        gd.gridw = 1;\n      }\n      if (gd.gridh < 1) {\n        gd.gridh = 1;\n      }\n      for (x = gd.gridx; x < gd.gridx + gd.gridw; x++) {\n        usedCols.add(x);\n      }\n      for (y = gd.gridy; y < gd.gridy + gd.gridh; y++) {\n        usedRows.add(y);\n      }\n    }\n    let maxCol = usedCols.last();\n    for (x = maxCol; x >= 0; x--) {\n      if (!usedCols.contains(x)) {\n        // eliminate column\n        // ticket 86645 use member gridDatas instead of param cons\n        for (i = 0; i < this.gridDatas.length; i++) {\n          gd = this.gridDatas[i];\n          if (gd.gridx > x) {\n            gd.gridx--;\n          }\n        }\n      }\n    }\n    let maxRow = usedRows.last();\n    for (y = maxRow; y >= 0; y--) {\n      if (!usedRows.contains(y)) {\n        // eliminate row\n        // ticket 86645 use member gridDatas instead of param cons\n        for (i = 0; i < this.gridDatas.length; i++) {\n          gd = this.gridDatas[i];\n          if (gd.gridy > y) {\n            // ticket 86645\n            gd.gridy--;\n          }\n        }\n      }\n    }\n    //\n    this.cols = usedCols.size();\n    this.rows = usedRows.size();\n    $.log.isTraceEnabled() && $.log.trace('(LogicalGridLayoutInfo#CTOR) $components.length=' + this.$components.length + ' usedCols=' + this.cols + ' usedRows=' + this.rows);\n    this._initializeInfo();\n  }\n  _initializeInfo() {\n    let compCount = this.$components.length;\n    let uiHeightElements = [];\n    for (let i = 0; i < compCount; i++) {\n      // cleanup constraints\n      let $comp = this.$components[i];\n      let cons = this.gridDatas[i];\n      if (cons.gridx < 0) {\n        cons.gridx = 0;\n      }\n      if (cons.gridy < 0) {\n        cons.gridy = 0;\n      }\n      if (cons.gridw < 1) {\n        cons.gridw = 1;\n      }\n      if (cons.gridh < 1) {\n        cons.gridh = 1;\n      }\n      if (cons.gridx >= this.cols) {\n        cons.gridx = this.cols - 1;\n      }\n      if (cons.gridy >= this.rows) {\n        cons.gridy = this.rows - 1;\n      }\n      if (cons.gridx + cons.gridw - 1 >= this.cols) {\n        cons.gridw = this.cols - cons.gridx;\n      }\n      if (cons.gridy + cons.gridh >= this.rows) {\n        cons.gridh = this.rows - cons.gridy;\n      }\n\n      // Calculate and cache component size\n      let size = new Dimension(0, 0);\n      if (cons.widthHint > 0) {\n        // Use explicit width hint, if set\n        size.width = cons.widthHint;\n        // eslint-disable-next-line brace-style\n      } else if (cons.useUiWidth || !cons.fillHorizontal) {\n        // Calculate preferred width otherwise\n        // This size is needed by _initializeColumns\n        // But only if really needed by the logical grid layout (because it is expensive)\n        size = this.uiSizeInPixel($comp, cons);\n      }\n      if (cons.heightHint > 0) {\n        // Use explicit height hint, if set\n        size.height = cons.heightHint;\n      } else if (cons.useUiHeight || !cons.fillVertical) {\n        // Otherwise check if preferred height should be calculated.\n        // Don't do it now because because weightX need to be calculated first to get the correct width hints\n        uiHeightElements.push({\n          cons: cons,\n          $comp: $comp,\n          index: i\n        });\n      }\n      this.compSize[i] = size;\n    }\n\n    // Calculate this.width and this.weightX\n    this._initializeColumns();\n    if (this.widthOnly) {\n      // Abort here if only width is of interest\n      this.height = arrays.init(this.rows, [0, 0, 0]);\n      return;\n    }\n\n    // Calculate preferred heights using the width hints\n    if (this.widthHint && uiHeightElements.length > 0) {\n      let totalHGap = Math.max(0, (this.cols - 1) * this.hgap);\n      this.widthHints = this.layoutSizes(this.widthHint - totalHGap, this.width, this.weightX);\n    }\n    uiHeightElements.forEach(function (elem) {\n      let $comp = elem.$comp;\n      let cons = elem.cons;\n      let widthHint = this.widthHintForGridData(cons);\n      if (!cons.fillHorizontal) {\n        widthHint = Math.min(widthHint, this.compSize[elem.index].width);\n      }\n      this.compSize[elem.index] = this.uiSizeInPixel($comp, cons, {\n        widthHint: widthHint\n      });\n    }, this);\n\n    // Calculate this.height and this.weightY\n    this._initializeRows();\n  }\n  _initializeColumns() {\n    let compSize = this.compSize;\n    let compCount = compSize.length;\n    let prefWidths = arrays.init(this.cols, 0);\n    let fixedWidths = arrays.init(this.cols, false);\n    let i, j, k, prefw, cons;\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridw === 1) {\n        if (cons.widthHint > 0) {\n          prefw = cons.widthHint;\n        } else if (cons.useUiWidth) {\n          prefw = compSize[i].width;\n        } else {\n          prefw = this.logicalWidthInPixel(cons);\n        }\n        prefw = Math.floor(prefw);\n        for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {\n          prefWidths[j] = Math.max(prefWidths[j], prefw);\n          if (cons.weightx === 0) {\n            fixedWidths[j] = true;\n          }\n        }\n      }\n    }\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridw > 1) {\n        let hSpan = cons.gridw;\n        let spanWidth = 0;\n        let distWidth;\n        // pref\n        for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {\n          if (!fixedWidths[j]) {\n            spanWidth += prefWidths[j];\n          }\n        }\n        if (cons.widthHint > 0) {\n          distWidth = cons.widthHint - spanWidth - (hSpan - 1) * this.hgap;\n        } else if (cons.useUiWidth) {\n          distWidth = compSize[i].width - spanWidth - (hSpan - 1) * this.hgap;\n        } else {\n          distWidth = this.logicalWidthInPixel(cons) - spanWidth - (hSpan - 1) * this.hgap;\n        }\n        if (distWidth > 0) {\n          let equalWidth = Math.floor((distWidth + spanWidth) / hSpan);\n          let remainder = (distWidth + spanWidth) % hSpan;\n          let last = -1;\n          for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {\n            last = j;\n            if (!fixedWidths[j]) {\n              prefWidths[j] = Math.max(equalWidth, prefWidths[j]);\n            }\n            if (cons.weightx === 0) {\n              fixedWidths[j] = true;\n            }\n          }\n          if (last > -1) {\n            prefWidths[last] += remainder;\n          }\n        }\n      }\n    }\n    let lc = LayoutConstants;\n    for (i = 0; i < this.cols; i++) {\n      this.width[i] = [];\n      if (fixedWidths[i]) {\n        this.width[i][lc.MIN] = prefWidths[i];\n        this.width[i][lc.PREF] = prefWidths[i];\n        this.width[i][lc.MAX] = prefWidths[i];\n      } else {\n        this.width[i][lc.MIN] = 0; // must be exactly 0!\n        this.width[i][lc.PREF] = prefWidths[i];\n        this.width[i][lc.MAX] = 10240;\n      }\n    }\n\n    // averaged column weights, normalized so that sum of weights is equal to\n    // 1.0\n    for (i = 0; i < this.cols; i++) {\n      if (fixedWidths[i]) {\n        this.weightX[i] = 0;\n      } else {\n        let weightSum = 0;\n        let weightCount = 0;\n        for (k = 0; k < compCount; k++) {\n          cons = this.gridDatas[k];\n          if (cons.weightx > 0 && cons.gridx <= i && i <= cons.gridx + cons.gridw - 1) {\n            weightSum += cons.weightx / cons.gridw;\n            weightCount++;\n          }\n        }\n        this.weightX[i] = weightCount > 0 ? weightSum / weightCount : 0;\n      }\n    }\n    let sumWeightX = 0;\n    for (i = 0; i < this.cols; i++) {\n      sumWeightX += this.weightX[i];\n    }\n    if (sumWeightX >= 1e-6) {\n      let f = 1.0 / sumWeightX;\n      for (i = 0; i < this.cols; i++) {\n        this.weightX[i] = this.weightX[i] * f;\n      }\n    }\n  }\n  _initializeRows() {\n    let compSize = this.compSize;\n    let compCount = compSize.length;\n    let prefHeights = arrays.init(this.rows, 0);\n    let fixedHeights = arrays.init(this.rows, false);\n    let i, j, k, prefh, cons;\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridh === 1) {\n        if (cons.heightHint > 0) {\n          prefh = cons.heightHint;\n        } else if (cons.useUiHeight) {\n          prefh = compSize[i].height;\n        } else {\n          prefh = this.logicalHeightInPixel(cons);\n        }\n        prefh = Math.floor(prefh);\n        for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {\n          prefHeights[j] = Math.max(prefHeights[j], prefh);\n          if (cons.weighty === 0) {\n            fixedHeights[j] = true;\n          }\n        }\n      }\n    }\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridh > 1) {\n        let vSpan = cons.gridh;\n        let spanHeight = 0;\n        let distHeight;\n        // pref\n        for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {\n          if (!fixedHeights[j]) {\n            spanHeight += prefHeights[j];\n          }\n        }\n        if (cons.heightHint > 0) {\n          distHeight = cons.heightHint - spanHeight - (vSpan - 1) * this.vgap;\n        } else if (cons.useUiHeight) {\n          distHeight = compSize[i].height - spanHeight - (vSpan - 1) * this.vgap;\n        } else {\n          distHeight = this.logicalHeightInPixel(cons) - spanHeight - (vSpan - 1) * this.vgap;\n        }\n        if (distHeight > 0) {\n          let equalHeight = Math.floor((distHeight + spanHeight) / vSpan);\n          let remainder = (distHeight + spanHeight) % vSpan;\n          let last = -1;\n          for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {\n            last = j;\n            if (!fixedHeights[j]) {\n              prefHeights[j] = Math.max(equalHeight, prefHeights[j]);\n            }\n            if (cons.weighty === 0) {\n              fixedHeights[j] = true;\n            }\n          }\n          if (last > -1) {\n            prefHeights[last] += remainder;\n          }\n        }\n      }\n    }\n    let lc = LayoutConstants;\n    for (i = 0; i < this.rows; i++) {\n      this.height[i] = [];\n      if (fixedHeights[i]) {\n        this.height[i][lc.MIN] = prefHeights[i];\n        this.height[i][lc.PREF] = prefHeights[i];\n        this.height[i][lc.MAX] = prefHeights[i];\n      } else {\n        this.height[i][lc.MIN] = 0; // must be exactly 0!\n        this.height[i][lc.PREF] = prefHeights[i];\n        this.height[i][lc.MAX] = 10240;\n      }\n    }\n\n    // averaged row weights, normalized so that sum of weights is equal to 1.0\n    for (i = 0; i < this.rows; i++) {\n      if (fixedHeights[i]) {\n        this.weightY[i] = 0;\n      } else {\n        let weightSum = 0;\n        let weightCount = 0;\n        for (k = 0; k < compCount; k++) {\n          cons = this.gridDatas[k];\n          if (cons.weighty > 0 && cons.gridy <= i && i <= cons.gridy + cons.gridh - 1) {\n            weightSum += cons.weighty / cons.gridh;\n            weightCount++;\n          }\n        }\n        this.weightY[i] = weightCount > 0 ? weightSum / weightCount : 0;\n      }\n    }\n    let sumWeightY = 0;\n    for (i = 0; i < this.rows; i++) {\n      sumWeightY += this.weightY[i];\n    }\n    if (sumWeightY >= 1e-6) {\n      let f = 1.0 / sumWeightY;\n      for (i = 0; i < this.rows; i++) {\n        this.weightY[i] = this.weightY[i] * f;\n      }\n    }\n  }\n  layoutCellBounds(size, insets) {\n    let w = this.layoutSizes(size.width - insets.horizontal() - Math.max(0, (this.cols - 1) * this.hgap), this.width, this.weightX);\n    let h = this.layoutSizes(size.height - insets.vertical() - Math.max(0, (this.rows - 1) * this.vgap), this.height, this.weightY);\n    this.cellBounds = arrays.init(this.rows, null);\n    let y = insets.top,\n      r,\n      x,\n      c;\n    for (r = 0; r < this.rows; r++) {\n      x = insets.left;\n      this.cellBounds[r] = arrays.init(this.cols, null);\n      for (c = 0; c < this.cols; c++) {\n        this.cellBounds[r][c] = new Rectangle(x, y, w[c], h[r]);\n        x += w[c];\n        x += this.hgap;\n      }\n      y += h[r];\n      y += this.vgap;\n    }\n    return this.cellBounds;\n  }\n  layoutSizes(targetSize, sizes, weights) {\n    let i;\n    let outSizes = arrays.init(sizes.length, 0);\n    if (targetSize <= 0) {\n      for (i = 0; i < sizes.length; i++) {\n        outSizes[i] = sizes[i][LayoutConstants.MIN];\n      }\n      return outSizes;\n    }\n    let sumSize = 0;\n    let tmpWeight = arrays.init(weights.length, 0.0);\n    let sumWeight = 0;\n    for (i = 0; i < sizes.length; i++) {\n      outSizes[i] = sizes[i][LayoutConstants.PREF];\n      sumSize += outSizes[i];\n      tmpWeight[i] = weights[i];\n      /**\n       * auto correction: if weight is 0 and min / max sizes are NOT equal then\n       * set weight to 1; if weight<eps set it to 0\n       */\n      if (tmpWeight[i] < LayoutConstants.EPS) {\n        if (sizes[i][LayoutConstants.MAX] > sizes[i][LayoutConstants.MIN]) {\n          tmpWeight[i] = 1;\n        } else {\n          tmpWeight[i] = 0;\n        }\n      }\n      sumWeight += tmpWeight[i];\n    }\n    // normalize weights\n    if (sumWeight > 0) {\n      for (i = 0; i < tmpWeight.length; i++) {\n        tmpWeight[i] = tmpWeight[i] / sumWeight;\n      }\n    }\n    let deltaInt = targetSize - sumSize;\n    // expand or shrink\n    if (Math.abs(deltaInt) > 0) {\n      // setup accumulators\n      /* float[] */\n      let accWeight = arrays.init(tmpWeight.length, 0.0);\n      let hasTargets;\n      if (deltaInt > 0) {\n        // expand, if delta is > 0\n        hasTargets = true;\n        while (deltaInt > 0 && hasTargets) {\n          hasTargets = false;\n          for (i = 0; i < outSizes.length && deltaInt > 0; i++) {\n            if (tmpWeight[i] > 0 && outSizes[i] < sizes[i][LayoutConstants.MAX]) {\n              hasTargets = true;\n              accWeight[i] += tmpWeight[i];\n              if (accWeight[i] > 0) {\n                accWeight[i] -= 1;\n                outSizes[i] += 1;\n                deltaInt -= 1;\n              }\n            }\n          }\n        }\n      } else {\n        // shrink, if delta is <= 0\n        hasTargets = true;\n        while (deltaInt < 0 && hasTargets) {\n          hasTargets = false;\n          for (i = 0; i < outSizes.length && deltaInt < 0; i++) {\n            if (tmpWeight[i] > 0 && outSizes[i] > sizes[i][LayoutConstants.MIN]) {\n              hasTargets = true;\n              accWeight[i] += tmpWeight[i];\n              if (accWeight[i] > 0) {\n                accWeight[i] -= 1;\n                outSizes[i] -= 1;\n                deltaInt += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    return outSizes;\n  }\n  logicalWidthInPixel(cons) {\n    let gridW = cons.gridw;\n    return this.columnWidth * gridW + this.hgap * Math.max(0, gridW - 1);\n  }\n  logicalHeightInPixel(cons) {\n    let gridH = cons.gridh,\n      addition = cons.logicalRowHeightAddition || 0;\n    return this.rowHeight * gridH + this.vgap * Math.max(0, gridH - 1) + addition;\n  }\n  uiSizeInPixel($comp, cons, options) {\n    let htmlComp = HtmlComponent.get($comp);\n    return htmlComp.prefSize(options).add(htmlComp.margins());\n  }\n\n  /**\n   * @returns {number|null} the width hint for the given gridData\n   */\n  widthHintForGridData(gridData) {\n    if (this.widthHints.length === 0) {\n      return null;\n    }\n    let widthHint = (gridData.gridw - 1) * this.hgap;\n    for (let i = gridData.gridx; i < gridData.gridx + gridData.gridw; i++) {\n      widthHint += this.widthHints[i];\n    }\n    return widthHint;\n  }\n}","map":{"version":3,"names":["arrays","Dimension","HtmlComponent","LayoutConstants","LogicalGridData","Rectangle","TreeSet","$","LogicalGridLayoutInfo","constructor","model","gridDatas","$components","cols","compSize","rows","width","widthHints","height","weightX","weightY","hgap","vgap","rowHeight","columnWidth","cellBounds","widthHint","widthOnly","extend","i","gd","x","y","cons","length","usedCols","usedRows","gridx","gridy","gridw","gridh","add","maxCol","last","contains","maxRow","size","log","isTraceEnabled","trace","_initializeInfo","compCount","uiHeightElements","$comp","useUiWidth","fillHorizontal","uiSizeInPixel","heightHint","useUiHeight","fillVertical","push","index","_initializeColumns","init","totalHGap","Math","max","layoutSizes","forEach","elem","widthHintForGridData","min","_initializeRows","prefWidths","fixedWidths","j","k","prefw","logicalWidthInPixel","floor","weightx","hSpan","spanWidth","distWidth","equalWidth","remainder","lc","MIN","PREF","MAX","weightSum","weightCount","sumWeightX","f","prefHeights","fixedHeights","prefh","logicalHeightInPixel","weighty","vSpan","spanHeight","distHeight","equalHeight","sumWeightY","layoutCellBounds","insets","w","horizontal","h","vertical","top","r","c","left","targetSize","sizes","weights","outSizes","sumSize","tmpWeight","sumWeight","EPS","deltaInt","abs","accWeight","hasTargets","gridW","gridH","addition","logicalRowHeightAddition","options","htmlComp","get","prefSize","margins","gridData"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/layout/logicalgrid/LogicalGridLayoutInfo.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Dimension, HtmlComponent, LayoutConstants, LogicalGridData, Rectangle, TreeSet} from '../../index';\nimport $ from 'jquery';\n\n/**\n * JavaScript port of org.eclipse.scout.rt.ui.swing.LogicalGridLayoutInfo.\n */\nexport default class LogicalGridLayoutInfo {\n\n  constructor(model) {\n    this.gridDatas = [];\n    this.$components = null;\n    this.cols = 0;\n    this.compSize = [];\n    this.rows = 0;\n    this.width = [];\n    this.widthHints = [];\n    this.height = [];\n    this.weightX = [];\n    this.weightY = [];\n    this.hgap = 0;\n    this.vgap = 0;\n    this.rowHeight = 0;\n    this.columnWidth = 0;\n    this.cellBounds = [];\n    this.widthHint = null;\n    this.widthOnly = false;\n    $.extend(this, model);\n\n    // create a modifiable copy of the grid datas\n    let i, gd, x, y;\n    for (i = 0; i < this.cons.length; i++) {\n      this.gridDatas[i] = new LogicalGridData(this.cons[i]);\n    }\n    if (this.$components.length === 0) {\n      return;\n    }\n    // eliminate unused rows and columns\n    let usedCols = new TreeSet();\n    let usedRows = new TreeSet();\n    // ticket 86645 use member gridDatas instead of param cons\n    for (i = 0; i < this.gridDatas.length; i++) {\n      gd = this.gridDatas[i];\n      if (gd.gridx < 0) {\n        gd.gridx = 0;\n      }\n      if (gd.gridy < 0) {\n        gd.gridy = 0;\n      }\n      if (gd.gridw < 1) {\n        gd.gridw = 1;\n      }\n      if (gd.gridh < 1) {\n        gd.gridh = 1;\n      }\n      for (x = gd.gridx; x < gd.gridx + gd.gridw; x++) {\n        usedCols.add(x);\n      }\n      for (y = gd.gridy; y < gd.gridy + gd.gridh; y++) {\n        usedRows.add(y);\n      }\n    }\n    let maxCol = usedCols.last();\n    for (x = maxCol; x >= 0; x--) {\n      if (!usedCols.contains(x)) {\n        // eliminate column\n        // ticket 86645 use member gridDatas instead of param cons\n        for (i = 0; i < this.gridDatas.length; i++) {\n          gd = this.gridDatas[i];\n          if (gd.gridx > x) {\n            gd.gridx--;\n          }\n        }\n      }\n    }\n    let maxRow = usedRows.last();\n    for (y = maxRow; y >= 0; y--) {\n      if (!usedRows.contains(y)) {\n        // eliminate row\n        // ticket 86645 use member gridDatas instead of param cons\n        for (i = 0; i < this.gridDatas.length; i++) {\n          gd = this.gridDatas[i];\n          if (gd.gridy > y) {\n            // ticket 86645\n            gd.gridy--;\n          }\n        }\n      }\n    }\n    //\n    this.cols = usedCols.size();\n    this.rows = usedRows.size();\n\n    $.log.isTraceEnabled() && $.log.trace('(LogicalGridLayoutInfo#CTOR) $components.length=' + this.$components.length + ' usedCols=' + this.cols + ' usedRows=' + this.rows);\n    this._initializeInfo();\n  }\n\n  _initializeInfo() {\n    let compCount = this.$components.length;\n    let uiHeightElements = [];\n    for (let i = 0; i < compCount; i++) {\n      // cleanup constraints\n      let $comp = this.$components[i];\n      let cons = this.gridDatas[i];\n      if (cons.gridx < 0) {\n        cons.gridx = 0;\n      }\n      if (cons.gridy < 0) {\n        cons.gridy = 0;\n      }\n      if (cons.gridw < 1) {\n        cons.gridw = 1;\n      }\n      if (cons.gridh < 1) {\n        cons.gridh = 1;\n      }\n      if (cons.gridx >= this.cols) {\n        cons.gridx = this.cols - 1;\n      }\n      if (cons.gridy >= this.rows) {\n        cons.gridy = this.rows - 1;\n      }\n      if (cons.gridx + cons.gridw - 1 >= this.cols) {\n        cons.gridw = this.cols - cons.gridx;\n      }\n      if (cons.gridy + cons.gridh >= this.rows) {\n        cons.gridh = this.rows - cons.gridy;\n      }\n\n      // Calculate and cache component size\n      let size = new Dimension(0, 0);\n      if (cons.widthHint > 0) {\n        // Use explicit width hint, if set\n        size.width = cons.widthHint;\n        // eslint-disable-next-line brace-style\n      } else if (cons.useUiWidth || !cons.fillHorizontal) {\n        // Calculate preferred width otherwise\n        // This size is needed by _initializeColumns\n        // But only if really needed by the logical grid layout (because it is expensive)\n        size = this.uiSizeInPixel($comp, cons);\n      }\n      if (cons.heightHint > 0) {\n        // Use explicit height hint, if set\n        size.height = cons.heightHint;\n      } else if (cons.useUiHeight || !cons.fillVertical) {\n        // Otherwise check if preferred height should be calculated.\n        // Don't do it now because because weightX need to be calculated first to get the correct width hints\n        uiHeightElements.push({\n          cons: cons,\n          $comp: $comp,\n          index: i\n        });\n      }\n      this.compSize[i] = size;\n    }\n\n    // Calculate this.width and this.weightX\n    this._initializeColumns();\n\n    if (this.widthOnly) {\n      // Abort here if only width is of interest\n      this.height = arrays.init(this.rows, [0, 0, 0]);\n      return;\n    }\n\n    // Calculate preferred heights using the width hints\n    if (this.widthHint && uiHeightElements.length > 0) {\n      let totalHGap = Math.max(0, (this.cols - 1) * this.hgap);\n      this.widthHints = this.layoutSizes(this.widthHint - totalHGap, this.width, this.weightX);\n    }\n    uiHeightElements.forEach(function(elem) {\n      let $comp = elem.$comp;\n      let cons = elem.cons;\n      let widthHint = this.widthHintForGridData(cons);\n      if (!cons.fillHorizontal) {\n        widthHint = Math.min(widthHint, this.compSize[elem.index].width);\n      }\n      this.compSize[elem.index] = this.uiSizeInPixel($comp, cons, {\n        widthHint: widthHint\n      });\n    }, this);\n\n    // Calculate this.height and this.weightY\n    this._initializeRows();\n  }\n\n  _initializeColumns() {\n    let compSize = this.compSize;\n    let compCount = compSize.length;\n    let prefWidths = arrays.init(this.cols, 0);\n    let fixedWidths = arrays.init(this.cols, false);\n    let i, j, k, prefw, cons;\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridw === 1) {\n        if (cons.widthHint > 0) {\n          prefw = cons.widthHint;\n        } else if (cons.useUiWidth) {\n          prefw = compSize[i].width;\n        } else {\n          prefw = this.logicalWidthInPixel(cons);\n        }\n        prefw = Math.floor(prefw);\n        for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {\n          prefWidths[j] = Math.max(prefWidths[j], prefw);\n          if (cons.weightx === 0) {\n            fixedWidths[j] = true;\n          }\n        }\n      }\n    }\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridw > 1) {\n        let hSpan = cons.gridw;\n        let spanWidth = 0;\n        let distWidth;\n        // pref\n        for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {\n          if (!fixedWidths[j]) {\n            spanWidth += prefWidths[j];\n          }\n        }\n        if (cons.widthHint > 0) {\n          distWidth = cons.widthHint - spanWidth - (hSpan - 1) * this.hgap;\n        } else if (cons.useUiWidth) {\n          distWidth = compSize[i].width - spanWidth - (hSpan - 1) * this.hgap;\n        } else {\n          distWidth = this.logicalWidthInPixel(cons) - spanWidth - (hSpan - 1) * this.hgap;\n        }\n        if (distWidth > 0) {\n          let equalWidth = Math.floor((distWidth + spanWidth) / hSpan);\n          let remainder = (distWidth + spanWidth) % hSpan;\n          let last = -1;\n          for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {\n            last = j;\n            if (!fixedWidths[j]) {\n              prefWidths[j] = Math.max(equalWidth, prefWidths[j]);\n            }\n            if (cons.weightx === 0) {\n              fixedWidths[j] = true;\n            }\n          }\n          if (last > -1) {\n            prefWidths[last] += remainder;\n          }\n        }\n      }\n    }\n\n    let lc = LayoutConstants;\n    for (i = 0; i < this.cols; i++) {\n      this.width[i] = [];\n      if (fixedWidths[i]) {\n        this.width[i][lc.MIN] = prefWidths[i];\n        this.width[i][lc.PREF] = prefWidths[i];\n        this.width[i][lc.MAX] = prefWidths[i];\n      } else {\n        this.width[i][lc.MIN] = 0; // must be exactly 0!\n        this.width[i][lc.PREF] = prefWidths[i];\n        this.width[i][lc.MAX] = 10240;\n      }\n    }\n\n    // averaged column weights, normalized so that sum of weights is equal to\n    // 1.0\n    for (i = 0; i < this.cols; i++) {\n      if (fixedWidths[i]) {\n        this.weightX[i] = 0;\n      } else {\n        let weightSum = 0;\n        let weightCount = 0;\n        for (k = 0; k < compCount; k++) {\n          cons = this.gridDatas[k];\n          if (cons.weightx > 0 && cons.gridx <= i && i <= cons.gridx + cons.gridw - 1) {\n            weightSum += (cons.weightx / cons.gridw);\n            weightCount++;\n          }\n        }\n        this.weightX[i] = (weightCount > 0 ? weightSum / weightCount : 0);\n      }\n    }\n    let sumWeightX = 0;\n    for (i = 0; i < this.cols; i++) {\n      sumWeightX += this.weightX[i];\n    }\n    if (sumWeightX >= 1e-6) {\n      let f = 1.0 / sumWeightX;\n      for (i = 0; i < this.cols; i++) {\n        this.weightX[i] = this.weightX[i] * f;\n      }\n    }\n  }\n\n  _initializeRows() {\n    let compSize = this.compSize;\n    let compCount = compSize.length;\n    let prefHeights = arrays.init(this.rows, 0);\n    let fixedHeights = arrays.init(this.rows, false);\n    let i, j, k, prefh, cons;\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridh === 1) {\n        if (cons.heightHint > 0) {\n          prefh = cons.heightHint;\n        } else if (cons.useUiHeight) {\n          prefh = compSize[i].height;\n        } else {\n          prefh = this.logicalHeightInPixel(cons);\n        }\n        prefh = Math.floor(prefh);\n        for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {\n          prefHeights[j] = Math.max(prefHeights[j], prefh);\n          if (cons.weighty === 0) {\n            fixedHeights[j] = true;\n          }\n        }\n      }\n    }\n    for (i = 0; i < compCount; i++) {\n      cons = this.gridDatas[i];\n      if (cons.gridh > 1) {\n        let vSpan = cons.gridh;\n        let spanHeight = 0;\n        let distHeight;\n        // pref\n        for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {\n          if (!fixedHeights[j]) {\n            spanHeight += prefHeights[j];\n          }\n        }\n        if (cons.heightHint > 0) {\n          distHeight = cons.heightHint - spanHeight - (vSpan - 1) * this.vgap;\n        } else if (cons.useUiHeight) {\n          distHeight = compSize[i].height - spanHeight - (vSpan - 1) * this.vgap;\n        } else {\n          distHeight = this.logicalHeightInPixel(cons) - spanHeight - (vSpan - 1) * this.vgap;\n        }\n        if (distHeight > 0) {\n          let equalHeight = Math.floor((distHeight + spanHeight) / vSpan);\n          let remainder = (distHeight + spanHeight) % vSpan;\n          let last = -1;\n          for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {\n            last = j;\n            if (!fixedHeights[j]) {\n              prefHeights[j] = Math.max(equalHeight, prefHeights[j]);\n            }\n            if (cons.weighty === 0) {\n              fixedHeights[j] = true;\n            }\n          }\n          if (last > -1) {\n            prefHeights[last] += remainder;\n          }\n        }\n      }\n    }\n\n    let lc = LayoutConstants;\n    for (i = 0; i < this.rows; i++) {\n      this.height[i] = [];\n      if (fixedHeights[i]) {\n        this.height[i][lc.MIN] = prefHeights[i];\n        this.height[i][lc.PREF] = prefHeights[i];\n        this.height[i][lc.MAX] = prefHeights[i];\n      } else {\n        this.height[i][lc.MIN] = 0; // must be exactly 0!\n        this.height[i][lc.PREF] = prefHeights[i];\n        this.height[i][lc.MAX] = 10240;\n      }\n    }\n\n    // averaged row weights, normalized so that sum of weights is equal to 1.0\n    for (i = 0; i < this.rows; i++) {\n      if (fixedHeights[i]) {\n        this.weightY[i] = 0;\n      } else {\n        let weightSum = 0;\n        let weightCount = 0;\n        for (k = 0; k < compCount; k++) {\n          cons = this.gridDatas[k];\n          if (cons.weighty > 0 && cons.gridy <= i && i <= cons.gridy + cons.gridh - 1) {\n            weightSum += (cons.weighty / cons.gridh);\n            weightCount++;\n          }\n        }\n        this.weightY[i] = (weightCount > 0 ? weightSum / weightCount : 0);\n      }\n    }\n    let sumWeightY = 0;\n    for (i = 0; i < this.rows; i++) {\n      sumWeightY += this.weightY[i];\n    }\n    if (sumWeightY >= 1e-6) {\n      let f = 1.0 / sumWeightY;\n      for (i = 0; i < this.rows; i++) {\n        this.weightY[i] = this.weightY[i] * f;\n      }\n    }\n  }\n\n  layoutCellBounds(size, insets) {\n    let w = this.layoutSizes(size.width - insets.horizontal() - Math.max(0, (this.cols - 1) * this.hgap), this.width, this.weightX);\n    let h = this.layoutSizes(size.height - insets.vertical() - Math.max(0, (this.rows - 1) * this.vgap), this.height, this.weightY);\n    this.cellBounds = arrays.init(this.rows, null);\n    let y = insets.top,\n      r, x, c;\n    for (r = 0; r < this.rows; r++) {\n      x = insets.left;\n      this.cellBounds[r] = arrays.init(this.cols, null);\n      for (c = 0; c < this.cols; c++) {\n        this.cellBounds[r][c] = new Rectangle(x, y, w[c], h[r]);\n        x += w[c];\n        x += this.hgap;\n      }\n      y += h[r];\n      y += this.vgap;\n    }\n    return this.cellBounds;\n  }\n\n  layoutSizes(targetSize, sizes, weights) {\n    let i;\n    let outSizes = arrays.init(sizes.length, 0);\n    if (targetSize <= 0) {\n      for (i = 0; i < sizes.length; i++) {\n        outSizes[i] = sizes[i][LayoutConstants.MIN];\n      }\n      return outSizes;\n    }\n    let sumSize = 0;\n    let tmpWeight = arrays.init(weights.length, 0.0);\n    let sumWeight = 0;\n    for (i = 0; i < sizes.length; i++) {\n      outSizes[i] = sizes[i][LayoutConstants.PREF];\n      sumSize += outSizes[i];\n      tmpWeight[i] = weights[i];\n      /**\n       * auto correction: if weight is 0 and min / max sizes are NOT equal then\n       * set weight to 1; if weight<eps set it to 0\n       */\n      if (tmpWeight[i] < LayoutConstants.EPS) {\n        if (sizes[i][LayoutConstants.MAX] > sizes[i][LayoutConstants.MIN]) {\n          tmpWeight[i] = 1;\n        } else {\n          tmpWeight[i] = 0;\n        }\n      }\n      sumWeight += tmpWeight[i];\n    }\n    // normalize weights\n    if (sumWeight > 0) {\n      for (i = 0; i < tmpWeight.length; i++) {\n        tmpWeight[i] = tmpWeight[i] / sumWeight;\n      }\n    }\n    let deltaInt = targetSize - sumSize;\n    // expand or shrink\n    if (Math.abs(deltaInt) > 0) {\n      // setup accumulators\n      /* float[] */\n      let accWeight = arrays.init(tmpWeight.length, 0.0);\n      let hasTargets;\n      if (deltaInt > 0) {\n        // expand, if delta is > 0\n        hasTargets = true;\n        while (deltaInt > 0 && hasTargets) {\n          hasTargets = false;\n          for (i = 0; i < outSizes.length && deltaInt > 0; i++) {\n            if (tmpWeight[i] > 0 && outSizes[i] < sizes[i][LayoutConstants.MAX]) {\n              hasTargets = true;\n              accWeight[i] += tmpWeight[i];\n              if (accWeight[i] > 0) {\n                accWeight[i] -= 1;\n                outSizes[i] += 1;\n                deltaInt -= 1;\n              }\n            }\n          }\n        }\n      } else {\n        // shrink, if delta is <= 0\n        hasTargets = true;\n        while (deltaInt < 0 && hasTargets) {\n          hasTargets = false;\n          for (i = 0; i < outSizes.length && deltaInt < 0; i++) {\n            if (tmpWeight[i] > 0 && outSizes[i] > sizes[i][LayoutConstants.MIN]) {\n              hasTargets = true;\n              accWeight[i] += tmpWeight[i];\n              if (accWeight[i] > 0) {\n                accWeight[i] -= 1;\n                outSizes[i] -= 1;\n                deltaInt += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    return outSizes;\n  }\n\n  logicalWidthInPixel(cons) {\n    let gridW = cons.gridw;\n    return (this.columnWidth * gridW) + (this.hgap * Math.max(0, gridW - 1));\n  }\n\n  logicalHeightInPixel(cons) {\n    let gridH = cons.gridh,\n      addition = cons.logicalRowHeightAddition || 0;\n    return (this.rowHeight * gridH) + (this.vgap * Math.max(0, gridH - 1)) + addition;\n  }\n\n  uiSizeInPixel($comp, cons, options) {\n    let htmlComp = HtmlComponent.get($comp);\n    return htmlComp.prefSize(options).add(htmlComp.margins());\n  }\n\n  /**\n   * @returns {number|null} the width hint for the given gridData\n   */\n  widthHintForGridData(gridData) {\n    if (this.widthHints.length === 0) {\n      return null;\n    }\n    let widthHint = (gridData.gridw - 1) * this.hgap;\n    for (let i = gridData.gridx; i < gridData.gridx + gridData.gridw; i++) {\n      widthHint += this.widthHints[i];\n    }\n    return widthHint;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}