{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { filters, focusUtils, graphics, keys, Point, scrollbars } from '../index';\nimport $ from 'jquery';\n\n/**\n * A focus context is associated with a $container, and controls how to focus elements within that $container.\n */\nexport default class FocusContext {\n  constructor($container, focusManager) {\n    this.$container = $container;\n    this.focusManager = focusManager;\n    this.lastValidFocusedElement = null; // variable to store the last valid focus position; used to restore focus once being re-activated.\n    this.focusedElement = null;\n    this.prepared = false;\n\n    // Notice: every listener is installed on $container and not on $field level, except 'remove' listener because it does not bubble.\n    this._keyDownListener = this._onKeyDown.bind(this);\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._focusOutListener = this._onFocusOut.bind(this);\n    this._unfocusableListener = this._onUnfocusable.bind(this);\n    this._removeListener = this._onRemove.bind(this);\n  }\n  ready() {\n    if (this.prepared) {\n      return;\n    }\n    this.$container.on('keydown', this._keyDownListener).on('focusin', this._focusInListener).on('focusout', this._focusOutListener).on('hide disable', this._unfocusableListener);\n    this.prepared = true;\n    if (this.lastValidFocusedElement) {\n      // If a widget requested the focus while focus context was not ready, lastValidFocusedElement is set to that widget but the widget itself is not focused.\n      // -> Ensure that widget is focused\n      this.restoreFocus();\n    }\n  }\n  dispose() {\n    if (!this.prepared) {\n      return;\n    }\n    this.$container.off('keydown', this._keyDownListener).off('focusin', this._focusInListener).off('focusout', this._focusOutListener).off('hide disable', this._unfocusableListener);\n    $(this.focusedElement).off('remove', this._removeListener);\n  }\n\n  /**\n   * Method invoked once a 'keydown' event is fired to control proper tab cycle.\n   */\n  _onKeyDown(event) {\n    if (event.which === keys.TAB) {\n      let activeElement = this.$container.activeElement(true),\n        $focusableElements = this.$container.find(':tabbable:visible'),\n        firstFocusableElement = $focusableElements.first()[0],\n        lastFocusableElement = $focusableElements.last()[0],\n        activeElementIndex = $focusableElements.index(activeElement),\n        focusedElement;\n\n      // Forward Tab\n      if (!event.shiftKey) {\n        // If the last focusable element is focused, or the focus is on the container, set the focus to the first focusable element\n        if (firstFocusableElement && (activeElement === lastFocusableElement || activeElement === this.$container[0])) {\n          $.suppressEvent(event);\n          this.validateAndSetFocus(firstFocusableElement);\n          focusedElement = firstFocusableElement;\n        } else if (activeElementIndex < $focusableElements.length - 1) {\n          focusedElement = $focusableElements.get(activeElementIndex + 1);\n          // Note: event is _not_ suppressed here --> will be handled by browser\n        }\n      } else {\n        // Backward Tab (Shift+TAB)\n        // If the first focusable element is focused, or the focus is on the container, set the focus to the last focusable element\n        if (lastFocusableElement && (activeElement === firstFocusableElement || activeElement === this.$container[0])) {\n          $.suppressEvent(event);\n          this.validateAndSetFocus(lastFocusableElement);\n          focusedElement = lastFocusableElement;\n        } else if (activeElementIndex > 0) {\n          focusedElement = $focusableElements.get(activeElementIndex - 1);\n          // Note: event is _not_ suppressed here --> will be handled by browser\n        }\n      }\n\n      if (!focusedElement) {\n        return;\n      }\n      let $focusableElement = $(focusedElement);\n      $focusableElement.addClass('keyboard-navigation');\n\n      // Check if new focused element is currently visible, otherwise scroll the container\n      let containerBounds = graphics.offsetBounds($focusableElement);\n      let $scrollable = $focusableElement.scrollParent();\n      if (!scrollbars.isLocationInView(new Point(containerBounds.x, containerBounds.y), $scrollable)) {\n        scrollbars.scrollTo($scrollable, $focusableElement);\n      }\n    }\n  }\n\n  /**\n   * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusIn(event) {\n    let $target = $(event.target);\n    $target.on('remove', this._removeListener);\n    this.focusedElement = event.target;\n\n    // Do not update current focus context nor validate focus if target is $entryPoint.\n    // That is because focusing the $entryPoint is done whenever no control is currently focusable, e.g. due to glass panes.\n    if (event.target === this.$container.entryPoint(true)) {\n      return;\n    }\n\n    // Make this context the active context (nothing done if already active) and validate the focus event.\n    this.focusManager._pushIfAbsendElseMoveTop(this);\n    this.validateAndSetFocus(event.target);\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n  }\n\n  /**\n   * Method invoked once a 'focusout' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusOut(event) {\n    $(event.target).off('remove', this._removeListener);\n    $(this.focusedElement).removeClass('keyboard-navigation');\n    this.focusedElement = null;\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n  }\n\n  /**\n   * Method invoked once a child element of this context's $container is removed.\n   */\n  _onRemove(event) {\n    // This listener is installed on the focused element only.\n    this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n  }\n\n  /**\n   * Function invoked once a child element of this context's $container is hidden or disabled\n   * and it cannot have the focus anymore. In that case we need to look for a new focusable\n   * element.\n   */\n  _onUnfocusable(event) {\n    if ($(event.target).isOrHas(this.lastValidFocusedElement)) {\n      this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n      event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n    }\n  }\n\n  /**\n   * Focuses the given element if being a child of this context's container and matches the given filter (if provided).\n   *\n   * @param {HTMLElement|$} [element]\n   *        the element to focus, or null to focus the context's first focusable element matching the given filter.\n   * @param {function} [filter]\n   *        filter that controls which element should be focused, or null to accept all focusable candidates.\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   */\n  validateAndSetFocus(element, filter, options) {\n    // Ensure the element to be a child element, or set it to null otherwise.\n    if (element && !$.contains(this.$container[0], element)) {\n      element = null;\n    }\n    let elementToFocus = null;\n    if (!element) {\n      elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n    } else if (!filter || filter.call(element)) {\n      elementToFocus = element;\n    } else {\n      elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n    }\n\n    // Store the element to be focused, and regardless of whether currently covert by a glass pane or the focus manager is not active. That is for later focus restore.\n    this.lastValidFocusedElement = elementToFocus;\n\n    // Focus the element.\n    this._focus(elementToFocus, options);\n  }\n\n  /**\n   * Calls {@link #validateAndSetFocus} with {@link #lastValidFocusedElement}.\n   */\n  validateFocus(filter) {\n    this.validateAndSetFocus(this.lastValidFocusedElement, filter);\n  }\n\n  /**\n   * Restores the focus on the last valid focused element. Does nothing, if there is no last valid focused element.\n   */\n  restoreFocus() {\n    if (this.lastValidFocusedElement) {\n      this._focus(this.lastValidFocusedElement);\n    }\n  }\n\n  /**\n   * Focuses the requested element.\n   *\n   * @param {HTMLElement} element\n   *        the element to focus, or null to focus the context's first focusable element matching the given filter.\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   */\n  _focus(elementToFocus, options) {\n    options = options || {};\n    // Only focus element if focus manager is active\n    if (!this.focusManager.active) {\n      return;\n    }\n    if (!this.prepared) {\n      return;\n    }\n\n    // Check whether the element is covert by a glasspane\n    if (this.focusManager.isElementCovertByGlassPane(elementToFocus)) {\n      let activeElement = this.$container.activeElement(true);\n      if (elementToFocus && (!activeElement || !this.focusManager.isElementCovertByGlassPane(activeElement))) {\n        // If focus should be removed (blur), don't break here and try to focus the root element\n        // Otherwise, if desired element cannot be focused then break and leave the focus where it is, unless the currently focused element is covered by a glass pane\n        return false;\n      }\n      elementToFocus = null;\n    }\n\n    // Focus $entryPoint if current focus is to be blurred.\n    // Otherwise, the HTML body would be focused which makes global keystrokes (like backspace) not to work anymore.\n    elementToFocus = elementToFocus || this.$container.entryPoint(true);\n\n    // If element may not be focused (example SVG element in IE) -> use the entryPoint as fallback\n    // $elementToFocus.focus() would trigger a focus event even the element won't be focused -> loop\n    // In that case the focus function does not exist on the svg element\n    if (!elementToFocus.focus) {\n      elementToFocus = this.$container.entryPoint(true);\n    }\n\n    // Only focus element if different to current focused element\n    if (focusUtils.isActiveElement(elementToFocus)) {\n      return;\n    }\n\n    // Focus the requested element\n    elementToFocus.focus({\n      preventScroll: scout.nvl(options.preventScroll, false)\n    });\n    $.log.isDebugEnabled() && $.log.debug('Focus set to ' + graphics.debugOutput(elementToFocus));\n  }\n}","map":{"version":3,"names":["filters","focusUtils","graphics","keys","Point","scrollbars","$","FocusContext","constructor","$container","focusManager","lastValidFocusedElement","focusedElement","prepared","_keyDownListener","_onKeyDown","bind","_focusInListener","_onFocusIn","_focusOutListener","_onFocusOut","_unfocusableListener","_onUnfocusable","_removeListener","_onRemove","ready","on","restoreFocus","dispose","off","event","which","TAB","activeElement","$focusableElements","find","firstFocusableElement","first","lastFocusableElement","last","activeElementIndex","index","shiftKey","suppressEvent","validateAndSetFocus","length","get","$focusableElement","addClass","containerBounds","offsetBounds","$scrollable","scrollParent","isLocationInView","x","y","scrollTo","$target","target","entryPoint","_pushIfAbsendElseMoveTop","stopPropagation","removeClass","notSameFilter","isOrHas","element","filter","options","contains","elementToFocus","findFirstFocusableElement","call","_focus","validateFocus","active","isElementCovertByGlassPane","focus","isActiveElement","preventScroll","scout","nvl","log","isDebugEnabled","debug","debugOutput"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/focus/FocusContext.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {filters, focusUtils, graphics, keys, Point, scrollbars} from '../index';\nimport $ from 'jquery';\n\n/**\n * A focus context is associated with a $container, and controls how to focus elements within that $container.\n */\nexport default class FocusContext {\n\n  constructor($container, focusManager) {\n    this.$container = $container;\n    this.focusManager = focusManager;\n\n    this.lastValidFocusedElement = null; // variable to store the last valid focus position; used to restore focus once being re-activated.\n    this.focusedElement = null;\n    this.prepared = false;\n\n    // Notice: every listener is installed on $container and not on $field level, except 'remove' listener because it does not bubble.\n    this._keyDownListener = this._onKeyDown.bind(this);\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._focusOutListener = this._onFocusOut.bind(this);\n    this._unfocusableListener = this._onUnfocusable.bind(this);\n    this._removeListener = this._onRemove.bind(this);\n  }\n\n  ready() {\n    if (this.prepared) {\n      return;\n    }\n    this.$container\n      .on('keydown', this._keyDownListener)\n      .on('focusin', this._focusInListener)\n      .on('focusout', this._focusOutListener)\n      .on('hide disable', this._unfocusableListener);\n    this.prepared = true;\n\n    if (this.lastValidFocusedElement) {\n      // If a widget requested the focus while focus context was not ready, lastValidFocusedElement is set to that widget but the widget itself is not focused.\n      // -> Ensure that widget is focused\n      this.restoreFocus();\n    }\n  }\n\n  dispose() {\n    if (!this.prepared) {\n      return;\n    }\n    this.$container\n      .off('keydown', this._keyDownListener)\n      .off('focusin', this._focusInListener)\n      .off('focusout', this._focusOutListener)\n      .off('hide disable', this._unfocusableListener);\n    $(this.focusedElement).off('remove', this._removeListener);\n  }\n\n  /**\n   * Method invoked once a 'keydown' event is fired to control proper tab cycle.\n   */\n  _onKeyDown(event) {\n    if (event.which === keys.TAB) {\n      let activeElement = this.$container.activeElement(true),\n        $focusableElements = this.$container.find(':tabbable:visible'),\n        firstFocusableElement = $focusableElements.first()[0],\n        lastFocusableElement = $focusableElements.last()[0],\n        activeElementIndex = $focusableElements.index(activeElement),\n        focusedElement;\n\n      // Forward Tab\n      if (!event.shiftKey) {\n        // If the last focusable element is focused, or the focus is on the container, set the focus to the first focusable element\n        if (firstFocusableElement && (activeElement === lastFocusableElement || activeElement === this.$container[0])) {\n          $.suppressEvent(event);\n          this.validateAndSetFocus(firstFocusableElement);\n          focusedElement = firstFocusableElement;\n        } else if (activeElementIndex < $focusableElements.length - 1) {\n          focusedElement = $focusableElements.get(activeElementIndex + 1);\n          // Note: event is _not_ suppressed here --> will be handled by browser\n        }\n      } else { // Backward Tab (Shift+TAB)\n        // If the first focusable element is focused, or the focus is on the container, set the focus to the last focusable element\n        if (lastFocusableElement && (activeElement === firstFocusableElement || activeElement === this.$container[0])) {\n          $.suppressEvent(event);\n          this.validateAndSetFocus(lastFocusableElement);\n          focusedElement = lastFocusableElement;\n        } else if (activeElementIndex > 0) {\n          focusedElement = $focusableElements.get(activeElementIndex - 1);\n          // Note: event is _not_ suppressed here --> will be handled by browser\n        }\n      }\n      if (!focusedElement) {\n        return;\n      }\n\n      let $focusableElement = $(focusedElement);\n      $focusableElement.addClass('keyboard-navigation');\n\n      // Check if new focused element is currently visible, otherwise scroll the container\n      let containerBounds = graphics.offsetBounds($focusableElement);\n      let $scrollable = $focusableElement.scrollParent();\n      if (!scrollbars.isLocationInView(new Point(containerBounds.x, containerBounds.y), $scrollable)) {\n        scrollbars.scrollTo($scrollable, $focusableElement);\n      }\n    }\n  }\n\n  /**\n   * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusIn(event) {\n    let $target = $(event.target);\n    $target.on('remove', this._removeListener);\n    this.focusedElement = event.target;\n\n    // Do not update current focus context nor validate focus if target is $entryPoint.\n    // That is because focusing the $entryPoint is done whenever no control is currently focusable, e.g. due to glass panes.\n    if (event.target === this.$container.entryPoint(true)) {\n      return;\n    }\n\n    // Make this context the active context (nothing done if already active) and validate the focus event.\n    this.focusManager._pushIfAbsendElseMoveTop(this);\n    this.validateAndSetFocus(event.target);\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n  }\n\n  /**\n   * Method invoked once a 'focusout' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusOut(event) {\n    $(event.target).off('remove', this._removeListener);\n    $(this.focusedElement).removeClass('keyboard-navigation');\n    this.focusedElement = null;\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n  }\n\n  /**\n   * Method invoked once a child element of this context's $container is removed.\n   */\n  _onRemove(event) {\n    // This listener is installed on the focused element only.\n    this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n  }\n\n  /**\n   * Function invoked once a child element of this context's $container is hidden or disabled\n   * and it cannot have the focus anymore. In that case we need to look for a new focusable\n   * element.\n   */\n  _onUnfocusable(event) {\n    if ($(event.target).isOrHas(this.lastValidFocusedElement)) {\n      this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n      event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n    }\n  }\n\n  /**\n   * Focuses the given element if being a child of this context's container and matches the given filter (if provided).\n   *\n   * @param {HTMLElement|$} [element]\n   *        the element to focus, or null to focus the context's first focusable element matching the given filter.\n   * @param {function} [filter]\n   *        filter that controls which element should be focused, or null to accept all focusable candidates.\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   */\n  validateAndSetFocus(element, filter, options) {\n    // Ensure the element to be a child element, or set it to null otherwise.\n    if (element && !$.contains(this.$container[0], element)) {\n      element = null;\n    }\n\n    let elementToFocus = null;\n    if (!element) {\n      elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n    } else if (!filter || filter.call(element)) {\n      elementToFocus = element;\n    } else {\n      elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n    }\n\n    // Store the element to be focused, and regardless of whether currently covert by a glass pane or the focus manager is not active. That is for later focus restore.\n    this.lastValidFocusedElement = elementToFocus;\n\n    // Focus the element.\n    this._focus(elementToFocus, options);\n  }\n\n  /**\n   * Calls {@link #validateAndSetFocus} with {@link #lastValidFocusedElement}.\n   */\n  validateFocus(filter) {\n    this.validateAndSetFocus(this.lastValidFocusedElement, filter);\n  }\n\n  /**\n   * Restores the focus on the last valid focused element. Does nothing, if there is no last valid focused element.\n   */\n  restoreFocus() {\n    if (this.lastValidFocusedElement) {\n      this._focus(this.lastValidFocusedElement);\n    }\n  }\n\n  /**\n   * Focuses the requested element.\n   *\n   * @param {HTMLElement} element\n   *        the element to focus, or null to focus the context's first focusable element matching the given filter.\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   */\n  _focus(elementToFocus, options) {\n    options = options || {};\n    // Only focus element if focus manager is active\n    if (!this.focusManager.active) {\n      return;\n    }\n    if (!this.prepared) {\n      return;\n    }\n\n    // Check whether the element is covert by a glasspane\n    if (this.focusManager.isElementCovertByGlassPane(elementToFocus)) {\n      let activeElement = this.$container.activeElement(true);\n      if (elementToFocus && (!activeElement || !this.focusManager.isElementCovertByGlassPane(activeElement))) {\n        // If focus should be removed (blur), don't break here and try to focus the root element\n        // Otherwise, if desired element cannot be focused then break and leave the focus where it is, unless the currently focused element is covered by a glass pane\n        return false;\n      }\n      elementToFocus = null;\n    }\n\n    // Focus $entryPoint if current focus is to be blurred.\n    // Otherwise, the HTML body would be focused which makes global keystrokes (like backspace) not to work anymore.\n    elementToFocus = elementToFocus || this.$container.entryPoint(true);\n\n    // If element may not be focused (example SVG element in IE) -> use the entryPoint as fallback\n    // $elementToFocus.focus() would trigger a focus event even the element won't be focused -> loop\n    // In that case the focus function does not exist on the svg element\n    if (!elementToFocus.focus) {\n      elementToFocus = this.$container.entryPoint(true);\n    }\n\n    // Only focus element if different to current focused element\n    if (focusUtils.isActiveElement(elementToFocus)) {\n      return;\n    }\n\n    // Focus the requested element\n    elementToFocus.focus({\n      preventScroll: scout.nvl(options.preventScroll, false)\n    });\n\n    $.log.isDebugEnabled() && $.log.debug('Focus set to ' + graphics.debugOutput(elementToFocus));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}