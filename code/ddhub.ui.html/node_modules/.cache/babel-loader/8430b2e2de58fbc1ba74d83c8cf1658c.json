{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Device, FormField, scout, strings, TabItem, widgets } from '../../index';\n\n/**\n * @param $parent used to determine which HTML document is used to create the new HTML element\n * @returns an INPUT element as used in Scout forms.\n */\nexport function makeTextField($parent, cssClass) {\n  return $parent.makeElement('<input>', cssClass).attr('type', 'text').attr('autocomplete', 'NoAutocomplete') /* off and false are currently ignored in Chrome */.disableSpellcheck();\n}\nexport function appendIcon($field, cssClass) {\n  /*\n   * Note: the field usually does $field.focus() when the icon is clicked.\n   * Unfocusable is required because when the icon is clicked the browser is in the middle of setting\n   * a new focus target, so we cannot simply change the focus target, because at the end the wrong target would be\n   * focused and the popup would be closed immediately. With 'unfocusable' the focus manager will prevent the default focus\n   */\n  let $icon = $field.appendSpan('icon unfocusable text-field-icon');\n  if (cssClass) {\n    $icon.addClass(cssClass);\n  }\n  return $icon;\n}\nexport function initTouch(field, model) {\n  field.embedded = scout.nvl(model.embedded, false);\n  // when 'touchMode' is not set explicitly, check the device\n  field.touchMode = scout.nvl(model.touchMode, Device.get().supportsOnlyTouch());\n}\n\n/**\n * Calls JQuery $.text() for touch-devices and $.val() for all other devices, used together with #makeInputOrDiv().\n * Works as setter when called with 2 arguments, works a getter when called with 1 arguments.\n *\n * @return when called with 1 argument: $field.text() or $field.val()\n */\nexport function valOrText($field, text) {\n  let isDiv = $field.is('div');\n  if (arguments.length === 2) {\n    if (isDiv) {\n      $field.text(text);\n    } else {\n      $field.val(text);\n    }\n  } else {\n    return isDiv ? $field.text() : $field.val();\n  }\n}\n\n/**\n * Creates a DIV element for touch-devices and an INPUT element for all other devices,\n * depending on the touch flag of the given field.\n *\n * @param {FormField} field\n * @param {string} [cssClass]\n */\nexport function makeInputOrDiv(field, cssClass) {\n  if (field.touchMode) {\n    return makeInputDiv(field, cssClass);\n  }\n  return makeTextField(field.$container, cssClass);\n}\n\n/**\n * Creates a DIV element that looks like an INPUT element.\n *\n * @param {FormField} field\n * @param {string} [cssClass]\n */\nexport function makeInputDiv(field, cssClass) {\n  return field.$container.makeDiv(strings.join(' ', 'input-field', cssClass));\n}\n\n// note: the INPUT element does not process the click event when the field is disabled\n// however, the DIV element used in touch-mode does process the event anyway, that's\n// why this check is required.\nexport function handleOnClick(field) {\n  return field.enabledComputed && !field.embedded && !field.popup;\n}\n\n/**\n * Calls activate() on the first focusable field of the given fields. Does nothing if the widget is disabled or not rendered.\n *\n * @param {Widget} field\n * @param {FormField[]} fields\n */\nexport function activateFirstField(widget, fields) {\n  let firstField = widgets.findFirstFocusableWidget(fields, widget);\n  if (firstField) {\n    firstField.activate();\n  }\n}\n\n/**\n * Links the given element with the given label by setting aria-labelledby.<br>\n * This allows screen readers to build a catalog of the elements on the screen and their relationships, for example, to read the label when the input is focused.\n */\nexport function linkElementWithLabel($elem, $label) {\n  let labelId = $label.attr('id');\n  if (!labelId) {\n    // Create an id if the element does not have one yet\n    labelId = widgets.createUniqueId('lbl');\n    $label.attr('id', labelId);\n  }\n  let labelledBy = $elem.attr('aria-labelledby') || '';\n  if (labelledBy) {\n    // Add to the existing value if there is one\n    labelId += ' ' + labelledBy;\n  }\n  $elem.attr('aria-labelledby', labelId);\n}\n\n/**\n * @param field a ValueField which works like a Proposal- or SmartField. The field must have a property <i>popup</i> and\n *     a <i>_tooltip</i> function.\n * @param target\n * @returns {boolean} Whether or not the target is on the field (including popup and tooltip)\n */\nexport function eventOutsideProposalField(field, target) {\n  let eventOnField = safeIsOrHas(field.$field, target) || safeIsOrHas(field.$icon, target) || safeIsOrHas(field.$clearIcon, target);\n  let eventOnPopup = safeWidgetIsOrHas(field.popup, target);\n  let eventOnTooltip = safeWidgetIsOrHas(field._tooltip(), target);\n  return !eventOnField && !eventOnPopup && !eventOnTooltip;\n  function safeIsOrHas($elem, target) {\n    return $elem && $elem.isOrHas(target);\n  }\n  function safeWidgetIsOrHas(widget, target) {\n    return widget && widget.rendered && widget.$container.isOrHas(target);\n  }\n}\n\n/**\n * Selects the tab containing the given {@link FormField} for all parent tabBoxes.\n * This ensures that the given field could be seen (if visible itself).\n *\n * @param {FormField} field The field whose parent tabs should be selected.\n */\nexport function selectAllParentTabsOf(field) {\n  if (!field || !(field instanceof FormField)) {\n    return;\n  }\n  field.visitParentFields(selectIfIsTab);\n}\n\n/**\n * Selects the given tabItem if it is a {@link TabItem}.\n *\n * @param {TabItem} tabItem The tab to be selected.\n */\nexport function selectIfIsTab(tabItem) {\n  if (!tabItem || !(tabItem instanceof TabItem)) {\n    return;\n  }\n  tabItem.select(tabItem);\n}\n\n/**\n * Toggles FormField.statusPosition based on the given predicate in order to enlarge or reset the box header line while scrolling.\n * The header line is enlarged to match the width of the scroll shadow.\n * @param {GroupBox|TabBox} box\n * @param {function} predicate\n */\nexport function adjustStatusPositionForScrollShadow(box, predicate) {\n  if (box.htmlComp) {\n    // Suppress layout invalidation to prevent dialogs from resetting the height.\n    // The box itself must not change its size while scrolling anyway, so there is no need to propagate the invalidation.\n    box.htmlComp.suppressInvalidate = true;\n  }\n  if (predicate()) {\n    widgets.preserveAndSetProperty(() => box.setStatusPosition(FormField.StatusPosition.TOP), () => box.statusPosition, box, '_statusPositionOrig');\n  } else {\n    widgets.resetProperty(preservedValue => box.setStatusPosition(preservedValue), box, '_statusPositionOrig');\n  }\n  if (box.htmlComp) {\n    box.htmlComp.suppressInvalidate = false;\n  }\n}\nexport default {\n  activateFirstField,\n  appendIcon,\n  eventOutsideProposalField,\n  handleOnClick,\n  initTouch,\n  linkElementWithLabel,\n  makeInputDiv,\n  makeInputOrDiv,\n  makeTextField,\n  selectAllParentTabsOf,\n  selectIfIsTab,\n  valOrText,\n  adjustStatusPositionForScrollShadow\n};","map":{"version":3,"names":["Device","FormField","scout","strings","TabItem","widgets","makeTextField","$parent","cssClass","makeElement","attr","disableSpellcheck","appendIcon","$field","$icon","appendSpan","addClass","initTouch","field","model","embedded","nvl","touchMode","get","supportsOnlyTouch","valOrText","text","isDiv","is","arguments","length","val","makeInputOrDiv","makeInputDiv","$container","makeDiv","join","handleOnClick","enabledComputed","popup","activateFirstField","widget","fields","firstField","findFirstFocusableWidget","activate","linkElementWithLabel","$elem","$label","labelId","createUniqueId","labelledBy","eventOutsideProposalField","target","eventOnField","safeIsOrHas","$clearIcon","eventOnPopup","safeWidgetIsOrHas","eventOnTooltip","_tooltip","isOrHas","rendered","selectAllParentTabsOf","visitParentFields","selectIfIsTab","tabItem","select","adjustStatusPositionForScrollShadow","box","predicate","htmlComp","suppressInvalidate","preserveAndSetProperty","setStatusPosition","StatusPosition","TOP","statusPosition","resetProperty","preservedValue"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/fields.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Device, FormField, scout, strings, TabItem, widgets} from '../../index';\n\n/**\n * @param $parent used to determine which HTML document is used to create the new HTML element\n * @returns an INPUT element as used in Scout forms.\n */\nexport function makeTextField($parent, cssClass) {\n  return $parent.makeElement('<input>', cssClass)\n    .attr('type', 'text')\n    .attr('autocomplete', 'NoAutocomplete') /* off and false are currently ignored in Chrome */\n    .disableSpellcheck();\n}\n\nexport function appendIcon($field, cssClass) {\n  /*\n   * Note: the field usually does $field.focus() when the icon is clicked.\n   * Unfocusable is required because when the icon is clicked the browser is in the middle of setting\n   * a new focus target, so we cannot simply change the focus target, because at the end the wrong target would be\n   * focused and the popup would be closed immediately. With 'unfocusable' the focus manager will prevent the default focus\n   */\n  let $icon = $field.appendSpan('icon unfocusable text-field-icon');\n  if (cssClass) {\n    $icon.addClass(cssClass);\n  }\n  return $icon;\n}\n\nexport function initTouch(field, model) {\n  field.embedded = scout.nvl(model.embedded, false);\n  // when 'touchMode' is not set explicitly, check the device\n  field.touchMode = scout.nvl(model.touchMode, Device.get().supportsOnlyTouch());\n}\n\n/**\n * Calls JQuery $.text() for touch-devices and $.val() for all other devices, used together with #makeInputOrDiv().\n * Works as setter when called with 2 arguments, works a getter when called with 1 arguments.\n *\n * @return when called with 1 argument: $field.text() or $field.val()\n */\nexport function valOrText($field, text) {\n  let isDiv = $field.is('div');\n  if (arguments.length === 2) {\n    if (isDiv) {\n      $field.text(text);\n    } else {\n      $field.val(text);\n    }\n  } else {\n    return isDiv ? $field.text() : $field.val();\n  }\n}\n\n/**\n * Creates a DIV element for touch-devices and an INPUT element for all other devices,\n * depending on the touch flag of the given field.\n *\n * @param {FormField} field\n * @param {string} [cssClass]\n */\nexport function makeInputOrDiv(field, cssClass) {\n  if (field.touchMode) {\n    return makeInputDiv(field, cssClass);\n  }\n  return makeTextField(field.$container, cssClass);\n}\n\n/**\n * Creates a DIV element that looks like an INPUT element.\n *\n * @param {FormField} field\n * @param {string} [cssClass]\n */\nexport function makeInputDiv(field, cssClass) {\n  return field.$container.makeDiv(strings.join(' ', 'input-field', cssClass));\n}\n\n// note: the INPUT element does not process the click event when the field is disabled\n// however, the DIV element used in touch-mode does process the event anyway, that's\n// why this check is required.\nexport function handleOnClick(field) {\n  return field.enabledComputed && !field.embedded && !field.popup;\n}\n\n/**\n * Calls activate() on the first focusable field of the given fields. Does nothing if the widget is disabled or not rendered.\n *\n * @param {Widget} field\n * @param {FormField[]} fields\n */\nexport function activateFirstField(widget, fields) {\n  let firstField = widgets.findFirstFocusableWidget(fields, widget);\n  if (firstField) {\n    firstField.activate();\n  }\n}\n\n/**\n * Links the given element with the given label by setting aria-labelledby.<br>\n * This allows screen readers to build a catalog of the elements on the screen and their relationships, for example, to read the label when the input is focused.\n */\nexport function linkElementWithLabel($elem, $label) {\n  let labelId = $label.attr('id');\n  if (!labelId) {\n    // Create an id if the element does not have one yet\n    labelId = widgets.createUniqueId('lbl');\n    $label.attr('id', labelId);\n  }\n  let labelledBy = $elem.attr('aria-labelledby') || '';\n  if (labelledBy) {\n    // Add to the existing value if there is one\n    labelId += ' ' + labelledBy;\n  }\n  $elem.attr('aria-labelledby', labelId);\n}\n\n/**\n * @param field a ValueField which works like a Proposal- or SmartField. The field must have a property <i>popup</i> and\n *     a <i>_tooltip</i> function.\n * @param target\n * @returns {boolean} Whether or not the target is on the field (including popup and tooltip)\n */\nexport function eventOutsideProposalField(field, target) {\n  let eventOnField =\n    safeIsOrHas(field.$field, target) ||\n    safeIsOrHas(field.$icon, target) ||\n    safeIsOrHas(field.$clearIcon, target);\n  let eventOnPopup = safeWidgetIsOrHas(field.popup, target);\n  let eventOnTooltip = safeWidgetIsOrHas(field._tooltip(), target);\n\n  return !eventOnField && !eventOnPopup && !eventOnTooltip;\n\n  function safeIsOrHas($elem, target) {\n    return $elem && $elem.isOrHas(target);\n  }\n\n  function safeWidgetIsOrHas(widget, target) {\n    return widget && widget.rendered && widget.$container.isOrHas(target);\n  }\n}\n\n/**\n * Selects the tab containing the given {@link FormField} for all parent tabBoxes.\n * This ensures that the given field could be seen (if visible itself).\n *\n * @param {FormField} field The field whose parent tabs should be selected.\n */\nexport function selectAllParentTabsOf(field) {\n  if (!field || !(field instanceof FormField)) {\n    return;\n  }\n  field.visitParentFields(selectIfIsTab);\n}\n\n/**\n * Selects the given tabItem if it is a {@link TabItem}.\n *\n * @param {TabItem} tabItem The tab to be selected.\n */\nexport function selectIfIsTab(tabItem) {\n  if (!tabItem || !(tabItem instanceof TabItem)) {\n    return;\n  }\n  tabItem.select(tabItem);\n}\n\n/**\n * Toggles FormField.statusPosition based on the given predicate in order to enlarge or reset the box header line while scrolling.\n * The header line is enlarged to match the width of the scroll shadow.\n * @param {GroupBox|TabBox} box\n * @param {function} predicate\n */\nexport function adjustStatusPositionForScrollShadow(box, predicate) {\n  if (box.htmlComp) {\n    // Suppress layout invalidation to prevent dialogs from resetting the height.\n    // The box itself must not change its size while scrolling anyway, so there is no need to propagate the invalidation.\n    box.htmlComp.suppressInvalidate = true;\n  }\n  if (predicate()) {\n    widgets.preserveAndSetProperty(() => box.setStatusPosition(FormField.StatusPosition.TOP), () => box.statusPosition, box, '_statusPositionOrig');\n  } else {\n    widgets.resetProperty(preservedValue => box.setStatusPosition(preservedValue), box, '_statusPositionOrig');\n  }\n  if (box.htmlComp) {\n    box.htmlComp.suppressInvalidate = false;\n  }\n}\n\nexport default {\n  activateFirstField,\n  appendIcon,\n  eventOutsideProposalField,\n  handleOnClick,\n  initTouch,\n  linkElementWithLabel,\n  makeInputDiv,\n  makeInputOrDiv,\n  makeTextField,\n  selectAllParentTabsOf,\n  selectIfIsTab,\n  valOrText,\n  adjustStatusPositionForScrollShadow\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}