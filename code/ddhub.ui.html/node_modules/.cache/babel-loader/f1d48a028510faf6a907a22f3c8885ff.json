{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { DateFormatPatternDefinition, DateFormatPatternType, dates, numbers, objects, scout, strings } from '../index';\n\n/**\n * Custom JavaScript Date Format\n *\n * Support for formatting and parsing dates based on a pattern string and some locale\n * information from the server model. A subset of the standard Java pattern strings\n * (see SimpleDateFormat) with the most commonly used patterns is supported.\n *\n * This object only operates on the local time zone.\n * <p>\n * locale.dateFormatSymbols contains:\n * <ul>\n * <li>weekdays start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>weekdaysShort start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>months start with January</li>\n * <li>monthsShort start with January<7li>\n * <li>am</li>\n * <li>pm</li>\n *</ul>\n *\n * @see http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n */\nexport default class DateFormat {\n  constructor(locale, pattern, options) {\n    // NOSONAR\n    options = options || {};\n\n    /* jshint sub:true */\n    this.locale = locale;\n    scout.assertParameter('locale', this.locale);\n    this.pattern = pattern || locale.dateFormatPatternDefault;\n    scout.assertParameter('pattern', this.pattern);\n    this.symbols = locale.dateFormatSymbols;\n    this.symbols.firstDayOfWeek = 1; // monday // TODO [7.0] cgu: deliver from server\n    this.symbols.weekdaysOrdered = dates.orderWeekdays(this.symbols.weekdays, this.symbols.firstDayOfWeek);\n    this.symbols.weekdaysShortOrdered = dates.orderWeekdays(this.symbols.weekdaysShort, this.symbols.firstDayOfWeek);\n    this.symbols.monthsToNumber;\n    this.symbols.monthsShortToNumber;\n\n    // Relevant during analyze(). When this is true (default), terms of the same \"pattern type\" (e.g. \"d\" and \"dd\") will\n    // also be considered. Otherwise, analyze() behaves like parse(), i.g. the pattern must match exactly.\n    // Example: \"2.10\" will match the pattern \"dd.MM.yyy\" when lenient=true. If lenient is false, it won't match.\n    this.lenient = scout.nvl(options.lenient, true);\n\n    // List of terms, e.g. split up parts of this.pattern. The length of this array is equal\n    // to the length of this._formatFunctions, this._parseFunctions and this._analyzeFunctions.\n    this._terms = [];\n\n    // List of format function to be called _in that exact order_ to convert this.pattern\n    // to a formatted date string (by sequentially replacing all terms with real values).\n    this._formatFunctions = [];\n\n    // List of parse functions to be called _in that exact order_ to convert an input\n    // string to a valid JavaScript Date object. This order matches the recognized terms\n    // in the pattern. Unrecognized terms are represented by a \"constant\" function that\n    // matches the string itself (e.g. separator characters or spaces).\n    this._parseFunctions = [];\n\n    // Array of arrays, same order as _parseFunctions, but term functions are a list of term functions (to support lenient parsing)\n    this._analyzeFunctions = [];\n\n    // Build a list of all pattern definitions. This list is then used to build the list of\n    // format, parse and analyze functions according to this.pattern.\n    //\n    // !!! PLEASE NOTE !!!\n    // The order of these definitions is important! For each term in the pattern, the list\n    // is scanned from the beginning until a definition accepts the term. If the wrong\n    // definition was picked, results would be unpredictable.\n    //\n    // Following the following rules ensures that the algorithm can pick the best matching\n    // pattern format definition for each term in the pattern:\n    // - Sort definitions by time span, from large (year) to small (milliseconds).\n    // - Two definitions of the same type should be sorted by term length, from long\n    //   (e.g. MMMM) to short (e.g. M).\n    this._patternDefinitions = [\n    // --- Year ---\n    // This definition can _format_ dates with years with 4 or more digits.\n    // See: http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n    //      chapter 'Date and Time Patterns', paragraph 'Year'\n    // We do not allow to _parse_ a date with 5 or more digits. We could allow that in a\n    // future release, but it could have an impact on backend logic, databases, etc.\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.YEAR,\n      terms: ['yyyy'],\n      // meaning: any number of digits is allowed\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => {\n        let year = formatContext.inputDate.getFullYear();\n        let numDigits = Math.max(4, year.toString().length); // min. digits = 4\n        return strings.padZeroLeft(formatContext.inputDate.getFullYear(), numDigits).slice(-numDigits);\n      },\n      parseRegExp: /^(\\d{4})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.matchInfo.year = match;\n        parseContext.dateInfo.year = Number(match);\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.YEAR,\n      terms: ['yyy', 'yy', 'y'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => {\n        let year = String(formatContext.inputDate.getFullYear());\n        let length = formatContext.exactLength ? acceptedTerm.length : 2;\n        if (length === 1) {\n          // Return max. 2 digits, no leading zero\n          return year.slice(-length);\n        }\n        // Return max. 2 digits with zero padding\n        return strings.padZeroLeft(year, length).slice(-length);\n      },\n      parseRegExp: /^(\\d{1,3})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        if (match.length === 3) {\n          parseContext.dateInfo.year = Number(match);\n          parseContext.matchInfo.year = match;\n          return;\n        }\n        let startYear = (parseContext.startDate || new Date()).getFullYear();\n        // Construct a new year using the startYear's century and the entered 'short year'\n        let year = Number(strings.padZeroLeft(startYear, 4).substr(0, 2) + strings.padZeroLeft(match, 2));\n        // Ensure max. 50 years distance between 'startYear' and 'year'\n        let distance = year - startYear;\n        if (distance <= -50) {\n          year += 100;\n        } else if (distance > 50) {\n          year -= 100;\n        }\n        parseContext.dateInfo.year = year;\n        parseContext.matchInfo.year = match;\n      }\n    }),\n    // --- Month ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['MMMM'],\n      dateFormat: this,\n      formatFunction: function (formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.months[formatContext.inputDate.getMonth()];\n      },\n      parseFunction: function (parseContext, acceptedTerm) {\n        let i, symbol, re, m;\n        for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n          symbol = this.dateFormat.symbols.months[i];\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n          if (m) {\n            // match found\n            parseContext.dateInfo.month = i;\n            parseContext.matchInfo.month = m[1];\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        }\n        // No match found so far. In analyze mode, check prefixes.\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n            symbol = this.dateFormat.symbols.months[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n            if (m) {\n              // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = symbol;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['MMM'],\n      dateFormat: this,\n      formatFunction: function (formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.monthsShort[formatContext.inputDate.getMonth()];\n      },\n      parseFunction: function (parseContext, acceptedTerm) {\n        let i, symbol, re, m;\n        for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n          symbol = this.dateFormat.symbols.monthsShort[i];\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n          if (m) {\n            // match found\n            parseContext.dateInfo.month = i;\n            parseContext.matchInfo.month = m[1];\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        }\n        // No match found so far. In analyze mode, check prefixes.\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n            symbol = this.dateFormat.symbols.monthsShort[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n            if (m) {\n              // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = symbol;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['MM'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getMonth() + 1, 2),\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        let month = Number(match);\n        parseContext.dateInfo.month = month - 1;\n        parseContext.matchInfo.month = match;\n      },\n      parseFunction: function (parseContext, acceptedTerm) {\n        // Special case! When regexp did not match, check if input is '0'. In this case (and only\n        // if we are in analyze mode), predict '01' as input.\n        if (parseContext.analyze) {\n          if (parseContext.inputString === '0') {\n            // Use current dateInfo to create a date\n            let date = this.dateFormat._dateInfoToDate(parseContext.dateInfo);\n            if (!date) {\n              return null; // parsing failed (dateInfo does not seem to contain a valid string)\n            }\n\n            let month = date.getMonth();\n            if (month >= 9) {\n              month = 0;\n              if (parseContext.dateInfo.year === undefined) {\n                parseContext.dateInfo.year = Number(date.getFullYear()) + 1;\n              } else {\n                parseContext.dateInfo.year = parseContext.dateInfo.year + 1;\n              }\n            }\n            parseContext.dateInfo.month = month;\n            parseContext.matchInfo.month = strings.padZeroLeft(String(month + 1), 2);\n            parseContext.inputString = '';\n            return '0';\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['M'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getMonth() + 1),\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        let month = Number(match);\n        parseContext.dateInfo.month = month - 1;\n        parseContext.matchInfo.month = match;\n      }\n    }),\n    // --- Week in year ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEK_IN_YEAR,\n      terms: ['ww'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(dates.weekInYear(formatContext.inputDate), 2),\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.matchInfo.week = match;\n        parseContext.hints.weekInYear = Number(match);\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEK_IN_YEAR,\n      terms: ['w'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(dates.weekInYear(formatContext.inputDate)),\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.matchInfo.week = match;\n        parseContext.hints.weekInYear = Number(match);\n      }\n    }),\n    // --- Day in month ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.DAY_IN_MONTH,\n      terms: ['dd'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getDate(), 2),\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.day = Number(match);\n        parseContext.matchInfo.day = match;\n      },\n      parseFunction: (parseContext, acceptedTerm) => {\n        // Special case! When regexp did not match, check if input is '0'. In this case (and only\n        // if we are in analyze mode), predict '01' as input.\n        if (parseContext.analyze) {\n          if (parseContext.inputString === '0') {\n            parseContext.dateInfo.day = 1;\n            parseContext.matchInfo.day = '01';\n            parseContext.inputString = '';\n            return '0';\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.DAY_IN_MONTH,\n      terms: ['d'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getDate()),\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.day = Number(match);\n        parseContext.matchInfo.day = match;\n      }\n    }),\n    // --- Weekday ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEKDAY,\n      terms: ['EEEE'],\n      dateFormat: this,\n      formatFunction: function (formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.weekdays[formatContext.inputDate.getDay()];\n      },\n      parseFunction: function (parseContext, acceptedTerm) {\n        let i, symbol, re, m;\n        for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n          symbol = this.dateFormat.symbols.weekdays[i];\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n          if (m) {\n            // match found\n            parseContext.matchInfo.weekday = m[1];\n            parseContext.hints.weekday = i;\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        }\n        // No match found so far. In analyze mode, check prefixes.\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n            symbol = this.dateFormat.symbols.weekdays[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n            if (m) {\n              // match found\n              parseContext.matchInfo.weekday = symbol;\n              parseContext.hints.weekday = i;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEKDAY,\n      terms: ['EEE', 'EE', 'E'],\n      dateFormat: this,\n      formatFunction: function (formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.weekdaysShort[formatContext.inputDate.getDay()];\n      },\n      parseFunction: function (parseContext, acceptedTerm) {\n        let i, symbol, re, m;\n        for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n          symbol = this.dateFormat.symbols.weekdaysShort[i];\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n          if (m) {\n            // match found\n            parseContext.matchInfo.weekday = m[1];\n            parseContext.hints.weekday = i;\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        }\n        // No match found so far. In analyze mode, check prefixes.\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n            symbol = this.dateFormat.symbols.weekdaysShort[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n            if (m) {\n              // match found\n              parseContext.matchInfo.weekday = symbol;\n              parseContext.hints.weekday = i;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n        return null; // no match found\n      }\n    }),\n    // --- Hour (24h) ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_24,\n      terms: ['HH'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getHours(), 2),\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.hours = Number(match);\n        parseContext.matchInfo.hours = match;\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_24,\n      terms: ['H'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getHours()),\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.hours = Number(match);\n        parseContext.matchInfo.hours = match;\n      }\n    }),\n    // --- Hour (12h) ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_12,\n      terms: ['hh'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => {\n        if (formatContext.inputDate.getHours() % 12 === 0) {\n          return '12'; // there is no hour '0' in 12-hour format\n        }\n\n        return strings.padZeroLeft(formatContext.inputDate.getHours() % 12, 2);\n      },\n      parseRegExp: /^(10|11|12|0[1-9])(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n        parseContext.matchInfo.hours = match;\n      },\n      parseFunction: (parseContext, acceptedTerm) => {\n        // Special case! When regexp did not match and input is a single '0', predict '01'\n        if (parseContext.analyze) {\n          if (parseContext.inputString === '0') {\n            parseContext.dateInfo.hours = 1;\n            parseContext.matchInfo.hours = '01';\n            parseContext.inputString = '';\n            return parseContext.inputString;\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_12,\n      terms: ['h'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => {\n        if (formatContext.inputDate.getHours() % 12 === 0) {\n          return '12'; // there is no hour '0' in 12-hour format\n        }\n\n        return String(formatContext.inputDate.getHours() % 12);\n      },\n      parseRegExp: /^(10|11|12|0?[1-9])(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n        parseContext.matchInfo.hours = match;\n      }\n    }),\n    // --- AM/PM marker ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.AM_PM,\n      terms: ['a'],\n      dateFormat: this,\n      formatFunction: function (formatContext, acceptedTerm) {\n        if (formatContext.inputDate.getHours() < 12) {\n          return this.dateFormat.symbols.am;\n        }\n        return this.dateFormat.symbols.pm;\n      },\n      parseFunction: function (parseContext, acceptedTerm) {\n        let re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.am) + ')(.*)$', 'i');\n        let m = re.exec(parseContext.inputString);\n        parseContext.matchInfo.ampm = null;\n        if (m) {\n          // match found\n          parseContext.matchInfo.ampm = m[1];\n          parseContext.inputString = m[2];\n          parseContext.hints.am = true;\n          parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n          return m[1];\n        }\n        re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.pm) + ')(.*)$', 'i');\n        m = re.exec(parseContext.inputString);\n        if (m) {\n          // match found\n          parseContext.matchInfo.ampm = m[1];\n          parseContext.inputString = m[2];\n          parseContext.hints.pm = true;\n          parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12 + 12;\n          return m[1];\n        }\n\n        // No match found so far. In analyze mode, check prefixes.\n        if (parseContext.analyze) {\n          re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n          m = re.exec(this.dateFormat.symbols.am);\n          if (m) {\n            parseContext.matchInfo.ampm = this.dateFormat.symbols.am;\n            parseContext.inputString = '';\n            parseContext.hints.am = true;\n            parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n            return m[1];\n          }\n          m = re.exec(this.dateFormat.symbols.pm);\n          if (m) {\n            parseContext.matchInfo.ampm = this.dateFormat.symbols.pm;\n            parseContext.inputString = '';\n            parseContext.hints.pm = true;\n            parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12 + 12;\n            return m[1];\n          }\n        }\n        return null; // no match found\n      }\n    }),\n    // --- Minute ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MINUTE,\n      terms: ['mm'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getMinutes(), 2),\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.minutes = Number(match);\n        parseContext.matchInfo.minutes = match;\n      },\n      parseFunction: (parseContext, acceptedTerm) => {\n        // Special case! When regexp did not match, check if input + '0' would make a\n        // valid minutes value. If yes, predict this value.\n        if (parseContext.analyze) {\n          if (scout.isOneOf(parseContext.inputString, '0', '1', '2', '3', '4', '5')) {\n            let tenMinutes = parseContext.inputString + '0';\n            parseContext.dateInfo.minutes = Number(tenMinutes);\n            parseContext.matchInfo.minutes = tenMinutes;\n            parseContext.inputString = '';\n            return parseContext.inputString;\n          }\n        }\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MINUTE,\n      terms: ['m'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getMinutes()),\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.minutes = Number(match);\n        parseContext.matchInfo.minutes = match;\n      }\n    }),\n    // --- Second ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.SECOND,\n      terms: ['ss'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getSeconds(), 2),\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.seconds = Number(match);\n        parseContext.matchInfo.seconds = match;\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.SECOND,\n      terms: ['s'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getSeconds()),\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.seconds = Number(match);\n        parseContext.matchInfo.seconds = match;\n      }\n    }),\n    // --- Millisecond ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MILLISECOND,\n      terms: ['SSS'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getMilliseconds(), 3),\n      parseRegExp: /^(\\d{3})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.milliseconds = Number(match);\n        parseContext.matchInfo.milliseconds = match;\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MILLISECOND,\n      terms: ['S'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getMilliseconds()),\n      parseRegExp: /^(\\d{1,3})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        parseContext.dateInfo.milliseconds = Number(match);\n        parseContext.matchInfo.milliseconds = match;\n      }\n    }),\n    // --- Time zone ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.TIMEZONE,\n      terms: ['Z'],\n      dateFormat: this,\n      formatFunction: (formatContext, acceptedTerm) => {\n        let offset = Math.abs(formatContext.inputDate.getTimezoneOffset()),\n          isNegative = offset !== formatContext.inputDate.getTimezoneOffset();\n        return (isNegative ? '-' : '+') + strings.padZeroLeft(Math.floor(offset / 60), 2) + strings.padZeroLeft(offset % 60, 2);\n      },\n      parseRegExp: /^([+|-]\\d{4})(.*)$/,\n      applyMatchFunction: (parseContext, match, acceptedTerm) => {\n        let offset = Number(match.substr(1, 2)) * 60 + Number(match.substr(3, 2));\n        if (match.charAt(0) === '-') {\n          offset *= -1;\n        }\n        parseContext.dateInfo.timezone = offset;\n        parseContext.matchInfo.timezone = match;\n      }\n    })];\n\n    // Build a map of pattern definitions by pattern type\n    this._patternLibrary = {};\n    for (let i = 0; i < this._patternDefinitions.length; i++) {\n      let patternDefinition = this._patternDefinitions[i];\n      let type = patternDefinition.type;\n      if (type) {\n        if (!this._patternLibrary[type]) {\n          this._patternLibrary[type] = [];\n        }\n        this._patternLibrary[type].push(patternDefinition);\n      }\n    }\n    this._compile();\n  }\n  _compile() {\n    let i, j, patternDefinitions, patternDefinition, re, m, term, termAccepted, analyseFunctions;\n\n    // Build format, parse and analyze functions for all terms in the DateFormat's pattern.\n    // A term is a continuous sequence of the same character.\n    re = /(.)\\1*/g;\n    while (m = re.exec(this.pattern)) {\n      term = m[0];\n      this._terms.push(term);\n      termAccepted = false;\n      for (i = 0; i < this._patternDefinitions.length; i++) {\n        patternDefinition = this._patternDefinitions[i];\n        let acceptedTerm = patternDefinition.accept(term);\n        if (acceptedTerm) {\n          // 1. Create and install format function\n          this._formatFunctions.push(patternDefinition.createFormatFunction(acceptedTerm));\n\n          // 2. Create and install parse function\n          this._parseFunctions.push(patternDefinition.createParseFunction(acceptedTerm));\n\n          // 3. Create and install analyze functions\n          analyseFunctions = [patternDefinition.createParseFunction(acceptedTerm)];\n          if (this.lenient) {\n            // In lenient mode, add all other parse functions of the same type\n            patternDefinitions = this._patternLibrary[patternDefinition.type];\n            for (j = 0; j < patternDefinitions.length; j++) {\n              if (patternDefinitions[j] !== patternDefinition) {\n                analyseFunctions.push(patternDefinitions[j].createParseFunction(acceptedTerm));\n              }\n            }\n          }\n          this._analyzeFunctions.push(analyseFunctions);\n\n          // Term was processed, continue with next term\n          termAccepted = true;\n          break;\n        }\n      }\n\n      // In case term was not accepted by any pattern definition, assume it is a constant string\n      if (!termAccepted) {\n        // 1. Create and install constant format function\n        this._formatFunctions.push(this._createConstantStringFormatFunction(term));\n        // 2./3. Create and install parse and analyse functions\n        let constantStringParseFunction = this._createConstantStringParseFunction(term);\n        this._parseFunctions.push(constantStringParseFunction);\n        this._analyzeFunctions.push([constantStringParseFunction]);\n      }\n    }\n  }\n\n  /**\n   * Returns a format function for constant terms (e.g. all parts of a pattern that don't\n   * have a DateFormatPatternDefinition).\n   */\n  _createConstantStringFormatFunction(term) {\n    return formatContext => {\n      formatContext.formattedString += term;\n    };\n  }\n\n  /**\n   * Returns a parse function for constant terms (e.g. all parts of a pattern that don't\n   * have a DateFormatPatternDefinition).\n   */\n  _createConstantStringParseFunction(term) {\n    return parseContext => {\n      if (strings.startsWith(parseContext.inputString, term)) {\n        parseContext.inputString = parseContext.inputString.substr(term.length);\n        parseContext.parsedPattern += term;\n        return true;\n      }\n      // In analyze mode, constant terms are optional (this supports \"020318\" --> \"02.03.2018\")\n      return parseContext.analyze;\n    };\n  }\n\n  /**\n   * Formats the given date according to the date pattern. If the date is missing, the\n   * empty string is returned.\n   *\n   * @param exactLength\n   *          May be set to true to force the patterns to use the exact length. For example,\n   *          the year pattern 'yyy' would normally format the year using 2 digits. If\n   *          the parameter is true, 3 are used. This is mainly useful, when an \"analyzed\"\n   *          date should be formatted again using the \"parsedPattern\".\n   */\n  format(date, exactLength) {\n    if (!date) {\n      return '';\n    }\n    let formatContext = this._createFormatContext(date);\n    formatContext.exactLength = scout.nvl(exactLength, false);\n    // Apply all formatter functions for this DateFormat to the pattern to replace the\n    // different terms with the corresponding value from the given date.\n    for (let i = 0; i < this._formatFunctions.length; i++) {\n      let formatFunction = this._formatFunctions[i];\n      formatFunction(formatContext);\n    }\n    return formatContext.formattedString;\n  }\n\n  /**\n   * Analyzes the given string and returns an information object with all recognized information\n   * for the current date format.\n   *\n   * The result object contains the following properties:\n   *\n   * inputString:\n   *   The original input for the analysis.\n   *\n   * dateInfo:\n   *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n   *   parts are undefined, all others are converted to numbers. Those values may be directly\n   *   used in the JavaScript Date() type (month is zero-based!).\n   *   Valid properties:\n   *   - year, month, day, hours, minutes, seconds, milliseconds, timezone\n   *\n   * matchInfo:\n   *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n   *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n   *   the month is \"one-based\", as opposed to dateInfo.month!\n   *   Valid properties:\n   *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds, timezone\n   *\n   * hints:\n   *   An object that contains further recognized date parts that are not needed to define the exact time.\n   *   Valid properties:\n   *   - am [true / false]\n   *   - pm [true / false]\n   *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n   *   - weekInYear [number 1-53]\n   *\n   * parsedPattern:\n   *   The pattern that was used to parse the input. This may differ from the date format's pattern.\n   *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.2015\" --> parsedPattern=\"d.M.yyyy\"\n   *\n   * matchedPattern:\n   *   The pattern that was recognized in the input. Unlike \"parsedPattern\", this may not be a full pattern.\n   *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.\" --> parsedPattern=\"d.M.yyyy\", matchedPattern=\"d.M.\"\n   *\n   * predictedDate:\n   *   The date that could be predicted from the recognized inputs. If the second method argument\n   *   'startDate' is set, this date is used as basis for this predicted date. Otherwise, 'today' is used.\n   *\n   * error:\n   *   Boolean that indicates if analyzing the input was successful (e.g. if the pattern could be parsed\n   *   and a date could be predicted).\n   */\n  analyze(text, startDate) {\n    let analyzeInfo = this._createAnalyzeInfo(text);\n    if (!text) {\n      return analyzeInfo;\n    }\n    let parseContext = this._createParseContext(text);\n    parseContext.analyze = true; // Mark context as \"analyze mode\"\n    parseContext.startDate = startDate;\n    let matchedPattern = '';\n    for (let i = 0; i < this._terms.length; i++) {\n      if (parseContext.inputString.length > 0) {\n        let parseFunctions = this._analyzeFunctions[i];\n        let parsed = false;\n        for (let j = 0; j < parseFunctions.length; j++) {\n          let parseFunction = parseFunctions[j];\n          if (parseFunction(parseContext)) {\n            parsed = true;\n            break;\n          }\n        }\n        if (!parsed) {\n          // Parsing failed\n          analyzeInfo.error = true;\n          return analyzeInfo;\n        }\n        matchedPattern = parseContext.parsedPattern;\n      } else {\n        // Input is fully consumed, now just add the remaining terms from the pattern\n        parseContext.parsedPattern += this._terms[i];\n      }\n    }\n    if (parseContext.inputString.length > 0) {\n      // There is still input, but the pattern has no more terms --> parsing failed\n      analyzeInfo.error = true;\n      return analyzeInfo;\n    }\n\n    // Try to generate a valid predicted date with the information retrieved so far\n    startDate = this._prepareStartDate(startDate);\n\n    // When weekday is included in pattern, try to find a suitable start date #235975\n    let dayInWeek = parseContext.hints.weekday;\n    let dayInMonth = parseContext.dateInfo.day;\n    if (dayInWeek !== undefined) {\n      if (dayInMonth !== undefined && dayInMonth <= 31) {\n        startDate = dates.shiftToNextDayAndDate(startDate, dayInWeek, dayInMonth);\n      } else {\n        startDate = dates.shiftToNextDayOfType(startDate, dayInWeek);\n      }\n    }\n    let predictedDate = this._dateInfoToDate(parseContext.dateInfo, startDate, parseContext.hints);\n\n    // Update analyzeInfo\n    analyzeInfo.dateInfo = parseContext.dateInfo;\n    analyzeInfo.matchInfo = parseContext.matchInfo;\n    analyzeInfo.hints = parseContext.hints;\n    analyzeInfo.parsedPattern = parseContext.parsedPattern;\n    analyzeInfo.matchedPattern = matchedPattern;\n    analyzeInfo.predictedDate = predictedDate;\n    analyzeInfo.error = !predictedDate;\n    return analyzeInfo;\n  }\n\n  /**\n   * Parses the given text with the current date format. If the text does not match exactly\n   * with the pattern, \"null\" is returned. Otherwise, the parsed date is returned.\n   *\n   * The argument 'startDate' is optional. It may set the date where parsed information should\n   * be applied to (e.g. relevant for 2-digit years).\n   */\n  parse(text, startDate) {\n    if (!text) {\n      return null;\n    }\n    let parseContext = this._createParseContext(text);\n    parseContext.startDate = startDate;\n    for (let i = 0; i < this._parseFunctions.length; i++) {\n      let parseFunction = this._parseFunctions[i];\n      if (!parseFunction(parseContext)) {\n        return null; // Parsing failed\n      }\n\n      if (parseContext.inputString.length === 0) {\n        break; // Everything parsed!\n      }\n    }\n\n    if (parseContext.inputString.length > 0) {\n      // Input remaining but no more parse functions available -> parsing failed\n      return null;\n    }\n\n    // Build date from dateInfo\n    let date = this._dateInfoToDate(parseContext.dateInfo, startDate);\n    if (!date) {\n      return null; // dateInfo could not be converted to a valid date -> parsing failed\n    }\n\n    // Handle hints\n    if (parseContext.hints.weekday !== undefined) {\n      if (date.getDay() !== parseContext.hints.weekday) {\n        return null; // Date and weekday don't match -> parsing failed\n      }\n    }\n\n    // Return valid date\n    return date;\n  }\n\n  /**\n   * @param {Object} dateInfo\n   * @param {Date} [startDate]\n   * @param {Object} [hints]\n   * @returns {null|Date}\n   * @private\n   */\n  _dateInfoToDate(dateInfo, startDate, hints) {\n    if (!dateInfo) {\n      return null;\n    }\n\n    // Default date\n    startDate = this._prepareStartDate(startDate);\n\n    // Apply date info (Start with \"zero date\", otherwise the date may become invalid\n    // due to JavaScript's automatic date correction, e.g. dateInfo = { day: 11, month: 1 }\n    // and startDate = 2015-07-29 would result in invalid date 2015-03-11, because February\n    // 2015 does not have 29 days and is \"corrected\" to March.)\n    let result = new Date(1970, 0, 1);\n    let validDay = scout.nvl(dateInfo.day, startDate.getDate());\n    let validMonth = scout.nvl(dateInfo.month, startDate.getMonth());\n    let validYear = scout.nvl(dateInfo.year, startDate.getFullYear());\n    // When user entered the day but not (yet) the month, adjust month if possible to propose a valid date\n    if (dateInfo.day && !dateInfo.month) {\n      // If day \"31\" does not exist in the proposed month, use the next month\n      if (dateInfo.day === 31) {\n        let monthsWithThirthyOneDays = [0, 2, 4, 6, 7, 9, 11];\n        if (!scout.isOneOf(validMonth, monthsWithThirthyOneDays)) {\n          validMonth = validMonth + 1;\n        }\n      } else if (dateInfo.day >= 29 && validMonth === 1) {\n        // If day is \"29\" or \"30\" and month is february, use next month (except day is \"29\" and the year is a leap year)\n        if (dateInfo.day > 29 || !dates.isLeapYear(validYear)) {\n          validMonth = validMonth + 1;\n        }\n      }\n    }\n\n    // ensure valid day for selected month for dateInfo without day\n    if (!dateInfo.day && dateInfo.month) {\n      let lastOfMonth = dates.shift(new Date(validYear, dateInfo.month + 1, 1), 0, 0, -1);\n      validDay = Math.min(lastOfMonth.getDate(), startDate.getDate());\n    }\n    result.setFullYear(validYear, validMonth, validDay);\n    result.setHours(scout.nvl(dateInfo.hours, startDate.getHours()), scout.nvl(dateInfo.minutes, startDate.getMinutes()), scout.nvl(dateInfo.seconds, startDate.getSeconds()), scout.nvl(dateInfo.milliseconds, startDate.getMilliseconds()));\n\n    // Validate. A date is considered valid if the value from the dateInfo did\n    // not change (JS date automatically converts illegal values, e.g. day 32 is\n    // converted to first day of next month).\n    if (!isValid(result.getFullYear(), dateInfo.year)) {\n      return null;\n    }\n    if (!isValid(result.getMonth(), dateInfo.month)) {\n      return null;\n    }\n    if (!isValid(result.getDate(), dateInfo.day)) {\n      return null;\n    }\n    if (!isValid(result.getHours(), dateInfo.hours)) {\n      return null;\n    }\n    if (!isValid(result.getMinutes(), dateInfo.minutes)) {\n      return null;\n    }\n    if (!isValid(result.getSeconds(), dateInfo.seconds)) {\n      return null;\n    }\n    if (!isValid(result.getMilliseconds(), dateInfo.milliseconds)) {\n      return null;\n    }\n    if (!isValid(result.getDay(), objects.optProperty(hints, 'weekday'))) {\n      return null;\n    }\n\n    // Adjust time zone\n    if (numbers.isNumber(dateInfo.timezone)) {\n      result.setMinutes(result.getMinutes() - result.getTimezoneOffset() + dateInfo.timezone);\n    }\n    return result;\n\n    // ----- Helper functions -----\n\n    function isValid(value, expectedValue) {\n      return objects.isNullOrUndefined(expectedValue) || expectedValue === value;\n    }\n  }\n\n  /**\n   * Returns the date where parsed information should be applied to. The given\n   * startDate is used when specified, otherwise a new date is created (today).\n   */\n  _prepareStartDate(startDate) {\n    if (startDate) {\n      // It is important that we don't alter the argument 'startDate', but create an independent copy!\n      return new Date(startDate.getTime());\n    }\n    return dates.trunc(new Date()); // clear time\n  }\n\n  /**\n   * Returns the \"format context\", an object that is initially filled with the input date and is then\n   * passed through the various formatting functions. As the formatting progresses, the format context object\n   * is updated accordingly. At the end of the process, the object contains the result.\n   *\n   * The format context contains the following properties:\n   *\n   * inputDate:\n   *   The date to be formatted.\n   *\n   * formattedString:\n   *   The result of the formatting. The string is initially empty. During the format process, the\n   *   formatted parts will be appended to the string until the final string is complete.\n   *\n   * exactLength:\n   *   Flag to force the format functions to use the exact length of the accepted term. The default\n   *   is false, which will use the canonical length. For example, the year pattern 'yyy' will\n   *   format the year using 2 digits by default. If the parameter is true, 3 are used. This is mainly\n   *   useful, when an \"analyzed\" date should be formatted again using the \"parsedPattern\".\n   */\n  _createFormatContext(inputDate) {\n    return {\n      inputDate: inputDate,\n      formattedString: '',\n      exactLength: false\n    };\n  }\n\n  /**\n   * Returns the \"parse context\", an object that is initially filled with the input string and is then\n   * passed through the various parsing functions. As the parsing progresses, the parse context object\n   * is updated accordingly. At the end of the process, the object contains the result.\n   *\n   * The parse context contains the following properties:\n   *\n   * inputString:\n   *   The original input for the parsing. This string will be consumed during the parse process,\n   *   and will be empty at the end.\n   *\n   * dateInfo:\n   *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n   *   parts are undefined, all others are converted to numbers. Those values may be directly\n   *   used in the JavaScript Date() type (month is zero-based!).\n   *   Valid properties:\n   *   - year, month, day, hours, minutes, seconds, milliseconds\n   *\n   * matchInfo:\n   *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n   *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n   *   the month is \"one-based\", as opposed to dateInfo.month!\n   *   Valid properties:\n   *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds\n   *\n   * hints:\n   *   An object that contains further recognized date parts that are not needed to define the exact time.\n   *   Valid properties:\n   *   - am [true / false]\n   *   - pm [true / false]\n   *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n   *   - weekInYear [number 1-53]\n   *\n   * analyze:\n   *   A flag that indicates if the \"analyze mode\" is on. This is true when analyze() was called, and\n   *   false when parse() was called. It may alter the behavior of the parse functions, i.e. they will\n   *   not fail in analyze mode when the pattern does not match exactly.\n   *\n   * startDate:\n   *   A date to be used as reference for date calculations. Is used for example when mapping a 2-digit\n   *   year to a 4-digit year.\n   */\n  _createParseContext(inputText) {\n    return {\n      inputString: inputText,\n      dateInfo: {},\n      matchInfo: {},\n      hints: {},\n      parsedPattern: '',\n      analyze: false,\n      startDate: null\n    };\n  }\n\n  /**\n   * @see analyze()\n   */\n  _createAnalyzeInfo(inputText) {\n    return {\n      inputString: inputText,\n      dateInfo: {},\n      matchInfo: {},\n      hints: {},\n      parsedPattern: '',\n      matchedPattern: '',\n      predictedDate: null,\n      error: false\n    };\n  }\n  static ensure(locale, format) {\n    if (!format) {\n      return format;\n    }\n    if (format instanceof DateFormat) {\n      return format;\n    }\n    return new DateFormat(locale, format);\n  }\n}","map":{"version":3,"names":["DateFormatPatternDefinition","DateFormatPatternType","dates","numbers","objects","scout","strings","DateFormat","constructor","locale","pattern","options","assertParameter","dateFormatPatternDefault","symbols","dateFormatSymbols","firstDayOfWeek","weekdaysOrdered","orderWeekdays","weekdays","weekdaysShortOrdered","weekdaysShort","monthsToNumber","monthsShortToNumber","lenient","nvl","_terms","_formatFunctions","_parseFunctions","_analyzeFunctions","_patternDefinitions","type","YEAR","terms","dateFormat","formatFunction","formatContext","acceptedTerm","year","inputDate","getFullYear","numDigits","Math","max","toString","length","padZeroLeft","slice","parseRegExp","applyMatchFunction","parseContext","match","matchInfo","dateInfo","Number","String","exactLength","startYear","startDate","Date","substr","distance","MONTH","months","getMonth","parseFunction","i","symbol","re","m","RegExp","quote","exec","inputString","month","analyze","monthsShort","date","_dateInfoToDate","undefined","WEEK_IN_YEAR","weekInYear","week","hints","DAY_IN_MONTH","getDate","day","WEEKDAY","getDay","weekday","HOUR_24","getHours","hours","HOUR_12","pm","AM_PM","am","ampm","MINUTE","getMinutes","minutes","isOneOf","tenMinutes","SECOND","getSeconds","seconds","MILLISECOND","getMilliseconds","milliseconds","TIMEZONE","offset","abs","getTimezoneOffset","isNegative","floor","charAt","timezone","_patternLibrary","patternDefinition","push","_compile","j","patternDefinitions","term","termAccepted","analyseFunctions","accept","createFormatFunction","createParseFunction","_createConstantStringFormatFunction","constantStringParseFunction","_createConstantStringParseFunction","formattedString","startsWith","parsedPattern","format","_createFormatContext","text","analyzeInfo","_createAnalyzeInfo","_createParseContext","matchedPattern","parseFunctions","parsed","error","_prepareStartDate","dayInWeek","dayInMonth","shiftToNextDayAndDate","shiftToNextDayOfType","predictedDate","parse","result","validDay","validMonth","validYear","monthsWithThirthyOneDays","isLeapYear","lastOfMonth","shift","min","setFullYear","setHours","isValid","optProperty","isNumber","setMinutes","value","expectedValue","isNullOrUndefined","getTime","trunc","inputText","ensure"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/text/DateFormat.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {DateFormatPatternDefinition, DateFormatPatternType, dates, numbers, objects, scout, strings} from '../index';\n\n/**\n * Custom JavaScript Date Format\n *\n * Support for formatting and parsing dates based on a pattern string and some locale\n * information from the server model. A subset of the standard Java pattern strings\n * (see SimpleDateFormat) with the most commonly used patterns is supported.\n *\n * This object only operates on the local time zone.\n * <p>\n * locale.dateFormatSymbols contains:\n * <ul>\n * <li>weekdays start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>weekdaysShort start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>months start with January</li>\n * <li>monthsShort start with January<7li>\n * <li>am</li>\n * <li>pm</li>\n *</ul>\n *\n * @see http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n */\nexport default class DateFormat {\n\n  constructor(locale, pattern, options) { // NOSONAR\n    options = options || {};\n\n    /* jshint sub:true */\n    this.locale = locale;\n    scout.assertParameter('locale', this.locale);\n    this.pattern = pattern || locale.dateFormatPatternDefault;\n    scout.assertParameter('pattern', this.pattern);\n\n    this.symbols = locale.dateFormatSymbols;\n    this.symbols.firstDayOfWeek = 1; // monday // TODO [7.0] cgu: deliver from server\n    this.symbols.weekdaysOrdered = dates.orderWeekdays(this.symbols.weekdays, this.symbols.firstDayOfWeek);\n    this.symbols.weekdaysShortOrdered = dates.orderWeekdays(this.symbols.weekdaysShort, this.symbols.firstDayOfWeek);\n    this.symbols.monthsToNumber;\n    this.symbols.monthsShortToNumber;\n\n    // Relevant during analyze(). When this is true (default), terms of the same \"pattern type\" (e.g. \"d\" and \"dd\") will\n    // also be considered. Otherwise, analyze() behaves like parse(), i.g. the pattern must match exactly.\n    // Example: \"2.10\" will match the pattern \"dd.MM.yyy\" when lenient=true. If lenient is false, it won't match.\n    this.lenient = scout.nvl(options.lenient, true);\n\n    // List of terms, e.g. split up parts of this.pattern. The length of this array is equal\n    // to the length of this._formatFunctions, this._parseFunctions and this._analyzeFunctions.\n    this._terms = [];\n\n    // List of format function to be called _in that exact order_ to convert this.pattern\n    // to a formatted date string (by sequentially replacing all terms with real values).\n    this._formatFunctions = [];\n\n    // List of parse functions to be called _in that exact order_ to convert an input\n    // string to a valid JavaScript Date object. This order matches the recognized terms\n    // in the pattern. Unrecognized terms are represented by a \"constant\" function that\n    // matches the string itself (e.g. separator characters or spaces).\n    this._parseFunctions = [];\n\n    // Array of arrays, same order as _parseFunctions, but term functions are a list of term functions (to support lenient parsing)\n    this._analyzeFunctions = [];\n\n    // Build a list of all pattern definitions. This list is then used to build the list of\n    // format, parse and analyze functions according to this.pattern.\n    //\n    // !!! PLEASE NOTE !!!\n    // The order of these definitions is important! For each term in the pattern, the list\n    // is scanned from the beginning until a definition accepts the term. If the wrong\n    // definition was picked, results would be unpredictable.\n    //\n    // Following the following rules ensures that the algorithm can pick the best matching\n    // pattern format definition for each term in the pattern:\n    // - Sort definitions by time span, from large (year) to small (milliseconds).\n    // - Two definitions of the same type should be sorted by term length, from long\n    //   (e.g. MMMM) to short (e.g. M).\n    this._patternDefinitions = [\n      // --- Year ---\n      // This definition can _format_ dates with years with 4 or more digits.\n      // See: http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n      //      chapter 'Date and Time Patterns', paragraph 'Year'\n      // We do not allow to _parse_ a date with 5 or more digits. We could allow that in a\n      // future release, but it could have an impact on backend logic, databases, etc.\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.YEAR,\n        terms: ['yyyy'], // meaning: any number of digits is allowed\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => {\n          let year = formatContext.inputDate.getFullYear();\n          let numDigits = Math.max(4, year.toString().length); // min. digits = 4\n          return strings.padZeroLeft(formatContext.inputDate.getFullYear(), numDigits).slice(-numDigits);\n        },\n        parseRegExp: /^(\\d{4})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.matchInfo.year = match;\n          parseContext.dateInfo.year = Number(match);\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.YEAR,\n        terms: ['yyy', 'yy', 'y'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => {\n          let year = String(formatContext.inputDate.getFullYear());\n          let length = (formatContext.exactLength ? acceptedTerm.length : 2);\n          if (length === 1) {\n            // Return max. 2 digits, no leading zero\n            return year.slice(-length);\n          }\n          // Return max. 2 digits with zero padding\n          return strings.padZeroLeft(year, length).slice(-length);\n        },\n        parseRegExp: /^(\\d{1,3})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          if (match.length === 3) {\n            parseContext.dateInfo.year = Number(match);\n            parseContext.matchInfo.year = match;\n            return;\n          }\n          let startYear = (parseContext.startDate || new Date()).getFullYear();\n          // Construct a new year using the startYear's century and the entered 'short year'\n          let year = Number(\n            strings.padZeroLeft(startYear, 4).substr(0, 2) +\n            strings.padZeroLeft(match, 2));\n          // Ensure max. 50 years distance between 'startYear' and 'year'\n          let distance = year - startYear;\n          if (distance <= -50) {\n            year += 100;\n          } else if (distance > 50) {\n            year -= 100;\n          }\n          parseContext.dateInfo.year = year;\n          parseContext.matchInfo.year = match;\n        }\n      }),\n      // --- Month ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['MMMM'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.months[formatContext.inputDate.getMonth()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          let i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n            symbol = this.dateFormat.symbols.months[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = m[1];\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n              symbol = this.dateFormat.symbols.months[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.dateInfo.month = i;\n                parseContext.matchInfo.month = symbol;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['MMM'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.monthsShort[formatContext.inputDate.getMonth()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          let i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n            symbol = this.dateFormat.symbols.monthsShort[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = m[1];\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n              symbol = this.dateFormat.symbols.monthsShort[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.dateInfo.month = i;\n                parseContext.matchInfo.month = symbol;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['MM'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getMonth() + 1, 2),\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          let month = Number(match);\n          parseContext.dateInfo.month = month - 1;\n          parseContext.matchInfo.month = match;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          // Special case! When regexp did not match, check if input is '0'. In this case (and only\n          // if we are in analyze mode), predict '01' as input.\n          if (parseContext.analyze) {\n            if (parseContext.inputString === '0') {\n              // Use current dateInfo to create a date\n              let date = this.dateFormat._dateInfoToDate(parseContext.dateInfo);\n              if (!date) {\n                return null; // parsing failed (dateInfo does not seem to contain a valid string)\n              }\n              let month = date.getMonth();\n              if (month >= 9) {\n                month = 0;\n                if (parseContext.dateInfo.year === undefined) {\n                  parseContext.dateInfo.year = Number(date.getFullYear()) + 1;\n                } else {\n                  parseContext.dateInfo.year = parseContext.dateInfo.year + 1;\n                }\n              }\n              parseContext.dateInfo.month = month;\n              parseContext.matchInfo.month = strings.padZeroLeft(String(month + 1), 2);\n              parseContext.inputString = '';\n              return '0';\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['M'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getMonth() + 1),\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          let month = Number(match);\n          parseContext.dateInfo.month = month - 1;\n          parseContext.matchInfo.month = match;\n        }\n      }),\n      // --- Week in year ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEK_IN_YEAR,\n        terms: ['ww'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(dates.weekInYear(formatContext.inputDate), 2),\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.matchInfo.week = match;\n          parseContext.hints.weekInYear = Number(match);\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEK_IN_YEAR,\n        terms: ['w'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(dates.weekInYear(formatContext.inputDate)),\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.matchInfo.week = match;\n          parseContext.hints.weekInYear = Number(match);\n        }\n      }),\n      // --- Day in month ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.DAY_IN_MONTH,\n        terms: ['dd'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getDate(), 2),\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.day = Number(match);\n          parseContext.matchInfo.day = match;\n        },\n        parseFunction: (parseContext, acceptedTerm) => {\n          // Special case! When regexp did not match, check if input is '0'. In this case (and only\n          // if we are in analyze mode), predict '01' as input.\n          if (parseContext.analyze) {\n            if (parseContext.inputString === '0') {\n              parseContext.dateInfo.day = 1;\n              parseContext.matchInfo.day = '01';\n              parseContext.inputString = '';\n              return '0';\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.DAY_IN_MONTH,\n        terms: ['d'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getDate()),\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.day = Number(match);\n          parseContext.matchInfo.day = match;\n        }\n      }),\n      // --- Weekday ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEKDAY,\n        terms: ['EEEE'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.weekdays[formatContext.inputDate.getDay()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          let i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n            symbol = this.dateFormat.symbols.weekdays[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.matchInfo.weekday = m[1];\n              parseContext.hints.weekday = i;\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n              symbol = this.dateFormat.symbols.weekdays[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.matchInfo.weekday = symbol;\n                parseContext.hints.weekday = i;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEKDAY,\n        terms: ['EEE', 'EE', 'E'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.weekdaysShort[formatContext.inputDate.getDay()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          let i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n            symbol = this.dateFormat.symbols.weekdaysShort[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.matchInfo.weekday = m[1];\n              parseContext.hints.weekday = i;\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n              symbol = this.dateFormat.symbols.weekdaysShort[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.matchInfo.weekday = symbol;\n                parseContext.hints.weekday = i;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      // --- Hour (24h) ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_24,\n        terms: ['HH'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getHours(), 2),\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.hours = Number(match);\n          parseContext.matchInfo.hours = match;\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_24,\n        terms: ['H'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getHours()),\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.hours = Number(match);\n          parseContext.matchInfo.hours = match;\n        }\n      }),\n      // --- Hour (12h) ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_12,\n        terms: ['hh'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => {\n          if (formatContext.inputDate.getHours() % 12 === 0) {\n            return '12'; // there is no hour '0' in 12-hour format\n          }\n          return strings.padZeroLeft(formatContext.inputDate.getHours() % 12, 2);\n        },\n        parseRegExp: /^(10|11|12|0[1-9])(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n          parseContext.matchInfo.hours = match;\n        },\n        parseFunction: (parseContext, acceptedTerm) => {\n          // Special case! When regexp did not match and input is a single '0', predict '01'\n          if (parseContext.analyze) {\n            if (parseContext.inputString === '0') {\n              parseContext.dateInfo.hours = 1;\n              parseContext.matchInfo.hours = '01';\n              parseContext.inputString = '';\n              return parseContext.inputString;\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_12,\n        terms: ['h'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => {\n          if (formatContext.inputDate.getHours() % 12 === 0) {\n            return '12'; // there is no hour '0' in 12-hour format\n          }\n          return String(formatContext.inputDate.getHours() % 12);\n        },\n        parseRegExp: /^(10|11|12|0?[1-9])(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n          parseContext.matchInfo.hours = match;\n        }\n      }),\n      // --- AM/PM marker ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.AM_PM,\n        terms: ['a'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          if (formatContext.inputDate.getHours() < 12) {\n            return this.dateFormat.symbols.am;\n          }\n          return this.dateFormat.symbols.pm;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          let re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.am) + ')(.*)$', 'i');\n          let m = re.exec(parseContext.inputString);\n          parseContext.matchInfo.ampm = null;\n          if (m) { // match found\n            parseContext.matchInfo.ampm = m[1];\n            parseContext.inputString = m[2];\n            parseContext.hints.am = true;\n            parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n            return m[1];\n          }\n          re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.pm) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n          if (m) { // match found\n            parseContext.matchInfo.ampm = m[1];\n            parseContext.inputString = m[2];\n            parseContext.hints.pm = true;\n            parseContext.dateInfo.hours = (parseContext.dateInfo.hours % 12) + 12;\n            return m[1];\n          }\n\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(this.dateFormat.symbols.am);\n            if (m) {\n              parseContext.matchInfo.ampm = this.dateFormat.symbols.am;\n              parseContext.inputString = '';\n              parseContext.hints.am = true;\n              parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n              return m[1];\n            }\n            m = re.exec(this.dateFormat.symbols.pm);\n            if (m) {\n              parseContext.matchInfo.ampm = this.dateFormat.symbols.pm;\n              parseContext.inputString = '';\n              parseContext.hints.pm = true;\n              parseContext.dateInfo.hours = (parseContext.dateInfo.hours % 12) + 12;\n              return m[1];\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      // --- Minute ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MINUTE,\n        terms: ['mm'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getMinutes(), 2),\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.minutes = Number(match);\n          parseContext.matchInfo.minutes = match;\n        },\n        parseFunction: (parseContext, acceptedTerm) => {\n          // Special case! When regexp did not match, check if input + '0' would make a\n          // valid minutes value. If yes, predict this value.\n          if (parseContext.analyze) {\n            if (scout.isOneOf(parseContext.inputString, '0', '1', '2', '3', '4', '5')) {\n              let tenMinutes = parseContext.inputString + '0';\n              parseContext.dateInfo.minutes = Number(tenMinutes);\n              parseContext.matchInfo.minutes = tenMinutes;\n              parseContext.inputString = '';\n              return parseContext.inputString;\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MINUTE,\n        terms: ['m'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getMinutes()),\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.minutes = Number(match);\n          parseContext.matchInfo.minutes = match;\n        }\n      }),\n      // --- Second ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.SECOND,\n        terms: ['ss'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getSeconds(), 2),\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.seconds = Number(match);\n          parseContext.matchInfo.seconds = match;\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.SECOND,\n        terms: ['s'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getSeconds()),\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.seconds = Number(match);\n          parseContext.matchInfo.seconds = match;\n        }\n      }),\n      // --- Millisecond ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MILLISECOND,\n        terms: ['SSS'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => strings.padZeroLeft(formatContext.inputDate.getMilliseconds(), 3),\n        parseRegExp: /^(\\d{3})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.milliseconds = Number(match);\n          parseContext.matchInfo.milliseconds = match;\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MILLISECOND,\n        terms: ['S'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => String(formatContext.inputDate.getMilliseconds()),\n        parseRegExp: /^(\\d{1,3})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          parseContext.dateInfo.milliseconds = Number(match);\n          parseContext.matchInfo.milliseconds = match;\n        }\n      }),\n\n      // --- Time zone ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.TIMEZONE,\n        terms: ['Z'],\n        dateFormat: this,\n        formatFunction: (formatContext, acceptedTerm) => {\n          let offset = Math.abs(formatContext.inputDate.getTimezoneOffset()),\n            isNegative = offset !== formatContext.inputDate.getTimezoneOffset();\n          return (isNegative ? '-' : '+') + strings.padZeroLeft(Math.floor(offset / 60), 2) + strings.padZeroLeft(offset % 60, 2);\n        },\n        parseRegExp: /^([+|-]\\d{4})(.*)$/,\n        applyMatchFunction: (parseContext, match, acceptedTerm) => {\n          let offset = Number(match.substr(1, 2)) * 60 + Number(match.substr(3, 2));\n          if (match.charAt(0) === '-') {\n            offset *= -1;\n          }\n          parseContext.dateInfo.timezone = offset;\n          parseContext.matchInfo.timezone = match;\n        }\n      })\n    ];\n\n    // Build a map of pattern definitions by pattern type\n    this._patternLibrary = {};\n    for (let i = 0; i < this._patternDefinitions.length; i++) {\n      let patternDefinition = this._patternDefinitions[i];\n      let type = patternDefinition.type;\n      if (type) {\n        if (!this._patternLibrary[type]) {\n          this._patternLibrary[type] = [];\n        }\n        this._patternLibrary[type].push(patternDefinition);\n      }\n    }\n\n    this._compile();\n  }\n\n  _compile() {\n    let i, j, patternDefinitions, patternDefinition, re, m, term, termAccepted, analyseFunctions;\n\n    // Build format, parse and analyze functions for all terms in the DateFormat's pattern.\n    // A term is a continuous sequence of the same character.\n    re = /(.)\\1*/g;\n    while ((m = re.exec(this.pattern))) {\n      term = m[0];\n      this._terms.push(term);\n\n      termAccepted = false;\n      for (i = 0; i < this._patternDefinitions.length; i++) {\n        patternDefinition = this._patternDefinitions[i];\n        let acceptedTerm = patternDefinition.accept(term);\n        if (acceptedTerm) {\n          // 1. Create and install format function\n          this._formatFunctions.push(patternDefinition.createFormatFunction(acceptedTerm));\n\n          // 2. Create and install parse function\n          this._parseFunctions.push(patternDefinition.createParseFunction(acceptedTerm));\n\n          // 3. Create and install analyze functions\n          analyseFunctions = [patternDefinition.createParseFunction(acceptedTerm)];\n          if (this.lenient) {\n            // In lenient mode, add all other parse functions of the same type\n            patternDefinitions = this._patternLibrary[patternDefinition.type];\n            for (j = 0; j < patternDefinitions.length; j++) {\n              if (patternDefinitions[j] !== patternDefinition) {\n                analyseFunctions.push(patternDefinitions[j].createParseFunction(acceptedTerm));\n              }\n            }\n          }\n          this._analyzeFunctions.push(analyseFunctions);\n\n          // Term was processed, continue with next term\n          termAccepted = true;\n          break;\n        }\n      }\n\n      // In case term was not accepted by any pattern definition, assume it is a constant string\n      if (!termAccepted) {\n        // 1. Create and install constant format function\n        this._formatFunctions.push(this._createConstantStringFormatFunction(term));\n        // 2./3. Create and install parse and analyse functions\n        let constantStringParseFunction = this._createConstantStringParseFunction(term);\n        this._parseFunctions.push(constantStringParseFunction);\n        this._analyzeFunctions.push([constantStringParseFunction]);\n      }\n    }\n  }\n\n  /**\n   * Returns a format function for constant terms (e.g. all parts of a pattern that don't\n   * have a DateFormatPatternDefinition).\n   */\n  _createConstantStringFormatFunction(term) {\n    return formatContext => {\n      formatContext.formattedString += term;\n    };\n  }\n\n  /**\n   * Returns a parse function for constant terms (e.g. all parts of a pattern that don't\n   * have a DateFormatPatternDefinition).\n   */\n  _createConstantStringParseFunction(term) {\n    return parseContext => {\n      if (strings.startsWith(parseContext.inputString, term)) {\n        parseContext.inputString = parseContext.inputString.substr(term.length);\n        parseContext.parsedPattern += term;\n        return true;\n      }\n      // In analyze mode, constant terms are optional (this supports \"020318\" --> \"02.03.2018\")\n      return parseContext.analyze;\n    };\n  }\n\n  /**\n   * Formats the given date according to the date pattern. If the date is missing, the\n   * empty string is returned.\n   *\n   * @param exactLength\n   *          May be set to true to force the patterns to use the exact length. For example,\n   *          the year pattern 'yyy' would normally format the year using 2 digits. If\n   *          the parameter is true, 3 are used. This is mainly useful, when an \"analyzed\"\n   *          date should be formatted again using the \"parsedPattern\".\n   */\n  format(date, exactLength) {\n    if (!date) {\n      return '';\n    }\n\n    let formatContext = this._createFormatContext(date);\n    formatContext.exactLength = scout.nvl(exactLength, false);\n    // Apply all formatter functions for this DateFormat to the pattern to replace the\n    // different terms with the corresponding value from the given date.\n    for (let i = 0; i < this._formatFunctions.length; i++) {\n      let formatFunction = this._formatFunctions[i];\n      formatFunction(formatContext);\n    }\n    return formatContext.formattedString;\n  }\n\n  /**\n   * Analyzes the given string and returns an information object with all recognized information\n   * for the current date format.\n   *\n   * The result object contains the following properties:\n   *\n   * inputString:\n   *   The original input for the analysis.\n   *\n   * dateInfo:\n   *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n   *   parts are undefined, all others are converted to numbers. Those values may be directly\n   *   used in the JavaScript Date() type (month is zero-based!).\n   *   Valid properties:\n   *   - year, month, day, hours, minutes, seconds, milliseconds, timezone\n   *\n   * matchInfo:\n   *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n   *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n   *   the month is \"one-based\", as opposed to dateInfo.month!\n   *   Valid properties:\n   *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds, timezone\n   *\n   * hints:\n   *   An object that contains further recognized date parts that are not needed to define the exact time.\n   *   Valid properties:\n   *   - am [true / false]\n   *   - pm [true / false]\n   *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n   *   - weekInYear [number 1-53]\n   *\n   * parsedPattern:\n   *   The pattern that was used to parse the input. This may differ from the date format's pattern.\n   *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.2015\" --> parsedPattern=\"d.M.yyyy\"\n   *\n   * matchedPattern:\n   *   The pattern that was recognized in the input. Unlike \"parsedPattern\", this may not be a full pattern.\n   *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.\" --> parsedPattern=\"d.M.yyyy\", matchedPattern=\"d.M.\"\n   *\n   * predictedDate:\n   *   The date that could be predicted from the recognized inputs. If the second method argument\n   *   'startDate' is set, this date is used as basis for this predicted date. Otherwise, 'today' is used.\n   *\n   * error:\n   *   Boolean that indicates if analyzing the input was successful (e.g. if the pattern could be parsed\n   *   and a date could be predicted).\n   */\n  analyze(text, startDate) {\n    let analyzeInfo = this._createAnalyzeInfo(text);\n    if (!text) {\n      return analyzeInfo;\n    }\n\n    let parseContext = this._createParseContext(text);\n    parseContext.analyze = true; // Mark context as \"analyze mode\"\n    parseContext.startDate = startDate;\n    let matchedPattern = '';\n    for (let i = 0; i < this._terms.length; i++) {\n      if (parseContext.inputString.length > 0) {\n        let parseFunctions = this._analyzeFunctions[i];\n        let parsed = false;\n        for (let j = 0; j < parseFunctions.length; j++) {\n          let parseFunction = parseFunctions[j];\n          if (parseFunction(parseContext)) {\n            parsed = true;\n            break;\n          }\n        }\n        if (!parsed) {\n          // Parsing failed\n          analyzeInfo.error = true;\n          return analyzeInfo;\n        }\n        matchedPattern = parseContext.parsedPattern;\n      } else {\n        // Input is fully consumed, now just add the remaining terms from the pattern\n        parseContext.parsedPattern += this._terms[i];\n      }\n    }\n\n    if (parseContext.inputString.length > 0) {\n      // There is still input, but the pattern has no more terms --> parsing failed\n      analyzeInfo.error = true;\n      return analyzeInfo;\n    }\n\n    // Try to generate a valid predicted date with the information retrieved so far\n    startDate = this._prepareStartDate(startDate);\n\n    // When weekday is included in pattern, try to find a suitable start date #235975\n    let dayInWeek = parseContext.hints.weekday;\n    let dayInMonth = parseContext.dateInfo.day;\n    if (dayInWeek !== undefined) {\n      if (dayInMonth !== undefined && dayInMonth <= 31) {\n        startDate = dates.shiftToNextDayAndDate(startDate, dayInWeek, dayInMonth);\n      } else {\n        startDate = dates.shiftToNextDayOfType(startDate, dayInWeek);\n      }\n    }\n\n    let predictedDate = this._dateInfoToDate(parseContext.dateInfo, startDate, parseContext.hints);\n\n    // Update analyzeInfo\n    analyzeInfo.dateInfo = parseContext.dateInfo;\n    analyzeInfo.matchInfo = parseContext.matchInfo;\n    analyzeInfo.hints = parseContext.hints;\n    analyzeInfo.parsedPattern = parseContext.parsedPattern;\n    analyzeInfo.matchedPattern = matchedPattern;\n    analyzeInfo.predictedDate = predictedDate;\n    analyzeInfo.error = (!predictedDate);\n    return analyzeInfo;\n  }\n\n  /**\n   * Parses the given text with the current date format. If the text does not match exactly\n   * with the pattern, \"null\" is returned. Otherwise, the parsed date is returned.\n   *\n   * The argument 'startDate' is optional. It may set the date where parsed information should\n   * be applied to (e.g. relevant for 2-digit years).\n   */\n  parse(text, startDate) {\n    if (!text) {\n      return null;\n    }\n\n    let parseContext = this._createParseContext(text);\n    parseContext.startDate = startDate;\n    for (let i = 0; i < this._parseFunctions.length; i++) {\n      let parseFunction = this._parseFunctions[i];\n      if (!parseFunction(parseContext)) {\n        return null; // Parsing failed\n      }\n      if (parseContext.inputString.length === 0) {\n        break; // Everything parsed!\n      }\n    }\n    if (parseContext.inputString.length > 0) {\n      // Input remaining but no more parse functions available -> parsing failed\n      return null;\n    }\n\n    // Build date from dateInfo\n    let date = this._dateInfoToDate(parseContext.dateInfo, startDate);\n    if (!date) {\n      return null; // dateInfo could not be converted to a valid date -> parsing failed\n    }\n\n    // Handle hints\n    if (parseContext.hints.weekday !== undefined) {\n      if (date.getDay() !== parseContext.hints.weekday) {\n        return null; // Date and weekday don't match -> parsing failed\n      }\n    }\n\n    // Return valid date\n    return date;\n  }\n\n  /**\n   * @param {Object} dateInfo\n   * @param {Date} [startDate]\n   * @param {Object} [hints]\n   * @returns {null|Date}\n   * @private\n   */\n  _dateInfoToDate(dateInfo, startDate, hints) {\n    if (!dateInfo) {\n      return null;\n    }\n\n    // Default date\n    startDate = this._prepareStartDate(startDate);\n\n    // Apply date info (Start with \"zero date\", otherwise the date may become invalid\n    // due to JavaScript's automatic date correction, e.g. dateInfo = { day: 11, month: 1 }\n    // and startDate = 2015-07-29 would result in invalid date 2015-03-11, because February\n    // 2015 does not have 29 days and is \"corrected\" to March.)\n    let result = new Date(1970, 0, 1);\n\n    let validDay = scout.nvl(dateInfo.day, startDate.getDate());\n    let validMonth = scout.nvl(dateInfo.month, startDate.getMonth());\n    let validYear = scout.nvl(dateInfo.year, startDate.getFullYear());\n    // When user entered the day but not (yet) the month, adjust month if possible to propose a valid date\n    if (dateInfo.day && !dateInfo.month) {\n      // If day \"31\" does not exist in the proposed month, use the next month\n      if (dateInfo.day === 31) {\n        let monthsWithThirthyOneDays = [0, 2, 4, 6, 7, 9, 11];\n        if (!scout.isOneOf(validMonth, monthsWithThirthyOneDays)) {\n          validMonth = validMonth + 1;\n        }\n      } else if (dateInfo.day >= 29 && validMonth === 1) {\n        // If day is \"29\" or \"30\" and month is february, use next month (except day is \"29\" and the year is a leap year)\n        if (dateInfo.day > 29 || !dates.isLeapYear(validYear)) {\n          validMonth = validMonth + 1;\n        }\n      }\n    }\n\n    // ensure valid day for selected month for dateInfo without day\n    if (!dateInfo.day && dateInfo.month) {\n      let lastOfMonth = dates.shift(new Date(validYear, dateInfo.month + 1, 1), 0, 0, -1);\n      validDay = Math.min(lastOfMonth.getDate(), startDate.getDate());\n    }\n\n    result.setFullYear(\n      validYear,\n      validMonth,\n      validDay\n    );\n\n    result.setHours(\n      scout.nvl(dateInfo.hours, startDate.getHours()),\n      scout.nvl(dateInfo.minutes, startDate.getMinutes()),\n      scout.nvl(dateInfo.seconds, startDate.getSeconds()),\n      scout.nvl(dateInfo.milliseconds, startDate.getMilliseconds())\n    );\n\n    // Validate. A date is considered valid if the value from the dateInfo did\n    // not change (JS date automatically converts illegal values, e.g. day 32 is\n    // converted to first day of next month).\n    if (!isValid(result.getFullYear(), dateInfo.year)) {\n      return null;\n    }\n    if (!isValid(result.getMonth(), dateInfo.month)) {\n      return null;\n    }\n    if (!isValid(result.getDate(), dateInfo.day)) {\n      return null;\n    }\n    if (!isValid(result.getHours(), dateInfo.hours)) {\n      return null;\n    }\n    if (!isValid(result.getMinutes(), dateInfo.minutes)) {\n      return null;\n    }\n    if (!isValid(result.getSeconds(), dateInfo.seconds)) {\n      return null;\n    }\n    if (!isValid(result.getMilliseconds(), dateInfo.milliseconds)) {\n      return null;\n    }\n    if (!isValid(result.getDay(), objects.optProperty(hints, 'weekday'))) {\n      return null;\n    }\n\n    // Adjust time zone\n    if (numbers.isNumber(dateInfo.timezone)) {\n      result.setMinutes(result.getMinutes() - result.getTimezoneOffset() + dateInfo.timezone);\n    }\n\n    return result;\n\n    // ----- Helper functions -----\n\n    function isValid(value, expectedValue) {\n      return objects.isNullOrUndefined(expectedValue) || expectedValue === value;\n    }\n  }\n\n  /**\n   * Returns the date where parsed information should be applied to. The given\n   * startDate is used when specified, otherwise a new date is created (today).\n   */\n  _prepareStartDate(startDate) {\n    if (startDate) {\n      // It is important that we don't alter the argument 'startDate', but create an independent copy!\n      return new Date(startDate.getTime());\n    }\n    return dates.trunc(new Date()); // clear time\n  }\n\n  /**\n   * Returns the \"format context\", an object that is initially filled with the input date and is then\n   * passed through the various formatting functions. As the formatting progresses, the format context object\n   * is updated accordingly. At the end of the process, the object contains the result.\n   *\n   * The format context contains the following properties:\n   *\n   * inputDate:\n   *   The date to be formatted.\n   *\n   * formattedString:\n   *   The result of the formatting. The string is initially empty. During the format process, the\n   *   formatted parts will be appended to the string until the final string is complete.\n   *\n   * exactLength:\n   *   Flag to force the format functions to use the exact length of the accepted term. The default\n   *   is false, which will use the canonical length. For example, the year pattern 'yyy' will\n   *   format the year using 2 digits by default. If the parameter is true, 3 are used. This is mainly\n   *   useful, when an \"analyzed\" date should be formatted again using the \"parsedPattern\".\n   */\n  _createFormatContext(inputDate) {\n    return {\n      inputDate: inputDate,\n      formattedString: '',\n      exactLength: false\n    };\n  }\n\n  /**\n   * Returns the \"parse context\", an object that is initially filled with the input string and is then\n   * passed through the various parsing functions. As the parsing progresses, the parse context object\n   * is updated accordingly. At the end of the process, the object contains the result.\n   *\n   * The parse context contains the following properties:\n   *\n   * inputString:\n   *   The original input for the parsing. This string will be consumed during the parse process,\n   *   and will be empty at the end.\n   *\n   * dateInfo:\n   *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n   *   parts are undefined, all others are converted to numbers. Those values may be directly\n   *   used in the JavaScript Date() type (month is zero-based!).\n   *   Valid properties:\n   *   - year, month, day, hours, minutes, seconds, milliseconds\n   *\n   * matchInfo:\n   *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n   *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n   *   the month is \"one-based\", as opposed to dateInfo.month!\n   *   Valid properties:\n   *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds\n   *\n   * hints:\n   *   An object that contains further recognized date parts that are not needed to define the exact time.\n   *   Valid properties:\n   *   - am [true / false]\n   *   - pm [true / false]\n   *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n   *   - weekInYear [number 1-53]\n   *\n   * analyze:\n   *   A flag that indicates if the \"analyze mode\" is on. This is true when analyze() was called, and\n   *   false when parse() was called. It may alter the behavior of the parse functions, i.e. they will\n   *   not fail in analyze mode when the pattern does not match exactly.\n   *\n   * startDate:\n   *   A date to be used as reference for date calculations. Is used for example when mapping a 2-digit\n   *   year to a 4-digit year.\n   */\n  _createParseContext(inputText) {\n    return {\n      inputString: inputText,\n      dateInfo: {},\n      matchInfo: {},\n      hints: {},\n      parsedPattern: '',\n      analyze: false,\n      startDate: null\n    };\n  }\n\n  /**\n   * @see analyze()\n   */\n  _createAnalyzeInfo(inputText) {\n    return {\n      inputString: inputText,\n      dateInfo: {},\n      matchInfo: {},\n      hints: {},\n      parsedPattern: '',\n      matchedPattern: '',\n      predictedDate: null,\n      error: false\n    };\n  }\n\n  static ensure(locale, format) {\n    if (!format) {\n      return format;\n    }\n    if (format instanceof DateFormat) {\n      return format;\n    }\n    return new DateFormat(locale, format);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}