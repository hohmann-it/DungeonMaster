{"ast":null,"code":"/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { CellEditorCancelEditKeyStroke, CellEditorCompleteEditKeyStroke, CellEditorPopupLayout, CellEditorTabKeyStroke, events, FormField, graphics, Point, Popup, Rectangle, scout } from '../../index';\nimport $ from 'jquery';\nexport default class CellEditorPopup extends Popup {\n  constructor() {\n    super();\n    this.table = null;\n    this.column = null;\n    this.row = null;\n    this.cell = null;\n    this._pendingCompleteCellEdit = null;\n    this._keyStrokeHandler = this._onKeyStroke.bind(this);\n  }\n  _init(options) {\n    options.scrollType = options.scrollType || 'position';\n    super._init(options);\n    this.table = options.column.table;\n    this.link(this.cell.field);\n  }\n  _createLayout() {\n    return new CellEditorPopupLayout(this);\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke([new CellEditorCompleteEditKeyStroke(this), new CellEditorTabKeyStroke(this)]);\n  }\n\n  /**\n   * @override\n   */\n  _createCloseKeyStroke() {\n    return new CellEditorCancelEditKeyStroke(this);\n  }\n\n  /**\n   * @override\n   */\n  _open($parent, event) {\n    this.render($parent, event);\n    this.position();\n    this.pack();\n  }\n\n  /**\n   * @override\n   */\n  _getDefaultOpen$Parent() {\n    return this.table.$data;\n  }\n  _render() {\n    super._render();\n\n    // determine CSS class for first and last column, required for additional margins/padding in cell-editor\n    let cssClass = '',\n      visibleCols = this.table.visibleColumns(),\n      colPos = visibleCols.indexOf(this.column);\n    if (colPos === 0) {\n      // first cell\n      cssClass = 'first';\n    } else if (colPos === visibleCols.length - 1) {\n      // last cell\n      cssClass = 'last';\n    }\n    this.$container.addClass('cell-editor-popup ' + cssClass).data('popup', this);\n    let field = this.cell.field;\n    field.mode = FormField.Mode.CELLEDITOR; // hint that this field is used within a cell-editor\n    field.render();\n    field.prepareForCellEdit({\n      cssClass: cssClass\n    });\n\n    // Make sure cell content is not visible while the editor is open (especially necessary for transparent editors like checkboxes)\n    this.$anchor.css('visibility', 'hidden');\n    this._rowOrderChangedFunc = event => {\n      if (event.animating) {\n        // row is only set while animating\n        if (event.row === this.row) {\n          this.position();\n        }\n      } else {\n        this.position();\n      }\n    };\n    this.table.on('rowOrderChanged', this._rowOrderChangedFunc);\n    // Set table style to focused, so that it looks as it still has the focus.\n    // This prevents flickering if the cell editor gets opened, especially when tabbing to the next cell editor.\n    if (this.table.enabled) {\n      this.table.$container.addClass('focused');\n    }\n    this.session.keyStrokeManager.on('keyStroke', this._keyStrokeHandler);\n  }\n\n  /**\n   * Selection border is an after element that is moved to top a little to cover the border of the previous row.\n   * This won't happen for the first row if there is no table header, since there is no space on top to move it up.\n   * In that case the selection is moved down by 1px to ensure the height of the selection always stays the same.\n   * If there is no border between the rows, there is no adjustment necessary, the selection is as height as the row.\n   * -> Position and size of the cell editor popup depends on the selection of the current row and the table style (with or without row borders)\n   */\n  _alignWithSelection() {\n    let selectionTop = this._rowSelectionBounds().y;\n    if (selectionTop < 0) {\n      this.$container.cssMarginTop(selectionTop);\n      this.$container.addClass('overflow-top');\n    }\n  }\n  _rowSelectionBounds() {\n    let bounds = new Rectangle();\n    let style = getComputedStyle(this.row.$row[0], ':after');\n    if (style) {\n      bounds = new Rectangle($.pxToNumber(style['left']), $.pxToNumber(style['top']), $.pxToNumber(style['width']), $.pxToNumber(style['height']));\n    }\n    return bounds;\n  }\n  _postRender() {\n    super._postRender(); // installs the focus context for this popup\n\n    // If applicable, invoke the field's function 'onCellEditorRendered' to signal the cell-editor to be rendered.\n    let field = this.cell.field;\n    if (field.onCellEditorRendered) {\n      field.onCellEditorRendered({\n        openFieldPopup: this.table.openFieldPopupOnCellEdit,\n        cellEditorPopup: this\n      });\n    }\n  }\n  _remove() {\n    super._remove(); // uninstalls the focus context for this popup\n\n    this.session.keyStrokeManager.off('keyStroke', this._keyStrokeHandler);\n    this.table.off('rowOrderChanged', this._rowOrderChangedFunc);\n    // table may have been removed in the meantime\n    if (this.table.rendered) {\n      this.table.$container.removeClass('focused');\n    }\n    this.$anchor.css('visibility', '');\n  }\n  position() {\n    let $tableData = this.table.$data,\n      $row = this.row.$row,\n      $cell = this.$anchor,\n      insetsLeft = $tableData.cssPaddingLeft() + $row.cssMarginLeft() + $row.cssBorderLeftWidth();\n    this._alignWithSelection();\n    let cellBounds = graphics.bounds($cell);\n    let rowBounds = graphics.bounds($row);\n    this.setLocation(new Point(insetsLeft + cellBounds.x, $tableData.scrollTop() + rowBounds.y));\n  }\n\n  /**\n   * @returns {Promise} resolved when acceptInput is performed on the editor field\n   */\n  completeEdit(waitForAcceptInput) {\n    if (this._pendingCompleteCellEdit) {\n      // Make sure complete cell edit does not get sent twice since it will lead to exceptions. This may happen if user clicks very fast multiple times.\n      return this._pendingCompleteCellEdit;\n    }\n\n    // There is no blur event when the popup gets closed -> trigger blur so that the field may react (accept display text, close popups etc.)\n    // When acceptInput returns a promise, we must wait until input is accepted\n    // Otherwise call completeEdit immediately, also call it immediately if waitForAcceptInput is false (see _onKeyStroke)\n    let field = this.cell.field;\n    let acceptInputPromise = field.acceptInput();\n    if (!acceptInputPromise || !scout.nvl(waitForAcceptInput, true)) {\n      this._pendingCompleteCellEdit = $.resolvedPromise();\n      this.table.completeCellEdit();\n    } else {\n      this._pendingCompleteCellEdit = acceptInputPromise.then(() => {\n        this.table.completeCellEdit();\n      });\n    }\n    this._pendingCompleteCellEdit.then(() => {\n      // Ensure complete will never be called more than once\n      this._pendingCompleteCellEdit = $.resolvedPromise();\n    });\n    return this._pendingCompleteCellEdit;\n  }\n  isCompleteCellEditRequested() {\n    return !!this._pendingCompleteCellEdit;\n  }\n  cancelEdit() {\n    this.table.cancelCellEdit();\n    this.remove();\n  }\n  _onMouseDownOutside(event) {\n    let $clickedRow = $(event.target).closest('.table-row', this.table.$container[0]);\n    // noinspection JSIgnoredPromiseFromCall\n    this.completeEdit();\n\n    // When the edit completes the edited row is updated and replaced with new html elements.\n    // When the user clicks on a cell of such a row that will be updated in order to complete the edit, the mouse down handler of the table won't be triggered.\n    // The mouse up handler will be triggered but does nothing because _$mouseDownRow is not set (which would be done by the mouse down handler).\n    // To make sure the new cell editor opens correctly we need to delegate the event to the new row that should receive the click to ensure table._onRowMouseDown is executed.\n    if ($clickedRow.length > 0 && !$clickedRow.isAttached()) {\n      this._propagateMouseDownToTableRow(event);\n    }\n  }\n  _propagateMouseDownToTableRow(event) {\n    let doc = this.table.$container.document(true);\n    let $target = $(doc.elementFromPoint(event.pageX, event.pageY));\n    let $clickedRow = $target.closest('.table-row', this.table.$container[0]);\n    if ($clickedRow.length === 0) {\n      return;\n    }\n    events.propagateEvent($target[0], event);\n  }\n  _onKeyStroke(event) {\n    if (!this._invokeCompleteEditBeforeKeyStroke(event)) {\n      return;\n    }\n    // Make sure completeEdit is called immediately after calling acceptInput.\n    // Otherwise the key stroke will be executed before completing the edit which prevents the input from being saved\n    // noinspection JSIgnoredPromiseFromCall\n    this.completeEdit(false);\n  }\n  _invokeCompleteEditBeforeKeyStroke(event) {\n    if (!this.session.keyStrokeManager.invokeAcceptInputOnActiveValueField(event.keyStroke, event.keyStrokeContext)) {\n      return false;\n    }\n    if (this.$container.isOrHas(event.keyStrokeContext.$getScopeTarget())) {\n      // Don't interfere with key strokes of the popup or children of the popup (otherwise pressing enter would close both the popup and the form at once)\n      return false;\n    }\n    return true;\n  }\n  waitForCompleteCellEdit() {\n    if (this._pendingCompleteCellEdit) {\n      return this._pendingCompleteCellEdit.promise();\n    }\n    return $.resolvedPromise();\n  }\n}","map":{"version":3,"names":["CellEditorCancelEditKeyStroke","CellEditorCompleteEditKeyStroke","CellEditorPopupLayout","CellEditorTabKeyStroke","events","FormField","graphics","Point","Popup","Rectangle","scout","$","CellEditorPopup","constructor","table","column","row","cell","_pendingCompleteCellEdit","_keyStrokeHandler","_onKeyStroke","bind","_init","options","scrollType","link","field","_createLayout","_initKeyStrokeContext","keyStrokeContext","registerKeyStroke","_createCloseKeyStroke","_open","$parent","event","render","position","pack","_getDefaultOpen$Parent","$data","_render","cssClass","visibleCols","visibleColumns","colPos","indexOf","length","$container","addClass","data","mode","Mode","CELLEDITOR","prepareForCellEdit","$anchor","css","_rowOrderChangedFunc","animating","on","enabled","session","keyStrokeManager","_alignWithSelection","selectionTop","_rowSelectionBounds","y","cssMarginTop","bounds","style","getComputedStyle","$row","pxToNumber","_postRender","onCellEditorRendered","openFieldPopup","openFieldPopupOnCellEdit","cellEditorPopup","_remove","off","rendered","removeClass","$tableData","$cell","insetsLeft","cssPaddingLeft","cssMarginLeft","cssBorderLeftWidth","cellBounds","rowBounds","setLocation","x","scrollTop","completeEdit","waitForAcceptInput","acceptInputPromise","acceptInput","nvl","resolvedPromise","completeCellEdit","then","isCompleteCellEditRequested","cancelEdit","cancelCellEdit","remove","_onMouseDownOutside","$clickedRow","target","closest","isAttached","_propagateMouseDownToTableRow","doc","document","$target","elementFromPoint","pageX","pageY","propagateEvent","_invokeCompleteEditBeforeKeyStroke","invokeAcceptInputOnActiveValueField","keyStroke","isOrHas","$getScopeTarget","waitForCompleteCellEdit","promise"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/editor/CellEditorPopup.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {CellEditorCancelEditKeyStroke, CellEditorCompleteEditKeyStroke, CellEditorPopupLayout, CellEditorTabKeyStroke, events, FormField, graphics, Point, Popup, Rectangle, scout} from '../../index';\nimport $ from 'jquery';\n\nexport default class CellEditorPopup extends Popup {\n\n  constructor() {\n    super();\n    this.table = null;\n    this.column = null;\n    this.row = null;\n    this.cell = null;\n    this._pendingCompleteCellEdit = null;\n    this._keyStrokeHandler = this._onKeyStroke.bind(this);\n  }\n\n  _init(options) {\n    options.scrollType = options.scrollType || 'position';\n    super._init(options);\n\n    this.table = options.column.table;\n    this.link(this.cell.field);\n  }\n\n  _createLayout() {\n    return new CellEditorPopupLayout(this);\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke([\n      new CellEditorCompleteEditKeyStroke(this),\n      new CellEditorTabKeyStroke(this)\n    ]);\n  }\n\n  /**\n   * @override\n   */\n  _createCloseKeyStroke() {\n    return new CellEditorCancelEditKeyStroke(this);\n  }\n\n  /**\n   * @override\n   */\n  _open($parent, event) {\n    this.render($parent, event);\n    this.position();\n    this.pack();\n  }\n\n  /**\n   * @override\n   */\n  _getDefaultOpen$Parent() {\n    return this.table.$data;\n  }\n\n  _render() {\n    super._render();\n\n    // determine CSS class for first and last column, required for additional margins/padding in cell-editor\n    let cssClass = '',\n      visibleCols = this.table.visibleColumns(),\n      colPos = visibleCols.indexOf(this.column);\n    if (colPos === 0) { // first cell\n      cssClass = 'first';\n    } else if (colPos === visibleCols.length - 1) { // last cell\n      cssClass = 'last';\n    }\n\n    this.$container\n      .addClass('cell-editor-popup ' + cssClass)\n      .data('popup', this);\n\n    let field = this.cell.field;\n    field.mode = FormField.Mode.CELLEDITOR; // hint that this field is used within a cell-editor\n    field.render();\n    field.prepareForCellEdit({\n      cssClass: cssClass\n    });\n\n    // Make sure cell content is not visible while the editor is open (especially necessary for transparent editors like checkboxes)\n    this.$anchor.css('visibility', 'hidden');\n\n    this._rowOrderChangedFunc = event => {\n      if (event.animating) {\n        // row is only set while animating\n        if (event.row === this.row) {\n          this.position();\n        }\n      } else {\n        this.position();\n      }\n    };\n    this.table.on('rowOrderChanged', this._rowOrderChangedFunc);\n    // Set table style to focused, so that it looks as it still has the focus.\n    // This prevents flickering if the cell editor gets opened, especially when tabbing to the next cell editor.\n    if (this.table.enabled) {\n      this.table.$container.addClass('focused');\n    }\n    this.session.keyStrokeManager.on('keyStroke', this._keyStrokeHandler);\n  }\n\n  /**\n   * Selection border is an after element that is moved to top a little to cover the border of the previous row.\n   * This won't happen for the first row if there is no table header, since there is no space on top to move it up.\n   * In that case the selection is moved down by 1px to ensure the height of the selection always stays the same.\n   * If there is no border between the rows, there is no adjustment necessary, the selection is as height as the row.\n   * -> Position and size of the cell editor popup depends on the selection of the current row and the table style (with or without row borders)\n   */\n  _alignWithSelection() {\n    let selectionTop = this._rowSelectionBounds().y;\n    if (selectionTop < 0) {\n      this.$container.cssMarginTop(selectionTop);\n      this.$container.addClass('overflow-top');\n    }\n  }\n\n  _rowSelectionBounds() {\n    let bounds = new Rectangle();\n    let style = getComputedStyle(this.row.$row[0], ':after');\n    if (style) {\n      bounds = new Rectangle($.pxToNumber(style['left']), $.pxToNumber(style['top']), $.pxToNumber(style['width']), $.pxToNumber(style['height']));\n    }\n    return bounds;\n  }\n\n  _postRender() {\n    super._postRender(); // installs the focus context for this popup\n\n    // If applicable, invoke the field's function 'onCellEditorRendered' to signal the cell-editor to be rendered.\n    let field = this.cell.field;\n    if (field.onCellEditorRendered) {\n      field.onCellEditorRendered({\n        openFieldPopup: this.table.openFieldPopupOnCellEdit,\n        cellEditorPopup: this\n      });\n    }\n  }\n\n  _remove() {\n    super._remove(); // uninstalls the focus context for this popup\n\n    this.session.keyStrokeManager.off('keyStroke', this._keyStrokeHandler);\n    this.table.off('rowOrderChanged', this._rowOrderChangedFunc);\n    // table may have been removed in the meantime\n    if (this.table.rendered) {\n      this.table.$container.removeClass('focused');\n    }\n    this.$anchor.css('visibility', '');\n  }\n\n  position() {\n    let $tableData = this.table.$data,\n      $row = this.row.$row,\n      $cell = this.$anchor,\n      insetsLeft = $tableData.cssPaddingLeft() + $row.cssMarginLeft() + $row.cssBorderLeftWidth();\n\n    this._alignWithSelection();\n\n    let cellBounds = graphics.bounds($cell);\n    let rowBounds = graphics.bounds($row);\n    this.setLocation(new Point(insetsLeft + cellBounds.x, $tableData.scrollTop() + rowBounds.y));\n  }\n\n  /**\n   * @returns {Promise} resolved when acceptInput is performed on the editor field\n   */\n  completeEdit(waitForAcceptInput) {\n    if (this._pendingCompleteCellEdit) {\n      // Make sure complete cell edit does not get sent twice since it will lead to exceptions. This may happen if user clicks very fast multiple times.\n      return this._pendingCompleteCellEdit;\n    }\n\n    // There is no blur event when the popup gets closed -> trigger blur so that the field may react (accept display text, close popups etc.)\n    // When acceptInput returns a promise, we must wait until input is accepted\n    // Otherwise call completeEdit immediately, also call it immediately if waitForAcceptInput is false (see _onKeyStroke)\n    let field = this.cell.field;\n    let acceptInputPromise = field.acceptInput();\n    if (!acceptInputPromise || !scout.nvl(waitForAcceptInput, true)) {\n      this._pendingCompleteCellEdit = $.resolvedPromise();\n      this.table.completeCellEdit();\n    } else {\n      this._pendingCompleteCellEdit = acceptInputPromise.then(() => {\n        this.table.completeCellEdit();\n      });\n    }\n\n    this._pendingCompleteCellEdit.then(() => {\n      // Ensure complete will never be called more than once\n      this._pendingCompleteCellEdit = $.resolvedPromise();\n    });\n\n    return this._pendingCompleteCellEdit;\n  }\n\n  isCompleteCellEditRequested() {\n    return !!this._pendingCompleteCellEdit;\n  }\n\n  cancelEdit() {\n    this.table.cancelCellEdit();\n    this.remove();\n  }\n\n  _onMouseDownOutside(event) {\n    let $clickedRow = $(event.target).closest('.table-row', this.table.$container[0]);\n    // noinspection JSIgnoredPromiseFromCall\n    this.completeEdit();\n\n    // When the edit completes the edited row is updated and replaced with new html elements.\n    // When the user clicks on a cell of such a row that will be updated in order to complete the edit, the mouse down handler of the table won't be triggered.\n    // The mouse up handler will be triggered but does nothing because _$mouseDownRow is not set (which would be done by the mouse down handler).\n    // To make sure the new cell editor opens correctly we need to delegate the event to the new row that should receive the click to ensure table._onRowMouseDown is executed.\n    if ($clickedRow.length > 0 && !$clickedRow.isAttached()) {\n      this._propagateMouseDownToTableRow(event);\n    }\n  }\n\n  _propagateMouseDownToTableRow(event) {\n    let doc = this.table.$container.document(true);\n    let $target = $(doc.elementFromPoint(event.pageX, event.pageY));\n    let $clickedRow = $target.closest('.table-row', this.table.$container[0]);\n    if ($clickedRow.length === 0) {\n      return;\n    }\n    events.propagateEvent($target[0], event);\n  }\n\n  _onKeyStroke(event) {\n    if (!this._invokeCompleteEditBeforeKeyStroke(event)) {\n      return;\n    }\n    // Make sure completeEdit is called immediately after calling acceptInput.\n    // Otherwise the key stroke will be executed before completing the edit which prevents the input from being saved\n    // noinspection JSIgnoredPromiseFromCall\n    this.completeEdit(false);\n  }\n\n  _invokeCompleteEditBeforeKeyStroke(event) {\n    if (!this.session.keyStrokeManager.invokeAcceptInputOnActiveValueField(event.keyStroke, event.keyStrokeContext)) {\n      return false;\n    }\n    if (this.$container.isOrHas(event.keyStrokeContext.$getScopeTarget())) {\n      // Don't interfere with key strokes of the popup or children of the popup (otherwise pressing enter would close both the popup and the form at once)\n      return false;\n    }\n    return true;\n  }\n\n  waitForCompleteCellEdit() {\n    if (this._pendingCompleteCellEdit) {\n      return this._pendingCompleteCellEdit.promise();\n    }\n    return $.resolvedPromise();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}