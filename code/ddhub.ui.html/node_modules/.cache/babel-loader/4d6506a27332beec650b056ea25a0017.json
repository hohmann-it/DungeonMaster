{"ast":null,"code":"/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, scout } from '../index';\nimport $ from 'jquery';\nlet modelMap = {};\nexport function init(data) {\n  modelMap = data;\n}\n\n/**\n * Returns a new instance of a model supplied by the given model func\n *\n * @param {Function} modelFunc A function that returns the model instance.\n * @param {Object} [parent]\n *          Optional parent that is set on the returned object.\n * @returns {Object}\n */\nexport function get(modelFunc, parent) {\n  let model = modelFunc();\n  if (parent) {\n    model.parent = parent;\n  }\n  return model;\n}\n\n/**\n * Returns a new instance of of an extension from the global modelMap.\n *\n * @param {string} extensionId\n *          The id of the extension.\n * @returns {Object}\n */\nexport function getExtension(extensionId) {\n  return _get(extensionId, 'extension');\n}\n\n/**\n * Returns a copy of the object in the global modelMap.\n *\n * @param id\n *          ID of the requested object (model or extension)\n * @param type\n *          Expected type of the requested object ('model' or 'extension')\n * @returns {Object}\n */\n\nexport function _get(id, type) {\n  let model = modelMap[id];\n  if (!model) {\n    throw new Error('No model map entry found for id \\'' + id + '\\'');\n  }\n  if (scout.nvl(model.type, 'model') !== type) {\n    throw new Error('Model \\'' + id + '\\' is not of type \\'' + type + '\\'');\n  }\n  return $.extend(true, {}, model);\n}\n\n/**\n * Extends 'parentModel' with the contents of 'extension'.\n *\n * Parent model\n * ------------\n * The 'parentModel' argument (mandatory) will be changed and returned.\n *\n * Extension\n * ---------\n * Needs a property id on the parentModel to find the extension point.\n * Syntax of the extension:\n *\n * [appendTo]\n * Adding or overriding a property:\n *   {\n *     \"id\": \"...\"\n *     \"type\": \"extension\"\n *     \"extensions\": [\n *       {\n *         \"operation\": \"appendTo\"\n *         \"target\": {\n *           \"id\": \"someObjectID\"\n *         }\n *         \"extension\": {\n *           \"propertyX\": \"xyz\"\n *         }\n *       }\n *     ]\n *   }\n *\n * [insert]\n * Adding new object to the tree:\n *   {\n *     \"id\": \"...\"\n *     \"type\": \"extension\"\n *     \"extensions\": [\n *       {\n *         \"operation\": \"insert\",\n *         \"target\": {\n *           \"id\": \"someObjectID\",\n *           \"property\": \"collectionOfsomeObject\",\n *           \"before\": \"somObjectIDInPropertyArray\"    // (alternative \"index\": 0)\n *         },\n *         \"extension\": {\n *            \"id\": \"newObjectID\",\n *            \"propertyx\": \"someThing\",\n *            \"collectiony\": [...]\n *         }\n *       }\n *     ]\n *   }\n *\n * To extend the root object directly, \"target.root: true\" can be used instead of \"target.id\".\n *\n * To group inserted elements positions with its target use:\n *   \"target\": {\n *     \"id\": \"someObjectID\",\n *     \"property\": \"collectionOfsomeObject\",\n *     \"before\": \"somObjectIDInPropertyArray\",\n *     \"groupWithTarget\": true\n *   }\n * This will group the properties together. future extensions which use \"before\": \"somObjectIDInPropertyArray\"\n * will insert new elements before the grouped items. (Works the same with \"after\".)\n *\n * The extension property can be an object or an array of objects.\n *\n * @param extension {Object|string|function|}\n *          extension to the parentModel.\n * @param parentModel {Object}\n *          object which contains id's as properties\n * @returns parentModel extended by extension\n */\nexport function extend(extension, parentModel) {\n  if (typeof extension === 'string') {\n    extension = getExtension(extension);\n  }\n  if (typeof extension === 'function') {\n    extension = extension();\n  }\n  scout.assertParameter('extensions', extension.extensions);\n  extension.extensions.forEach(extensionConfig => {\n    let operation = scout.assertParameter('operation', extensionConfig.operation);\n    let target = scout.assertParameter('target', extensionConfig.target);\n    let targetObject;\n    if (target.root) {\n      targetObject = parentModel;\n    } else {\n      targetObject = objects.findChildObjectByKey(parentModel, 'id', target.id);\n    }\n    if (!targetObject) {\n      throw new Error('Extension target not found: [extension: ' + extension.id + ', target: ' + target.id + ']');\n    }\n    if (operation === 'appendTo') {\n      $.extend(targetObject, extensionConfig.extension);\n    } else if (operation === 'insert') {\n      targetObject[target.property] = targetObject[target.property] || [];\n      let targetArray = targetObject[target.property];\n      let extensionArray = arrays.ensure(extensionConfig.extension);\n      _bindExtensionsToBeforeOrAfter(target, extensionArray);\n      let insertAt = _findExtensionIndex(target, targetArray);\n      arrays.insertAll(targetArray, extensionArray, insertAt);\n    }\n  });\n  return parentModel;\n}\n\n/**\n * Finds the index in the target array which is given through the target.\n *\n * @param target\n *          target information to search the index (either fixed index or a \"before\" or \"after\" tag).\n * @param targetArray\n *          array to search the extension index in.\n * @returns extension index between 0 and targetArray.length or targetArray.length if no index is found.\n */\n\nexport function _findExtensionIndex(target, targetArray) {\n  let insertAt = targetArray.length;\n  if (target.before) {\n    insertAt = arrays.findIndex(targetArray, element => {\n      return element.id === target.before || element.groupedWith === target.before;\n    });\n    if (insertAt === -1) {\n      insertAt = targetArray.length;\n    }\n  } else if (target.after) {\n    insertAt = arrays.findIndex(targetArray, element => {\n      return element.id === target.after || element.groupedWith === target.after;\n    });\n    if (insertAt === -1) {\n      insertAt = targetArray.length;\n    } else {\n      insertAt++;\n    }\n  }\n  if ($.isNumeric(target.index)) {\n    insertAt = target.index;\n  }\n  return insertAt;\n}\n\n/**\n * Adds the groupedWith tag to all given extensions.\n *\n * @param target\n *          target to bind the extensions to.\n * @param extensionsArray\n *          extensions to bind\n */\n\nexport function _bindExtensionsToBeforeOrAfter(target, extensionsArray) {\n  let beforeOrAfter = target.before || target.after;\n  if (beforeOrAfter && target.groupWithTarget) {\n    extensionsArray.forEach(element => {\n      element.groupedWith = beforeOrAfter;\n    });\n  }\n}\nexport default {\n  init,\n  extend,\n  get,\n  getExtension,\n  modelMap\n};","map":{"version":3,"names":["arrays","objects","scout","$","modelMap","init","data","get","modelFunc","parent","model","getExtension","extensionId","_get","id","type","Error","nvl","extend","extension","parentModel","assertParameter","extensions","forEach","extensionConfig","operation","target","targetObject","root","findChildObjectByKey","property","targetArray","extensionArray","ensure","_bindExtensionsToBeforeOrAfter","insertAt","_findExtensionIndex","insertAll","length","before","findIndex","element","groupedWith","after","isNumeric","index","extensionsArray","beforeOrAfter","groupWithTarget"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/models.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, scout} from '../index';\nimport $ from 'jquery';\n\nlet modelMap = {};\n\nexport function init(data) {\n  modelMap = data;\n}\n\n/**\n * Returns a new instance of a model supplied by the given model func\n *\n * @param {Function} modelFunc A function that returns the model instance.\n * @param {Object} [parent]\n *          Optional parent that is set on the returned object.\n * @returns {Object}\n */\nexport function get(modelFunc, parent) {\n  let model = modelFunc();\n  if (parent) {\n    model.parent = parent;\n  }\n  return model;\n}\n\n/**\n * Returns a new instance of of an extension from the global modelMap.\n *\n * @param {string} extensionId\n *          The id of the extension.\n * @returns {Object}\n */\nexport function getExtension(extensionId) {\n  return _get(extensionId, 'extension');\n}\n\n/**\n * Returns a copy of the object in the global modelMap.\n *\n * @param id\n *          ID of the requested object (model or extension)\n * @param type\n *          Expected type of the requested object ('model' or 'extension')\n * @returns {Object}\n */\n\nexport function _get(id, type) {\n  let model = modelMap[id];\n  if (!model) {\n    throw new Error('No model map entry found for id \\'' + id + '\\'');\n  }\n  if (scout.nvl(model.type, 'model') !== type) {\n    throw new Error('Model \\'' + id + '\\' is not of type \\'' + type + '\\'');\n  }\n  return $.extend(true, {}, model);\n}\n\n/**\n * Extends 'parentModel' with the contents of 'extension'.\n *\n * Parent model\n * ------------\n * The 'parentModel' argument (mandatory) will be changed and returned.\n *\n * Extension\n * ---------\n * Needs a property id on the parentModel to find the extension point.\n * Syntax of the extension:\n *\n * [appendTo]\n * Adding or overriding a property:\n *   {\n *     \"id\": \"...\"\n *     \"type\": \"extension\"\n *     \"extensions\": [\n *       {\n *         \"operation\": \"appendTo\"\n *         \"target\": {\n *           \"id\": \"someObjectID\"\n *         }\n *         \"extension\": {\n *           \"propertyX\": \"xyz\"\n *         }\n *       }\n *     ]\n *   }\n *\n * [insert]\n * Adding new object to the tree:\n *   {\n *     \"id\": \"...\"\n *     \"type\": \"extension\"\n *     \"extensions\": [\n *       {\n *         \"operation\": \"insert\",\n *         \"target\": {\n *           \"id\": \"someObjectID\",\n *           \"property\": \"collectionOfsomeObject\",\n *           \"before\": \"somObjectIDInPropertyArray\"    // (alternative \"index\": 0)\n *         },\n *         \"extension\": {\n *            \"id\": \"newObjectID\",\n *            \"propertyx\": \"someThing\",\n *            \"collectiony\": [...]\n *         }\n *       }\n *     ]\n *   }\n *\n * To extend the root object directly, \"target.root: true\" can be used instead of \"target.id\".\n *\n * To group inserted elements positions with its target use:\n *   \"target\": {\n *     \"id\": \"someObjectID\",\n *     \"property\": \"collectionOfsomeObject\",\n *     \"before\": \"somObjectIDInPropertyArray\",\n *     \"groupWithTarget\": true\n *   }\n * This will group the properties together. future extensions which use \"before\": \"somObjectIDInPropertyArray\"\n * will insert new elements before the grouped items. (Works the same with \"after\".)\n *\n * The extension property can be an object or an array of objects.\n *\n * @param extension {Object|string|function|}\n *          extension to the parentModel.\n * @param parentModel {Object}\n *          object which contains id's as properties\n * @returns parentModel extended by extension\n */\nexport function extend(extension, parentModel) {\n  if (typeof extension === 'string') {\n    extension = getExtension(extension);\n  }\n\n  if (typeof extension === 'function') {\n    extension = extension();\n  }\n\n  scout.assertParameter('extensions', extension.extensions);\n  extension.extensions.forEach(extensionConfig => {\n    let operation = scout.assertParameter('operation', extensionConfig.operation);\n    let target = scout.assertParameter('target', extensionConfig.target);\n\n    let targetObject;\n    if (target.root) {\n      targetObject = parentModel;\n    } else {\n      targetObject = objects.findChildObjectByKey(parentModel, 'id', target.id);\n    }\n    if (!targetObject) {\n      throw new Error('Extension target not found: [extension: ' + extension.id + ', target: ' + target.id + ']');\n    }\n\n    if (operation === 'appendTo') {\n      $.extend(targetObject, extensionConfig.extension);\n    } else if (operation === 'insert') {\n      targetObject[target.property] = targetObject[target.property] || [];\n      let targetArray = targetObject[target.property];\n      let extensionArray = arrays.ensure(extensionConfig.extension);\n      _bindExtensionsToBeforeOrAfter(target, extensionArray);\n      let insertAt = _findExtensionIndex(target, targetArray);\n      arrays.insertAll(targetArray, extensionArray, insertAt);\n    }\n  });\n\n  return parentModel;\n}\n\n/**\n * Finds the index in the target array which is given through the target.\n *\n * @param target\n *          target information to search the index (either fixed index or a \"before\" or \"after\" tag).\n * @param targetArray\n *          array to search the extension index in.\n * @returns extension index between 0 and targetArray.length or targetArray.length if no index is found.\n */\n\nexport function _findExtensionIndex(target, targetArray) {\n  let insertAt = targetArray.length;\n  if (target.before) {\n    insertAt = arrays.findIndex(targetArray, element => {\n      return element.id === target.before || element.groupedWith === target.before;\n    });\n    if (insertAt === -1) {\n      insertAt = targetArray.length;\n    }\n  } else if (target.after) {\n    insertAt = arrays.findIndex(targetArray, element => {\n      return element.id === target.after || element.groupedWith === target.after;\n    });\n    if (insertAt === -1) {\n      insertAt = targetArray.length;\n    } else {\n      insertAt++;\n    }\n  }\n  if ($.isNumeric(target.index)) {\n    insertAt = target.index;\n  }\n  return insertAt;\n}\n\n/**\n * Adds the groupedWith tag to all given extensions.\n *\n * @param target\n *          target to bind the extensions to.\n * @param extensionsArray\n *          extensions to bind\n */\n\nexport function _bindExtensionsToBeforeOrAfter(target, extensionsArray) {\n  let beforeOrAfter = target.before || target.after;\n  if (beforeOrAfter && target.groupWithTarget) {\n    extensionsArray.forEach(element => {\n      element.groupedWith = beforeOrAfter;\n    });\n  }\n}\n\nexport default {\n  init,\n  extend,\n  get,\n  getExtension,\n  modelMap\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}