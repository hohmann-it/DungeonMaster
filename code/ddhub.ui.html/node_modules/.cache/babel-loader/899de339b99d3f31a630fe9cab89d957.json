{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { App, arrays, Device } from '../index';\nexport default class LayoutValidator {\n  constructor() {\n    this._invalidComponents = [];\n    this._validateTimeoutId = null;\n    this._postValidateFunctions = [];\n    this._suppressValidate = false;\n  }\n  invalidateTree(htmlComp) {\n    let validateRoot,\n      htmlParent = htmlComp,\n      htmlSource = htmlComp;\n\n    // Mark every parent as invalid until validate root\n    while (htmlParent) {\n      htmlComp = htmlParent;\n      htmlComp.invalidateLayout(htmlSource);\n      if (htmlComp.isValidateRoot()) {\n        validateRoot = htmlComp;\n        break;\n      }\n      htmlParent = htmlComp.getParent();\n    }\n    if (!htmlParent) {\n      validateRoot = htmlComp;\n    }\n    this.invalidate(validateRoot);\n  }\n  invalidate(htmlComp) {\n    let position = 0;\n    // Don't insert if already inserted...\n    // Info: when component is already in list but no one triggers validation,\n    // validation is never scheduled that's why we call scheduleValidation here.\n    if (this._invalidComponents.indexOf(htmlComp) >= 0) {\n      this._scheduleValidation(); // ... but schedule validation\n      return;\n    }\n\n    // Make sure it will be inserted before any descendant\n    // This prevents multiple layouting of the descendant\n    this._invalidComponents.forEach((invalidComponent, i) => {\n      if (invalidComponent.isDescendantOf(htmlComp)) {\n        return;\n      }\n      position++;\n    }, this);\n\n    // Add validate root to list of invalid components. These are the starting point for a subsequent call to validate().\n    arrays.insert(this._invalidComponents, htmlComp, position);\n    this._scheduleValidation();\n  }\n  _scheduleValidation() {\n    if (this._validateTimeoutId !== null) {\n      // Task already scheduled\n      return;\n    }\n    if (Device.get().supportsMicrotask()) {\n      this._validateTimeoutId = true; // boolean is sufficient, an id is only necessary for legacy purpose when setTimeout is used\n      queueMicrotask(() => {\n        // Validate, but only if still required\n        if (this._validateTimeoutId) {\n          try {\n            this.validate();\n          } catch (e) {\n            // Without handling the exception it would be swallowed (as it happens for promises)\n            App.get().errorHandler.handle(e);\n          }\n        }\n      });\n    } else {\n      this._validateTimeoutId = setTimeout(() => this.validate());\n    }\n  }\n\n  /**\n   * Layouts all invalid components (as long as they haven't been removed).\n   */\n  validate() {\n    if (!Device.get().supportsMicrotask()) {\n      clearTimeout(this._validateTimeoutId);\n    }\n    this._validateTimeoutId = null;\n    if (this._suppressValidate) {\n      return;\n    }\n    this._invalidComponents.slice().forEach(function (comp) {\n      if (comp.validateLayout()) {\n        arrays.remove(this._invalidComponents, comp);\n      }\n    }, this);\n    this._postValidateFunctions.slice().forEach(function (func) {\n      func();\n      arrays.remove(this._postValidateFunctions, func);\n    }, this);\n  }\n\n  /**\n   * Suppresses every upcoming validations. The caller has to call {@link unsuppressValidate} to reactive validation again.\n   * Can be useful if the browser starts the processing of the micro task queue unexpectedly (e.g. when inserting certain DOM elements).\n   */\n  suppressValidate() {\n    this._suppressValidate = true;\n  }\n  unsuppressValidate() {\n    this._suppressValidate = false;\n    this._scheduleValidation();\n  }\n\n  /**\n   * Removes those components from this._invalidComponents which have the given container as ancestor.\n   * The idea is to remove all components whose ancestor is about to be removed from the DOM.\n   */\n  cleanupInvalidComponents($parentContainer) {\n    this._invalidComponents.slice().forEach(function (comp) {\n      if (comp.$comp.closest($parentContainer).length > 0) {\n        arrays.remove(this._invalidComponents, comp);\n      }\n    }, this);\n  }\n\n  /**\n   * Runs the given function at the end of validate().\n   */\n  schedulePostValidateFunction(func) {\n    if (func) {\n      this._postValidateFunctions.push(func);\n    }\n  }\n}","map":{"version":3,"names":["App","arrays","Device","LayoutValidator","constructor","_invalidComponents","_validateTimeoutId","_postValidateFunctions","_suppressValidate","invalidateTree","htmlComp","validateRoot","htmlParent","htmlSource","invalidateLayout","isValidateRoot","getParent","invalidate","position","indexOf","_scheduleValidation","forEach","invalidComponent","i","isDescendantOf","insert","get","supportsMicrotask","queueMicrotask","validate","e","errorHandler","handle","setTimeout","clearTimeout","slice","comp","validateLayout","remove","func","suppressValidate","unsuppressValidate","cleanupInvalidComponents","$parentContainer","$comp","closest","length","schedulePostValidateFunction","push"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/layout/LayoutValidator.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {App, arrays, Device} from '../index';\n\nexport default class LayoutValidator {\n\n  constructor() {\n    this._invalidComponents = [];\n    this._validateTimeoutId = null;\n    this._postValidateFunctions = [];\n    this._suppressValidate = false;\n  }\n\n  invalidateTree(htmlComp) {\n    let validateRoot,\n      htmlParent = htmlComp,\n      htmlSource = htmlComp;\n\n    // Mark every parent as invalid until validate root\n    while (htmlParent) {\n      htmlComp = htmlParent;\n      htmlComp.invalidateLayout(htmlSource);\n      if (htmlComp.isValidateRoot()) {\n        validateRoot = htmlComp;\n        break;\n      }\n      htmlParent = htmlComp.getParent();\n    }\n\n    if (!htmlParent) {\n      validateRoot = htmlComp;\n    }\n\n    this.invalidate(validateRoot);\n  }\n\n  invalidate(htmlComp) {\n    let position = 0;\n    // Don't insert if already inserted...\n    // Info: when component is already in list but no one triggers validation,\n    // validation is never scheduled that's why we call scheduleValidation here.\n    if (this._invalidComponents.indexOf(htmlComp) >= 0) {\n      this._scheduleValidation(); // ... but schedule validation\n      return;\n    }\n\n    // Make sure it will be inserted before any descendant\n    // This prevents multiple layouting of the descendant\n    this._invalidComponents.forEach((invalidComponent, i) => {\n      if (invalidComponent.isDescendantOf(htmlComp)) {\n        return;\n      }\n      position++;\n    }, this);\n\n    // Add validate root to list of invalid components. These are the starting point for a subsequent call to validate().\n    arrays.insert(this._invalidComponents, htmlComp, position);\n\n    this._scheduleValidation();\n  }\n\n  _scheduleValidation() {\n    if (this._validateTimeoutId !== null) {\n      // Task already scheduled\n      return;\n    }\n    if (Device.get().supportsMicrotask()) {\n      this._validateTimeoutId = true; // boolean is sufficient, an id is only necessary for legacy purpose when setTimeout is used\n      queueMicrotask(() => {\n        // Validate, but only if still required\n        if (this._validateTimeoutId) {\n          try {\n            this.validate();\n          } catch (e) {\n            // Without handling the exception it would be swallowed (as it happens for promises)\n            App.get().errorHandler.handle(e);\n          }\n        }\n      });\n    } else {\n      this._validateTimeoutId = setTimeout(() => this.validate());\n    }\n  }\n\n  /**\n   * Layouts all invalid components (as long as they haven't been removed).\n   */\n  validate() {\n    if (!Device.get().supportsMicrotask()) {\n      clearTimeout(this._validateTimeoutId);\n    }\n    this._validateTimeoutId = null;\n    if (this._suppressValidate) {\n      return;\n    }\n    this._invalidComponents.slice().forEach(function(comp) {\n      if (comp.validateLayout()) {\n        arrays.remove(this._invalidComponents, comp);\n      }\n    }, this);\n    this._postValidateFunctions.slice().forEach(function(func) {\n      func();\n      arrays.remove(this._postValidateFunctions, func);\n    }, this);\n  }\n\n  /**\n   * Suppresses every upcoming validations. The caller has to call {@link unsuppressValidate} to reactive validation again.\n   * Can be useful if the browser starts the processing of the micro task queue unexpectedly (e.g. when inserting certain DOM elements).\n   */\n  suppressValidate() {\n    this._suppressValidate = true;\n  }\n\n  unsuppressValidate() {\n    this._suppressValidate = false;\n    this._scheduleValidation();\n  }\n\n  /**\n   * Removes those components from this._invalidComponents which have the given container as ancestor.\n   * The idea is to remove all components whose ancestor is about to be removed from the DOM.\n   */\n  cleanupInvalidComponents($parentContainer) {\n    this._invalidComponents.slice().forEach(function(comp) {\n      if (comp.$comp.closest($parentContainer).length > 0) {\n        arrays.remove(this._invalidComponents, comp);\n      }\n    }, this);\n  }\n\n  /**\n   * Runs the given function at the end of validate().\n   */\n  schedulePostValidateFunction(func) {\n    if (func) {\n      this._postValidateFunctions.push(func);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}