{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, DateFormat, DatePickerPopup, DatePredictionFailedStatus, dates, DateTimeCompositeLayout, Device, fields, focusUtils, FormField, HtmlComponent, InputFieldKeyStrokeContext, keys, objects, ParsingFailedStatus, scout, Status, strings, styles, TimePickerPopup, ValueField } from '../../../index';\nimport $ from 'jquery';\nexport default class DateField extends ValueField {\n  constructor() {\n    super();\n    this.allowedDates = [];\n    this.popup = null;\n    this.autoDate = null;\n    this.dateDisplayText = null;\n    this.dateHasText = false;\n    this.dateFocused = false;\n    this.dateFormatPattern = null;\n    this.disabledCopyOverlay = true;\n    this.hasDate = true;\n    this.touchMode = false;\n    this.embedded = false;\n    this.hasTime = false;\n    this.hasTimePopup = true;\n    this.timeDisplayText = null;\n    this.timeHasText = false;\n    this.timeDisplayText = null;\n    this.timePickerResolution = 30;\n    this.timeFormatPattern = null;\n    this.timeFocused = false;\n    this.$dateField = null;\n    this.$timeField = null;\n    this.$dateFieldIcon = null;\n    this.$timeFieldIcon = null;\n    this.$dateClearIcon = null;\n    this.$timeClearIcon = null;\n    this._$predictDateField = null;\n    this._$predictTimeField = null;\n\n    // This is the storage for the time (as date) while the focus in the field (e.g. when\n    // pressing up/down). In date fields, the date picker is used for that purposes.\n    this._tempTimeDate = null;\n    this.invalidValueMessageKey = 'ui.InvalidDate';\n    this._addCloneProperties(['hasDate', 'hasTime', 'dateFormatPattern', 'timeFormatPattern', 'allowedDates', 'autoDate']);\n  }\n  /**\n   * @override Widget.js\n   */\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n  _init(model) {\n    super._init(model);\n    fields.initTouch(this, model);\n    this.popup = model.popup;\n    this._setAutoDate(this.autoDate);\n    this._setDisplayText(this.displayText);\n    this._setAllowedDates(this.allowedDates);\n    this._setTimePickerResolution(this.timePickerResolution);\n  }\n\n  /**\n   * Initializes the date format before calling set value.\n   * This cannot be done in _init because the value field would call _setValue first\n   */\n  _initValue(value) {\n    this._setDateFormatPattern(this.dateFormatPattern);\n    this._setTimeFormatPattern(this.timeFormatPattern);\n    super._initValue(value);\n  }\n  createDatePopup() {\n    let popupType = this.touchMode ? 'DatePickerTouchPopup' : 'DatePickerPopup';\n    return scout.create(popupType, {\n      parent: this,\n      $anchor: this.$field,\n      boundToAnchor: !this.touchMode,\n      cssClass: this._errorStatusClass(),\n      closeOnAnchorMouseDown: false,\n      field: this,\n      allowedDates: this.allowedDates,\n      dateFormat: this.isolatedDateFormat,\n      displayText: this.dateDisplayText\n    });\n  }\n  createTimePopup() {\n    let popupType = this.touchMode ? 'TimePickerTouchPopup' : 'TimePickerPopup';\n    return scout.create(popupType, {\n      parent: this,\n      $anchor: this.$timeField,\n      boundToAnchor: !this.touchMode,\n      cssClass: this._errorStatusClass(),\n      closeOnAnchorMouseDown: false,\n      field: this,\n      timeResolution: this.timePickerResolution\n    });\n  }\n  _render() {\n    this.addContainer(this.$parent, 'date-field');\n    this.addLabel();\n    this.addField(this.$parent.makeDiv('date-time-composite'));\n    this.addStatus(this.$field);\n    if (!this.embedded) {\n      this.addMandatoryIndicator();\n    }\n    this.htmlDateTimeComposite = HtmlComponent.install(this.$field, this.session);\n    this.htmlDateTimeComposite.setLayout(new DateTimeCompositeLayout(this));\n  }\n  _renderProperties() {\n    this._renderHasDate();\n    this._renderHasTime();\n\n    // Has to be the last call, otherwise _renderErrorStatus() would operate on the wrong state.\n    super._renderProperties();\n    this._renderDateHasText();\n    this._renderTimeHasText();\n  }\n  _remove() {\n    super._remove();\n    this.$dateField = null;\n    this.$timeField = null;\n    this.$dateFieldIcon = null;\n    this.$timeFieldIcon = null;\n    this.$dateClearIcon = null;\n    this.$timeClearIcon = null;\n    this._$predictDateField = null;\n    this._$predictTimeField = null;\n    this.popup = null;\n  }\n  setHasDate(hasDate) {\n    this.setProperty('hasDate', hasDate);\n  }\n  _setHasDate(hasDate) {\n    this._setProperty('hasDate', hasDate);\n    if (this.initialized) {\n      // if property changes on the fly, update the display text\n      this._updateDisplayTextProperty();\n    }\n  }\n  _renderHasDate() {\n    if (this.hasDate && !this.$dateField) {\n      // Add $dateField\n      this.$dateField = fields.makeInputOrDiv(this, 'date').on('mousedown', this._onDateFieldMouseDown.bind(this)).appendTo(this.$field);\n      if (this.$timeField) {\n        // make sure date field comes before time field, otherwise tab won't work as expected\n        this.$dateField.insertBefore(this.$timeField);\n      }\n      if (!this.touchMode) {\n        this.$dateField.on('keydown', this._onDateFieldKeyDown.bind(this)).on('input', this._onDateFieldInput.bind(this)).on('blur', this._onDateFieldBlur.bind(this)).on('focus', this._onDateFieldFocus.bind(this));\n      }\n      this._linkWithLabel(this.$dateField);\n      HtmlComponent.install(this.$dateField, this.session);\n      this.$dateFieldIcon = fields.appendIcon(this.$field, 'date').on('mousedown', this._onDateIconMouseDown.bind(this));\n    } else if (!this.hasDate && this.$dateField) {\n      // Remove $dateField\n      this.$dateField.remove();\n      this.$dateField = null;\n      this.$dateFieldIcon.remove();\n      this.$dateFieldIcon = null;\n    }\n    if (!this.rendering) {\n      this._renderDisplayText();\n      this._renderFieldStyle();\n      this._renderEnabled();\n      this.htmlDateTimeComposite.invalidateLayoutTree();\n    }\n    this._renderDateClearable();\n    this.$container.toggleClass('has-date', this.hasDate);\n  }\n  setHasTime(hasTime) {\n    this.setProperty('hasTime', hasTime);\n  }\n  _setHasTime(hasTime) {\n    this._setProperty('hasTime', hasTime);\n    if (this.initialized) {\n      // if property changes on the fly, update the display text\n      this._updateDisplayTextProperty();\n    }\n  }\n  _renderHasTime() {\n    if (this.hasTime && !this.$timeField) {\n      // Add $timeField\n      this.$timeField = fields.makeInputOrDiv(this, 'time').on('mousedown', this._onTimeFieldMouseDown.bind(this)).appendTo(this.$field);\n      if (this.$dateField) {\n        // make sure time field comes after date field, otherwise tab won't work as expected\n        this.$timeField.insertAfter(this.$dateField);\n      }\n      if (!this.touchMode || !this.hasTimePopup) {\n        this.$timeField.on('keydown', this._onTimeFieldKeyDown.bind(this)).on('input', this._onTimeFieldInput.bind(this)).on('blur', this._onTimeFieldBlur.bind(this)).on('focus', this._onTimeFieldFocus.bind(this));\n      }\n      this._linkWithLabel(this.$timeField);\n      HtmlComponent.install(this.$timeField, this.session);\n      this.$timeFieldIcon = fields.appendIcon(this.$field, 'time').on('mousedown', this._onTimeIconMouseDown.bind(this));\n    } else if (!this.hasTime && this.$timeField) {\n      // Remove $timeField\n      this.$timeField.remove();\n      this.$timeField = null;\n      this.$timeFieldIcon.remove();\n      this.$timeFieldIcon = null;\n    }\n    if (!this.rendering) {\n      this._renderDisplayText();\n      this._renderFieldStyle();\n      this._renderEnabled();\n      this.htmlDateTimeComposite.invalidateLayoutTree();\n    }\n    this._renderTimeClearable();\n    this.$container.toggleClass('has-time', this.hasTime);\n  }\n  setTimePickerResolution(timePickerResolution) {\n    this.setProperty('timePickerResolution', timePickerResolution);\n  }\n  _setTimePickerResolution(timePickerResolution) {\n    if (timePickerResolution < 1) {\n      // default\n      timePickerResolution = 10;\n      this.hasTimePopup = false;\n    } else {\n      this.hasTimePopup = true;\n    }\n    this._setProperty('timePickerResolution', timePickerResolution);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderPlaceholder($field) {\n    super._renderPlaceholder(this._fieldForPlaceholder());\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _removePlaceholder($field) {\n    super._removePlaceholder(this._fieldForPlaceholder());\n  }\n  _fieldForPlaceholder() {\n    if (this.hasDate) {\n      return this.$dateField;\n    } else if (this.hasTime) {\n      return this.$timeField;\n    }\n    return null;\n  }\n  setDateFormatPattern(dateFormatPattern) {\n    this.setProperty('dateFormatPattern', dateFormatPattern);\n  }\n  _setDateFormatPattern(dateFormatPattern) {\n    if (!dateFormatPattern) {\n      dateFormatPattern = this.session.locale.dateFormatPatternDefault;\n    }\n    this._setProperty('dateFormatPattern', dateFormatPattern);\n    this.isolatedDateFormat = new DateFormat(this.session.locale, this.dateFormatPattern);\n    if (this.initialized) {\n      // if format changes on the fly, just update the display text\n      this._updateDisplayText();\n    }\n  }\n  setTimeFormatPattern(timeFormatPattern) {\n    this.setProperty('timeFormatPattern', timeFormatPattern);\n  }\n  _setTimeFormatPattern(timeFormatPattern) {\n    if (!timeFormatPattern) {\n      timeFormatPattern = this.session.locale.timeFormatPatternDefault;\n    }\n    this._setProperty('timeFormatPattern', timeFormatPattern);\n    this.isolatedTimeFormat = new DateFormat(this.session.locale, this.timeFormatPattern);\n    if (this.initialized) {\n      // if format changes on the fly, just update the display text\n      this._updateDisplayText();\n    }\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n    this.$container.setEnabled(this.enabledComputed);\n    if (this.$dateField) {\n      this.$dateField.setEnabled(this.enabledComputed);\n    }\n    if (this.$timeField) {\n      this.$timeField.setEnabled(this.enabledComputed);\n    }\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  _renderDisplayText() {\n    if (this.hasDate) {\n      this._renderDateDisplayText();\n    }\n    if (this.hasTime) {\n      this._renderTimeDisplayText();\n    }\n    this._removePredictionFields();\n  }\n  _readDisplayText() {\n    let dateDisplayText, timeDisplayText;\n    if (this.hasDate) {\n      dateDisplayText = this._readDateDisplayText();\n    }\n    if (this.hasTime) {\n      timeDisplayText = this._readTimeDisplayText();\n    }\n    return this._computeDisplayText(dateDisplayText, timeDisplayText);\n  }\n  _renderDateDisplayText() {\n    fields.valOrText(this.$dateField, this.dateDisplayText);\n    this._updateDateHasText();\n  }\n  _readDateDisplayText() {\n    return this._$predictDateField ? fields.valOrText(this._$predictDateField) : fields.valOrText(this.$dateField);\n  }\n  _renderTimeDisplayText() {\n    fields.valOrText(this.$timeField, this.timeDisplayText);\n    this._updateTimeHasText();\n  }\n  _readTimeDisplayText() {\n    return this._$predictTimeField ? fields.valOrText(this._$predictTimeField) : fields.valOrText(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  setDisplayText(displayText) {\n    // Overridden to avoid the equals check -> make sure renderDisplayText is executed whenever setDisplayText is called\n    // Reason: key up/down and picker day click modify the display text, but input doesn't\n    // -> reverting to a date using day click or up down after the input changed would not work anymore\n    // changing 'onXyInput' to always update the display text would fix that, but would break acceptInput\n    this._setDisplayText(displayText);\n    if (this.rendered) {\n      this._renderDisplayText();\n    }\n  }\n  _setDisplayText(displayText) {\n    this._setProperty('displayText', displayText);\n    let parts = this._splitDisplayText(displayText);\n    if (this.hasDate) {\n      // preserve dateDisplayText if hasDate is set to false (only override if it is true)\n      this.dateDisplayText = parts.dateText;\n    }\n    if (this.hasTime) {\n      // preserve timeDisplayText if hasTime is set to false (only override if it is true)\n      this.timeDisplayText = parts.timeText;\n    }\n  }\n\n  /**\n   * @override\n   */\n  _ensureValue(value) {\n    return dates.ensure(value);\n  }\n\n  /**\n   * @param {Date} value the date to validate\n   * @return {Date} the validated date\n   * @override\n   */\n  _validateValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return value;\n    }\n    if (!(value instanceof Date)) {\n      throw this.session.text(this.invalidValueMessageKey);\n    }\n    if (!this.isDateAllowed(value)) {\n      throw this.session.text('DateIsNotAllowed');\n    }\n    if (!this.hasDate && !this.value) {\n      // truncate to 01.01.1970 if no date was entered before. Otherwise preserve date part (important for toggling hasDate on the fly)\n      value = dates.combineDateTime(null, value);\n    }\n    return value;\n  }\n  isDateAllowed(date) {\n    if (!date || this.allowedDates.length === 0 || this.embedded) {\n      // in embedded mode, main date field must take care of validation, otherwise error status won't be shown\n      return true;\n    }\n    let dateAsTimestamp = dates.trunc(date).getTime();\n    return this.allowedDates.some(allowedDate => allowedDate.getTime() === dateAsTimestamp);\n  }\n  _valueEquals(valueA, valueB) {\n    return dates.equals(valueA, valueB);\n  }\n  setAutoDate(autoDate) {\n    this.setProperty('autoDate', autoDate);\n  }\n  _setAutoDate(autoDate) {\n    autoDate = dates.ensure(autoDate);\n    this._setProperty('autoDate', autoDate);\n  }\n  setAllowedDates(allowedDates) {\n    this.setProperty('allowedDates', allowedDates);\n  }\n  _setAllowedDates(allowedDates) {\n    let truncDates = [];\n    arrays.ensure(allowedDates).forEach(date => {\n      if (date) {\n        truncDates.push(dates.trunc(dates.ensure(date)));\n      }\n    });\n    truncDates = truncDates.sort(dates.compare);\n    this._setProperty('allowedDates', truncDates);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderErrorStatus() {\n    super._renderErrorStatus();\n    let hasStatus = !!this.errorStatus,\n      statusClass = this._errorStatusClass();\n    if (this.$dateField) {\n      this._updateErrorStatusClassesOnElement(this.$dateField, statusClass, hasStatus);\n\n      // Because the error color of field icons depends on the error status of sibling <input> elements.\n      // The prediction fields are clones of the input fields, so the 'has-error' class has to be\n      // removed from them as well to make the icon \"valid\".\n      this._updateErrorStatusClassesOnElement(this._$predictDateField, statusClass, hasStatus);\n    }\n\n    // Do the same for the time field\n    if (this.$timeField) {\n      this._updateErrorStatusClassesOnElement(this.$timeField, statusClass, hasStatus);\n      this._updateErrorStatusClassesOnElement(this._$predictTimeField, statusClass, hasStatus);\n    }\n    if (this.popup) {\n      this._updateErrorStatusClassesOnElement(this.popup.$container, statusClass, hasStatus);\n    }\n  }\n  _errorStatusClass() {\n    return this.errorStatus && !this._isSuppressStatusField() ? 'has-' + this.errorStatus.cssClass() : '';\n  }\n\n  /**\n   * @Override FormField.js\n   */\n  _renderFont() {\n    this.$dateField && styles.legacyFont(this, this.$dateField);\n    this.$timeField && styles.legacyFont(this, this.$timeField);\n  }\n\n  /**\n   * @Override FormField.js\n   */\n  _renderForegroundColor() {\n    this.$dateField && styles.legacyForegroundColor(this, this.$dateField);\n    this.$timeField && styles.legacyForegroundColor(this, this.$timeField);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderBackgroundColor() {\n    this.$dateField && styles.legacyBackgroundColor(this, this.$dateField);\n    this.$timeField && styles.legacyBackgroundColor(this, this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  activate() {\n    if (!this.enabledComputed || !this.rendered) {\n      return;\n    }\n    if (this.$dateField) {\n      this.$dateField.focus();\n      this._onDateFieldMouseDown();\n    } else if (this.$timeField) {\n      this.$timeField.focus();\n      this._onTimeFieldMouseDown();\n    }\n  }\n\n  /**\n   * @override\n   */\n  getFocusableElement() {\n    if (this.$dateField) {\n      return this.$dateField;\n    }\n    if (this.$timeField) {\n      return this.$timeField;\n    }\n    return null;\n  }\n  _onDateFieldMouseDown() {\n    if (fields.handleOnClick(this)) {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n  _onTimeFieldMouseDown() {\n    if (fields.handleOnClick(this)) {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n  setDateFocused(dateFocused) {\n    this.setProperty('dateFocused', dateFocused);\n  }\n  _renderDateFocused() {\n    this.$container.toggleClass('date-focused', this.dateFocused);\n  }\n  _updateTimeHasText() {\n    this.setTimeHasText(strings.hasText(this._readTimeDisplayText()));\n  }\n  setTimeHasText(timeHasText) {\n    this.setProperty('timeHasText', timeHasText);\n  }\n  _renderTimeHasText() {\n    if (this.$timeField) {\n      this.$timeField.toggleClass('has-text', this.timeHasText);\n    }\n    this.$container.toggleClass('time-has-text', this.timeHasText);\n  }\n  _updateDateHasText() {\n    this.setDateHasText(strings.hasText(this._readDateDisplayText()));\n  }\n  setDateHasText(dateHasText) {\n    this.setProperty('dateHasText', dateHasText);\n  }\n  _renderDateHasText() {\n    if (this.$dateField) {\n      this.$dateField.toggleClass('has-text', this.dateHasText);\n    }\n    this.$container.toggleClass('date-has-text', this.dateHasText);\n  }\n\n  /**\n   * @override\n   */\n  clear() {\n    if (!(this.hasDate && this.hasTime)) {\n      super.clear();\n      return;\n    }\n    this._clear();\n    // If field shows date and time, don't accept input while one field has the focus\n    // Reason: x icon is shown in one field, pressing that icon should clear the content of that field.\n    // Accept input would set the value to '', thus clearing both fields which may be unexpected.\n    if (!this.dateFocused && !this.timeFocused) {\n      this.acceptInput();\n    }\n    this._triggerClear();\n  }\n  _clear() {\n    this._removePredictionFields();\n    if (this.hasDate && !this.timeFocused) {\n      fields.valOrText(this.$dateField, '');\n      this._setDateValid(true);\n      this._updateDateHasText();\n    }\n    if (this.hasTime && !this.dateFocused) {\n      fields.valOrText(this.$timeField, '');\n      this._setTimeValid(true);\n      this._updateTimeHasText();\n    }\n  }\n  _onDateClearIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$dateField.focus();\n    this.clear();\n    if (this.value) {\n      this.selectDate(this.value, false);\n    } else {\n      this.preselectDate(this._referenceDate(), false);\n    }\n    event.preventDefault();\n  }\n  _onDateIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$dateField.focus();\n    if (!this.embedded) {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n  setTimeFocused(timeFocused) {\n    this.setProperty('timeFocused', timeFocused);\n  }\n  _renderTimeFocused() {\n    this.$container.toggleClass('time-focused', this.timeFocused);\n  }\n  _renderClearable() {\n    this._renderDateClearable();\n    this._renderTimeClearable();\n    this._updateClearableStyles();\n  }\n  _renderDateClearable() {\n    if (this.hasDate && this.isClearable()) {\n      if (!this.$dateClearIcon) {\n        // date clear icon\n        this.$dateClearIcon = this.$field.appendSpan('icon date-clear unfocusable text-field-icon action').on('mousedown', this._onDateClearIconMouseDown.bind(this));\n      }\n    } else {\n      if (this.$dateClearIcon) {\n        // Remove clear icon\n        this.$dateClearIcon.remove();\n        this.$dateClearIcon = null;\n      }\n    }\n  }\n  _renderTimeClearable() {\n    if (this.hasTime && this.isClearable()) {\n      if (!this.$timeClearIcon) {\n        // time clear icon\n        this.$timeClearIcon = this.$field.appendSpan('icon time-clear unfocusable text-field-icon action').on('mousedown', this._onTimeClearIconMouseDown.bind(this));\n      }\n    } else {\n      if (this.$timeClearIcon) {\n        // Remove clear icon\n        this.$timeClearIcon.remove();\n        this.$timeClearIcon = null;\n      }\n    }\n  }\n  _onTimeClearIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$timeField.focus();\n    this.clear();\n    if (this.value) {\n      this.selectTime(this.value, false);\n    } else {\n      this.preselectTime(this._referenceDate(), false);\n    }\n    event.preventDefault();\n  }\n  _onTimeIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$timeField.focus();\n    if (!this.embedded) {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n  _onDateFieldBlur(event) {\n    this.setFocused(false);\n    this.setDateFocused(false);\n    if (this.embedded) {\n      // Don't execute, otherwise date would be accepted even though touch popup is still open.\n      // This prevents following behavior: user clears date by pressing x and then selects another date. Now a blur event is triggered which would call acceptDate and eventually remove the time\n      // -> Don't accept as long as touch dialog is open\n      return;\n    }\n\n    // Close picker and update model\n    if (this.popup instanceof DatePickerPopup) {\n      // in embedded mode we must update the date prediction but not close the popup (don't accidentally close time picker popup)\n      this.closePopup();\n    }\n    this.setDateFocused(false);\n    this.acceptDate();\n    this._removePredictionFields();\n  }\n  _onDateFieldFocus(event) {\n    this.setFocused(true);\n    this.setDateFocused(true);\n  }\n  _onTimeFieldBlur(event) {\n    this._tempTimeDate = null;\n    this.setFocused(false);\n    this.setTimeFocused(false);\n    if (this.embedded) {\n      // Don't execute, otherwise time would be accepted even though touch popup is still open.\n      // This prevents following behavior: user clears time by pressing x and then selects another time. Now a blur event is triggered which would call acceptTime and eventually remove the date\n      // -> Don't accept as long as touch dialog is open\n      return;\n    }\n\n    // Close picker and update model\n    if (this.popup instanceof TimePickerPopup) {\n      // in embedded mode we must update the date prediction but not close the popup\n      this.closePopup();\n    }\n    this._tempTimeDate = null;\n    this.setTimeFocused(false);\n    this.acceptTime();\n    this._removePredictionFields();\n  }\n  _onTimeFieldFocus() {\n    this.setFocused(true);\n    this.setTimeFocused(true);\n  }\n\n  /**\n   * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n   * in _onDateFieldInput(), which is fired after 'keydown'.\n   */\n  _onDateFieldKeyDown(event) {\n    let delta = 0,\n      diffYears = 0,\n      diffMonths = 0,\n      diffDays = 0,\n      cursorPos = this.$dateField[0].selectionStart,\n      displayText = fields.valOrText(this.$dateField),\n      prediction = this._$predictDateField && fields.valOrText(this._$predictDateField),\n      modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n      pickerStartDate = this.value || this._referenceDate(),\n      shiftDate = true;\n\n    // Don't propagate tab to cell editor -> tab should focus time field\n    if (this.hasTime && this.mode === FormField.Mode.CELLEDITOR && event.which === keys.TAB && modifierCount === 0) {\n      event.stopPropagation();\n      return;\n    }\n    if (event.which === keys.TAB || event.which === keys.SHIFT || event.which === keys.HOME || event.which === keys.END || event.which === keys.CTRL || event.which === keys.ALT) {\n      // Default handling\n      return;\n    }\n    if (event.which === keys.ENTER) {\n      if (this.popup || this._$predictDateField) {\n        // Close the picker and accept the current prediction (if available)\n        this.acceptDate();\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n    if (event.which === keys.ESC) {\n      if (this.popup) {\n        // Close the picker, but don't do anything else\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n    if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n      // Move cursor one right and apply next char of the prediction\n      if (prediction) {\n        this._setDateDisplayText(prediction.substring(0, displayText.length + 1));\n      }\n      return;\n    }\n    if (event.which === keys.UP || event.which === keys.DOWN || event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n      if (displayText && !this._isDateValid()) {\n        // If there is an error, try to parse the date. If it may be parsed, the error was likely a validation error.\n        // In that case use the parsed date as starting point and not the for the user invisible value\n        let parsedValue = this.isolatedDateFormat.parse(displayText, pickerStartDate);\n        if (parsedValue) {\n          pickerStartDate = parsedValue;\n          this._setDateValid(true);\n        }\n      }\n    }\n    if (event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n      if (!displayText || !this._isDateValid()) {\n        // If input is empty or invalid, set picker to reference date\n        pickerStartDate = this._referenceDate();\n        if (this.hasTime) {\n          // keep time part\n          pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n        }\n        this.openDatePopupAndSelect(pickerStartDate);\n        this._updateDisplayText(pickerStartDate);\n        this._setDateValid(true);\n        shiftDate = false; // don't shift if field has no value yet and popup was not open\n      } else if (!this.popup) {\n        // Otherwise, ensure picker is open\n        this.openDatePopupAndSelect(pickerStartDate);\n      }\n      if (shiftDate) {\n        diffMonths = event.which === keys.PAGE_UP ? -1 : 1;\n        this.shiftSelectedDate(0, diffMonths, 0);\n        this._updateDisplayText(this.getDatePicker().selectedDate);\n      }\n      $.suppressEvent(event);\n      return;\n    }\n    if (event.which === keys.UP || event.which === keys.DOWN) {\n      delta = event.which === keys.UP ? -1 : 1;\n      // event.ctrlKey || event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx, use command key instead\n      if ((event.ctrlKey || event.metaKey) && modifierCount === 1) {\n        // only ctrl\n        diffYears = delta;\n      } else if (event.shiftKey && modifierCount === 1) {\n        // only shift\n        diffMonths = delta;\n      } else if (modifierCount === 0) {\n        // no modifier\n        diffDays = delta;\n      } else {\n        // Unsupported modifier or too many modifiers\n        $.suppressEvent(event);\n        return;\n      }\n      if (!displayText || !this._isDateValid()) {\n        // If input is empty or invalid, set picker to reference date\n        pickerStartDate = this._referenceDate();\n        if (this.hasTime) {\n          // keep time part\n          pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n        }\n        this.openDatePopupAndSelect(pickerStartDate);\n        this._updateDisplayText(pickerStartDate);\n        this._setDateValid(true);\n        shiftDate = false; // don't shift if field has no value yet and popup was not open\n      } else if (!this.popup) {\n        // Otherwise, ensure picker is open\n        this.openDatePopupAndSelect(pickerStartDate);\n      }\n      if (shiftDate) {\n        this.shiftSelectedDate(diffYears, diffMonths, diffDays);\n        this._updateDisplayText(this.getDatePicker().selectedDate);\n      }\n      $.suppressEvent(event);\n    }\n  }\n\n  /**\n   * Handle changed input. This method is fired when the field's content has been altered by a user\n   * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n   * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n   * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n   * in _onDateFieldKeyDown().\n   */\n  _onDateFieldInput(event) {\n    let displayText = fields.valOrText(this.$dateField);\n\n    // If the focus has changed to another field in the meantime, don't predict anything and\n    // don't show the picker. Just validate the input.\n    if (this.$dateField[0] !== this.$dateField.activeElement(true)) {\n      return;\n    }\n\n    // Create $predictDateField if necessary\n    if (!this._$predictDateField) {\n      this._$predictDateField = this._createPredictionField(this.$dateField);\n    }\n\n    // Predict date\n    this._removePredictErrorStatus();\n    let datePrediction = this._predictDate(displayText); // this also updates the errorStatus\n    if (datePrediction) {\n      fields.valOrText(this._$predictDateField, datePrediction.text);\n      this.openDatePopupAndSelect(datePrediction.date);\n    } else {\n      // No valid prediction!\n      this._removePredictionFields();\n    }\n    this._updateDateHasText();\n\n    // Hide the prediction field if input field is scrolled to the left. Otherwise, the\n    // two fields would not be aligned correctly, which looks bad. This can only happen\n    // when the fields are rather small, so the prediction would be of limited use anyway.\n    // Unfortunately, most browsers don't fire 'scroll' events for input fields. Also,\n    // when the 'input' even is fired, the scrollLeft() position sometimes has not been\n    // updated yet, that's why we must use setTimeout() with a short delay.\n    setTimeout(() => {\n      if (this._$predictDateField) {\n        this._$predictDateField.setVisible(this.$dateField.scrollLeft() === 0);\n      }\n    }, 50);\n  }\n  acceptInput() {\n    let displayText = scout.nvl(this._readDisplayText(), '');\n    let inputChanged = this._checkDisplayTextChanged(displayText);\n    if (inputChanged) {\n      this.parseAndSetValue(displayText);\n    } else {\n      let oldValue = this.value;\n      this.parseAndSetValue(displayText);\n      if (!dates.equals(this.value, oldValue)) {\n        inputChanged = true;\n      }\n    }\n    if (inputChanged) {\n      this._triggerAcceptInput();\n    }\n  }\n\n  /**\n   * Clears the time field if date field is empty before accepting the input.<br/>\n   * Don't delete invalid input from the time field.\n   */\n  acceptDate() {\n    let invalid = this.containsStatus(ParsingFailedStatus);\n    if (this.hasTime && !invalid && strings.empty(this.$dateField.val())) {\n      this.$timeField.val('');\n    }\n    this.acceptInput();\n  }\n\n  /**\n   * Clears the date field if time field is empty before accepting the input.<br/>\n   * Don't delete invalid input from the time field.\n   */\n  acceptTime() {\n    let invalid = this.containsStatus(ParsingFailedStatus);\n    if (this.hasDate && !invalid && strings.empty(this.$timeField.val())) {\n      this.$dateField.val('');\n    }\n    this.acceptInput();\n  }\n  acceptDateTime(acceptDate, acceptTime) {\n    if (acceptDate) {\n      this.acceptDate();\n    } else if (acceptTime) {\n      this.acceptTime();\n    }\n  }\n\n  /**\n   * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n   * in _onTimeFieldInput(), which is fired after 'keydown'.\n   */\n  _onTimeFieldKeyDown(event) {\n    let delta = 0,\n      diffHours = 0,\n      diffMinutes = 0,\n      diffSeconds = 0,\n      cursorPos = this.$timeField[0].selectionStart,\n      displayText = this.$timeField.val(),\n      prediction = this._$predictTimeField && this._$predictTimeField.val(),\n      modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n      pickerStartTime = this.value || this._referenceDate(),\n      shiftTime = true;\n\n    // Don't propagate shift-tab to cell editor -> shift tab should focus date field\n    if (this.hasDate && this.mode === FormField.Mode.CELLEDITOR && event.which === keys.TAB && event.shiftKey && modifierCount === 1) {\n      event.stopPropagation();\n      return;\n    }\n    if (event.which === keys.TAB || event.which === keys.SHIFT || event.which === keys.HOME || event.which === keys.END || event.which === keys.CTRL || event.which === keys.ALT) {\n      // Default handling\n      return;\n    }\n    if (event.which === keys.ENTER) {\n      // Timefield is shown in touch popup, so we need to make sure time gets accepted and popup closed, even if the regular time field itself has no popup\n      if (this.popup || this._$predictDateField) {\n        // Accept the current prediction (if available)\n        this._tempTimeDate = null;\n        this.acceptTime();\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n    if (event.which === keys.ESC) {\n      if (this.popup) {\n        // Close the picker, but don't do anything else\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n    if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n      // Move cursor one right and apply next char of the prediction\n      if (prediction) {\n        this._setTimeDisplayText(prediction.substring(0, displayText.length + 1));\n      }\n      return;\n    }\n    if (event.which === keys.UP || event.which === keys.DOWN) {\n      delta = event.which === keys.UP ? -1 : 1;\n      if (event.ctrlKey && modifierCount === 1) {\n        // only ctrl\n        diffSeconds = delta;\n      } else if (event.shiftKey && modifierCount === 1) {\n        // only shift\n        diffHours = delta;\n      } else if (modifierCount === 0) {\n        // no modifier\n        diffMinutes = delta;\n      } else {\n        // Unsupported modifier or too many modifiers\n        $.suppressEvent(event);\n        return;\n      }\n      if (this.hasTimePopup) {\n        if (!displayText || !this._isTimeValid()) {\n          // If input is empty or invalid, set picker to reference date\n          pickerStartTime = this._referenceDate();\n          this.openTimePopupAndSelect(pickerStartTime);\n          this._updateDisplayText(pickerStartTime);\n          this._setTimeValid(true);\n          shiftTime = false; // don't shift if field has no value yet and popup was not open\n        } else if (!this.popup) {\n          // Otherwise, ensure picker is open\n          this.openTimePopupAndSelect(pickerStartTime);\n        }\n        if (shiftTime) {\n          this.shiftSelectedTime(diffHours, diffMinutes, diffSeconds);\n          this._updateDisplayText(this.getTimePicker().selectedTime);\n        }\n        $.suppressEvent(event);\n      } else {\n        // without picker\n        if (!this._tempTimeDate) {\n          let timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n          if (timePrediction && timePrediction.date) {\n            this._tempTimeDate = timePrediction.date;\n          } else {\n            this._tempTimeDate = this._referenceDate();\n            shiftTime = false;\n          }\n        }\n        if (shiftTime) {\n          this._tempTimeDate = dates.shiftTime(this._tempTimeDate, diffHours, diffMinutes, diffSeconds);\n        }\n        if (this.hasDate) {\n          // Combine _tempTimeDate with existing date part\n          this._tempTimeDate = dates.combineDateTime(this.value || this._referenceDate(), this._tempTimeDate);\n        }\n        this._updateDisplayText(this._tempTimeDate);\n        this._setTimeValid(true);\n        $.suppressEvent(event);\n      }\n    }\n  }\n\n  /**\n   * Handle changed input. This method is fired when the field's content has been altered by a user\n   * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n   * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n   * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n   * in _onTimeFieldKeyDown().\n   */\n  _onTimeFieldInput(event) {\n    let displayText = this.$timeField.val();\n\n    // If the focus has changed to another field in the meantime, don't predict anything and\n    // don't show the picker. Just validate the input.\n    if (this.$timeField[0] !== this.$timeField.activeElement(true)) {\n      return;\n    }\n\n    // Create $predictTimeField if necessary\n    if (!this._$predictTimeField) {\n      this._$predictTimeField = this._createPredictionField(this.$timeField);\n    }\n\n    // Predict time\n    let timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n    if (timePrediction) {\n      this._$predictTimeField.val(timePrediction.text);\n      this.openTimePopupAndSelect(timePrediction.date);\n    } else {\n      // No valid prediction!\n      this._tempTimeDate = null;\n      this._removePredictionFields();\n    }\n    this._updateTimeHasText();\n\n    // See comment for similar code in _onDateFieldInput()\n    setTimeout(() => {\n      if (this._$predictTimeField) {\n        this._$predictTimeField.setVisible(this.$timeField.scrollLeft() === 0);\n      }\n    }, 50);\n  }\n  _onDatePickerDateSelect(event) {\n    this._setNewDateTimeValue(this._newTimestampAsDate(event.date, this.value));\n  }\n  _onTimePickerTimeSelect(event) {\n    this._setNewDateTimeValue(this._newTimestampAsDate(this.value, event.time));\n  }\n  _setNewDateTimeValue(newValue) {\n    this._setDateValid(true);\n    this._setTimeValid(true);\n    this.setValue(newValue);\n    this._triggerAcceptInput();\n    this.closePopup();\n  }\n  _createPredictionField($inputField) {\n    this.setSuppressStatus(FormField.SuppressStatus.ALL);\n    let $predictionField = $inputField.clone().addClass('predict').attr('tabIndex', '-1').insertBefore($inputField);\n    if ($inputField.hasClass('has-error')) {\n      $predictionField.addClass('has-error');\n    }\n    return $predictionField;\n  }\n  _removePredictionFields() {\n    this.setSuppressStatus(null);\n    if (this._$predictDateField) {\n      this._$predictDateField.remove();\n      this._$predictDateField = null;\n    }\n    if (this._$predictTimeField) {\n      this._$predictTimeField.remove();\n      this._$predictTimeField = null;\n    }\n  }\n  _setDateDisplayText(displayText) {\n    this.dateDisplayText = displayText;\n    this._updateDisplayTextProperty();\n    if (this.rendered) {\n      this._renderDateDisplayText();\n    }\n  }\n  _setTimeDisplayText(displayText) {\n    this.timeDisplayText = displayText;\n    this._updateDisplayTextProperty();\n    if (this.rendered) {\n      this._renderTimeDisplayText();\n    }\n  }\n  _computeDisplayText(dateDisplayText, timeDisplayText) {\n    let dateText = dateDisplayText || '',\n      timeText = timeDisplayText || '';\n\n    // do not use strings.join which ignores empty components\n    let displayText = (this.hasDate ? dateText : '') + (this.hasDate && this.hasTime ? '\\n' : '') + (this.hasTime ? timeText : '');\n\n    // empty display text should always be just an empty string\n    if (displayText === '\\n') {\n      displayText = '';\n    }\n    return displayText;\n  }\n  _splitDisplayText(displayText) {\n    let dateText = '',\n      timeText = '';\n    if (strings.hasText(displayText)) {\n      let parts = displayText.split('\\n');\n      dateText = this.hasDate ? parts[0] : '';\n      timeText = this.hasTime ? this.hasDate ? parts[1] : parts[0] : '';\n    }\n    return {\n      dateText: dateText,\n      timeText: timeText\n    };\n  }\n  _updateDisplayTextProperty() {\n    this._setProperty('displayText', this._computeDisplayText(this.dateDisplayText, this.timeDisplayText));\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  aboutToBlurByMouseDown(target) {\n    let dateFieldActive,\n      timeFieldActive,\n      eventOnDatePicker,\n      eventOnTimePicker,\n      eventOnDateField = this.$dateField ? this.$dateField.isOrHas(target) || this.$dateFieldIcon.isOrHas(target) || this.$dateClearIcon && this.$dateClearIcon.isOrHas(target) : false,\n      eventOnTimeField = this.$timeField ? this.$timeField.isOrHas(target) || this.$timeFieldIcon.isOrHas(target) || this.$timeClearIcon && this.$timeClearIcon.isOrHas(target) : false,\n      eventOnPopup = this.popup && this.popup.$container.isOrHas(target),\n      eventOnStatus = this.fieldStatus && this.fieldStatus.$container.isOrHas(target),\n      datePicker = this.getDatePicker(),\n      timePicker = this.getTimePicker();\n    if (!eventOnDateField && !eventOnTimeField && !eventOnPopup && !eventOnStatus) {\n      // event outside this field.\n      dateFieldActive = focusUtils.isActiveElement(this.$dateField);\n      timeFieldActive = focusUtils.isActiveElement(this.$timeField);\n      // Accept only the currently focused part (the other one cannot have a pending change)\n      this.acceptDateTime(dateFieldActive, timeFieldActive);\n      return;\n    }\n\n    // when date-field is embedded, time-prediction must be accepted before\n    // the date-picker triggers the 'dateSelect' event.\n    if (this.embedded) {\n      eventOnDatePicker = datePicker && datePicker.$container.isOrHas(target);\n      eventOnTimePicker = timePicker && timePicker.$container.isOrHas(target);\n      if (eventOnDatePicker && eventOnTimePicker) {\n        this.acceptTime();\n      }\n    }\n  }\n\n  /**\n   * Returns null if both arguments are not set. Otherwise, this.value or the current date\n   * is used as basis and the given arguments are applied to that date. The result is returned.\n   */\n  _newTimestampAsDate(date, time) {\n    let result = null;\n    if (date || time) {\n      result = this.value || this._referenceDate();\n      if (date) {\n        result = dates.combineDateTime(date, result);\n      }\n      if (time) {\n        result = dates.combineDateTime(result, time);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns the reference date for this date field, which is used in various places (i.e. opening the date picker, analyzing user inputs).\n   *\n   * The reference date is either (in that order):\n   * - the model's \"auto timestamp\" (as date), or\n   * - the current date/time\n   */\n  _referenceDate() {\n    let referenceDate = this.autoDate || dates.ceil(dates.newDate(), this.timePickerResolution);\n    if (this.autoDate) {\n      referenceDate = this.autoDate;\n    } else if (this.hasTime) {\n      referenceDate = dates.ceil(dates.newDate(), this.timePickerResolution);\n    } else {\n      referenceDate = dates.trunc(dates.newDate());\n    }\n    if (this.allowedDates) {\n      referenceDate = this._findAllowedReferenceDate(referenceDate);\n    }\n    return referenceDate;\n  }\n\n  /**\n   * Find nearest allowed date which is equals or greater than the current referenceDate.\n   */\n  _findAllowedReferenceDate(referenceDate) {\n    let i, allowedDate;\n    // 1st: try to find a date which is equals or greater than the referenceDate (today)\n    for (i = 0; i < this.allowedDates.length; i++) {\n      allowedDate = this.allowedDates[i];\n      if (dates.compare(allowedDate, referenceDate) >= 0) {\n        return allowedDate;\n      }\n    }\n    // 2nd: try to find an allowed date in the past\n    for (i = this.allowedDates.length - 1; i >= 0; i--) {\n      allowedDate = this.allowedDates[i];\n      if (dates.compare(allowedDate, referenceDate) <= 0) {\n        return allowedDate;\n      }\n    }\n    return referenceDate;\n  }\n  openDatePopup(date) {\n    if (this.popup) {\n      // already open\n      return;\n    }\n    this.popup = this.createDatePopup();\n    this.popup.open();\n    this.$dateField.addClass('focused');\n    this.popup.one('destroy', event => {\n      // Removing the class must happen before _onPopupDestroy() is called, otherwise the date field no longer exists,\n      // because in touch mode _onPopupDestroy() destroys the date field.\n      this.$dateField.removeClass('focused');\n      this._onPopupDestroy(event);\n      this.popup = null;\n    });\n    this.getDatePicker().on('dateSelect', this._onDatePickerDateSelect.bind(this));\n  }\n  closePopup() {\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n  toggleDatePopup() {\n    $.log.isInfoEnabled() && $.log.info('(DateField#toggleDatePopup) popupOpen=', !!this.popup);\n    if (this.popup) {\n      this.closePopup();\n    } else {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n  openTimePopup(date) {\n    if (!this.hasTimePopup || this.popup) {\n      // already open\n      return;\n    }\n    this.popup = this.createTimePopup();\n    this.popup.open();\n    this.$timeField.addClass('focused');\n    this.popup.one('destroy', event => {\n      // Removing the class must happen before _onPopupDestroy() is called, otherwise the date field no longer exists,\n      // because in touch mode _onPopupDestroy() destroys the date field.\n      this.$timeField.removeClass('focused');\n      this._onPopupDestroy(event);\n      this.popup = null;\n    });\n    this.getTimePicker().on('timeSelect', this._onTimePickerTimeSelect.bind(this));\n  }\n  toggleTimePopup() {\n    $.log.isInfoEnabled() && $.log.info('(DateField#toggleTimePopup) popupOpen=', !!this.popup);\n    if (this.popup) {\n      this.closePopup();\n    } else {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n  _parseValue(displayText) {\n    let parts = this._splitDisplayText(displayText);\n    let dateText = parts.dateText;\n    let datePrediction = {};\n    let timeText = parts.timeText;\n    let timePrediction = {};\n    let success = true;\n    this._removePredictErrorStatus();\n    if (this.hasDate) {\n      datePrediction = this._predictDate(dateText); // this also updates the errorStatus\n      if (!datePrediction) {\n        success = false;\n      }\n      this._setDateDisplayText(dateText);\n    }\n    if (this.hasTime) {\n      timePrediction = this._predictTime(timeText); // this also updates the errorStatus\n      if (!timePrediction) {\n        success = false;\n      }\n      this._setTimeDisplayText(timeText);\n    }\n\n    // Error status was already set by _predict functions, throw this typed Status so DateField knows it must\n    // not set the error status again when the parse error is catched\n    if (!success) {\n      throw new DatePredictionFailedStatus();\n    }\n\n    // parse success -> return new value\n    if (datePrediction.date || timePrediction.date) {\n      return this._newTimestampAsDate(datePrediction.date, timePrediction.date);\n    }\n    return null;\n  }\n\n  /**\n   * Don't add error if it is a DatePredictionFailedStatus because the predict function\n   * has already added a parsing error.\n   */\n  _addParsingFailedErrorStatus(displayText, error) {\n    if (error instanceof DatePredictionFailedStatus) {\n      return;\n    }\n    super._addParsingFailedErrorStatus(displayText, error);\n  }\n\n  /**\n   * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n   */\n  _predictDate(inputText) {\n    inputText = inputText || '';\n\n    // \"Date calculations\"\n    let m = inputText.match(/^([+-])(\\d*)$/);\n    if (m) {\n      let now = dates.newDate();\n      let daysToAdd = Number(m[1] + (m[2] || '0'));\n      now.setDate(now.getDate() + daysToAdd);\n      if (isNaN(now.valueOf()) || now.getDate() < 0) {\n        // Some older browsers don't set NaN but return invalid values\n        this._setDateValid(false);\n        return null;\n      }\n      this._setDateValid(true);\n      return {\n        date: now,\n        text: inputText\n      };\n    }\n    let analyzeInfo = this._analyzeInputAsDate(inputText, this.value || this._referenceDate());\n    if (analyzeInfo.error) {\n      this._setDateValid(false);\n      return null;\n    }\n\n    // No predicted date? -> return empty string (may happen if inputText is empty)\n    if (!analyzeInfo.predictedDate) {\n      this._setDateValid(true);\n      return {\n        date: null,\n        text: ''\n      };\n    }\n    let predictedDate = analyzeInfo.predictedDate;\n    let predictionFormat = new DateFormat(this.isolatedDateFormat.locale, analyzeInfo.parsedPattern);\n    let predictedDateFormatted = predictionFormat.format(predictedDate, true);\n\n    // If predicted date format starts with validatedText, ensure that the capitalization matches.\n    // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n    m = predictedDateFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n    if (m) {\n      predictedDateFormatted = inputText + m[1];\n    }\n    this._setDateValid(true);\n    return {\n      date: predictedDate,\n      text: predictedDateFormatted\n    };\n  }\n\n  /**\n   * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n   */\n  _predictTime(inputText) {\n    inputText = inputText || '';\n    let analyzeInfo = this._analyzeInputAsTime(inputText, this.value || this._referenceDate());\n    if (analyzeInfo.error) {\n      this._setTimeValid(false);\n      return null;\n    }\n\n    // No predicted date? -> return empty string (may happen if inputText is empty)\n    if (!analyzeInfo.predictedDate) {\n      this._setTimeValid(true);\n      return {\n        date: null,\n        text: ''\n      };\n    }\n    let predictedDate = analyzeInfo.predictedDate;\n    let predictionFormat = new DateFormat(this.isolatedTimeFormat.locale, analyzeInfo.parsedPattern);\n    let predictedTimeFormatted = predictionFormat.format(predictedDate, true);\n\n    // If predicted date format starts with validatedText, ensure that the capitalization matches.\n    // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n    let m = predictedTimeFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n    if (m) {\n      predictedTimeFormatted = inputText + m[1];\n    }\n    this._setTimeValid(true);\n    return {\n      date: predictedDate,\n      text: predictedTimeFormatted\n    };\n  }\n  _analyzeInputAsDate(inputText, startDate) {\n    return this.isolatedDateFormat.analyze(inputText, startDate);\n  }\n  _analyzeInputAsTime(inputText, startDate) {\n    return this.isolatedTimeFormat.analyze(inputText, startDate);\n  }\n\n  /**\n   * This method updates the parts (date, time) of the error status.\n   */\n  _setErrorStatusPart(property, valid) {\n    // check if date/time error exists\n    let status = null;\n    let storedStatus = null;\n    if (this.errorStatus) {\n      storedStatus = arrays.find(this.errorStatus.asFlatList(), DateField.PARSE_ERROR_PREDICATE);\n    }\n    if (storedStatus) {\n      status = storedStatus;\n    } else {\n      status = new ParsingFailedStatus({\n        message: this.session.text('ui.InvalidDate'),\n        severity: Status.Severity.ERROR,\n        code: DateField.ErrorCode.PARSE_ERROR\n      });\n    }\n    if (valid) {\n      delete status[property];\n    } else {\n      status[property] = true;\n    }\n    if (!status.hasOwnProperty('invalidDate') && !status.hasOwnProperty('invalidTime')) {\n      status = null;\n    }\n    if (status && !storedStatus) {\n      this.addErrorStatus(status);\n    } else if (!status && storedStatus) {\n      this._removePredictErrorStatus();\n    } // else: just update existing error\n  }\n\n  _removePredictErrorStatus() {\n    this.removeErrorStatusByPredicate(DateField.PARSE_ERROR_PREDICATE);\n  }\n\n  /**\n   * @override\n   */\n  _createInvalidValueStatus(statusType, value, error) {\n    let errorStatus = super._createInvalidValueStatus(statusType, value, error);\n    // Set date and time to invalid, otherwise isDateValid and isTimeValid return false even though there is a validation error\n    errorStatus.invalidDate = true;\n    errorStatus.invalidTime = true;\n    errorStatus.code = DateField.ErrorCode.PARSE_ERROR;\n    return errorStatus;\n  }\n  _setDateValid(valid) {\n    this._setErrorStatusPart('invalidDate', valid);\n  }\n  _setTimeValid(valid) {\n    this._setErrorStatusPart('invalidTime', valid);\n  }\n  _isErrorStatusPartValid(property) {\n    if (!this.errorStatus) {\n      return true;\n    }\n\n    // return false if one of the status has the invalid* property\n    return !this.errorStatus.asFlatList().some(status => {\n      return !!status[property];\n    });\n  }\n  _isDateValid() {\n    return this._isErrorStatusPartValid('invalidDate');\n  }\n  _isTimeValid() {\n    return this._isErrorStatusPartValid('invalidTime');\n  }\n\n  /**\n   * Method invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n   */\n  onCellEditorRendered(options) {\n    if (options.openFieldPopup) {\n      if (this.hasDate && !this.hasTime) {\n        this.openDatePopupAndSelect(this.value);\n      } else if (!this.hasDate && this.hasTime) {\n        this.openTimePopupAndSelect(this.value);\n      } else if (!Device.get().supportsOnlyTouch()) {\n        // If date AND time are active, don't open popup on touch devices because the user has to choose first what he wants to edit\n        this.openDatePopupAndSelect(this.value);\n      }\n    }\n    if (this.touchMode) {\n      this._cellEditorPopup = options.cellEditorPopup;\n    }\n  }\n  _onPopupDestroy(event) {\n    if (!this.touchMode || !this._cellEditorPopup) {\n      return;\n    }\n    if (this.hasDate && this.hasTime) {\n      // If date and time is shown, user might want to change both, let him close the cell editor when he is finished\n      return;\n    }\n    // Close cell editor when touch popup closes\n    this._cellEditorPopup.completeEdit();\n    this._cellEditorPopup = null;\n  }\n\n  /**\n   * @override FormField.js\n   */\n  prepareForCellEdit(opts) {\n    opts = opts || {};\n    super.prepareForCellEdit(opts);\n    this.$field.removeClass('cell-editor-field first last');\n    if (this.$dateField) {\n      this.addCellEditorFieldCssClasses(this.$dateField, opts);\n    }\n    if (this.$timeField) {\n      if (!this.$dateField) {\n        opts.cssClass = '';\n      }\n      this.addCellEditorFieldCssClasses(this.$timeField, opts);\n    }\n  }\n\n  /**\n   * @returns DatePicker instance from popup, because the property name is different\n   *    for DatePickerPopup and DatePickerTouchPopup.\n   */\n  getDatePicker() {\n    if (this.popup && this.popup.getDatePicker) {\n      return this.popup.getDatePicker();\n    }\n  }\n\n  /**\n   * Opens picker and selects date\n   *\n   * @param date\n   *          optional, Date to pass to the date picker. If no date is specified, the reference date\n   *          is preselected (not selected!).\n   */\n  openDatePopupAndSelect(date) {\n    this.openDatePopup();\n    if (!date) {\n      this.preselectDate(this._referenceDate(), false);\n    } else {\n      this.selectDate(date, false);\n    }\n  }\n  preselectDate(date, animated) {\n    let datePicker = this.getDatePicker();\n    if (datePicker) {\n      datePicker.preselectDate(date, animated);\n    }\n  }\n  selectDate(date, animated) {\n    let datePicker = this.getDatePicker();\n    if (datePicker) {\n      datePicker.selectDate(date, animated);\n    }\n  }\n\n  /**\n   * @returns DatePicker instance from popup, because the property name is different\n   *    for DatePickerPopup and DatePickerTouchPopup.\n   */\n  getTimePicker() {\n    if (this.popup && this.popup.getTimePicker) {\n      return this.popup.getTimePicker();\n    }\n  }\n\n  /**\n   * Opens picker and selects date\n   *\n   * @param date\n   *          optional, Date to pass to the date picker. If no date is specified, the reference date\n   *          is preselected (not selected!).\n   */\n  openTimePopupAndSelect(time) {\n    // resolution < 1 means no picker required\n    if (!this.hasTimePopup) {\n      return;\n    }\n    this.openTimePopup();\n    if (!time) {\n      this.preselectTime(this._referenceDate());\n    } else {\n      this.selectTime(time);\n    }\n  }\n  preselectTime(time) {\n    let timePicker = this.getTimePicker();\n    if (timePicker) {\n      timePicker.preselectTime(time);\n    }\n  }\n  selectTime(time) {\n    let timePicker = this.getTimePicker();\n    if (timePicker) {\n      timePicker.selectTime(time);\n    }\n  }\n  shiftSelectedDate(years, months, days) {\n    this.openDatePopup();\n    this.getDatePicker().shiftSelectedDate(years, months, days);\n  }\n  shiftSelectedTime(hourUnits, minuteUnits, secondUnits) {\n    this.openTimePopup();\n    this.getTimePicker().shiftSelectedTime(hourUnits, minuteUnits, secondUnits);\n  }\n  _formatValue(value) {\n    let dateText = '',\n      timeText = '';\n    if (this.hasDate) {\n      if (value) {\n        dateText = this.isolatedDateFormat.format(value);\n      }\n      this.dateDisplayText = dateText;\n    }\n    if (this.hasTime) {\n      if (value) {\n        timeText = this.isolatedTimeFormat.format(value);\n      }\n      this.timeDisplayText = timeText;\n    }\n    return this._computeDisplayText(this.dateDisplayText, this.timeDisplayText);\n  }\n\n  /**\n   * @override\n   */\n  _renderFieldStyle() {\n    super._renderFieldStyle();\n    this._renderFieldStyleInternal(this.$dateField);\n    this._renderFieldStyleInternal(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$dateField);\n    this._renderDisabledStyleInternal(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  _triggerAcceptInput() {\n    let event = {\n      displayText: this.displayText,\n      errorStatus: this.errorStatus,\n      value: this.value\n    };\n    this.trigger('acceptInput', event);\n  }\n}\n_defineProperty(DateField, \"ErrorCode\", {\n  PARSE_ERROR: -1\n});\n_defineProperty(DateField, \"PARSE_ERROR_PREDICATE\", function (status) {\n  return status.code === DateField.ErrorCode.PARSE_ERROR;\n});","map":{"version":3,"names":["arrays","DateFormat","DatePickerPopup","DatePredictionFailedStatus","dates","DateTimeCompositeLayout","Device","fields","focusUtils","FormField","HtmlComponent","InputFieldKeyStrokeContext","keys","objects","ParsingFailedStatus","scout","Status","strings","styles","TimePickerPopup","ValueField","$","DateField","constructor","allowedDates","popup","autoDate","dateDisplayText","dateHasText","dateFocused","dateFormatPattern","disabledCopyOverlay","hasDate","touchMode","embedded","hasTime","hasTimePopup","timeDisplayText","timeHasText","timePickerResolution","timeFormatPattern","timeFocused","$dateField","$timeField","$dateFieldIcon","$timeFieldIcon","$dateClearIcon","$timeClearIcon","_$predictDateField","_$predictTimeField","_tempTimeDate","invalidValueMessageKey","_addCloneProperties","_createKeyStrokeContext","_init","model","initTouch","_setAutoDate","_setDisplayText","displayText","_setAllowedDates","_setTimePickerResolution","_initValue","value","_setDateFormatPattern","_setTimeFormatPattern","createDatePopup","popupType","create","parent","$anchor","$field","boundToAnchor","cssClass","_errorStatusClass","closeOnAnchorMouseDown","field","dateFormat","isolatedDateFormat","createTimePopup","timeResolution","_render","addContainer","$parent","addLabel","addField","makeDiv","addStatus","addMandatoryIndicator","htmlDateTimeComposite","install","session","setLayout","_renderProperties","_renderHasDate","_renderHasTime","_renderDateHasText","_renderTimeHasText","_remove","setHasDate","setProperty","_setHasDate","_setProperty","initialized","_updateDisplayTextProperty","makeInputOrDiv","on","_onDateFieldMouseDown","bind","appendTo","insertBefore","_onDateFieldKeyDown","_onDateFieldInput","_onDateFieldBlur","_onDateFieldFocus","_linkWithLabel","appendIcon","_onDateIconMouseDown","remove","rendering","_renderDisplayText","_renderFieldStyle","_renderEnabled","invalidateLayoutTree","_renderDateClearable","$container","toggleClass","setHasTime","_setHasTime","_onTimeFieldMouseDown","insertAfter","_onTimeFieldKeyDown","_onTimeFieldInput","_onTimeFieldBlur","_onTimeFieldFocus","_onTimeIconMouseDown","_renderTimeClearable","setTimePickerResolution","_renderPlaceholder","_fieldForPlaceholder","_removePlaceholder","setDateFormatPattern","locale","dateFormatPatternDefault","_updateDisplayText","setTimeFormatPattern","timeFormatPatternDefault","isolatedTimeFormat","setEnabled","enabledComputed","_renderDateDisplayText","_renderTimeDisplayText","_removePredictionFields","_readDisplayText","_readDateDisplayText","_readTimeDisplayText","_computeDisplayText","valOrText","_updateDateHasText","_updateTimeHasText","setDisplayText","rendered","parts","_splitDisplayText","dateText","timeText","_ensureValue","ensure","_validateValue","isNullOrUndefined","Date","text","isDateAllowed","combineDateTime","date","length","dateAsTimestamp","trunc","getTime","some","allowedDate","_valueEquals","valueA","valueB","equals","setAutoDate","setAllowedDates","truncDates","forEach","push","sort","compare","_renderErrorStatus","hasStatus","errorStatus","statusClass","_updateErrorStatusClassesOnElement","_isSuppressStatusField","_renderFont","legacyFont","_renderForegroundColor","legacyForegroundColor","_renderBackgroundColor","legacyBackgroundColor","activate","focus","getFocusableElement","handleOnClick","openDatePopupAndSelect","openTimePopupAndSelect","setDateFocused","_renderDateFocused","setTimeHasText","hasText","setDateHasText","clear","_clear","acceptInput","_triggerClear","_setDateValid","_setTimeValid","_onDateClearIconMouseDown","event","selectDate","preselectDate","_referenceDate","preventDefault","setTimeFocused","_renderTimeFocused","_renderClearable","_updateClearableStyles","isClearable","appendSpan","_onTimeClearIconMouseDown","selectTime","preselectTime","setFocused","closePopup","acceptDate","acceptTime","delta","diffYears","diffMonths","diffDays","cursorPos","selectionStart","prediction","modifierCount","ctrlKey","shiftKey","altKey","metaKey","pickerStartDate","shiftDate","mode","Mode","CELLEDITOR","which","TAB","stopPropagation","SHIFT","HOME","END","CTRL","ALT","ENTER","suppressEvent","ESC","RIGHT","_setDateDisplayText","substring","UP","DOWN","PAGE_UP","PAGE_DOWN","_isDateValid","parsedValue","parse","shiftSelectedDate","getDatePicker","selectedDate","activeElement","_createPredictionField","_removePredictErrorStatus","datePrediction","_predictDate","setTimeout","setVisible","scrollLeft","nvl","inputChanged","_checkDisplayTextChanged","parseAndSetValue","oldValue","_triggerAcceptInput","invalid","containsStatus","empty","val","acceptDateTime","diffHours","diffMinutes","diffSeconds","pickerStartTime","shiftTime","_setTimeDisplayText","_isTimeValid","shiftSelectedTime","getTimePicker","selectedTime","timePrediction","_predictTime","_onDatePickerDateSelect","_setNewDateTimeValue","_newTimestampAsDate","_onTimePickerTimeSelect","time","newValue","setValue","$inputField","setSuppressStatus","SuppressStatus","ALL","$predictionField","clone","addClass","attr","hasClass","split","aboutToBlurByMouseDown","target","dateFieldActive","timeFieldActive","eventOnDatePicker","eventOnTimePicker","eventOnDateField","isOrHas","eventOnTimeField","eventOnPopup","eventOnStatus","fieldStatus","datePicker","timePicker","isActiveElement","result","referenceDate","ceil","newDate","_findAllowedReferenceDate","i","openDatePopup","open","one","removeClass","_onPopupDestroy","close","toggleDatePopup","log","isInfoEnabled","info","openTimePopup","toggleTimePopup","_parseValue","success","_addParsingFailedErrorStatus","error","inputText","m","match","now","daysToAdd","Number","setDate","getDate","isNaN","valueOf","analyzeInfo","_analyzeInputAsDate","predictedDate","predictionFormat","parsedPattern","predictedDateFormatted","format","RegExp","quote","_analyzeInputAsTime","predictedTimeFormatted","startDate","analyze","_setErrorStatusPart","property","valid","status","storedStatus","find","asFlatList","PARSE_ERROR_PREDICATE","message","severity","Severity","ERROR","code","ErrorCode","PARSE_ERROR","hasOwnProperty","addErrorStatus","removeErrorStatusByPredicate","_createInvalidValueStatus","statusType","invalidDate","invalidTime","_isErrorStatusPartValid","onCellEditorRendered","options","openFieldPopup","get","supportsOnlyTouch","_cellEditorPopup","cellEditorPopup","completeEdit","prepareForCellEdit","opts","addCellEditorFieldCssClasses","animated","years","months","days","hourUnits","minuteUnits","secondUnits","_formatValue","_renderFieldStyleInternal","_renderDisabledStyle","_renderDisabledStyleInternal","trigger"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/form/fields/datefield/DateField.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, DateFormat, DatePickerPopup, DatePredictionFailedStatus, dates, DateTimeCompositeLayout, Device, fields, focusUtils, FormField, HtmlComponent, InputFieldKeyStrokeContext, keys, objects, ParsingFailedStatus, scout, Status, strings, styles, TimePickerPopup, ValueField} from '../../../index';\nimport $ from 'jquery';\n\nexport default class DateField extends ValueField {\n\n  constructor() {\n    super();\n\n    this.allowedDates = [];\n    this.popup = null;\n    this.autoDate = null;\n    this.dateDisplayText = null;\n    this.dateHasText = false;\n    this.dateFocused = false;\n    this.dateFormatPattern = null;\n    this.disabledCopyOverlay = true;\n    this.hasDate = true;\n    this.touchMode = false;\n    this.embedded = false;\n\n    this.hasTime = false;\n    this.hasTimePopup = true;\n    this.timeDisplayText = null;\n    this.timeHasText = false;\n    this.timeDisplayText = null;\n    this.timePickerResolution = 30;\n    this.timeFormatPattern = null;\n    this.timeFocused = false;\n\n    this.$dateField = null;\n    this.$timeField = null;\n    this.$dateFieldIcon = null;\n    this.$timeFieldIcon = null;\n    this.$dateClearIcon = null;\n    this.$timeClearIcon = null;\n    this._$predictDateField = null;\n    this._$predictTimeField = null;\n\n    // This is the storage for the time (as date) while the focus in the field (e.g. when\n    // pressing up/down). In date fields, the date picker is used for that purposes.\n    this._tempTimeDate = null;\n    this.invalidValueMessageKey = 'ui.InvalidDate';\n    this._addCloneProperties(['hasDate', 'hasTime', 'dateFormatPattern', 'timeFormatPattern', 'allowedDates', 'autoDate']);\n  }\n\n  static ErrorCode = {\n    PARSE_ERROR: -1\n  };\n\n  /**\n   * Predicate function to find a PARSE_ERROR.\n   */\n  static PARSE_ERROR_PREDICATE = function(status) {\n    return status.code === DateField.ErrorCode.PARSE_ERROR;\n  };\n\n  /**\n   * @override Widget.js\n   */\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n\n  _init(model) {\n    super._init(model);\n    fields.initTouch(this, model);\n    this.popup = model.popup;\n    this._setAutoDate(this.autoDate);\n    this._setDisplayText(this.displayText);\n    this._setAllowedDates(this.allowedDates);\n    this._setTimePickerResolution(this.timePickerResolution);\n  }\n\n  /**\n   * Initializes the date format before calling set value.\n   * This cannot be done in _init because the value field would call _setValue first\n   */\n  _initValue(value) {\n    this._setDateFormatPattern(this.dateFormatPattern);\n    this._setTimeFormatPattern(this.timeFormatPattern);\n    super._initValue(value);\n  }\n\n  createDatePopup() {\n    let popupType = this.touchMode ? 'DatePickerTouchPopup' : 'DatePickerPopup';\n    return scout.create(popupType, {\n      parent: this,\n      $anchor: this.$field,\n      boundToAnchor: !this.touchMode,\n      cssClass: this._errorStatusClass(),\n      closeOnAnchorMouseDown: false,\n      field: this,\n      allowedDates: this.allowedDates,\n      dateFormat: this.isolatedDateFormat,\n      displayText: this.dateDisplayText\n    });\n  }\n\n  createTimePopup() {\n    let popupType = this.touchMode ? 'TimePickerTouchPopup' : 'TimePickerPopup';\n    return scout.create(popupType, {\n      parent: this,\n      $anchor: this.$timeField,\n      boundToAnchor: !this.touchMode,\n      cssClass: this._errorStatusClass(),\n      closeOnAnchorMouseDown: false,\n      field: this,\n      timeResolution: this.timePickerResolution\n    });\n  }\n\n  _render() {\n    this.addContainer(this.$parent, 'date-field');\n    this.addLabel();\n    this.addField(this.$parent.makeDiv('date-time-composite'));\n    this.addStatus(this.$field);\n    if (!this.embedded) {\n      this.addMandatoryIndicator();\n    }\n\n    this.htmlDateTimeComposite = HtmlComponent.install(this.$field, this.session);\n    this.htmlDateTimeComposite.setLayout(new DateTimeCompositeLayout(this));\n  }\n\n  _renderProperties() {\n    this._renderHasDate();\n    this._renderHasTime();\n\n    // Has to be the last call, otherwise _renderErrorStatus() would operate on the wrong state.\n    super._renderProperties();\n\n    this._renderDateHasText();\n    this._renderTimeHasText();\n  }\n\n  _remove() {\n    super._remove();\n    this.$dateField = null;\n    this.$timeField = null;\n    this.$dateFieldIcon = null;\n    this.$timeFieldIcon = null;\n    this.$dateClearIcon = null;\n    this.$timeClearIcon = null;\n    this._$predictDateField = null;\n    this._$predictTimeField = null;\n    this.popup = null;\n  }\n\n  setHasDate(hasDate) {\n    this.setProperty('hasDate', hasDate);\n  }\n\n  _setHasDate(hasDate) {\n    this._setProperty('hasDate', hasDate);\n    if (this.initialized) {\n      // if property changes on the fly, update the display text\n      this._updateDisplayTextProperty();\n    }\n  }\n\n  _renderHasDate() {\n    if (this.hasDate && !this.$dateField) {\n      // Add $dateField\n      this.$dateField = fields.makeInputOrDiv(this, 'date')\n        .on('mousedown', this._onDateFieldMouseDown.bind(this))\n        .appendTo(this.$field);\n      if (this.$timeField) {\n        // make sure date field comes before time field, otherwise tab won't work as expected\n        this.$dateField.insertBefore(this.$timeField);\n      }\n      if (!this.touchMode) {\n        this.$dateField\n          .on('keydown', this._onDateFieldKeyDown.bind(this))\n          .on('input', this._onDateFieldInput.bind(this))\n          .on('blur', this._onDateFieldBlur.bind(this))\n          .on('focus', this._onDateFieldFocus.bind(this));\n      }\n      this._linkWithLabel(this.$dateField);\n      HtmlComponent.install(this.$dateField, this.session);\n\n      this.$dateFieldIcon = fields.appendIcon(this.$field, 'date')\n        .on('mousedown', this._onDateIconMouseDown.bind(this));\n\n    } else if (!this.hasDate && this.$dateField) {\n      // Remove $dateField\n      this.$dateField.remove();\n      this.$dateField = null;\n      this.$dateFieldIcon.remove();\n      this.$dateFieldIcon = null;\n    }\n\n    if (!this.rendering) {\n      this._renderDisplayText();\n      this._renderFieldStyle();\n      this._renderEnabled();\n      this.htmlDateTimeComposite.invalidateLayoutTree();\n    }\n    this._renderDateClearable();\n    this.$container.toggleClass('has-date', this.hasDate);\n  }\n\n  setHasTime(hasTime) {\n    this.setProperty('hasTime', hasTime);\n  }\n\n  _setHasTime(hasTime) {\n    this._setProperty('hasTime', hasTime);\n    if (this.initialized) {\n      // if property changes on the fly, update the display text\n      this._updateDisplayTextProperty();\n    }\n  }\n\n  _renderHasTime() {\n    if (this.hasTime && !this.$timeField) {\n      // Add $timeField\n      this.$timeField = fields.makeInputOrDiv(this, 'time')\n        .on('mousedown', this._onTimeFieldMouseDown.bind(this))\n        .appendTo(this.$field);\n      if (this.$dateField) {\n        // make sure time field comes after date field, otherwise tab won't work as expected\n        this.$timeField.insertAfter(this.$dateField);\n      }\n      if (!this.touchMode || !this.hasTimePopup) {\n        this.$timeField\n          .on('keydown', this._onTimeFieldKeyDown.bind(this))\n          .on('input', this._onTimeFieldInput.bind(this))\n          .on('blur', this._onTimeFieldBlur.bind(this))\n          .on('focus', this._onTimeFieldFocus.bind(this));\n      }\n      this._linkWithLabel(this.$timeField);\n      HtmlComponent.install(this.$timeField, this.session);\n\n      this.$timeFieldIcon = fields.appendIcon(this.$field, 'time')\n        .on('mousedown', this._onTimeIconMouseDown.bind(this));\n\n    } else if (!this.hasTime && this.$timeField) {\n      // Remove $timeField\n      this.$timeField.remove();\n      this.$timeField = null;\n      this.$timeFieldIcon.remove();\n      this.$timeFieldIcon = null;\n    }\n\n    if (!this.rendering) {\n      this._renderDisplayText();\n      this._renderFieldStyle();\n      this._renderEnabled();\n      this.htmlDateTimeComposite.invalidateLayoutTree();\n    }\n    this._renderTimeClearable();\n    this.$container.toggleClass('has-time', this.hasTime);\n  }\n\n  setTimePickerResolution(timePickerResolution) {\n    this.setProperty('timePickerResolution', timePickerResolution);\n  }\n\n  _setTimePickerResolution(timePickerResolution) {\n    if (timePickerResolution < 1) {\n      // default\n      timePickerResolution = 10;\n      this.hasTimePopup = false;\n    } else {\n      this.hasTimePopup = true;\n    }\n    this._setProperty('timePickerResolution', timePickerResolution);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderPlaceholder($field) {\n    super._renderPlaceholder(\n      this._fieldForPlaceholder());\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _removePlaceholder($field) {\n    super._removePlaceholder(\n      this._fieldForPlaceholder());\n  }\n\n  _fieldForPlaceholder() {\n    if (this.hasDate) {\n      return this.$dateField;\n    } else if (this.hasTime) {\n      return this.$timeField;\n    }\n    return null;\n  }\n\n  setDateFormatPattern(dateFormatPattern) {\n    this.setProperty('dateFormatPattern', dateFormatPattern);\n  }\n\n  _setDateFormatPattern(dateFormatPattern) {\n    if (!dateFormatPattern) {\n      dateFormatPattern = this.session.locale.dateFormatPatternDefault;\n    }\n    this._setProperty('dateFormatPattern', dateFormatPattern);\n    this.isolatedDateFormat = new DateFormat(this.session.locale, this.dateFormatPattern);\n\n    if (this.initialized) {\n      // if format changes on the fly, just update the display text\n      this._updateDisplayText();\n    }\n  }\n\n  setTimeFormatPattern(timeFormatPattern) {\n    this.setProperty('timeFormatPattern', timeFormatPattern);\n  }\n\n  _setTimeFormatPattern(timeFormatPattern) {\n    if (!timeFormatPattern) {\n      timeFormatPattern = this.session.locale.timeFormatPatternDefault;\n    }\n    this._setProperty('timeFormatPattern', timeFormatPattern);\n    this.isolatedTimeFormat = new DateFormat(this.session.locale, this.timeFormatPattern);\n\n    if (this.initialized) {\n      // if format changes on the fly, just update the display text\n      this._updateDisplayText();\n    }\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n    this.$container.setEnabled(this.enabledComputed);\n    if (this.$dateField) {\n      this.$dateField.setEnabled(this.enabledComputed);\n    }\n    if (this.$timeField) {\n      this.$timeField.setEnabled(this.enabledComputed);\n    }\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  _renderDisplayText() {\n    if (this.hasDate) {\n      this._renderDateDisplayText();\n    }\n    if (this.hasTime) {\n      this._renderTimeDisplayText();\n    }\n    this._removePredictionFields();\n  }\n\n  _readDisplayText() {\n    let dateDisplayText, timeDisplayText;\n    if (this.hasDate) {\n      dateDisplayText = this._readDateDisplayText();\n    }\n    if (this.hasTime) {\n      timeDisplayText = this._readTimeDisplayText();\n    }\n    return this._computeDisplayText(dateDisplayText, timeDisplayText);\n  }\n\n  _renderDateDisplayText() {\n    fields.valOrText(this.$dateField, this.dateDisplayText);\n    this._updateDateHasText();\n  }\n\n  _readDateDisplayText() {\n    return (this._$predictDateField ? fields.valOrText(this._$predictDateField) : fields.valOrText(this.$dateField));\n  }\n\n  _renderTimeDisplayText() {\n    fields.valOrText(this.$timeField, this.timeDisplayText);\n    this._updateTimeHasText();\n  }\n\n  _readTimeDisplayText() {\n    return (this._$predictTimeField ? fields.valOrText(this._$predictTimeField) : fields.valOrText(this.$timeField));\n  }\n\n  /**\n   * @override\n   */\n  setDisplayText(displayText) {\n    // Overridden to avoid the equals check -> make sure renderDisplayText is executed whenever setDisplayText is called\n    // Reason: key up/down and picker day click modify the display text, but input doesn't\n    // -> reverting to a date using day click or up down after the input changed would not work anymore\n    // changing 'onXyInput' to always update the display text would fix that, but would break acceptInput\n    this._setDisplayText(displayText);\n    if (this.rendered) {\n      this._renderDisplayText();\n    }\n  }\n\n  _setDisplayText(displayText) {\n    this._setProperty('displayText', displayText);\n\n    let parts = this._splitDisplayText(displayText);\n    if (this.hasDate) {\n      // preserve dateDisplayText if hasDate is set to false (only override if it is true)\n      this.dateDisplayText = parts.dateText;\n    }\n    if (this.hasTime) {\n      // preserve timeDisplayText if hasTime is set to false (only override if it is true)\n      this.timeDisplayText = parts.timeText;\n    }\n  }\n\n  /**\n   * @override\n   */\n  _ensureValue(value) {\n    return dates.ensure(value);\n  }\n\n  /**\n   * @param {Date} value the date to validate\n   * @return {Date} the validated date\n   * @override\n   */\n  _validateValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return value;\n    }\n    if (!(value instanceof Date)) {\n      throw this.session.text(this.invalidValueMessageKey);\n    }\n\n    if (!this.isDateAllowed(value)) {\n      throw this.session.text('DateIsNotAllowed');\n    }\n\n    if (!this.hasDate && !this.value) {\n      // truncate to 01.01.1970 if no date was entered before. Otherwise preserve date part (important for toggling hasDate on the fly)\n      value = dates.combineDateTime(null, value);\n    }\n    return value;\n  }\n\n  isDateAllowed(date) {\n    if (!date || this.allowedDates.length === 0 || this.embedded) { // in embedded mode, main date field must take care of validation, otherwise error status won't be shown\n      return true;\n    }\n    let dateAsTimestamp = dates.trunc(date).getTime();\n    return this.allowedDates.some(allowedDate => allowedDate.getTime() === dateAsTimestamp);\n  }\n\n  _valueEquals(valueA, valueB) {\n    return dates.equals(valueA, valueB);\n  }\n\n  setAutoDate(autoDate) {\n    this.setProperty('autoDate', autoDate);\n  }\n\n  _setAutoDate(autoDate) {\n    autoDate = dates.ensure(autoDate);\n    this._setProperty('autoDate', autoDate);\n  }\n\n  setAllowedDates(allowedDates) {\n    this.setProperty('allowedDates', allowedDates);\n  }\n\n  _setAllowedDates(allowedDates) {\n    let truncDates = [];\n    arrays.ensure(allowedDates).forEach(date => {\n      if (date) {\n        truncDates.push(dates.trunc(dates.ensure(date)));\n      }\n    });\n    truncDates = truncDates.sort(dates.compare);\n    this._setProperty('allowedDates', truncDates);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderErrorStatus() {\n    super._renderErrorStatus();\n    let hasStatus = !!this.errorStatus,\n      statusClass = this._errorStatusClass();\n\n    if (this.$dateField) {\n      this._updateErrorStatusClassesOnElement(this.$dateField, statusClass, hasStatus);\n\n      // Because the error color of field icons depends on the error status of sibling <input> elements.\n      // The prediction fields are clones of the input fields, so the 'has-error' class has to be\n      // removed from them as well to make the icon \"valid\".\n      this._updateErrorStatusClassesOnElement(this._$predictDateField, statusClass, hasStatus);\n    }\n\n    // Do the same for the time field\n    if (this.$timeField) {\n      this._updateErrorStatusClassesOnElement(this.$timeField, statusClass, hasStatus);\n      this._updateErrorStatusClassesOnElement(this._$predictTimeField, statusClass, hasStatus);\n    }\n\n    if (this.popup) {\n      this._updateErrorStatusClassesOnElement(this.popup.$container, statusClass, hasStatus);\n    }\n  }\n\n  _errorStatusClass() {\n    return (this.errorStatus && !this._isSuppressStatusField()) ? 'has-' + this.errorStatus.cssClass() : '';\n  }\n\n  /**\n   * @Override FormField.js\n   */\n  _renderFont() {\n    this.$dateField && styles.legacyFont(this, this.$dateField);\n    this.$timeField && styles.legacyFont(this, this.$timeField);\n  }\n\n  /**\n   * @Override FormField.js\n   */\n  _renderForegroundColor() {\n    this.$dateField && styles.legacyForegroundColor(this, this.$dateField);\n    this.$timeField && styles.legacyForegroundColor(this, this.$timeField);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderBackgroundColor() {\n    this.$dateField && styles.legacyBackgroundColor(this, this.$dateField);\n    this.$timeField && styles.legacyBackgroundColor(this, this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  activate() {\n    if (!this.enabledComputed || !this.rendered) {\n      return;\n    }\n    if (this.$dateField) {\n      this.$dateField.focus();\n      this._onDateFieldMouseDown();\n    } else if (this.$timeField) {\n      this.$timeField.focus();\n      this._onTimeFieldMouseDown();\n    }\n  }\n\n  /**\n   * @override\n   */\n  getFocusableElement() {\n    if (this.$dateField) {\n      return this.$dateField;\n    }\n    if (this.$timeField) {\n      return this.$timeField;\n    }\n    return null;\n  }\n\n  _onDateFieldMouseDown() {\n    if (fields.handleOnClick(this)) {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n\n  _onTimeFieldMouseDown() {\n    if (fields.handleOnClick(this)) {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n\n  setDateFocused(dateFocused) {\n    this.setProperty('dateFocused', dateFocused);\n  }\n\n  _renderDateFocused() {\n    this.$container.toggleClass('date-focused', this.dateFocused);\n  }\n\n  _updateTimeHasText() {\n    this.setTimeHasText(strings.hasText(this._readTimeDisplayText()));\n  }\n\n  setTimeHasText(timeHasText) {\n    this.setProperty('timeHasText', timeHasText);\n  }\n\n  _renderTimeHasText() {\n    if (this.$timeField) {\n      this.$timeField.toggleClass('has-text', this.timeHasText);\n    }\n    this.$container.toggleClass('time-has-text', this.timeHasText);\n  }\n\n  _updateDateHasText() {\n    this.setDateHasText(strings.hasText(this._readDateDisplayText()));\n  }\n\n  setDateHasText(dateHasText) {\n    this.setProperty('dateHasText', dateHasText);\n  }\n\n  _renderDateHasText() {\n    if (this.$dateField) {\n      this.$dateField.toggleClass('has-text', this.dateHasText);\n    }\n    this.$container.toggleClass('date-has-text', this.dateHasText);\n  }\n\n  /**\n   * @override\n   */\n  clear() {\n    if (!(this.hasDate && this.hasTime)) {\n      super.clear();\n      return;\n    }\n    this._clear();\n    // If field shows date and time, don't accept input while one field has the focus\n    // Reason: x icon is shown in one field, pressing that icon should clear the content of that field.\n    // Accept input would set the value to '', thus clearing both fields which may be unexpected.\n    if (!this.dateFocused && !this.timeFocused) {\n      this.acceptInput();\n    }\n    this._triggerClear();\n  }\n\n  _clear() {\n    this._removePredictionFields();\n    if (this.hasDate && !this.timeFocused) {\n      fields.valOrText(this.$dateField, '');\n      this._setDateValid(true);\n      this._updateDateHasText();\n    }\n    if (this.hasTime && !this.dateFocused) {\n      fields.valOrText(this.$timeField, '');\n      this._setTimeValid(true);\n      this._updateTimeHasText();\n    }\n  }\n\n  _onDateClearIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$dateField.focus();\n    this.clear();\n    if (this.value) {\n      this.selectDate(this.value, false);\n    } else {\n      this.preselectDate(this._referenceDate(), false);\n    }\n    event.preventDefault();\n  }\n\n  _onDateIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$dateField.focus();\n    if (!this.embedded) {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n\n  setTimeFocused(timeFocused) {\n    this.setProperty('timeFocused', timeFocused);\n  }\n\n  _renderTimeFocused() {\n    this.$container.toggleClass('time-focused', this.timeFocused);\n  }\n\n  _renderClearable() {\n    this._renderDateClearable();\n    this._renderTimeClearable();\n    this._updateClearableStyles();\n  }\n\n  _renderDateClearable() {\n    if (this.hasDate && this.isClearable()) {\n      if (!this.$dateClearIcon) {\n        // date clear icon\n        this.$dateClearIcon = this.$field.appendSpan('icon date-clear unfocusable text-field-icon action')\n          .on('mousedown', this._onDateClearIconMouseDown.bind(this));\n      }\n    } else {\n      if (this.$dateClearIcon) {\n        // Remove clear icon\n        this.$dateClearIcon.remove();\n        this.$dateClearIcon = null;\n      }\n    }\n  }\n\n  _renderTimeClearable() {\n    if (this.hasTime && this.isClearable()) {\n      if (!this.$timeClearIcon) {\n        // time clear icon\n        this.$timeClearIcon = this.$field.appendSpan('icon time-clear unfocusable text-field-icon action')\n          .on('mousedown', this._onTimeClearIconMouseDown.bind(this));\n      }\n    } else {\n      if (this.$timeClearIcon) {\n        // Remove clear icon\n        this.$timeClearIcon.remove();\n        this.$timeClearIcon = null;\n      }\n    }\n  }\n\n  _onTimeClearIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$timeField.focus();\n    this.clear();\n    if (this.value) {\n      this.selectTime(this.value, false);\n    } else {\n      this.preselectTime(this._referenceDate(), false);\n    }\n    event.preventDefault();\n  }\n\n  _onTimeIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$timeField.focus();\n    if (!this.embedded) {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n\n  _onDateFieldBlur(event) {\n    this.setFocused(false);\n    this.setDateFocused(false);\n    if (this.embedded) {\n      // Don't execute, otherwise date would be accepted even though touch popup is still open.\n      // This prevents following behavior: user clears date by pressing x and then selects another date. Now a blur event is triggered which would call acceptDate and eventually remove the time\n      // -> Don't accept as long as touch dialog is open\n      return;\n    }\n\n    // Close picker and update model\n    if (this.popup instanceof DatePickerPopup) {\n      // in embedded mode we must update the date prediction but not close the popup (don't accidentally close time picker popup)\n      this.closePopup();\n    }\n    this.setDateFocused(false);\n    this.acceptDate();\n    this._removePredictionFields();\n  }\n\n  _onDateFieldFocus(event) {\n    this.setFocused(true);\n    this.setDateFocused(true);\n  }\n\n  _onTimeFieldBlur(event) {\n    this._tempTimeDate = null;\n    this.setFocused(false);\n    this.setTimeFocused(false);\n    if (this.embedded) {\n      // Don't execute, otherwise time would be accepted even though touch popup is still open.\n      // This prevents following behavior: user clears time by pressing x and then selects another time. Now a blur event is triggered which would call acceptTime and eventually remove the date\n      // -> Don't accept as long as touch dialog is open\n      return;\n    }\n\n    // Close picker and update model\n    if (this.popup instanceof TimePickerPopup) {\n      // in embedded mode we must update the date prediction but not close the popup\n      this.closePopup();\n    }\n    this._tempTimeDate = null;\n    this.setTimeFocused(false);\n    this.acceptTime();\n    this._removePredictionFields();\n  }\n\n  _onTimeFieldFocus() {\n    this.setFocused(true);\n    this.setTimeFocused(true);\n  }\n\n  /**\n   * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n   * in _onDateFieldInput(), which is fired after 'keydown'.\n   */\n  _onDateFieldKeyDown(event) {\n    let delta = 0,\n      diffYears = 0,\n      diffMonths = 0,\n      diffDays = 0,\n      cursorPos = this.$dateField[0].selectionStart,\n      displayText = fields.valOrText(this.$dateField),\n      prediction = this._$predictDateField && fields.valOrText(this._$predictDateField),\n      modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n      pickerStartDate = this.value || this._referenceDate(),\n      shiftDate = true;\n\n    // Don't propagate tab to cell editor -> tab should focus time field\n    if (this.hasTime &&\n      this.mode === FormField.Mode.CELLEDITOR &&\n      event.which === keys.TAB &&\n      modifierCount === 0) {\n      event.stopPropagation();\n      return;\n    }\n\n    if (event.which === keys.TAB ||\n      event.which === keys.SHIFT ||\n      event.which === keys.HOME ||\n      event.which === keys.END ||\n      event.which === keys.CTRL ||\n      event.which === keys.ALT) {\n      // Default handling\n      return;\n    }\n\n    if (event.which === keys.ENTER) {\n      if (this.popup || this._$predictDateField) {\n        // Close the picker and accept the current prediction (if available)\n        this.acceptDate();\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.ESC) {\n      if (this.popup) {\n        // Close the picker, but don't do anything else\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n      // Move cursor one right and apply next char of the prediction\n      if (prediction) {\n        this._setDateDisplayText(prediction.substring(0, displayText.length + 1));\n      }\n      return;\n    }\n\n    if (event.which === keys.UP || event.which === keys.DOWN ||\n      event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n      if (displayText && !this._isDateValid()) {\n        // If there is an error, try to parse the date. If it may be parsed, the error was likely a validation error.\n        // In that case use the parsed date as starting point and not the for the user invisible value\n        let parsedValue = this.isolatedDateFormat.parse(displayText, pickerStartDate);\n        if (parsedValue) {\n          pickerStartDate = parsedValue;\n          this._setDateValid(true);\n        }\n      }\n    }\n    if (event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n      if (!displayText || !this._isDateValid()) {\n        // If input is empty or invalid, set picker to reference date\n        pickerStartDate = this._referenceDate();\n        if (this.hasTime) { // keep time part\n          pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n        }\n        this.openDatePopupAndSelect(pickerStartDate);\n        this._updateDisplayText(pickerStartDate);\n        this._setDateValid(true);\n        shiftDate = false; // don't shift if field has no value yet and popup was not open\n      } else if (!this.popup) {\n        // Otherwise, ensure picker is open\n        this.openDatePopupAndSelect(pickerStartDate);\n      }\n      if (shiftDate) {\n        diffMonths = (event.which === keys.PAGE_UP ? -1 : 1);\n        this.shiftSelectedDate(0, diffMonths, 0);\n        this._updateDisplayText(this.getDatePicker().selectedDate);\n      }\n      $.suppressEvent(event);\n      return;\n    }\n\n    if (event.which === keys.UP || event.which === keys.DOWN) {\n      delta = (event.which === keys.UP ? -1 : 1);\n      // event.ctrlKey || event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx, use command key instead\n      if ((event.ctrlKey || event.metaKey) && modifierCount === 1) { // only ctrl\n        diffYears = delta;\n      } else if (event.shiftKey && modifierCount === 1) { // only shift\n        diffMonths = delta;\n      } else if (modifierCount === 0) { // no modifier\n        diffDays = delta;\n      } else {\n        // Unsupported modifier or too many modifiers\n        $.suppressEvent(event);\n        return;\n      }\n\n      if (!displayText || !this._isDateValid()) {\n        // If input is empty or invalid, set picker to reference date\n        pickerStartDate = this._referenceDate();\n        if (this.hasTime) { // keep time part\n          pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n        }\n        this.openDatePopupAndSelect(pickerStartDate);\n        this._updateDisplayText(pickerStartDate);\n        this._setDateValid(true);\n        shiftDate = false; // don't shift if field has no value yet and popup was not open\n      } else if (!this.popup) {\n        // Otherwise, ensure picker is open\n        this.openDatePopupAndSelect(pickerStartDate);\n      }\n      if (shiftDate) {\n        this.shiftSelectedDate(diffYears, diffMonths, diffDays);\n        this._updateDisplayText(this.getDatePicker().selectedDate);\n      }\n      $.suppressEvent(event);\n    }\n  }\n\n  /**\n   * Handle changed input. This method is fired when the field's content has been altered by a user\n   * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n   * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n   * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n   * in _onDateFieldKeyDown().\n   */\n  _onDateFieldInput(event) {\n    let displayText = fields.valOrText(this.$dateField);\n\n    // If the focus has changed to another field in the meantime, don't predict anything and\n    // don't show the picker. Just validate the input.\n    if (this.$dateField[0] !== this.$dateField.activeElement(true)) {\n      return;\n    }\n\n    // Create $predictDateField if necessary\n    if (!this._$predictDateField) {\n      this._$predictDateField = this._createPredictionField(this.$dateField);\n    }\n\n    // Predict date\n    this._removePredictErrorStatus();\n    let datePrediction = this._predictDate(displayText); // this also updates the errorStatus\n    if (datePrediction) {\n      fields.valOrText(this._$predictDateField, datePrediction.text);\n      this.openDatePopupAndSelect(datePrediction.date);\n    } else {\n      // No valid prediction!\n      this._removePredictionFields();\n    }\n    this._updateDateHasText();\n\n    // Hide the prediction field if input field is scrolled to the left. Otherwise, the\n    // two fields would not be aligned correctly, which looks bad. This can only happen\n    // when the fields are rather small, so the prediction would be of limited use anyway.\n    // Unfortunately, most browsers don't fire 'scroll' events for input fields. Also,\n    // when the 'input' even is fired, the scrollLeft() position sometimes has not been\n    // updated yet, that's why we must use setTimeout() with a short delay.\n    setTimeout(() => {\n      if (this._$predictDateField) {\n        this._$predictDateField.setVisible(this.$dateField.scrollLeft() === 0);\n      }\n    }, 50);\n  }\n\n  acceptInput() {\n    let displayText = scout.nvl(this._readDisplayText(), '');\n\n    let inputChanged = this._checkDisplayTextChanged(displayText);\n    if (inputChanged) {\n      this.parseAndSetValue(displayText);\n    } else {\n      let oldValue = this.value;\n      this.parseAndSetValue(displayText);\n      if (!dates.equals(this.value, oldValue)) {\n        inputChanged = true;\n      }\n    }\n    if (inputChanged) {\n      this._triggerAcceptInput();\n    }\n  }\n\n  /**\n   * Clears the time field if date field is empty before accepting the input.<br/>\n   * Don't delete invalid input from the time field.\n   */\n  acceptDate() {\n    let invalid = this.containsStatus(ParsingFailedStatus);\n    if (this.hasTime && !invalid && strings.empty(this.$dateField.val())) {\n      this.$timeField.val('');\n    }\n    this.acceptInput();\n  }\n\n  /**\n   * Clears the date field if time field is empty before accepting the input.<br/>\n   * Don't delete invalid input from the time field.\n   */\n  acceptTime() {\n    let invalid = this.containsStatus(ParsingFailedStatus);\n    if (this.hasDate && !invalid && strings.empty(this.$timeField.val())) {\n      this.$dateField.val('');\n    }\n    this.acceptInput();\n  }\n\n  acceptDateTime(acceptDate, acceptTime) {\n    if (acceptDate) {\n      this.acceptDate();\n    } else if (acceptTime) {\n      this.acceptTime();\n    }\n  }\n\n  /**\n   * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n   * in _onTimeFieldInput(), which is fired after 'keydown'.\n   */\n  _onTimeFieldKeyDown(event) {\n    let delta = 0,\n      diffHours = 0,\n      diffMinutes = 0,\n      diffSeconds = 0,\n      cursorPos = this.$timeField[0].selectionStart,\n      displayText = this.$timeField.val(),\n      prediction = this._$predictTimeField && this._$predictTimeField.val(),\n      modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n      pickerStartTime = this.value || this._referenceDate(),\n      shiftTime = true;\n\n    // Don't propagate shift-tab to cell editor -> shift tab should focus date field\n    if (this.hasDate &&\n      this.mode === FormField.Mode.CELLEDITOR &&\n      event.which === keys.TAB &&\n      event.shiftKey &&\n      modifierCount === 1) {\n      event.stopPropagation();\n      return;\n    }\n\n    if (event.which === keys.TAB ||\n      event.which === keys.SHIFT ||\n      event.which === keys.HOME ||\n      event.which === keys.END ||\n      event.which === keys.CTRL ||\n      event.which === keys.ALT) {\n      // Default handling\n      return;\n    }\n\n    if (event.which === keys.ENTER) {\n      // Timefield is shown in touch popup, so we need to make sure time gets accepted and popup closed, even if the regular time field itself has no popup\n      if (this.popup || this._$predictDateField) {\n        // Accept the current prediction (if available)\n        this._tempTimeDate = null;\n        this.acceptTime();\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.ESC) {\n      if (this.popup) {\n        // Close the picker, but don't do anything else\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n      // Move cursor one right and apply next char of the prediction\n      if (prediction) {\n        this._setTimeDisplayText(prediction.substring(0, displayText.length + 1));\n      }\n      return;\n    }\n\n    if (event.which === keys.UP || event.which === keys.DOWN) {\n      delta = (event.which === keys.UP ? -1 : 1);\n      if (event.ctrlKey && modifierCount === 1) { // only ctrl\n        diffSeconds = delta;\n      } else if (event.shiftKey && modifierCount === 1) { // only shift\n        diffHours = delta;\n      } else if (modifierCount === 0) { // no modifier\n        diffMinutes = delta;\n      } else {\n        // Unsupported modifier or too many modifiers\n        $.suppressEvent(event);\n        return;\n      }\n\n      if (this.hasTimePopup) {\n        if (!displayText || !this._isTimeValid()) {\n          // If input is empty or invalid, set picker to reference date\n          pickerStartTime = this._referenceDate();\n          this.openTimePopupAndSelect(pickerStartTime);\n          this._updateDisplayText(pickerStartTime);\n          this._setTimeValid(true);\n          shiftTime = false; // don't shift if field has no value yet and popup was not open\n        } else if (!this.popup) {\n          // Otherwise, ensure picker is open\n          this.openTimePopupAndSelect(pickerStartTime);\n        }\n        if (shiftTime) {\n          this.shiftSelectedTime(diffHours, diffMinutes, diffSeconds);\n          this._updateDisplayText(this.getTimePicker().selectedTime);\n        }\n        $.suppressEvent(event);\n      } else {\n        // without picker\n        if (!this._tempTimeDate) {\n          let timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n          if (timePrediction && timePrediction.date) {\n            this._tempTimeDate = timePrediction.date;\n          } else {\n            this._tempTimeDate = this._referenceDate();\n            shiftTime = false;\n          }\n        }\n        if (shiftTime) {\n          this._tempTimeDate = dates.shiftTime(this._tempTimeDate, diffHours, diffMinutes, diffSeconds);\n        }\n        if (this.hasDate) {\n          // Combine _tempTimeDate with existing date part\n          this._tempTimeDate = dates.combineDateTime(this.value || this._referenceDate(), this._tempTimeDate);\n        }\n        this._updateDisplayText(this._tempTimeDate);\n        this._setTimeValid(true);\n        $.suppressEvent(event);\n      }\n    }\n  }\n\n  /**\n   * Handle changed input. This method is fired when the field's content has been altered by a user\n   * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n   * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n   * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n   * in _onTimeFieldKeyDown().\n   */\n  _onTimeFieldInput(event) {\n    let displayText = this.$timeField.val();\n\n    // If the focus has changed to another field in the meantime, don't predict anything and\n    // don't show the picker. Just validate the input.\n    if (this.$timeField[0] !== this.$timeField.activeElement(true)) {\n      return;\n    }\n\n    // Create $predictTimeField if necessary\n    if (!this._$predictTimeField) {\n      this._$predictTimeField = this._createPredictionField(this.$timeField);\n    }\n\n    // Predict time\n    let timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n    if (timePrediction) {\n      this._$predictTimeField.val(timePrediction.text);\n      this.openTimePopupAndSelect(timePrediction.date);\n    } else {\n      // No valid prediction!\n      this._tempTimeDate = null;\n      this._removePredictionFields();\n    }\n    this._updateTimeHasText();\n\n    // See comment for similar code in _onDateFieldInput()\n    setTimeout(() => {\n      if (this._$predictTimeField) {\n        this._$predictTimeField.setVisible(this.$timeField.scrollLeft() === 0);\n      }\n    }, 50);\n  }\n\n  _onDatePickerDateSelect(event) {\n    this._setNewDateTimeValue(this._newTimestampAsDate(event.date, this.value));\n  }\n\n  _onTimePickerTimeSelect(event) {\n    this._setNewDateTimeValue(this._newTimestampAsDate(this.value, event.time));\n  }\n\n  _setNewDateTimeValue(newValue) {\n    this._setDateValid(true);\n    this._setTimeValid(true);\n    this.setValue(newValue);\n    this._triggerAcceptInput();\n    this.closePopup();\n  }\n\n  _createPredictionField($inputField) {\n    this.setSuppressStatus(FormField.SuppressStatus.ALL);\n    let $predictionField = $inputField.clone()\n      .addClass('predict')\n      .attr('tabIndex', '-1')\n      .insertBefore($inputField);\n    if ($inputField.hasClass('has-error')) {\n      $predictionField.addClass('has-error');\n    }\n    return $predictionField;\n  }\n\n  _removePredictionFields() {\n    this.setSuppressStatus(null);\n    if (this._$predictDateField) {\n      this._$predictDateField.remove();\n      this._$predictDateField = null;\n    }\n    if (this._$predictTimeField) {\n      this._$predictTimeField.remove();\n      this._$predictTimeField = null;\n    }\n  }\n\n  _setDateDisplayText(displayText) {\n    this.dateDisplayText = displayText;\n    this._updateDisplayTextProperty();\n    if (this.rendered) {\n      this._renderDateDisplayText();\n    }\n  }\n\n  _setTimeDisplayText(displayText) {\n    this.timeDisplayText = displayText;\n    this._updateDisplayTextProperty();\n    if (this.rendered) {\n      this._renderTimeDisplayText();\n    }\n  }\n\n  _computeDisplayText(dateDisplayText, timeDisplayText) {\n    let dateText = dateDisplayText || '',\n      timeText = timeDisplayText || '';\n\n    // do not use strings.join which ignores empty components\n    let displayText = (this.hasDate ? dateText : '') + (this.hasDate && this.hasTime ? '\\n' : '') + (this.hasTime ? timeText : '');\n\n    // empty display text should always be just an empty string\n    if (displayText === '\\n') {\n      displayText = '';\n    }\n    return displayText;\n  }\n\n  _splitDisplayText(displayText) {\n    let dateText = '',\n      timeText = '';\n\n    if (strings.hasText(displayText)) {\n      let parts = displayText.split('\\n');\n      dateText = this.hasDate ? parts[0] : '';\n      timeText = this.hasTime ? (this.hasDate ? parts[1] : parts[0]) : '';\n    }\n    return {\n      dateText: dateText,\n      timeText: timeText\n    };\n  }\n\n  _updateDisplayTextProperty() {\n    this._setProperty('displayText', this._computeDisplayText(this.dateDisplayText, this.timeDisplayText));\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  aboutToBlurByMouseDown(target) {\n    let dateFieldActive, timeFieldActive, eventOnDatePicker, eventOnTimePicker,\n      eventOnDateField = this.$dateField ? (this.$dateField.isOrHas(target) || this.$dateFieldIcon.isOrHas(target) || (this.$dateClearIcon && this.$dateClearIcon.isOrHas(target))) : false,\n      eventOnTimeField = this.$timeField ? (this.$timeField.isOrHas(target) || this.$timeFieldIcon.isOrHas(target) || (this.$timeClearIcon && this.$timeClearIcon.isOrHas(target))) : false,\n      eventOnPopup = this.popup && this.popup.$container.isOrHas(target),\n      eventOnStatus = this.fieldStatus && this.fieldStatus.$container.isOrHas(target),\n      datePicker = this.getDatePicker(),\n      timePicker = this.getTimePicker();\n\n    if (!eventOnDateField && !eventOnTimeField && !eventOnPopup && !eventOnStatus) {\n      // event outside this field.\n      dateFieldActive = focusUtils.isActiveElement(this.$dateField);\n      timeFieldActive = focusUtils.isActiveElement(this.$timeField);\n      // Accept only the currently focused part (the other one cannot have a pending change)\n      this.acceptDateTime(dateFieldActive, timeFieldActive);\n      return;\n    }\n\n    // when date-field is embedded, time-prediction must be accepted before\n    // the date-picker triggers the 'dateSelect' event.\n    if (this.embedded) {\n      eventOnDatePicker = datePicker && datePicker.$container.isOrHas(target);\n      eventOnTimePicker = timePicker && timePicker.$container.isOrHas(target);\n      if (eventOnDatePicker && eventOnTimePicker) {\n        this.acceptTime();\n      }\n    }\n  }\n\n  /**\n   * Returns null if both arguments are not set. Otherwise, this.value or the current date\n   * is used as basis and the given arguments are applied to that date. The result is returned.\n   */\n  _newTimestampAsDate(date, time) {\n    let result = null;\n    if (date || time) {\n      result = this.value || this._referenceDate();\n      if (date) {\n        result = dates.combineDateTime(date, result);\n      }\n      if (time) {\n        result = dates.combineDateTime(result, time);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns the reference date for this date field, which is used in various places (i.e. opening the date picker, analyzing user inputs).\n   *\n   * The reference date is either (in that order):\n   * - the model's \"auto timestamp\" (as date), or\n   * - the current date/time\n   */\n  _referenceDate() {\n    let referenceDate = this.autoDate || dates.ceil(dates.newDate(), this.timePickerResolution);\n    if (this.autoDate) {\n      referenceDate = this.autoDate;\n    } else if (this.hasTime) {\n      referenceDate = dates.ceil(dates.newDate(), this.timePickerResolution);\n    } else {\n      referenceDate = dates.trunc(dates.newDate());\n    }\n    if (this.allowedDates) {\n      referenceDate = this._findAllowedReferenceDate(referenceDate);\n    }\n    return referenceDate;\n  }\n\n  /**\n   * Find nearest allowed date which is equals or greater than the current referenceDate.\n   */\n  _findAllowedReferenceDate(referenceDate) {\n    let i, allowedDate;\n    // 1st: try to find a date which is equals or greater than the referenceDate (today)\n    for (i = 0; i < this.allowedDates.length; i++) {\n      allowedDate = this.allowedDates[i];\n      if (dates.compare(allowedDate, referenceDate) >= 0) {\n        return allowedDate;\n      }\n    }\n    // 2nd: try to find an allowed date in the past\n    for (i = this.allowedDates.length - 1; i >= 0; i--) {\n      allowedDate = this.allowedDates[i];\n      if (dates.compare(allowedDate, referenceDate) <= 0) {\n        return allowedDate;\n      }\n    }\n    return referenceDate;\n  }\n\n  openDatePopup(date) {\n    if (this.popup) {\n      // already open\n      return;\n    }\n\n    this.popup = this.createDatePopup();\n    this.popup.open();\n    this.$dateField.addClass('focused');\n    this.popup.one('destroy', event => {\n      // Removing the class must happen before _onPopupDestroy() is called, otherwise the date field no longer exists,\n      // because in touch mode _onPopupDestroy() destroys the date field.\n      this.$dateField.removeClass('focused');\n      this._onPopupDestroy(event);\n      this.popup = null;\n    });\n    this.getDatePicker().on('dateSelect', this._onDatePickerDateSelect.bind(this));\n  }\n\n  closePopup() {\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n\n  toggleDatePopup() {\n    $.log.isInfoEnabled() && $.log.info('(DateField#toggleDatePopup) popupOpen=', !!this.popup);\n    if (this.popup) {\n      this.closePopup();\n    } else {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n\n  openTimePopup(date) {\n    if (!this.hasTimePopup || this.popup) {\n      // already open\n      return;\n    }\n    this.popup = this.createTimePopup();\n    this.popup.open();\n    this.$timeField.addClass('focused');\n    this.popup.one('destroy', event => {\n      // Removing the class must happen before _onPopupDestroy() is called, otherwise the date field no longer exists,\n      // because in touch mode _onPopupDestroy() destroys the date field.\n      this.$timeField.removeClass('focused');\n      this._onPopupDestroy(event);\n      this.popup = null;\n    });\n    this.getTimePicker().on('timeSelect', this._onTimePickerTimeSelect.bind(this));\n  }\n\n  toggleTimePopup() {\n    $.log.isInfoEnabled() && $.log.info('(DateField#toggleTimePopup) popupOpen=', !!this.popup);\n    if (this.popup) {\n      this.closePopup();\n    } else {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n\n  _parseValue(displayText) {\n    let parts = this._splitDisplayText(displayText);\n    let dateText = parts.dateText;\n    let datePrediction = {};\n    let timeText = parts.timeText;\n    let timePrediction = {};\n    let success = true;\n\n    this._removePredictErrorStatus();\n    if (this.hasDate) {\n      datePrediction = this._predictDate(dateText); // this also updates the errorStatus\n      if (!datePrediction) {\n        success = false;\n      }\n      this._setDateDisplayText(dateText);\n    }\n\n    if (this.hasTime) {\n      timePrediction = this._predictTime(timeText); // this also updates the errorStatus\n      if (!timePrediction) {\n        success = false;\n      }\n      this._setTimeDisplayText(timeText);\n    }\n\n    // Error status was already set by _predict functions, throw this typed Status so DateField knows it must\n    // not set the error status again when the parse error is catched\n    if (!success) {\n      throw new DatePredictionFailedStatus();\n    }\n\n    // parse success -> return new value\n    if (datePrediction.date || timePrediction.date) {\n      return this._newTimestampAsDate(datePrediction.date, timePrediction.date);\n    }\n    return null;\n  }\n\n  /**\n   * Don't add error if it is a DatePredictionFailedStatus because the predict function\n   * has already added a parsing error.\n   */\n  _addParsingFailedErrorStatus(displayText, error) {\n    if (error instanceof DatePredictionFailedStatus) {\n      return;\n    }\n    super._addParsingFailedErrorStatus(displayText, error);\n  }\n\n  /**\n   * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n   */\n  _predictDate(inputText) {\n    inputText = inputText || '';\n\n    // \"Date calculations\"\n    let m = inputText.match(/^([+-])(\\d*)$/);\n    if (m) {\n      let now = dates.newDate();\n      let daysToAdd = Number(m[1] + (m[2] || '0'));\n      now.setDate(now.getDate() + daysToAdd);\n      if (isNaN(now.valueOf()) || now.getDate() < 0) { // Some older browsers don't set NaN but return invalid values\n        this._setDateValid(false);\n        return null;\n      }\n      this._setDateValid(true);\n      return {\n        date: now,\n        text: inputText\n      };\n    }\n\n    let analyzeInfo = this._analyzeInputAsDate(inputText, this.value || this._referenceDate());\n    if (analyzeInfo.error) {\n      this._setDateValid(false);\n      return null;\n    }\n\n    // No predicted date? -> return empty string (may happen if inputText is empty)\n    if (!analyzeInfo.predictedDate) {\n      this._setDateValid(true);\n      return {\n        date: null,\n        text: ''\n      };\n    }\n\n    let predictedDate = analyzeInfo.predictedDate;\n    let predictionFormat = new DateFormat(this.isolatedDateFormat.locale, analyzeInfo.parsedPattern);\n    let predictedDateFormatted = predictionFormat.format(predictedDate, true);\n\n    // If predicted date format starts with validatedText, ensure that the capitalization matches.\n    // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n    m = predictedDateFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n    if (m) {\n      predictedDateFormatted = inputText + m[1];\n    }\n\n    this._setDateValid(true);\n    return {\n      date: predictedDate,\n      text: predictedDateFormatted\n    };\n  }\n\n  /**\n   * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n   */\n  _predictTime(inputText) {\n    inputText = inputText || '';\n\n    let analyzeInfo = this._analyzeInputAsTime(inputText, this.value || this._referenceDate());\n    if (analyzeInfo.error) {\n      this._setTimeValid(false);\n      return null;\n    }\n\n    // No predicted date? -> return empty string (may happen if inputText is empty)\n    if (!analyzeInfo.predictedDate) {\n      this._setTimeValid(true);\n      return {\n        date: null,\n        text: ''\n      };\n    }\n\n    let predictedDate = analyzeInfo.predictedDate;\n    let predictionFormat = new DateFormat(this.isolatedTimeFormat.locale, analyzeInfo.parsedPattern);\n    let predictedTimeFormatted = predictionFormat.format(predictedDate, true);\n\n    // If predicted date format starts with validatedText, ensure that the capitalization matches.\n    // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n    let m = predictedTimeFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n    if (m) {\n      predictedTimeFormatted = inputText + m[1];\n    }\n\n    this._setTimeValid(true);\n    return {\n      date: predictedDate,\n      text: predictedTimeFormatted\n    };\n  }\n\n  _analyzeInputAsDate(inputText, startDate) {\n    return this.isolatedDateFormat.analyze(inputText, startDate);\n  }\n\n  _analyzeInputAsTime(inputText, startDate) {\n    return this.isolatedTimeFormat.analyze(inputText, startDate);\n  }\n\n  /**\n   * This method updates the parts (date, time) of the error status.\n   */\n  _setErrorStatusPart(property, valid) {\n\n    // check if date/time error exists\n    let status = null;\n    let storedStatus = null;\n    if (this.errorStatus) {\n      storedStatus = arrays.find(this.errorStatus.asFlatList(), DateField.PARSE_ERROR_PREDICATE);\n    }\n\n    if (storedStatus) {\n      status = storedStatus;\n    } else {\n      status = new ParsingFailedStatus({\n        message: this.session.text('ui.InvalidDate'),\n        severity: Status.Severity.ERROR,\n        code: DateField.ErrorCode.PARSE_ERROR\n      });\n    }\n\n    if (valid) {\n      delete status[property];\n    } else {\n      status[property] = true;\n    }\n\n    if (!status.hasOwnProperty('invalidDate') && !status.hasOwnProperty('invalidTime')) {\n      status = null;\n    }\n\n    if (status && !storedStatus) {\n      this.addErrorStatus(status);\n    } else if (!status && storedStatus) {\n      this._removePredictErrorStatus();\n    } // else: just update existing error\n  }\n\n  _removePredictErrorStatus() {\n    this.removeErrorStatusByPredicate(DateField.PARSE_ERROR_PREDICATE);\n  }\n\n  /**\n   * @override\n   */\n  _createInvalidValueStatus(statusType, value, error) {\n    let errorStatus = super._createInvalidValueStatus(statusType, value, error);\n    // Set date and time to invalid, otherwise isDateValid and isTimeValid return false even though there is a validation error\n    errorStatus.invalidDate = true;\n    errorStatus.invalidTime = true;\n    errorStatus.code = DateField.ErrorCode.PARSE_ERROR;\n    return errorStatus;\n  }\n\n  _setDateValid(valid) {\n    this._setErrorStatusPart('invalidDate', valid);\n  }\n\n  _setTimeValid(valid) {\n    this._setErrorStatusPart('invalidTime', valid);\n  }\n\n  _isErrorStatusPartValid(property) {\n    if (!this.errorStatus) {\n      return true;\n    }\n\n    // return false if one of the status has the invalid* property\n    return !this.errorStatus.asFlatList().some(status => {\n      return !!status[property];\n    });\n  }\n\n  _isDateValid() {\n    return this._isErrorStatusPartValid('invalidDate');\n  }\n\n  _isTimeValid() {\n    return this._isErrorStatusPartValid('invalidTime');\n  }\n\n  /**\n   * Method invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n   */\n  onCellEditorRendered(options) {\n    if (options.openFieldPopup) {\n      if (this.hasDate && !this.hasTime) {\n        this.openDatePopupAndSelect(this.value);\n      } else if (!this.hasDate && this.hasTime) {\n        this.openTimePopupAndSelect(this.value);\n      } else if (!Device.get().supportsOnlyTouch()) {\n        // If date AND time are active, don't open popup on touch devices because the user has to choose first what he wants to edit\n        this.openDatePopupAndSelect(this.value);\n      }\n    }\n    if (this.touchMode) {\n      this._cellEditorPopup = options.cellEditorPopup;\n    }\n  }\n\n  _onPopupDestroy(event) {\n    if (!this.touchMode || !this._cellEditorPopup) {\n      return;\n    }\n    if (this.hasDate && this.hasTime) {\n      // If date and time is shown, user might want to change both, let him close the cell editor when he is finished\n      return;\n    }\n    // Close cell editor when touch popup closes\n    this._cellEditorPopup.completeEdit();\n    this._cellEditorPopup = null;\n  }\n\n  /**\n   * @override FormField.js\n   */\n  prepareForCellEdit(opts) {\n    opts = opts || {};\n    super.prepareForCellEdit(opts);\n\n    this.$field.removeClass('cell-editor-field first last');\n    if (this.$dateField) {\n      this.addCellEditorFieldCssClasses(this.$dateField, opts);\n    }\n    if (this.$timeField) {\n      if (!this.$dateField) {\n        opts.cssClass = '';\n      }\n      this.addCellEditorFieldCssClasses(this.$timeField, opts);\n    }\n  }\n\n  /**\n   * @returns DatePicker instance from popup, because the property name is different\n   *    for DatePickerPopup and DatePickerTouchPopup.\n   */\n  getDatePicker() {\n    if (this.popup && this.popup.getDatePicker) {\n      return this.popup.getDatePicker();\n    }\n  }\n\n  /**\n   * Opens picker and selects date\n   *\n   * @param date\n   *          optional, Date to pass to the date picker. If no date is specified, the reference date\n   *          is preselected (not selected!).\n   */\n  openDatePopupAndSelect(date) {\n    this.openDatePopup();\n    if (!date) {\n      this.preselectDate(this._referenceDate(), false);\n    } else {\n      this.selectDate(date, false);\n    }\n  }\n\n  preselectDate(date, animated) {\n    let datePicker = this.getDatePicker();\n    if (datePicker) {\n      datePicker.preselectDate(date, animated);\n    }\n  }\n\n  selectDate(date, animated) {\n    let datePicker = this.getDatePicker();\n    if (datePicker) {\n      datePicker.selectDate(date, animated);\n    }\n  }\n\n  /**\n   * @returns DatePicker instance from popup, because the property name is different\n   *    for DatePickerPopup and DatePickerTouchPopup.\n   */\n  getTimePicker() {\n    if (this.popup && this.popup.getTimePicker) {\n      return this.popup.getTimePicker();\n    }\n  }\n\n  /**\n   * Opens picker and selects date\n   *\n   * @param date\n   *          optional, Date to pass to the date picker. If no date is specified, the reference date\n   *          is preselected (not selected!).\n   */\n  openTimePopupAndSelect(time) {\n    // resolution < 1 means no picker required\n    if (!this.hasTimePopup) {\n      return;\n    }\n    this.openTimePopup();\n    if (!time) {\n      this.preselectTime(this._referenceDate());\n    } else {\n      this.selectTime(time);\n    }\n  }\n\n  preselectTime(time) {\n    let timePicker = this.getTimePicker();\n    if (timePicker) {\n      timePicker.preselectTime(time);\n    }\n  }\n\n  selectTime(time) {\n    let timePicker = this.getTimePicker();\n    if (timePicker) {\n      timePicker.selectTime(time);\n    }\n  }\n\n  shiftSelectedDate(years, months, days) {\n    this.openDatePopup();\n    this.getDatePicker().shiftSelectedDate(years, months, days);\n  }\n\n  shiftSelectedTime(hourUnits, minuteUnits, secondUnits) {\n    this.openTimePopup();\n    this.getTimePicker().shiftSelectedTime(hourUnits, minuteUnits, secondUnits);\n  }\n\n  _formatValue(value) {\n    let\n      dateText = '',\n      timeText = '';\n\n    if (this.hasDate) {\n      if (value) {\n        dateText = this.isolatedDateFormat.format(value);\n      }\n      this.dateDisplayText = dateText;\n    }\n    if (this.hasTime) {\n      if (value) {\n        timeText = this.isolatedTimeFormat.format(value);\n      }\n      this.timeDisplayText = timeText;\n    }\n\n    return this._computeDisplayText(this.dateDisplayText, this.timeDisplayText);\n  }\n\n  /**\n   * @override\n   */\n  _renderFieldStyle() {\n    super._renderFieldStyle();\n    this._renderFieldStyleInternal(this.$dateField);\n    this._renderFieldStyleInternal(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$dateField);\n    this._renderDisabledStyleInternal(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  _triggerAcceptInput() {\n    let event = {\n      displayText: this.displayText,\n      errorStatus: this.errorStatus,\n      value: this.value\n    };\n    this.trigger('acceptInput', event);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}