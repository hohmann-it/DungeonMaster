{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, graphics, KeyStroke } from '../../index';\nexport default class AbstractTableNavigationKeyStroke extends KeyStroke {\n  constructor(table) {\n    super();\n    this.repeatable = true;\n    this.field = table;\n    this.shift = !table.multiSelect ? false : undefined;\n    this.stopPropagation = true;\n    this.keyStrokeMode = KeyStroke.Mode.DOWN;\n    this.inheritAccessibility = false;\n  }\n  _accept(event) {\n    let accepted = super._accept(event);\n    if (!accepted) {\n      return false;\n    }\n    if (!this.field.visibleRows.length) {\n      // Key stroke is accepted but currently not executable because there are no rows.\n      // Apply propagation flags to prevent bubbling, a focused table should always swallow the navigation keys even if there are no rows.\n      this._applyPropagationFlags(event);\n      return false;\n    }\n    let $activeElement = this.field.$container.activeElement();\n    let elementType = $activeElement[0].tagName.toLowerCase();\n    let $filterInput = this.field.$container.data('filter-field');\n    if ((!$filterInput || $activeElement[0] !== $filterInput[0]) && (elementType === 'textarea' || elementType === 'input') && (!event.originalEvent || event.originalEvent && !event.originalEvent.smartFieldEvent)) {\n      return false;\n    }\n    this.field.$container.addClass('keyboard-navigation');\n    return true;\n  }\n\n  /**\n   * Returns viewport sensitive information containing the first and last visible row in the viewport.\n   */\n  _viewportInfo() {\n    let viewportBounds,\n      dataInsets,\n      dataMarginTop,\n      firstRow,\n      lastRow,\n      table = this.field,\n      viewport = {},\n      rows = table.visibleRows;\n    if (rows.length === 0) {\n      return viewport;\n    }\n    viewportBounds = graphics.offsetBounds(table.$data);\n    dataInsets = graphics.insets(table.$data);\n    dataMarginTop = table.$data.cssMarginTop();\n    viewportBounds = viewportBounds.subtract(dataInsets);\n\n    // if data has a negative margin, adjust viewport otherwise a selected first row will never be in the viewport\n    if (dataMarginTop < 0) {\n      viewportBounds.y -= Math.abs(dataMarginTop);\n      viewportBounds.height += Math.abs(dataMarginTop);\n    }\n    firstRow = this._findFirstRowInViewport(table, viewportBounds);\n    lastRow = this._findLastRowInViewport(table, rows.indexOf(firstRow), viewportBounds);\n    viewport.firstRow = firstRow;\n    viewport.lastRow = lastRow;\n    return viewport;\n  }\n  firstRowAfterSelection() {\n    let $selectedRows = this.field.$selectedRows();\n    if (!$selectedRows.length) {\n      return;\n    }\n    let rows = this.field.visibleRows,\n      row = $selectedRows.last().data('row'),\n      rowIndex = this.field.filteredRows().indexOf(row);\n    return rows[rowIndex + 1];\n  }\n  firstRowBeforeSelection() {\n    let $selectedRows = this.field.$selectedRows();\n    if (!$selectedRows.length) {\n      return;\n    }\n    let rows = this.field.visibleRows,\n      row = $selectedRows.first().data('row'),\n      rowIndex = this.field.visibleRows.indexOf(row);\n    return rows[rowIndex - 1];\n  }\n\n  /**\n   * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n   */\n  _findLastSelectedRowBefore(table, rowIndex) {\n    let row,\n      rows = table.visibleRows;\n    if (rowIndex === 0) {\n      return rows[rowIndex];\n    }\n    row = arrays.findFromReverse(rows, rowIndex, (row, i) => {\n      let previousRow = rows[i - 1];\n      if (!previousRow) {\n        return false;\n      }\n      return !table.isRowSelected(previousRow);\n    });\n    // when no row has been found, use first row in table\n    if (!row) {\n      row = rows[0];\n    }\n    return row;\n  }\n\n  /**\n   * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n   */\n  _findLastSelectedRowAfter(table, rowIndex) {\n    let row,\n      rows = table.visibleRows;\n    if (rowIndex === rows.length - 1) {\n      return rows[rowIndex];\n    }\n    row = arrays.findFrom(rows, rowIndex, (row, i) => {\n      let nextRow = rows[i + 1];\n      if (!nextRow) {\n        return false;\n      }\n      return !table.isRowSelected(nextRow);\n    });\n    // when no row has been found, use last row in table\n    if (!row) {\n      row = rows[rows.length - 1];\n    }\n    return row;\n  }\n  _findFirstRowInViewport(table, viewportBounds) {\n    let rows = table.visibleRows;\n    return arrays.find(rows, (row, i) => {\n      let rowOffset,\n        rowMarginTop,\n        $row = row.$row;\n      if (!row.$row) {\n        // If row is not rendered, it cannot be part of the view port -> check next row\n        return false;\n      }\n      rowOffset = $row.offset();\n      rowMarginTop = row.$row.cssMarginTop();\n      // Selected row has a negative row margin\n      // -> add this margin to the offset to make sure this function does always return the same row independent of selection state\n      if (rowMarginTop < 0) {\n        rowOffset.top += Math.abs(rowMarginTop);\n      }\n\n      // If the row is fully visible in the viewport -> break and return the row\n      return viewportBounds.contains(rowOffset.left, rowOffset.top);\n    });\n  }\n  _findLastRowInViewport(table, startRowIndex, viewportBounds) {\n    let rows = table.visibleRows;\n    if (startRowIndex === rows.length - 1) {\n      return rows[startRowIndex];\n    }\n    return arrays.findFromForward(rows, startRowIndex, (row, i) => {\n      let nextRowOffsetBounds,\n        $nextRow,\n        nextRow = rows[i + 1];\n      if (!nextRow) {\n        // If next row is not available (row is the last row) -> break and return current row\n        return true;\n      }\n      $nextRow = nextRow.$row;\n      if (!$nextRow) {\n        // If next row is not rendered anymore, current row has to be the last in the viewport\n        return true;\n      }\n      nextRowOffsetBounds = graphics.offsetBounds($nextRow);\n      // If the next row is not fully visible in the viewport -> break and return current row\n      return !viewportBounds.contains(nextRowOffsetBounds.x, nextRowOffsetBounds.y + nextRowOffsetBounds.height - 1);\n    });\n  }\n  _isEnabled() {\n    return !this.field.tileMode && super._isEnabled();\n  }\n}","map":{"version":3,"names":["arrays","graphics","KeyStroke","AbstractTableNavigationKeyStroke","constructor","table","repeatable","field","shift","multiSelect","undefined","stopPropagation","keyStrokeMode","Mode","DOWN","inheritAccessibility","_accept","event","accepted","visibleRows","length","_applyPropagationFlags","$activeElement","$container","activeElement","elementType","tagName","toLowerCase","$filterInput","data","originalEvent","smartFieldEvent","addClass","_viewportInfo","viewportBounds","dataInsets","dataMarginTop","firstRow","lastRow","viewport","rows","offsetBounds","$data","insets","cssMarginTop","subtract","y","Math","abs","height","_findFirstRowInViewport","_findLastRowInViewport","indexOf","firstRowAfterSelection","$selectedRows","row","last","rowIndex","filteredRows","firstRowBeforeSelection","first","_findLastSelectedRowBefore","findFromReverse","i","previousRow","isRowSelected","_findLastSelectedRowAfter","findFrom","nextRow","find","rowOffset","rowMarginTop","$row","offset","top","contains","left","startRowIndex","findFromForward","nextRowOffsetBounds","$nextRow","x","_isEnabled","tileMode"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/keystrokes/AbstractTableNavigationKeyStroke.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, graphics, KeyStroke} from '../../index';\n\nexport default class AbstractTableNavigationKeyStroke extends KeyStroke {\n\n  constructor(table) {\n    super();\n    this.repeatable = true;\n    this.field = table;\n    this.shift = !table.multiSelect ? false : undefined;\n    this.stopPropagation = true;\n    this.keyStrokeMode = KeyStroke.Mode.DOWN;\n    this.inheritAccessibility = false;\n  }\n\n  _accept(event) {\n    let accepted = super._accept(event);\n    if (!accepted) {\n      return false;\n    }\n\n    if (!this.field.visibleRows.length) {\n      // Key stroke is accepted but currently not executable because there are no rows.\n      // Apply propagation flags to prevent bubbling, a focused table should always swallow the navigation keys even if there are no rows.\n      this._applyPropagationFlags(event);\n      return false;\n    }\n\n    let $activeElement = this.field.$container.activeElement();\n    let elementType = $activeElement[0].tagName.toLowerCase();\n    let $filterInput = this.field.$container.data('filter-field');\n    if ((!$filterInput || $activeElement[0] !== $filterInput[0]) &&\n      (elementType === 'textarea' || elementType === 'input') &&\n      (!event.originalEvent || (event.originalEvent && !event.originalEvent.smartFieldEvent))) {\n      return false;\n    }\n\n    this.field.$container.addClass('keyboard-navigation');\n    return true;\n  }\n\n  /**\n   * Returns viewport sensitive information containing the first and last visible row in the viewport.\n   */\n  _viewportInfo() {\n    let viewportBounds, dataInsets, dataMarginTop, firstRow, lastRow,\n      table = this.field,\n      viewport = {},\n      rows = table.visibleRows;\n\n    if (rows.length === 0) {\n      return viewport;\n    }\n\n    viewportBounds = graphics.offsetBounds(table.$data);\n    dataInsets = graphics.insets(table.$data);\n    dataMarginTop = table.$data.cssMarginTop();\n    viewportBounds = viewportBounds.subtract(dataInsets);\n\n    // if data has a negative margin, adjust viewport otherwise a selected first row will never be in the viewport\n    if (dataMarginTop < 0) {\n      viewportBounds.y -= Math.abs(dataMarginTop);\n      viewportBounds.height += Math.abs(dataMarginTop);\n    }\n\n    firstRow = this._findFirstRowInViewport(table, viewportBounds);\n    lastRow = this._findLastRowInViewport(table, rows.indexOf(firstRow), viewportBounds);\n\n    viewport.firstRow = firstRow;\n    viewport.lastRow = lastRow;\n    return viewport;\n  }\n\n  firstRowAfterSelection() {\n    let $selectedRows = this.field.$selectedRows();\n    if (!$selectedRows.length) {\n      return;\n    }\n\n    let rows = this.field.visibleRows,\n      row = $selectedRows.last().data('row'),\n      rowIndex = this.field.filteredRows().indexOf(row);\n\n    return rows[rowIndex + 1];\n  }\n\n  firstRowBeforeSelection() {\n    let $selectedRows = this.field.$selectedRows();\n    if (!$selectedRows.length) {\n      return;\n    }\n    let rows = this.field.visibleRows,\n      row = $selectedRows.first().data('row'),\n      rowIndex = this.field.visibleRows.indexOf(row);\n\n    return rows[rowIndex - 1];\n  }\n\n  /**\n   * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n   */\n  _findLastSelectedRowBefore(table, rowIndex) {\n    let row, rows = table.visibleRows;\n    if (rowIndex === 0) {\n      return rows[rowIndex];\n    }\n    row = arrays.findFromReverse(rows, rowIndex, (row, i) => {\n      let previousRow = rows[i - 1];\n      if (!previousRow) {\n        return false;\n      }\n      return !table.isRowSelected(previousRow);\n    });\n    // when no row has been found, use first row in table\n    if (!row) {\n      row = rows[0];\n    }\n    return row;\n  }\n\n  /**\n   * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n   */\n  _findLastSelectedRowAfter(table, rowIndex) {\n    let row, rows = table.visibleRows;\n    if (rowIndex === rows.length - 1) {\n      return rows[rowIndex];\n    }\n    row = arrays.findFrom(rows, rowIndex, (row, i) => {\n      let nextRow = rows[i + 1];\n      if (!nextRow) {\n        return false;\n      }\n      return !table.isRowSelected(nextRow);\n    });\n    // when no row has been found, use last row in table\n    if (!row) {\n      row = rows[rows.length - 1];\n    }\n    return row;\n  }\n\n  _findFirstRowInViewport(table, viewportBounds) {\n    let rows = table.visibleRows;\n    return arrays.find(rows, (row, i) => {\n      let rowOffset, rowMarginTop,\n        $row = row.$row;\n\n      if (!row.$row) {\n        // If row is not rendered, it cannot be part of the view port -> check next row\n        return false;\n      }\n      rowOffset = $row.offset();\n      rowMarginTop = row.$row.cssMarginTop();\n      // Selected row has a negative row margin\n      // -> add this margin to the offset to make sure this function does always return the same row independent of selection state\n      if (rowMarginTop < 0) {\n        rowOffset.top += Math.abs(rowMarginTop);\n      }\n\n      // If the row is fully visible in the viewport -> break and return the row\n      return viewportBounds.contains(rowOffset.left, rowOffset.top);\n    });\n  }\n\n  _findLastRowInViewport(table, startRowIndex, viewportBounds) {\n    let rows = table.visibleRows;\n    if (startRowIndex === rows.length - 1) {\n      return rows[startRowIndex];\n    }\n    return arrays.findFromForward(rows, startRowIndex, (row, i) => {\n      let nextRowOffsetBounds, $nextRow,\n        nextRow = rows[i + 1];\n\n      if (!nextRow) {\n        // If next row is not available (row is the last row) -> break and return current row\n        return true;\n      }\n      $nextRow = nextRow.$row;\n      if (!$nextRow) {\n        // If next row is not rendered anymore, current row has to be the last in the viewport\n        return true;\n      }\n      nextRowOffsetBounds = graphics.offsetBounds($nextRow);\n      // If the next row is not fully visible in the viewport -> break and return current row\n      return !viewportBounds.contains(nextRowOffsetBounds.x, nextRowOffsetBounds.y + nextRowOffsetBounds.height - 1);\n    });\n  }\n\n  _isEnabled() {\n    return !this.field.tileMode && super._isEnabled();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}