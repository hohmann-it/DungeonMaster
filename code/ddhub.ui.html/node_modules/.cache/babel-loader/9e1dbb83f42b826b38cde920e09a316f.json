{"ast":null,"code":"/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, filters, FocusContext, FocusRule, focusUtils, scout } from '../index';\nimport $ from 'jquery';\n\n/**\n * The focus manager ensures proper focus handling based on focus contexts.\n *\n * A focus context is bound to a $container. Once a context is activated, that container defines the tab cycle,\n * meaning that only child elements of that container can be entered by tab. Also, the context ensures proper\n * focus gaining, meaning that only focusable elements can gain focus. A focusable element is defined as an element,\n * which is natively focusable and which is not covert by a glass pane. Furthermore, if a context is unintalled,\n * the previously active focus context is activated and its focus position restored.\n */\nexport default class FocusManager {\n  constructor(options) {\n    let defaults = {\n      // Auto focusing of elements is bad with on screen keyboards -> deactivate to prevent unwanted popping up of the keyboard\n      active: !Device.get().supportsOnlyTouch(),\n      // Preventing blur is bad on touch devices because every touch on a non input field is supposed to close the keyboard which does not happen if preventDefault is used on mouse down\n      restrictedFocusGain: !Device.get().supportsOnlyTouch(),\n      session: null\n    };\n    $.extend(this, defaults, options);\n    if (!this.session) {\n      throw new Error('Session expected');\n    }\n    this._focusContexts = [];\n    this._glassPaneTargets = [];\n    this._glassPaneDisplayParents = [];\n    this._glassPaneRenderers = [];\n\n    // Make $entryPoint focusable and install focus context.\n    let $mainEntryPoint = this.session.$entryPoint;\n    let portletPartId = $mainEntryPoint.data('partid') || '0';\n    $mainEntryPoint.attr('tabindex', portletPartId);\n\n    // Restricted focus gain means that not every click outside of the active element necessarily focuses another element but the active element stays focused\n    // See _acceptFocusChangeOnMouseDown for details\n    if (this.restrictedFocusGain) {\n      this.installTopLevelMouseHandlers($mainEntryPoint);\n    }\n    this.installFocusContext($mainEntryPoint, FocusRule.AUTO);\n  }\n  installTopLevelMouseHandlers($container) {\n    // Install 'mousedown' on top-level $container to accept or prevent focus gain\n    $container.on('mousedown', event => {\n      if (!this._acceptFocusChangeOnMouseDown($(event.target))) {\n        event.preventDefault();\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Activates or deactivates focus management.\n   *\n   * If deactivated, the focus manager still validates the current focus, but never gains focus nor enforces a valid focus position.\n   * Once activated, the current focus position is revalidated.\n   */\n  activate(activate) {\n    if (this.active !== activate) {\n      this.active = activate;\n      if ($.log.isDebugEnabled()) {\n        $.log.isDebugEnabled() && $.log.debug('Focus manager active: ' + this.active);\n      }\n      if (this.active) {\n        this.validateFocus();\n      }\n    }\n  }\n\n  /**\n   * Installs a new focus context for the given $container, and sets the $container's initial focus, either by\n   * the given rule, or tries to gain focus for the given element.\n   * @returns {FocusContext} the installed context.\n   */\n  installFocusContext($container, focusRuleOrElement) {\n    let elementToFocus = this.evaluateFocusRule($container, focusRuleOrElement);\n\n    // Create and register the focus context.\n    let focusContext = new FocusContext($container, this);\n    if (FocusRule.PREPARE !== focusRuleOrElement) {\n      focusContext.ready();\n    }\n    this._pushIfAbsendElseMoveTop(focusContext);\n    if (elementToFocus) {\n      focusContext.validateAndSetFocus(elementToFocus);\n    }\n    return focusContext;\n  }\n\n  /**\n   * Evaluates the {@link FocusRule} or just returns the given element if focusRuleOrElement is not a focus rule.\n   */\n  evaluateFocusRule($container, focusRuleOrElement) {\n    let elementToFocus;\n    if (!focusRuleOrElement || scout.isOneOf(focusRuleOrElement, FocusRule.AUTO, FocusRule.PREPARE)) {\n      elementToFocus = this.findFirstFocusableElement($container);\n    } else if (focusRuleOrElement === FocusRule.NONE) {\n      elementToFocus = null;\n    } else {\n      elementToFocus = focusRuleOrElement;\n    }\n    return elementToFocus;\n  }\n\n  /**\n   * Uninstalls the focus context for the given $container, and activates the last active context.\n   * This method has no effect, if there is no focus context installed for the given $container.\n   * @param container\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] a boolean whether to prevent scrolling to focused element or not (defaults to true)\n   */\n  uninstallFocusContext($container, options) {\n    options = $.extend({}, {\n      preventScroll: true\n    }, options);\n    let focusContext = this.getFocusContext($container);\n    if (!focusContext) {\n      return;\n    }\n\n    // Filter to exclude the current focus context's container and any of its child elements to gain focus.\n    let filter = filters.outsideFilter(focusContext.$container);\n\n    // Remove and dispose the current focus context.\n    arrays.remove(this._focusContexts, focusContext);\n    focusContext.dispose();\n\n    // Activate last active focus context.\n    let activeFocusContext = this._findActiveContext();\n    if (activeFocusContext) {\n      activeFocusContext.validateAndSetFocus(activeFocusContext.lastValidFocusedElement, filter, options);\n    }\n  }\n\n  /**\n   * Returns whether there is a focus context installed for the given $container.\n   */\n  isFocusContextInstalled($container) {\n    return !!this.getFocusContext($container);\n  }\n\n  /**\n   * Activates the focus context of the given $container or the given focus context and validates the focus so that the previously focused element will be focused again.\n   * @param {(FocusContext|$)} focusContextOr$Container\n   */\n  activateFocusContext(focusContextOr$Container) {\n    let focusContext = focusContextOr$Container;\n    if (!(focusContextOr$Container instanceof FocusContext)) {\n      focusContext = this.getFocusContext(focusContextOr$Container);\n    }\n    if (!focusContext || this.isElementCovertByGlassPane(focusContext.$container)) {\n      return;\n    }\n    this._pushIfAbsendElseMoveTop(focusContext);\n    this.validateFocus();\n  }\n\n  /**\n   * Checks if the given element is accessible, meaning not covert by a glasspane.\n   *\n   * @param element a HTMLElement or a jQuery collection\n   * @param [filter] if specified, the filter is used to filter the array of glass pane targets\n   */\n  isElementCovertByGlassPane(element, filter) {\n    let targets = this._glassPaneTargets;\n    if (filter) {\n      targets = this._glassPaneTargets.filter(filter);\n    }\n    if (!targets.length) {\n      return false; // no glasspanes active.\n    }\n\n    if (this._glassPaneDisplayParents.indexOf(scout.widget(element)) >= 0) {\n      return true;\n    }\n    // Checks whether the element is a child of a glasspane target.\n    // If so, the some-iterator returns immediately with true.\n    return targets.some($glassPaneTarget => {\n      return $(element).closest($glassPaneTarget).length !== 0;\n    });\n  }\n\n  /**\n   * Registers the given glasspane target, so that the focus cannot be gained on the given target nor on its child elements.\n   */\n  registerGlassPaneTarget($glassPaneTarget) {\n    this._glassPaneTargets.push($glassPaneTarget);\n    this.validateFocus();\n  }\n  registerGlassPaneDisplayParent(displayParent) {\n    this._glassPaneDisplayParents.push(displayParent);\n  }\n  registerGlassPaneRenderer(glassPaneRenderer) {\n    this._glassPaneRenderers.push(glassPaneRenderer);\n  }\n\n  /**\n   * Unregisters the given glasspane target, so that the focus can be gained again for the target or one of its child controls.\n   */\n  unregisterGlassPaneTarget($glassPaneTarget) {\n    arrays.$remove(this._glassPaneTargets, $glassPaneTarget);\n    this.validateFocus();\n  }\n  unregisterGlassPaneDisplayParent(displayParent) {\n    arrays.remove(this._glassPaneDisplayParents, displayParent);\n  }\n  unregisterGlassPaneRenderer(glassPaneRenderer) {\n    arrays.remove(this._glassPaneRenderers, glassPaneRenderer);\n  }\n  rerenderGlassPanes() {\n    // create a copy of the current glassPaneRenderers\n    let currGlassPaneRenderers = this._glassPaneRenderers.slice();\n    // remove and rerender every glassPaneRenderer to keep them (and their members) valid.\n    currGlassPaneRenderers.forEach(glassPaneRenderer => {\n      glassPaneRenderer.removeGlassPanes();\n      glassPaneRenderer.renderGlassPanes();\n    });\n  }\n\n  /**\n   * Enforces proper focus on the currently active focus context.\n   *\n   * @param filter\n   *        Filter to exclude elements to gain focus.\n   */\n  validateFocus(filter) {\n    let activeContext = this._findActiveContext();\n    if (activeContext) {\n      activeContext.validateFocus(filter);\n    }\n  }\n  requestFocusIfReady(element, filter) {\n    return this.requestFocus(element, filter, {\n      onlyIfReady: true\n    });\n  }\n\n  /**\n   * Requests the focus for the given element, but only if being a valid focus location.\n   *\n   * @param {HTMLElement|$} [element]\n   *        the element to focus, or null to focus the context's first focusable element matching the given filter.\n   * @param {function} [filter]\n   *        filter that controls which element should be focused, or null to accept all focusable candidates.\n   * @param {object|boolean} [options]\n   *        Use object, boolean is deprecated\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   * @param {boolean} [options.onlyIfReady] prevents focusing if not ready\n   * @return {boolean} true if focus was gained, false otherwise.\n   */\n  requestFocus(element, filter, options) {\n    // backward compatibility\n    if (typeof options === 'boolean') {\n      options = {\n        onlyIfReady: options\n      };\n    } else {\n      options = options || {};\n    }\n    element = element instanceof $ ? element[0] : element;\n    if (!element) {\n      return false;\n    }\n    let context = this._findFocusContextFor(element);\n    if (context) {\n      if (scout.nvl(options.onlyIfReady, false) && !context.prepared) {\n        return false;\n      }\n      context.validateAndSetFocus(element, filter, options);\n    }\n    return focusUtils.isActiveElement(element);\n  }\n\n  /**\n   * Finds the first focusable element of the given $container, or null if not found.\n   */\n  findFirstFocusableElement($container, filter) {\n    let firstElement,\n      firstDefaultButton,\n      firstButton,\n      i,\n      candidate,\n      $candidate,\n      $menuParents,\n      $tabParents,\n      $boxButtons,\n      $entryPoint = $container.entryPoint(),\n      $candidates = $container.find(':focusable').addBack(':focusable') /* in some use cases, the container should be focusable as well, e.g. context menu without focusable children */.not($entryPoint) /* $entryPoint should never be a focusable candidate. However, if no focusable candidate is found, 'FocusContext.validateAndSetFocus' focuses the $entryPoint as a fallback. */.filter(filter || filters.returnTrue);\n    for (i = 0; i < $candidates.length; i++) {\n      candidate = $candidates[i];\n      $candidate = $(candidate);\n\n      // Check whether the candidate is accessible and not covert by a glass pane.\n      if (this.isElementCovertByGlassPane(candidate)) {\n        continue;\n      }\n      // Check if the element (or one of its parents) does not want to be the first focusable element\n      if ($candidate.is('.prevent-initial-focus') || $candidate.closest('.prevent-initial-focus').length > 0) {\n        continue;\n      }\n      if (!firstElement && !($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n        firstElement = candidate;\n      }\n      if (!firstDefaultButton && $candidate.is('.default')) {\n        firstDefaultButton = candidate;\n      }\n      $menuParents = $candidate.parents('.menubar');\n      $tabParents = $candidate.parents('.tab-box-header');\n      $boxButtons = $candidate.parents('.box-buttons');\n      if (($menuParents.length > 0 || $tabParents.length > 0 || $boxButtons.length > 0) && !firstButton && ($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n        firstButton = candidate;\n      } else if (!$menuParents.length && !$tabParents.length && !$boxButtons.length && typeof candidate.focus === 'function') {\n        // inline buttons and menues are selectable before choosing button or menu from bar\n        return candidate;\n      }\n    }\n    if (firstDefaultButton) {\n      return firstDefaultButton;\n    } else if (firstButton) {\n      if (firstButton !== firstElement && firstElement) {\n        let $tabParentsButton = $(firstButton).parents('.tab-box-header'),\n          $firstItem = $(firstElement),\n          $tabParentsFirstElement = $(firstElement).parents('.tab-box-header');\n        if ($tabParentsFirstElement.length > 0 && $tabParentsButton.length > 0 && $firstItem.is('.tab-item')) {\n          return firstElement;\n        }\n      }\n      return firstButton;\n    }\n    return firstElement;\n  }\n\n  /**\n   * Returns the currently active focus context, or null if not applicable.\n   */\n  _findActiveContext() {\n    return arrays.last(this._focusContexts);\n  }\n\n  /**\n   * Returns the focus context which is associated with the given $container, or null if not applicable.\n   */\n  getFocusContext($container) {\n    return arrays.find(this._focusContexts, focusContext => {\n      return focusContext.$container === $container;\n    });\n  }\n  _findFocusContextFor($element) {\n    $element = $.ensure($element);\n    let context = null;\n    let distance = Number.MAX_VALUE;\n    this._focusContexts.forEach(focusContext => {\n      if (!focusContext.$container.isOrHas($element)) {\n        return;\n      }\n      // Return the context which is closest to the element\n      let length = $element.parentsUntil(focusContext.$container).length;\n      if (length < distance) {\n        context = focusContext;\n      }\n    });\n    return context;\n  }\n\n  /**\n   * Returns whether to accept a 'mousedown event'.\n   */\n  _acceptFocusChangeOnMouseDown($element) {\n    // 1. Prevent focus gain when glasspane is clicked.\n    //    Even if the glasspane is not focusable, this check is required because the glasspane might be contained in a focusable container\n    //    like table. Use case: outline modality with table-page as 'outlineContent'.\n    if ($element.hasClass('glasspane')) {\n      return false;\n    }\n\n    // 2. Prevent focus gain if covert by glasspane.\n    if (this.isElementCovertByGlassPane($element)) {\n      return false;\n    }\n\n    // 3. Prevent focus gain on elements excluded to gain focus by mouse, e.g. buttons.\n    if (!focusUtils.isFocusableByMouse($element)) {\n      return false;\n    }\n\n    // 4. Allow focus gain on focusable elements.\n    if ($element.is(':focusable')) {\n      return true;\n    }\n\n    // 5. Allow focus gain on elements with selectable content, e.g. the value of a label field.\n    if (focusUtils.isSelectableText($element)) {\n      return true;\n    }\n\n    // 6. Allow focus gain on elements with a focusable parent, e.g. when clicking on a row in a table.\n    if (focusUtils.containsParentFocusableByMouse($element, $element.entryPoint())) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Registers the given focus context, or moves it on top if already registered.\n   */\n  _pushIfAbsendElseMoveTop(focusContext) {\n    arrays.remove(this._focusContexts, focusContext);\n    this._focusContexts.push(focusContext);\n  }\n}","map":{"version":3,"names":["arrays","Device","filters","FocusContext","FocusRule","focusUtils","scout","$","FocusManager","constructor","options","defaults","active","get","supportsOnlyTouch","restrictedFocusGain","session","extend","Error","_focusContexts","_glassPaneTargets","_glassPaneDisplayParents","_glassPaneRenderers","$mainEntryPoint","$entryPoint","portletPartId","data","attr","installTopLevelMouseHandlers","installFocusContext","AUTO","$container","on","event","_acceptFocusChangeOnMouseDown","target","preventDefault","activate","log","isDebugEnabled","debug","validateFocus","focusRuleOrElement","elementToFocus","evaluateFocusRule","focusContext","PREPARE","ready","_pushIfAbsendElseMoveTop","validateAndSetFocus","isOneOf","findFirstFocusableElement","NONE","uninstallFocusContext","preventScroll","getFocusContext","filter","outsideFilter","remove","dispose","activeFocusContext","_findActiveContext","lastValidFocusedElement","isFocusContextInstalled","activateFocusContext","focusContextOr$Container","isElementCovertByGlassPane","element","targets","length","indexOf","widget","some","$glassPaneTarget","closest","registerGlassPaneTarget","push","registerGlassPaneDisplayParent","displayParent","registerGlassPaneRenderer","glassPaneRenderer","unregisterGlassPaneTarget","$remove","unregisterGlassPaneDisplayParent","unregisterGlassPaneRenderer","rerenderGlassPanes","currGlassPaneRenderers","slice","forEach","removeGlassPanes","renderGlassPanes","activeContext","requestFocusIfReady","requestFocus","onlyIfReady","context","_findFocusContextFor","nvl","prepared","isActiveElement","firstElement","firstDefaultButton","firstButton","i","candidate","$candidate","$menuParents","$tabParents","$boxButtons","entryPoint","$candidates","find","addBack","not","returnTrue","is","hasClass","parents","focus","$tabParentsButton","$firstItem","$tabParentsFirstElement","last","$element","ensure","distance","Number","MAX_VALUE","isOrHas","parentsUntil","isFocusableByMouse","isSelectableText","containsParentFocusableByMouse"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/focus/FocusManager.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, filters, FocusContext, FocusRule, focusUtils, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * The focus manager ensures proper focus handling based on focus contexts.\n *\n * A focus context is bound to a $container. Once a context is activated, that container defines the tab cycle,\n * meaning that only child elements of that container can be entered by tab. Also, the context ensures proper\n * focus gaining, meaning that only focusable elements can gain focus. A focusable element is defined as an element,\n * which is natively focusable and which is not covert by a glass pane. Furthermore, if a context is unintalled,\n * the previously active focus context is activated and its focus position restored.\n */\nexport default class FocusManager {\n\n  constructor(options) {\n    let defaults = {\n      // Auto focusing of elements is bad with on screen keyboards -> deactivate to prevent unwanted popping up of the keyboard\n      active: !Device.get().supportsOnlyTouch(),\n      // Preventing blur is bad on touch devices because every touch on a non input field is supposed to close the keyboard which does not happen if preventDefault is used on mouse down\n      restrictedFocusGain: !Device.get().supportsOnlyTouch(),\n      session: null\n    };\n    $.extend(this, defaults, options);\n\n    if (!this.session) {\n      throw new Error('Session expected');\n    }\n\n    this._focusContexts = [];\n    this._glassPaneTargets = [];\n    this._glassPaneDisplayParents = [];\n    this._glassPaneRenderers = [];\n\n    // Make $entryPoint focusable and install focus context.\n    let $mainEntryPoint = this.session.$entryPoint;\n    let portletPartId = $mainEntryPoint.data('partid') || '0';\n    $mainEntryPoint.attr('tabindex', portletPartId);\n\n    // Restricted focus gain means that not every click outside of the active element necessarily focuses another element but the active element stays focused\n    // See _acceptFocusChangeOnMouseDown for details\n    if (this.restrictedFocusGain) {\n      this.installTopLevelMouseHandlers($mainEntryPoint);\n    }\n    this.installFocusContext($mainEntryPoint, FocusRule.AUTO);\n  }\n\n  installTopLevelMouseHandlers($container) {\n    // Install 'mousedown' on top-level $container to accept or prevent focus gain\n    $container.on('mousedown', event => {\n      if (!this._acceptFocusChangeOnMouseDown($(event.target))) {\n        event.preventDefault();\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Activates or deactivates focus management.\n   *\n   * If deactivated, the focus manager still validates the current focus, but never gains focus nor enforces a valid focus position.\n   * Once activated, the current focus position is revalidated.\n   */\n  activate(activate) {\n    if (this.active !== activate) {\n      this.active = activate;\n      if ($.log.isDebugEnabled()) {\n        $.log.isDebugEnabled() && $.log.debug('Focus manager active: ' + this.active);\n      }\n      if (this.active) {\n        this.validateFocus();\n      }\n    }\n  }\n\n  /**\n   * Installs a new focus context for the given $container, and sets the $container's initial focus, either by\n   * the given rule, or tries to gain focus for the given element.\n   * @returns {FocusContext} the installed context.\n   */\n  installFocusContext($container, focusRuleOrElement) {\n    let elementToFocus = this.evaluateFocusRule($container, focusRuleOrElement);\n\n    // Create and register the focus context.\n    let focusContext = new FocusContext($container, this);\n    if (FocusRule.PREPARE !== focusRuleOrElement) {\n      focusContext.ready();\n    }\n    this._pushIfAbsendElseMoveTop(focusContext);\n\n    if (elementToFocus) {\n      focusContext.validateAndSetFocus(elementToFocus);\n    }\n    return focusContext;\n  }\n\n  /**\n   * Evaluates the {@link FocusRule} or just returns the given element if focusRuleOrElement is not a focus rule.\n   */\n  evaluateFocusRule($container, focusRuleOrElement) {\n    let elementToFocus;\n    if (!focusRuleOrElement || scout.isOneOf(focusRuleOrElement, FocusRule.AUTO, FocusRule.PREPARE)) {\n      elementToFocus = this.findFirstFocusableElement($container);\n    } else if (focusRuleOrElement === FocusRule.NONE) {\n      elementToFocus = null;\n    } else {\n      elementToFocus = focusRuleOrElement;\n    }\n    return elementToFocus;\n  }\n\n  /**\n   * Uninstalls the focus context for the given $container, and activates the last active context.\n   * This method has no effect, if there is no focus context installed for the given $container.\n   * @param container\n   * @param {object} [options]\n   * @param {boolean} [options.preventScroll] a boolean whether to prevent scrolling to focused element or not (defaults to true)\n   */\n  uninstallFocusContext($container, options) {\n    options = $.extend({}, {\n      preventScroll: true\n    }, options);\n    let focusContext = this.getFocusContext($container);\n    if (!focusContext) {\n      return;\n    }\n\n    // Filter to exclude the current focus context's container and any of its child elements to gain focus.\n    let filter = filters.outsideFilter(focusContext.$container);\n\n    // Remove and dispose the current focus context.\n    arrays.remove(this._focusContexts, focusContext);\n    focusContext.dispose();\n\n    // Activate last active focus context.\n    let activeFocusContext = this._findActiveContext();\n    if (activeFocusContext) {\n      activeFocusContext.validateAndSetFocus(activeFocusContext.lastValidFocusedElement, filter, options);\n    }\n  }\n\n  /**\n   * Returns whether there is a focus context installed for the given $container.\n   */\n  isFocusContextInstalled($container) {\n    return !!this.getFocusContext($container);\n  }\n\n  /**\n   * Activates the focus context of the given $container or the given focus context and validates the focus so that the previously focused element will be focused again.\n   * @param {(FocusContext|$)} focusContextOr$Container\n   */\n  activateFocusContext(focusContextOr$Container) {\n    let focusContext = focusContextOr$Container;\n    if (!(focusContextOr$Container instanceof FocusContext)) {\n      focusContext = this.getFocusContext(focusContextOr$Container);\n    }\n    if (!focusContext || this.isElementCovertByGlassPane(focusContext.$container)) {\n      return;\n    }\n    this._pushIfAbsendElseMoveTop(focusContext);\n    this.validateFocus();\n  }\n\n  /**\n   * Checks if the given element is accessible, meaning not covert by a glasspane.\n   *\n   * @param element a HTMLElement or a jQuery collection\n   * @param [filter] if specified, the filter is used to filter the array of glass pane targets\n   */\n  isElementCovertByGlassPane(element, filter) {\n    let targets = this._glassPaneTargets;\n    if (filter) {\n      targets = this._glassPaneTargets.filter(filter);\n    }\n    if (!targets.length) {\n      return false; // no glasspanes active.\n    }\n\n    if (this._glassPaneDisplayParents.indexOf(scout.widget(element)) >= 0) {\n      return true;\n    }\n    // Checks whether the element is a child of a glasspane target.\n    // If so, the some-iterator returns immediately with true.\n    return targets.some($glassPaneTarget => {\n      return $(element).closest($glassPaneTarget).length !== 0;\n    });\n  }\n\n  /**\n   * Registers the given glasspane target, so that the focus cannot be gained on the given target nor on its child elements.\n   */\n  registerGlassPaneTarget($glassPaneTarget) {\n    this._glassPaneTargets.push($glassPaneTarget);\n    this.validateFocus();\n  }\n\n  registerGlassPaneDisplayParent(displayParent) {\n    this._glassPaneDisplayParents.push(displayParent);\n  }\n\n  registerGlassPaneRenderer(glassPaneRenderer) {\n    this._glassPaneRenderers.push(glassPaneRenderer);\n  }\n\n  /**\n   * Unregisters the given glasspane target, so that the focus can be gained again for the target or one of its child controls.\n   */\n  unregisterGlassPaneTarget($glassPaneTarget) {\n    arrays.$remove(this._glassPaneTargets, $glassPaneTarget);\n    this.validateFocus();\n  }\n\n  unregisterGlassPaneDisplayParent(displayParent) {\n    arrays.remove(this._glassPaneDisplayParents, displayParent);\n  }\n\n  unregisterGlassPaneRenderer(glassPaneRenderer) {\n    arrays.remove(this._glassPaneRenderers, glassPaneRenderer);\n  }\n\n  rerenderGlassPanes() {\n    // create a copy of the current glassPaneRenderers\n    let currGlassPaneRenderers = this._glassPaneRenderers.slice();\n    // remove and rerender every glassPaneRenderer to keep them (and their members) valid.\n    currGlassPaneRenderers.forEach(glassPaneRenderer => {\n      glassPaneRenderer.removeGlassPanes();\n      glassPaneRenderer.renderGlassPanes();\n    });\n  }\n\n  /**\n   * Enforces proper focus on the currently active focus context.\n   *\n   * @param filter\n   *        Filter to exclude elements to gain focus.\n   */\n  validateFocus(filter) {\n    let activeContext = this._findActiveContext();\n    if (activeContext) {\n      activeContext.validateFocus(filter);\n    }\n  }\n\n  requestFocusIfReady(element, filter) {\n    return this.requestFocus(element, filter, {\n      onlyIfReady: true\n    });\n  }\n\n  /**\n   * Requests the focus for the given element, but only if being a valid focus location.\n   *\n   * @param {HTMLElement|$} [element]\n   *        the element to focus, or null to focus the context's first focusable element matching the given filter.\n   * @param {function} [filter]\n   *        filter that controls which element should be focused, or null to accept all focusable candidates.\n   * @param {object|boolean} [options]\n   *        Use object, boolean is deprecated\n   * @param {boolean} [options.preventScroll] prevents scrolling to new focused element (defaults to false)\n   * @param {boolean} [options.onlyIfReady] prevents focusing if not ready\n   * @return {boolean} true if focus was gained, false otherwise.\n   */\n  requestFocus(element, filter, options) {\n    // backward compatibility\n    if (typeof options === 'boolean') {\n      options = {\n        onlyIfReady: options\n      };\n    } else {\n      options = options || {};\n    }\n    element = element instanceof $ ? element[0] : element;\n    if (!element) {\n      return false;\n    }\n\n    let context = this._findFocusContextFor(element);\n    if (context) {\n      if (scout.nvl(options.onlyIfReady, false) && !context.prepared) {\n        return false;\n      }\n      context.validateAndSetFocus(element, filter, options);\n    }\n\n    return focusUtils.isActiveElement(element);\n  }\n\n  /**\n   * Finds the first focusable element of the given $container, or null if not found.\n   */\n  findFirstFocusableElement($container, filter) {\n    let firstElement, firstDefaultButton, firstButton, i, candidate, $candidate, $menuParents, $tabParents, $boxButtons,\n      $entryPoint = $container.entryPoint(),\n      $candidates = $container\n        .find(':focusable')\n        .addBack(':focusable') /* in some use cases, the container should be focusable as well, e.g. context menu without focusable children */\n        .not($entryPoint) /* $entryPoint should never be a focusable candidate. However, if no focusable candidate is found, 'FocusContext.validateAndSetFocus' focuses the $entryPoint as a fallback. */\n        .filter(filter || filters.returnTrue);\n\n    for (i = 0; i < $candidates.length; i++) {\n      candidate = $candidates[i];\n      $candidate = $(candidate);\n\n      // Check whether the candidate is accessible and not covert by a glass pane.\n      if (this.isElementCovertByGlassPane(candidate)) {\n        continue;\n      }\n      // Check if the element (or one of its parents) does not want to be the first focusable element\n      if ($candidate.is('.prevent-initial-focus') || $candidate.closest('.prevent-initial-focus').length > 0) {\n        continue;\n      }\n\n      if (!firstElement && !($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n        firstElement = candidate;\n      }\n\n      if (!firstDefaultButton && $candidate.is('.default')) {\n        firstDefaultButton = candidate;\n      }\n\n      $menuParents = $candidate.parents('.menubar');\n      $tabParents = $candidate.parents('.tab-box-header');\n      $boxButtons = $candidate.parents('.box-buttons');\n      if (($menuParents.length > 0 || $tabParents.length > 0 || $boxButtons.length > 0) && !firstButton && ($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n        firstButton = candidate;\n      } else if (!$menuParents.length && !$tabParents.length && !$boxButtons.length && typeof candidate.focus === 'function') { // inline buttons and menues are selectable before choosing button or menu from bar\n        return candidate;\n      }\n    }\n    if (firstDefaultButton) {\n      return firstDefaultButton;\n    } else if (firstButton) {\n      if (firstButton !== firstElement && firstElement) {\n        let $tabParentsButton = $(firstButton).parents('.tab-box-header'),\n          $firstItem = $(firstElement),\n          $tabParentsFirstElement = $(firstElement).parents('.tab-box-header');\n        if ($tabParentsFirstElement.length > 0 && $tabParentsButton.length > 0 && $firstItem.is('.tab-item')) {\n          return firstElement;\n        }\n      }\n      return firstButton;\n    }\n    return firstElement;\n  }\n\n  /**\n   * Returns the currently active focus context, or null if not applicable.\n   */\n  _findActiveContext() {\n    return arrays.last(this._focusContexts);\n  }\n\n  /**\n   * Returns the focus context which is associated with the given $container, or null if not applicable.\n   */\n  getFocusContext($container) {\n    return arrays.find(this._focusContexts, focusContext => {\n      return focusContext.$container === $container;\n    });\n  }\n\n  _findFocusContextFor($element) {\n    $element = $.ensure($element);\n    let context = null;\n    let distance = Number.MAX_VALUE;\n    this._focusContexts.forEach(focusContext => {\n      if (!focusContext.$container.isOrHas($element)) {\n        return;\n      }\n      // Return the context which is closest to the element\n      let length = $element.parentsUntil(focusContext.$container).length;\n      if (length < distance) {\n        context = focusContext;\n      }\n    });\n    return context;\n  }\n\n  /**\n   * Returns whether to accept a 'mousedown event'.\n   */\n  _acceptFocusChangeOnMouseDown($element) {\n    // 1. Prevent focus gain when glasspane is clicked.\n    //    Even if the glasspane is not focusable, this check is required because the glasspane might be contained in a focusable container\n    //    like table. Use case: outline modality with table-page as 'outlineContent'.\n    if ($element.hasClass('glasspane')) {\n      return false;\n    }\n\n    // 2. Prevent focus gain if covert by glasspane.\n    if (this.isElementCovertByGlassPane($element)) {\n      return false;\n    }\n\n    // 3. Prevent focus gain on elements excluded to gain focus by mouse, e.g. buttons.\n    if (!focusUtils.isFocusableByMouse($element)) {\n      return false;\n    }\n\n    // 4. Allow focus gain on focusable elements.\n    if ($element.is(':focusable')) {\n      return true;\n    }\n\n    // 5. Allow focus gain on elements with selectable content, e.g. the value of a label field.\n    if (focusUtils.isSelectableText($element)) {\n      return true;\n    }\n\n    // 6. Allow focus gain on elements with a focusable parent, e.g. when clicking on a row in a table.\n    if (focusUtils.containsParentFocusableByMouse($element, $element.entryPoint())) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Registers the given focus context, or moves it on top if already registered.\n   */\n  _pushIfAbsendElseMoveTop(focusContext) {\n    arrays.remove(this._focusContexts, focusContext);\n    this._focusContexts.push(focusContext);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}