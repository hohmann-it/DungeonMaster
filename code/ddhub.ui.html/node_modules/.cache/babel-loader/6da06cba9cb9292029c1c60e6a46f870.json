{"ast":null,"code":"/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AbstractLayout, arrays, Dimension, graphics, HtmlComponent, MenuBarLayout, RowLayout, scout, scrollbars } from '../index';\nexport default class TableLayout extends AbstractLayout {\n  constructor(table) {\n    super();\n    this.table = table;\n    this._dataHeightPositive = false;\n  }\n  layout($container) {\n    let menuBarHeight = 0,\n      footerHeight = 0,\n      headerHeight = 0,\n      tileTableHeight = 0,\n      controlContainerHeight = 0,\n      controlContainerInsets,\n      tileAccordion = this.table.tableTileGridMediator ? this.table.tableTileGridMediator.tileAccordion : null,\n      $data = this.table.$data,\n      dataMargins = graphics.margins(scout.nvl($data, this.table.$container)),\n      dataMarginsHeight = dataMargins.top + dataMargins.bottom,\n      menuBar = this.table.menuBar,\n      footer = this.table.footer,\n      header = this.table.header,\n      tileTableHeader = this.table.tileTableHeader,\n      visibleColumns = this.table.visibleColumns(),\n      lastColumn = visibleColumns[visibleColumns.length - 1],\n      htmlContainer = this.table.htmlComp,\n      containerSize = htmlContainer.availableSize({\n        exact: true\n      }).subtract(htmlContainer.insets());\n    if (this.table.menuBarVisible && menuBar.visible) {\n      let htmlMenuBar = HtmlComponent.get(menuBar.$container);\n      let menuBarSize = MenuBarLayout.size(htmlMenuBar, containerSize);\n      htmlMenuBar.setSize(menuBarSize);\n      menuBarHeight = menuBarSize.height;\n    }\n    $container.css('--menubar-height', menuBarHeight + 'px');\n    if (header) {\n      headerHeight = graphics.size(header.$container).height;\n      if (header.menuBar) {\n        header.menuBar.validateLayout();\n      }\n    }\n    if (footer) {\n      // Layout table footer and add size of footer (including the control content) to 'height'\n      footerHeight = graphics.size(footer.$container).height;\n      controlContainerHeight = footer.computeControlContainerHeight(this.table, footer.selectedControl, !this._dataHeightPositive);\n      controlContainerInsets = graphics.insets(footer.$controlContainer);\n      if (!footer.animating) {\n        // closing or opening: height is about to be changed\n        footer.$controlContainer.cssHeight(controlContainerHeight);\n        footer.$controlContent.outerHeight(controlContainerHeight - controlContainerInsets.vertical());\n        footer.revalidateLayout();\n      }\n    }\n    if (tileTableHeader && tileTableHeader.visible) {\n      let groupBoxSize = tileTableHeader.htmlComp.prefSize({\n        widthHint: containerSize.width\n      });\n      groupBoxSize.width = containerSize.width;\n      groupBoxSize = groupBoxSize.subtract(tileTableHeader.htmlComp.margins());\n      tileTableHeader.htmlComp.setSize(groupBoxSize);\n      tileTableHeight = groupBoxSize.height;\n    }\n    let controlsHeight = dataMarginsHeight + menuBarHeight + controlContainerHeight + footerHeight + headerHeight + tileTableHeight;\n    let dataHeight = containerSize.height - controlsHeight;\n    $container.css('--controls-height', controlsHeight + 'px');\n    if ($data) {\n      $data.css('height', 'calc(100% - ' + controlsHeight + 'px)');\n      this._dataHeightPositive = $data.height() > 0;\n    } else {\n      if (tileAccordion && tileAccordion.htmlComp) {\n        tileAccordion.htmlComp.setSize(new Dimension(containerSize.width, dataHeight));\n        scrollbars.update(tileAccordion.$container);\n        this._dataHeightPositive = dataHeight > 0;\n      }\n    }\n    if (!this.table.tileMode) {\n      this._layoutColumns();\n\n      // Size of last column may have to be adjusted due to the header menu items\n      if (header) {\n        header.resizeHeaderItem(lastColumn);\n      }\n      this.table.setViewRangeSize(this.table.calculateViewRangeSize());\n      if (!htmlContainer.layouted) {\n        this.table._renderScrollTop();\n      }\n\n      // Always render viewport (not only when viewRangeSize changes), because view range depends on scroll position and data height\n      this.table._renderViewport();\n\n      // Render scroll top again to make sure the data is really at the correct position after rendering viewport.\n      // Somehow table.$data[0].scrollTop changes during _renderViewport sometimes (e.g. when there are aggregate rows)\n      if (!htmlContainer.layouted) {\n        this.table._renderScrollTop();\n      }\n\n      // Make sure tooltips and editor popup are at correct position after layouting (e.g after window resizing)\n      this.table.tooltips.forEach(tooltip => {\n        if (tooltip.rendered) {\n          tooltip.position();\n        }\n      });\n      if (this.table.cellEditorPopup && this.table.cellEditorPopup.rendered) {\n        this.table.cellEditorPopup.position();\n        this.table.cellEditorPopup.pack();\n      }\n      this.table.updateScrollbars();\n    }\n  }\n  _layoutColumns(widthHint) {\n    this._autoOptimizeColumnsWidths();\n    let htmlContainer = this.table.htmlComp;\n    let columnLayoutDirty = this.table.columnLayoutDirty || !htmlContainer.sizeCached;\n    if (!columnLayoutDirty) {\n      let width = widthHint || htmlContainer.size().width;\n      columnLayoutDirty = htmlContainer.sizeCached.width !== width;\n    }\n    // Auto resize only if table width or column structure has changed\n    if (columnLayoutDirty) {\n      if (this.table.autoResizeColumns) {\n        this._autoResizeColumns(widthHint);\n      }\n      // This is already done in _renderRowsInRange, but it is necessary here as well if the zoom level changes dynamically (or autoResizeColumns toggles)\n      this._updateRealColumnWidths();\n      this.table.columnLayoutDirty = false;\n    }\n  }\n\n  /**\n   * Workaround for Chrome bug, see {@link Table._updateRealColumnWidths}\n   */\n  _updateRealColumnWidths() {\n    if (this.table._updateRealColumnWidths()) {\n      this.table._updateRowWidth();\n      if (this.table.header && this.table.header.rendered) {\n        this.table.header.resizeHeaderItems();\n      }\n      this.table.$rows(true).css('width', this.table.rowWidth);\n    }\n  }\n\n  /**\n   * Resizes all visible columns with autoOptimizeWidth set to true, if necessary (means if autoOptimizeWidthRequired is true)\n   */\n  _autoOptimizeColumnsWidths() {\n    this.table.visibleColumns().forEach(function (column) {\n      if (column.autoOptimizeWidth && column.autoOptimizeWidthRequired) {\n        this.table.resizeToFit(column, column.autoOptimizeMaxWidth);\n      }\n    }, this);\n  }\n\n  /**\n   * Resizes the visible columns to make them use all the available space.\n   */\n  _autoResizeColumns(widthHint) {\n    let newWidth,\n      weight,\n      relevantColumns = [],\n      currentWidth = 0,\n      totalInitialWidth = 0,\n      tableWidth = widthHint || this.table.$data.width(),\n      availableWidth = Math.floor(tableWidth - (this.table.rowBorders.horizontal() + this.table.rowMargins.horizontal()));\n\n    // Don't resize fixed and auto optimize width columns\n    this.table.visibleColumns().forEach(column => {\n      if (column.fixedWidth || column.autoOptimizeWidth) {\n        availableWidth -= column.width;\n      } else {\n        relevantColumns.push(column);\n        currentWidth += column.width;\n        totalInitialWidth += column.initialWidth;\n      }\n    });\n    if (availableWidth === currentWidth) {\n      // Columns already use the available space, no need to resize\n      return;\n    }\n    let remainingWidth = availableWidth;\n\n    // First, filter columns which would get smaller than their minimal size\n    let minWidthColumns = relevantColumns.filter(column => {\n      // Use initial width as preferred width for auto resize columns.\n      // This makes sure the column doesn't get too small on small screens. The user can still make the column smaller though.\n      let minWidth = Math.max(column.minWidth, column.initialWidth);\n      if (totalInitialWidth === 0) {\n        weight = 1 / relevantColumns.length;\n      } else {\n        weight = column.initialWidth / totalInitialWidth;\n      }\n      newWidth = Math.floor(weight * remainingWidth);\n      if (newWidth < minWidth) {\n        newWidth = minWidth;\n        remainingWidth = Math.max(remainingWidth - newWidth, 0);\n        return true;\n      }\n      return false;\n    });\n\n    // Resize them to their minimal width\n    minWidthColumns.forEach((column, index) => {\n      let minWidth = Math.max(column.minWidth, column.initialWidth);\n      arrays.remove(relevantColumns, column);\n      newWidth = minWidth;\n      totalInitialWidth -= column.initialWidth;\n      // If this is the last column, add remaining space (due to rounding) to this column\n      if (index === minWidthColumns.length - 1 && remainingWidth > 0 && relevantColumns.length === 0) {\n        newWidth += remainingWidth;\n        remainingWidth = 0;\n      }\n      if (newWidth !== column.width) {\n        this.table.resizeColumn(column, newWidth);\n      }\n    });\n\n    // Then resize the others\n    availableWidth = remainingWidth;\n    relevantColumns.forEach((column, index) => {\n      if (totalInitialWidth === 0) {\n        weight = 1 / relevantColumns.length;\n      } else {\n        weight = column.initialWidth / totalInitialWidth;\n      }\n      newWidth = Math.floor(weight * availableWidth);\n      remainingWidth -= newWidth;\n      // If this is the last column, add remaining space (due to rounding) to this column\n      if (index === relevantColumns.length - 1 && remainingWidth > 0) {\n        newWidth += remainingWidth;\n        remainingWidth = 0;\n      }\n      if (newWidth !== column.width) {\n        this.table.resizeColumn(column, newWidth);\n      }\n    });\n  }\n  preferredLayoutSize($container, options) {\n    if (this.table.tileMode) {\n      // Use RowLayout to calculate preferredLayoutSize of TileTableHeader, TileAccordion and Footer.\n      return new RowLayout().preferredLayoutSize($container, options);\n    }\n    // If autoResizeColumns and text wrap is enabled, the height of the table depends on the width\n    this._layoutColumns(options.widthHint);\n\n    // If table was not visible during renderViewport, the rows are not rendered yet (see _renderViewport)\n    // -> make sure rows are rendered otherwise preferred height cannot be determined\n    this.table._renderViewport();\n    return super.preferredLayoutSize($container, options);\n  }\n}","map":{"version":3,"names":["AbstractLayout","arrays","Dimension","graphics","HtmlComponent","MenuBarLayout","RowLayout","scout","scrollbars","TableLayout","constructor","table","_dataHeightPositive","layout","$container","menuBarHeight","footerHeight","headerHeight","tileTableHeight","controlContainerHeight","controlContainerInsets","tileAccordion","tableTileGridMediator","$data","dataMargins","margins","nvl","dataMarginsHeight","top","bottom","menuBar","footer","header","tileTableHeader","visibleColumns","lastColumn","length","htmlContainer","htmlComp","containerSize","availableSize","exact","subtract","insets","menuBarVisible","visible","htmlMenuBar","get","menuBarSize","size","setSize","height","css","validateLayout","computeControlContainerHeight","selectedControl","$controlContainer","animating","cssHeight","$controlContent","outerHeight","vertical","revalidateLayout","groupBoxSize","prefSize","widthHint","width","controlsHeight","dataHeight","update","tileMode","_layoutColumns","resizeHeaderItem","setViewRangeSize","calculateViewRangeSize","layouted","_renderScrollTop","_renderViewport","tooltips","forEach","tooltip","rendered","position","cellEditorPopup","pack","updateScrollbars","_autoOptimizeColumnsWidths","columnLayoutDirty","sizeCached","autoResizeColumns","_autoResizeColumns","_updateRealColumnWidths","_updateRowWidth","resizeHeaderItems","$rows","rowWidth","column","autoOptimizeWidth","autoOptimizeWidthRequired","resizeToFit","autoOptimizeMaxWidth","newWidth","weight","relevantColumns","currentWidth","totalInitialWidth","tableWidth","availableWidth","Math","floor","rowBorders","horizontal","rowMargins","fixedWidth","push","initialWidth","remainingWidth","minWidthColumns","filter","minWidth","max","index","remove","resizeColumn","preferredLayoutSize","options"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/TableLayout.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {AbstractLayout, arrays, Dimension, graphics, HtmlComponent, MenuBarLayout, RowLayout, scout, scrollbars} from '../index';\n\nexport default class TableLayout extends AbstractLayout {\n\n  constructor(table) {\n    super();\n    this.table = table;\n    this._dataHeightPositive = false;\n  }\n\n  layout($container) {\n    let menuBarHeight = 0,\n      footerHeight = 0,\n      headerHeight = 0,\n      tileTableHeight = 0,\n      controlContainerHeight = 0,\n      controlContainerInsets,\n      tileAccordion = this.table.tableTileGridMediator ? this.table.tableTileGridMediator.tileAccordion : null,\n      $data = this.table.$data,\n      dataMargins = graphics.margins(scout.nvl($data, this.table.$container)),\n      dataMarginsHeight = dataMargins.top + dataMargins.bottom,\n      menuBar = this.table.menuBar,\n      footer = this.table.footer,\n      header = this.table.header,\n      tileTableHeader = this.table.tileTableHeader,\n      visibleColumns = this.table.visibleColumns(),\n      lastColumn = visibleColumns[visibleColumns.length - 1],\n      htmlContainer = this.table.htmlComp,\n      containerSize = htmlContainer.availableSize({\n        exact: true\n      }).subtract(htmlContainer.insets());\n\n    if (this.table.menuBarVisible && menuBar.visible) {\n      let htmlMenuBar = HtmlComponent.get(menuBar.$container);\n      let menuBarSize = MenuBarLayout.size(htmlMenuBar, containerSize);\n      htmlMenuBar.setSize(menuBarSize);\n      menuBarHeight = menuBarSize.height;\n    }\n    $container.css('--menubar-height', menuBarHeight + 'px');\n    if (header) {\n      headerHeight = graphics.size(header.$container).height;\n      if (header.menuBar) {\n        header.menuBar.validateLayout();\n      }\n    }\n    if (footer) {\n      // Layout table footer and add size of footer (including the control content) to 'height'\n      footerHeight = graphics.size(footer.$container).height;\n      controlContainerHeight = footer.computeControlContainerHeight(this.table, footer.selectedControl, !this._dataHeightPositive);\n      controlContainerInsets = graphics.insets(footer.$controlContainer);\n      if (!footer.animating) { // closing or opening: height is about to be changed\n        footer.$controlContainer.cssHeight(controlContainerHeight);\n        footer.$controlContent.outerHeight(controlContainerHeight - controlContainerInsets.vertical());\n        footer.revalidateLayout();\n      }\n    }\n    if (tileTableHeader && tileTableHeader.visible) {\n      let groupBoxSize = tileTableHeader.htmlComp.prefSize({\n        widthHint: containerSize.width\n      });\n      groupBoxSize.width = containerSize.width;\n      groupBoxSize = groupBoxSize.subtract(tileTableHeader.htmlComp.margins());\n      tileTableHeader.htmlComp.setSize(groupBoxSize);\n      tileTableHeight = groupBoxSize.height;\n    }\n    let controlsHeight = dataMarginsHeight + menuBarHeight + controlContainerHeight + footerHeight + headerHeight + tileTableHeight;\n    let dataHeight = containerSize.height - controlsHeight;\n    $container.css('--controls-height', controlsHeight + 'px');\n    if ($data) {\n      $data.css('height', 'calc(100% - ' + controlsHeight + 'px)');\n      this._dataHeightPositive = $data.height() > 0;\n    } else {\n      if (tileAccordion && tileAccordion.htmlComp) {\n        tileAccordion.htmlComp.setSize(new Dimension(containerSize.width, dataHeight));\n        scrollbars.update(tileAccordion.$container);\n        this._dataHeightPositive = dataHeight > 0;\n      }\n    }\n\n    if (!this.table.tileMode) {\n      this._layoutColumns();\n\n      // Size of last column may have to be adjusted due to the header menu items\n      if (header) {\n        header.resizeHeaderItem(lastColumn);\n      }\n\n      this.table.setViewRangeSize(this.table.calculateViewRangeSize());\n\n      if (!htmlContainer.layouted) {\n        this.table._renderScrollTop();\n      }\n\n      // Always render viewport (not only when viewRangeSize changes), because view range depends on scroll position and data height\n      this.table._renderViewport();\n\n      // Render scroll top again to make sure the data is really at the correct position after rendering viewport.\n      // Somehow table.$data[0].scrollTop changes during _renderViewport sometimes (e.g. when there are aggregate rows)\n      if (!htmlContainer.layouted) {\n        this.table._renderScrollTop();\n      }\n\n      // Make sure tooltips and editor popup are at correct position after layouting (e.g after window resizing)\n      this.table.tooltips.forEach(tooltip => {\n        if (tooltip.rendered) {\n          tooltip.position();\n        }\n      });\n      if (this.table.cellEditorPopup && this.table.cellEditorPopup.rendered) {\n        this.table.cellEditorPopup.position();\n        this.table.cellEditorPopup.pack();\n      }\n\n      this.table.updateScrollbars();\n    }\n  }\n\n  _layoutColumns(widthHint) {\n    this._autoOptimizeColumnsWidths();\n\n    let htmlContainer = this.table.htmlComp;\n    let columnLayoutDirty = this.table.columnLayoutDirty || !htmlContainer.sizeCached;\n    if (!columnLayoutDirty) {\n      let width = widthHint || htmlContainer.size().width;\n      columnLayoutDirty = htmlContainer.sizeCached.width !== width;\n    }\n    // Auto resize only if table width or column structure has changed\n    if (columnLayoutDirty) {\n      if (this.table.autoResizeColumns) {\n        this._autoResizeColumns(widthHint);\n      }\n      // This is already done in _renderRowsInRange, but it is necessary here as well if the zoom level changes dynamically (or autoResizeColumns toggles)\n      this._updateRealColumnWidths();\n      this.table.columnLayoutDirty = false;\n    }\n  }\n\n  /**\n   * Workaround for Chrome bug, see {@link Table._updateRealColumnWidths}\n   */\n  _updateRealColumnWidths() {\n    if (this.table._updateRealColumnWidths()) {\n      this.table._updateRowWidth();\n      if (this.table.header && this.table.header.rendered) {\n        this.table.header.resizeHeaderItems();\n      }\n      this.table.$rows(true)\n        .css('width', this.table.rowWidth);\n    }\n  }\n\n  /**\n   * Resizes all visible columns with autoOptimizeWidth set to true, if necessary (means if autoOptimizeWidthRequired is true)\n   */\n  _autoOptimizeColumnsWidths() {\n    this.table.visibleColumns().forEach(function(column) {\n      if (column.autoOptimizeWidth && column.autoOptimizeWidthRequired) {\n        this.table.resizeToFit(column, column.autoOptimizeMaxWidth);\n      }\n    }, this);\n  }\n\n  /**\n   * Resizes the visible columns to make them use all the available space.\n   */\n  _autoResizeColumns(widthHint) {\n    let newWidth, weight,\n      relevantColumns = [],\n      currentWidth = 0,\n      totalInitialWidth = 0,\n      tableWidth = widthHint || this.table.$data.width(),\n      availableWidth = Math.floor(tableWidth - (this.table.rowBorders.horizontal() + this.table.rowMargins.horizontal()));\n\n    // Don't resize fixed and auto optimize width columns\n    this.table.visibleColumns().forEach(column => {\n      if (column.fixedWidth || column.autoOptimizeWidth) {\n        availableWidth -= column.width;\n      } else {\n        relevantColumns.push(column);\n        currentWidth += column.width;\n        totalInitialWidth += column.initialWidth;\n      }\n    });\n\n    if (availableWidth === currentWidth) {\n      // Columns already use the available space, no need to resize\n      return;\n    }\n\n    let remainingWidth = availableWidth;\n\n    // First, filter columns which would get smaller than their minimal size\n    let minWidthColumns = relevantColumns.filter(column => {\n      // Use initial width as preferred width for auto resize columns.\n      // This makes sure the column doesn't get too small on small screens. The user can still make the column smaller though.\n      let minWidth = Math.max(column.minWidth, column.initialWidth);\n      if (totalInitialWidth === 0) {\n        weight = 1 / relevantColumns.length;\n      } else {\n        weight = column.initialWidth / totalInitialWidth;\n      }\n      newWidth = Math.floor(weight * remainingWidth);\n      if (newWidth < minWidth) {\n        newWidth = minWidth;\n        remainingWidth = Math.max(remainingWidth - newWidth, 0);\n        return true;\n      }\n      return false;\n    });\n\n    // Resize them to their minimal width\n    minWidthColumns.forEach((column, index) => {\n      let minWidth = Math.max(column.minWidth, column.initialWidth);\n      arrays.remove(relevantColumns, column);\n\n      newWidth = minWidth;\n      totalInitialWidth -= column.initialWidth;\n      // If this is the last column, add remaining space (due to rounding) to this column\n      if (index === minWidthColumns.length - 1 && remainingWidth > 0 && relevantColumns.length === 0) {\n        newWidth += remainingWidth;\n        remainingWidth = 0;\n      }\n      if (newWidth !== column.width) {\n        this.table.resizeColumn(column, newWidth);\n      }\n    });\n\n    // Then resize the others\n    availableWidth = remainingWidth;\n    relevantColumns.forEach((column, index) => {\n      if (totalInitialWidth === 0) {\n        weight = 1 / relevantColumns.length;\n      } else {\n        weight = column.initialWidth / totalInitialWidth;\n      }\n      newWidth = Math.floor(weight * availableWidth);\n      remainingWidth -= newWidth;\n      // If this is the last column, add remaining space (due to rounding) to this column\n      if (index === relevantColumns.length - 1 && remainingWidth > 0) {\n        newWidth += remainingWidth;\n        remainingWidth = 0;\n      }\n      if (newWidth !== column.width) {\n        this.table.resizeColumn(column, newWidth);\n      }\n    });\n  }\n\n  preferredLayoutSize($container, options) {\n    if (this.table.tileMode) {\n      // Use RowLayout to calculate preferredLayoutSize of TileTableHeader, TileAccordion and Footer.\n      return new RowLayout().preferredLayoutSize($container, options);\n    }\n    // If autoResizeColumns and text wrap is enabled, the height of the table depends on the width\n    this._layoutColumns(options.widthHint);\n\n    // If table was not visible during renderViewport, the rows are not rendered yet (see _renderViewport)\n    // -> make sure rows are rendered otherwise preferred height cannot be determined\n    this.table._renderViewport();\n    return super.preferredLayoutSize($container, options);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}