{"ast":null,"code":"/*\n * Copyright (c) 2010-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Dimension, graphics, Insets, NullLayout, scout } from '../index';\nimport $ from 'jquery';\n\n/**\n * Wrapper for a JQuery selector. Used as replacement for javax.swing.JComponent.\n */\nexport default class HtmlComponent {\n  constructor($comp, session) {\n    if (!session) {\n      throw new Error('session must be defined for ' + this.debug());\n    }\n    this.$comp = $comp;\n    this.layout = new NullLayout();\n    this.layoutData = null;\n    this.valid = false;\n    this.validateRoot = false;\n\n    /**\n     * Flag to indicate that the component has been layouted at least once. Invalidation should NOT reset this flag.\n     */\n    this.layouted = false;\n\n    /**\n     * Flag to indicate that the component is being layouted.\n     */\n    this.layouting = false;\n\n    /**\n     * May be set to temporarily disable invalidation (e.g. if the component gets modified during the layouting process)\n     */\n    this.suppressInvalidate = false;\n\n    /**\n     * May be set to temporarily disable layout validation (e.g. if the component gets modified during the layouting process).\n     * It is still possible to invalidate its layout. But as long as this flag is set, it will not validate the layout.\n     * It is the responsibility of the caller to ensure that the component is validated again (if necessary) when the layout validation suppression is removed.\n     * @type {boolean}\n     */\n    this.suppressValidate = false;\n\n    /**\n     * Set pixelBasedSizing to false if your component automatically adjusts its size,\n     * e.g. by using CSS styling -> setSize won't be called.\n     */\n    this.pixelBasedSizing = true;\n    this.sizeCached = null;\n\n    /**\n     * Object which stores the computed preferred size. Key is a string containing the width and height hints.\n     * @see #computePrefSizeKey(options);\n     */\n    this.prefSizeCached = {};\n    this.session = session;\n    this.scrollable = false;\n  }\n\n  /**\n   * Returns the parent or $comp or null when $comp has no parent.\n   * Creates a new instance of HtmlComponent if the parent DOM element has no linked instance yet.\n   */\n  getParent() {\n    let $parent = this.$comp.parent();\n    if ($parent.length === 0) {\n      return null;\n    }\n    return HtmlComponent.optGet($parent);\n  }\n\n  /**\n   * @returns {boolean} true if the given htmlComponent is an ancestor, false if not\n   */\n  isDescendantOf(htmlComp) {\n    let $parent = this.$comp.parent();\n    while ($parent.length > 0) {\n      if (HtmlComponent.optGet($parent) === htmlComp) {\n        return true;\n      }\n      $parent = $parent.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Computes the preferred height if the component is scrollable and returns it if it is greater than the actual size.\n   * If it is not scrollable, the actual height is returned.\n   * <p>\n   * The returned size contains insets (padding and border) but no margin. The width is always the actual width because there are no horizontal scrollbars.\n   *\n   * OPTION    DEFAULT VALUE   DESCRIPTION\n   * -------------------------------------\n   * exact     false           When set to true the returned dimensions may contain fractional digits, otherwise the sizes are rounded up.\n   *\n   * @param (options) may contain the options of the above table\n   */\n  availableSize(options) {\n    options = options || {};\n    let size = this.size({\n      exact: options.exact\n    });\n    if (this.scrollable) {\n      let prefSize = this.prefSize({\n        widthHint: size.width,\n        removeMarginFromHints: false // Since the width of this component is used as hint, the margin must not be removed\n      });\n\n      if (prefSize.height > size.height) {\n        size.height = prefSize.height;\n      }\n    }\n    return size;\n  }\n\n  /**\n   * Invalidates the component (sets the valid property to false and calls layout.invalidate()).\n   * @param {HtmlComponent} [htmlSource] The component the invalidation originated from.\n   *        Is always set if the invalidation is triggered by using invalidateLayoutTree, may be undefined otherwise.\n   */\n  invalidateLayout(htmlSource) {\n    this.valid = false;\n    this.prefSizeCached = {};\n    if (this.layout) {\n      this.layout.invalidate(htmlSource);\n    }\n  }\n\n  /**\n   * Calls the layout of the component to layout its children but only if the component is not valid.\n   * @exception when component has no layout\n   * @return {boolean} true if validation was successful, false if it could not be executed (e.g. because the element is invisible or detached)\n   */\n  validateLayout() {\n    if (!this.layout) {\n      throw new Error('Called layout() but component has no layout');\n    }\n    if (this.valid) {\n      return true;\n    }\n    if (this.suppressValidate) {\n      return false;\n    }\n    if (this.layouting) {\n      return false;\n    }\n    if (!this._checkValidationPossible()) {\n      return false;\n    }\n    this.layouting = true;\n    this.layout.layout(this.$comp);\n    this.layouting = false;\n    this.layouted = true;\n    // Save size for later use (necessary if pixelBasedSizing is set to false)\n    this.sizeCached = this.size({\n      exact: true\n    });\n    this.valid = true;\n    return true;\n  }\n  _checkValidationPossible() {\n    // Don't layout components which don't exist anymore, are invisible or are detached from the DOM\n    if (!this.isAttachedAndVisible()) {\n      return false;\n    }\n\n    // Don't layout if component is currently animated\n    if (this.$comp.hasAnimationClass()) {\n      this._validateLayoutAfterAnimation(this.$comp);\n      return false;\n    }\n\n    // Check the visibility of the parents as well.\n    // Also check if one of the parents is currently being animated.\n    // To improve performance (the check might loop to the top of the DOM tree), the following code is\n    // not executed if the parent already executed it, which is the case if the parent is being layouted.\n    let parent = this.getParent();\n    if (!parent || !parent.layouting) {\n      let everyParentVisible = true;\n      let $animatedParent = null;\n      this.$comp.parents().each(function () {\n        let $parent = $(this);\n        if (!$parent.isVisible()) {\n          everyParentVisible = false;\n          return false;\n        }\n        if ($parent.hasAnimationClass()) {\n          $animatedParent = $parent;\n          return false;\n        }\n        return true; // continue loop\n      });\n\n      if (!everyParentVisible) {\n        return false;\n      }\n      if ($animatedParent) {\n        // Postpone the layout if there is a CSS animation in progress on one of the parent containers.\n        // Otherwise, wrong sizes might be measured (depending on the CSS animation, e.g. grow/shrink).\n        this._validateLayoutAfterAnimation($animatedParent);\n        return false;\n      }\n    }\n    return true;\n  }\n  _validateLayoutAfterAnimation($animatedElement) {\n    $animatedElement.oneAnimationEnd(this.validateLayout.bind(this));\n  }\n\n  /**\n   * Performs invalidateLayout() and validateLayout() subsequently.\n   */\n  revalidateLayout() {\n    this.invalidateLayout();\n    this.validateLayout();\n  }\n\n  /**\n   * Invalidates the component-tree up to the next validate root, but only if invalidateParents is set to true.\n   */\n  invalidateLayoutTree(invalidateParents) {\n    if (this.suppressInvalidate) {\n      return;\n    }\n    if (scout.nvl(invalidateParents, true)) {\n      this.session.layoutValidator.invalidateTree(this); // will call invalidateLayout(), which sets this.valid = false\n    } else {\n      this.invalidateLayout();\n      this.session.layoutValidator.invalidate(this);\n    }\n  }\n\n  /**\n   * Layouts all invalid components\n   */\n  validateLayoutTree() {\n    if (this.suppressValidate) {\n      return;\n    }\n    this.session.layoutValidator.validate();\n  }\n\n  /**\n   * Performs invalidateLayoutTree() and validateLayoutTree() subsequently.\n   */\n  revalidateLayoutTree(invalidateParents) {\n    if (this.suppressInvalidate) {\n      return;\n    }\n    this.invalidateLayoutTree(invalidateParents);\n    this.validateLayoutTree();\n  }\n\n  /**\n   * Marks the end of the parent invalidation. <p>\n   * A component is a validate root if its size does not depend on the visibility or bounds of its children.<p>\n   * Example: It is not necessary to relayout the whole form if just the label of a form field gets invisible.\n   * Only the form field container needs to be relayouted. In this case the form field container is the validate root.\n   */\n  isValidateRoot() {\n    if (this.validateRoot) {\n      return true;\n    }\n    if (!this.layoutData || !this.layoutData.isValidateRoot) {\n      return false;\n    }\n    return this.layoutData.isValidateRoot();\n  }\n\n  /**\n   * Sets the given layout.\n   */\n  setLayout(layout) {\n    this.layout = layout;\n    if (layout.cssClass) {\n      this.$comp.addClass(layout.cssClass);\n    }\n  }\n\n  /**\n   * Returns the preferred size of the component, insets included, margin excluded.<p>\n   * The preferred size is cached until the component will be invalidated.\n   * Hence, subsequent calls to this function will return the cached preferred size unless the component is invalidated.\n   * <p>\n   *\n   * @param {object|boolean} [options] an optional options object. Short-hand version: If a boolean is passed instead of an object, the value is automatically converted to the option \"includeMargin\".\n   *                  May contain the options described below. All other options are passed as they are to the layout when layout.preferredLayoutSize() is called.\n   *                  Possible options may be found at graphics.prefSize(), but it depends on the actual layout if these options have an effect or not.\n   * @param {boolean|null} [options.includeMargin] Whether to include the margin in the returned size. Default is false.\n   * @param {number} [options.widthHint] When set, horizontal padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n   * @param {number} [options.heightHint] When set, vertical padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n   * @param {boolean|null} [options.removeMarginFromHints] Whether or not to automatically remove the margin from the hints. Default is true.\n   * @param {boolean|null} [options.removeInsetsFromHints] Whether or not to automatically remove the insets (padding and border) from the hints. Default is true.\n   * @exception When component has no layout\n   */\n  prefSize(options) {\n    if (!this.isVisible()) {\n      return new Dimension(0, 0);\n    }\n    if (typeof options === 'boolean') {\n      options = {\n        includeMargin: options\n      };\n    } else {\n      // Create a copy to not modify the original options\n      options = $.extend({}, options);\n    }\n    let includeMargin = scout.nvl(options.includeMargin, false);\n    options.includeMargin = null;\n    if (!this.layout) {\n      throw new Error('Called prefSize() but component has no layout');\n    }\n    let prefSizeCacheKey = this.computePrefSizeKey(options);\n    let prefSizeCached = this.prefSizeCached[prefSizeCacheKey];\n    if (!$.isEmptyObject(prefSizeCached)) {\n      $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSizeCached=' + prefSizeCached);\n      if (includeMargin) {\n        prefSizeCached = prefSizeCached.add(this.margins());\n      }\n      return prefSizeCached.clone();\n    }\n    let minSize = this.cssMinSize();\n    let maxSize = this.cssMaxSize();\n    if (options.widthHint || options.heightHint) {\n      this._adjustSizeHintsForPrefSize(options, minSize, maxSize);\n    }\n    let prefSize = this.layout.preferredLayoutSize(this.$comp, options);\n    this._adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize);\n    this.prefSizeCached[prefSizeCacheKey] = prefSize;\n    $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSize=' + prefSize);\n    if (includeMargin) {\n      prefSize = prefSize.add(this.margins());\n    }\n    return prefSize.clone();\n  }\n  computePrefSizeKey(options) {\n    return 'wHint' + scout.nvl(options.widthHint, '-1') + 'hHint' + scout.nvl(options.heightHint, '-1') + 'wOnly' + scout.nvl(options.widthOnly, '-1');\n  }\n\n  /**\n   * Remove padding, border and margin from the width and heightHint so that the actual layout does not need to take care of it.\n   * Also makes sure the hints consider the min and max size set by CSS.\n   */\n  _adjustSizeHintsForPrefSize(options, minSize, maxSize) {\n    let removeMargins = scout.nvl(options.removeMarginFromHints, true);\n    let removeInsets = scout.nvl(options.removeInsetsFromHints, true);\n    options.removeMarginFromHints = null;\n    options.removeInsetsFromHints = null;\n    if (!options.widthHint && !options.heightHint) {\n      return;\n    }\n    let margins = removeMargins ? this.margins() : new Insets();\n    let insets = removeInsets ? this.insets() : new Insets();\n    if (options.widthHint) {\n      // The order is important! Box-sizing: border-box is expected.\n      options.widthHint -= margins.horizontal();\n      options.widthHint = Math.max(options.widthHint, minSize.width);\n      options.widthHint = Math.min(options.widthHint, maxSize.width);\n      options.widthHint -= insets.horizontal();\n    }\n    if (options.heightHint) {\n      // The order is important! Box-sizing: border-box is expected.\n      options.heightHint -= margins.vertical();\n      options.heightHint = Math.max(options.heightHint, minSize.height);\n      options.heightHint = Math.min(options.heightHint, maxSize.height);\n      options.heightHint -= insets.vertical();\n    }\n  }\n\n  /**\n   * The html element may define a min or max height/height -> adjust the pref size accordingly\n   */\n  _adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize) {\n    minSize = minSize || this.cssMinSize();\n    maxSize = maxSize || this.cssMaxSize();\n    prefSize.height = Math.max(prefSize.height, minSize.height);\n    prefSize.height = Math.min(prefSize.height, maxSize.height);\n    prefSize.width = Math.max(prefSize.width, minSize.width);\n    prefSize.width = Math.min(prefSize.width, maxSize.width);\n  }\n\n  /**\n   * Returns the inset-dimensions of the component (padding and border, no margin).\n   */\n  insets(options) {\n    return graphics.insets(this.$comp, options);\n  }\n  margins() {\n    return graphics.margins(this.$comp);\n  }\n  borders() {\n    return graphics.borders(this.$comp);\n  }\n  cssMinSize() {\n    return graphics.cssMinSize(this.$comp);\n  }\n  cssMaxSize() {\n    return graphics.cssMaxSize(this.$comp);\n  }\n\n  /**\n   * Returns the size of the component, insets included.\n   * @param options, see {@link graphics#size} for details.\n   */\n  size(options) {\n    return graphics.size(this.$comp, options);\n  }\n\n  /**\n   * Sets the size of the component, insets included. Which means: the method subtracts the components insets\n   * from the given size before setting the width/height of the component.\n   *\n   * @param {Dimension} size\n   */\n  setSize(size) {\n    if (!this.isAttachedAndVisible()) {\n      // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n      return;\n    }\n    let oldSize = this.sizeCached;\n    if (!size.equals(oldSize)) {\n      this.invalidateLayout();\n    }\n    if (this.pixelBasedSizing) {\n      graphics.setSize(this.$comp, size);\n    }\n    this.validateLayout();\n  }\n  bounds(options) {\n    return graphics.bounds(this.$comp, options);\n  }\n  position() {\n    return graphics.position(this.$comp);\n  }\n  offsetBounds(options) {\n    return graphics.offsetBounds(this.$comp, options);\n  }\n  offset() {\n    return graphics.offset(this.$comp);\n  }\n\n  /**\n   * Delegation to graphics.setLocation\n   * @param location Point\n   */\n  setLocation(location) {\n    graphics.setLocation(this.$comp, location);\n  }\n  location() {\n    return graphics.location(this.$comp);\n  }\n  setBounds(bounds) {\n    if (!this.isAttachedAndVisible()) {\n      // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n      return;\n    }\n    let oldSize = this.sizeCached;\n    if (!bounds.dimension().equals(oldSize)) {\n      this.invalidateLayout();\n    }\n    if (this.pixelBasedSizing) {\n      graphics.setBounds(this.$comp, bounds);\n    }\n    this.validateLayout();\n  }\n\n  /**\n   * Sets the component to its preferred size.\n   */\n  pack() {\n    let preferredSize = this.prefSize();\n    this.setSize(preferredSize);\n  }\n\n  /**\n   * Checks whether $comp is in the DOM or has been removed or detached.<br>\n   * Also returns false if the $comp does not belong to a window (defaultView) anymore. This may happen if it belonged to a popup window which is now closed\n   */\n  isAttached() {\n    return this.$comp.isAttached() && this.$comp.window(true);\n  }\n  isVisible() {\n    return this.$comp.isVisible();\n  }\n  isAttachedAndVisible() {\n    return this.isAttached() && this.isVisible();\n  }\n  debug() {\n    return graphics.debugOutput(this.$comp);\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Creates a new HtmlComponent and links it to the given $comp element, so it can be\n   * retrieved again with HtmlComponent.get($comp).\n   *\n   * @memberOf HtmlComponent\n   */\n  static install($comp, session) {\n    if (!$comp) {\n      throw new Error('Missing argument \"$comp\"');\n    }\n    if (!session) {\n      throw new Error('Missing argument \"session\"');\n    }\n    let htmlComp = new HtmlComponent($comp, session);\n    // link DOM element with the new instance\n    $comp.data('htmlComponent', htmlComp);\n    return htmlComp;\n  }\n\n  /**\n   * Static method to get the HtmlComponent associated with the given DOM $comp.\n   * Throws an error when data 'htmlComponent' is not set.\n   *\n   * @memberOf HtmlComponent\n   */\n  static get($comp) {\n    let htmlComp = this.optGet($comp);\n    if (!htmlComp) {\n      let details = '';\n      if ($comp) {\n        details = '\\nClass: ' + $comp.attr('class');\n        details += '\\nId: ' + $comp.attr('id');\n        details += '\\nAttached: ' + $comp.isAttached();\n      }\n      throw new Error('data \"htmlComponent\" is undefined.' + details);\n    }\n    return htmlComp;\n  }\n\n  /**\n   * @memberOf HtmlComponent\n   */\n  static optGet($comp) {\n    return $comp && $comp.data('htmlComponent');\n  }\n}","map":{"version":3,"names":["Dimension","graphics","Insets","NullLayout","scout","$","HtmlComponent","constructor","$comp","session","Error","debug","layout","layoutData","valid","validateRoot","layouted","layouting","suppressInvalidate","suppressValidate","pixelBasedSizing","sizeCached","prefSizeCached","scrollable","getParent","$parent","parent","length","optGet","isDescendantOf","htmlComp","availableSize","options","size","exact","prefSize","widthHint","width","removeMarginFromHints","height","invalidateLayout","htmlSource","invalidate","validateLayout","_checkValidationPossible","isAttachedAndVisible","hasAnimationClass","_validateLayoutAfterAnimation","everyParentVisible","$animatedParent","parents","each","isVisible","$animatedElement","oneAnimationEnd","bind","revalidateLayout","invalidateLayoutTree","invalidateParents","nvl","layoutValidator","invalidateTree","validateLayoutTree","validate","revalidateLayoutTree","isValidateRoot","setLayout","cssClass","addClass","includeMargin","extend","prefSizeCacheKey","computePrefSizeKey","isEmptyObject","log","isTraceEnabled","trace","heightHint","add","margins","clone","minSize","cssMinSize","maxSize","cssMaxSize","_adjustSizeHintsForPrefSize","preferredLayoutSize","_adjustPrefSizeWithMinMaxSize","widthOnly","removeMargins","removeInsets","removeInsetsFromHints","insets","horizontal","Math","max","min","vertical","borders","setSize","oldSize","equals","bounds","position","offsetBounds","offset","setLocation","location","setBounds","dimension","pack","preferredSize","isAttached","window","debugOutput","install","data","get","details","attr"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/layout/HtmlComponent.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Dimension, graphics, Insets, NullLayout, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * Wrapper for a JQuery selector. Used as replacement for javax.swing.JComponent.\n */\nexport default class HtmlComponent {\n  constructor($comp, session) {\n    if (!session) {\n      throw new Error('session must be defined for ' + this.debug());\n    }\n    this.$comp = $comp;\n    this.layout = new NullLayout();\n    this.layoutData = null;\n    this.valid = false;\n    this.validateRoot = false;\n\n    /**\n     * Flag to indicate that the component has been layouted at least once. Invalidation should NOT reset this flag.\n     */\n    this.layouted = false;\n\n    /**\n     * Flag to indicate that the component is being layouted.\n     */\n    this.layouting = false;\n\n    /**\n     * May be set to temporarily disable invalidation (e.g. if the component gets modified during the layouting process)\n     */\n    this.suppressInvalidate = false;\n\n    /**\n     * May be set to temporarily disable layout validation (e.g. if the component gets modified during the layouting process).\n     * It is still possible to invalidate its layout. But as long as this flag is set, it will not validate the layout.\n     * It is the responsibility of the caller to ensure that the component is validated again (if necessary) when the layout validation suppression is removed.\n     * @type {boolean}\n     */\n    this.suppressValidate = false;\n\n    /**\n     * Set pixelBasedSizing to false if your component automatically adjusts its size,\n     * e.g. by using CSS styling -> setSize won't be called.\n     */\n    this.pixelBasedSizing = true;\n    this.sizeCached = null;\n\n    /**\n     * Object which stores the computed preferred size. Key is a string containing the width and height hints.\n     * @see #computePrefSizeKey(options);\n     */\n    this.prefSizeCached = {};\n    this.session = session;\n    this.scrollable = false;\n  }\n\n  /**\n   * Returns the parent or $comp or null when $comp has no parent.\n   * Creates a new instance of HtmlComponent if the parent DOM element has no linked instance yet.\n   */\n  getParent() {\n    let $parent = this.$comp.parent();\n    if ($parent.length === 0) {\n      return null;\n    }\n    return HtmlComponent.optGet($parent);\n  }\n\n  /**\n   * @returns {boolean} true if the given htmlComponent is an ancestor, false if not\n   */\n  isDescendantOf(htmlComp) {\n    let $parent = this.$comp.parent();\n    while ($parent.length > 0) {\n      if (HtmlComponent.optGet($parent) === htmlComp) {\n        return true;\n      }\n      $parent = $parent.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Computes the preferred height if the component is scrollable and returns it if it is greater than the actual size.\n   * If it is not scrollable, the actual height is returned.\n   * <p>\n   * The returned size contains insets (padding and border) but no margin. The width is always the actual width because there are no horizontal scrollbars.\n   *\n   * OPTION    DEFAULT VALUE   DESCRIPTION\n   * -------------------------------------\n   * exact     false           When set to true the returned dimensions may contain fractional digits, otherwise the sizes are rounded up.\n   *\n   * @param (options) may contain the options of the above table\n   */\n  availableSize(options) {\n    options = options || {};\n    let size = this.size({\n      exact: options.exact\n    });\n\n    if (this.scrollable) {\n      let prefSize = this.prefSize({\n        widthHint: size.width,\n        removeMarginFromHints: false // Since the width of this component is used as hint, the margin must not be removed\n      });\n      if (prefSize.height > size.height) {\n        size.height = prefSize.height;\n      }\n    }\n\n    return size;\n  }\n\n  /**\n   * Invalidates the component (sets the valid property to false and calls layout.invalidate()).\n   * @param {HtmlComponent} [htmlSource] The component the invalidation originated from.\n   *        Is always set if the invalidation is triggered by using invalidateLayoutTree, may be undefined otherwise.\n   */\n  invalidateLayout(htmlSource) {\n    this.valid = false;\n    this.prefSizeCached = {};\n    if (this.layout) {\n      this.layout.invalidate(htmlSource);\n    }\n  }\n\n  /**\n   * Calls the layout of the component to layout its children but only if the component is not valid.\n   * @exception when component has no layout\n   * @return {boolean} true if validation was successful, false if it could not be executed (e.g. because the element is invisible or detached)\n   */\n  validateLayout() {\n    if (!this.layout) {\n      throw new Error('Called layout() but component has no layout');\n    }\n    if (this.valid) {\n      return true;\n    }\n    if (this.suppressValidate) {\n      return false;\n    }\n    if (this.layouting) {\n      return false;\n    }\n    if (!this._checkValidationPossible()) {\n      return false;\n    }\n\n    this.layouting = true;\n    this.layout.layout(this.$comp);\n    this.layouting = false;\n    this.layouted = true;\n    // Save size for later use (necessary if pixelBasedSizing is set to false)\n    this.sizeCached = this.size({exact: true});\n    this.valid = true;\n    return true;\n  }\n\n  _checkValidationPossible() {\n    // Don't layout components which don't exist anymore, are invisible or are detached from the DOM\n    if (!this.isAttachedAndVisible()) {\n      return false;\n    }\n\n    // Don't layout if component is currently animated\n    if (this.$comp.hasAnimationClass()) {\n      this._validateLayoutAfterAnimation(this.$comp);\n      return false;\n    }\n\n    // Check the visibility of the parents as well.\n    // Also check if one of the parents is currently being animated.\n    // To improve performance (the check might loop to the top of the DOM tree), the following code is\n    // not executed if the parent already executed it, which is the case if the parent is being layouted.\n    let parent = this.getParent();\n    if (!parent || !parent.layouting) {\n      let everyParentVisible = true;\n      let $animatedParent = null;\n      this.$comp.parents().each(function() {\n        let $parent = $(this);\n        if (!$parent.isVisible()) {\n          everyParentVisible = false;\n          return false;\n        }\n        if ($parent.hasAnimationClass()) {\n          $animatedParent = $parent;\n          return false;\n        }\n        return true; // continue loop\n      });\n      if (!everyParentVisible) {\n        return false;\n      }\n      if ($animatedParent) {\n        // Postpone the layout if there is a CSS animation in progress on one of the parent containers.\n        // Otherwise, wrong sizes might be measured (depending on the CSS animation, e.g. grow/shrink).\n        this._validateLayoutAfterAnimation($animatedParent);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  _validateLayoutAfterAnimation($animatedElement) {\n    $animatedElement.oneAnimationEnd(this.validateLayout.bind(this));\n  }\n\n  /**\n   * Performs invalidateLayout() and validateLayout() subsequently.\n   */\n  revalidateLayout() {\n    this.invalidateLayout();\n    this.validateLayout();\n  }\n\n  /**\n   * Invalidates the component-tree up to the next validate root, but only if invalidateParents is set to true.\n   */\n  invalidateLayoutTree(invalidateParents) {\n    if (this.suppressInvalidate) {\n      return;\n    }\n    if (scout.nvl(invalidateParents, true)) {\n      this.session.layoutValidator.invalidateTree(this); // will call invalidateLayout(), which sets this.valid = false\n    } else {\n      this.invalidateLayout();\n      this.session.layoutValidator.invalidate(this);\n    }\n  }\n\n  /**\n   * Layouts all invalid components\n   */\n  validateLayoutTree() {\n    if (this.suppressValidate) {\n      return;\n    }\n    this.session.layoutValidator.validate();\n  }\n\n  /**\n   * Performs invalidateLayoutTree() and validateLayoutTree() subsequently.\n   */\n  revalidateLayoutTree(invalidateParents) {\n    if (this.suppressInvalidate) {\n      return;\n    }\n    this.invalidateLayoutTree(invalidateParents);\n    this.validateLayoutTree();\n  }\n\n  /**\n   * Marks the end of the parent invalidation. <p>\n   * A component is a validate root if its size does not depend on the visibility or bounds of its children.<p>\n   * Example: It is not necessary to relayout the whole form if just the label of a form field gets invisible.\n   * Only the form field container needs to be relayouted. In this case the form field container is the validate root.\n   */\n  isValidateRoot() {\n    if (this.validateRoot) {\n      return true;\n    }\n    if (!this.layoutData || !this.layoutData.isValidateRoot) {\n      return false;\n    }\n    return this.layoutData.isValidateRoot();\n  }\n\n  /**\n   * Sets the given layout.\n   */\n  setLayout(layout) {\n    this.layout = layout;\n    if (layout.cssClass) {\n      this.$comp.addClass(layout.cssClass);\n    }\n  }\n\n  /**\n   * Returns the preferred size of the component, insets included, margin excluded.<p>\n   * The preferred size is cached until the component will be invalidated.\n   * Hence, subsequent calls to this function will return the cached preferred size unless the component is invalidated.\n   * <p>\n   *\n   * @param {object|boolean} [options] an optional options object. Short-hand version: If a boolean is passed instead of an object, the value is automatically converted to the option \"includeMargin\".\n   *                  May contain the options described below. All other options are passed as they are to the layout when layout.preferredLayoutSize() is called.\n   *                  Possible options may be found at graphics.prefSize(), but it depends on the actual layout if these options have an effect or not.\n   * @param {boolean|null} [options.includeMargin] Whether to include the margin in the returned size. Default is false.\n   * @param {number} [options.widthHint] When set, horizontal padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n   * @param {number} [options.heightHint] When set, vertical padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n   * @param {boolean|null} [options.removeMarginFromHints] Whether or not to automatically remove the margin from the hints. Default is true.\n   * @param {boolean|null} [options.removeInsetsFromHints] Whether or not to automatically remove the insets (padding and border) from the hints. Default is true.\n   * @exception When component has no layout\n   */\n  prefSize(options) {\n    if (!this.isVisible()) {\n      return new Dimension(0, 0);\n    }\n\n    if (typeof options === 'boolean') {\n      options = {\n        includeMargin: options\n      };\n    } else {\n      // Create a copy to not modify the original options\n      options = $.extend({}, options);\n    }\n    let includeMargin = scout.nvl(options.includeMargin, false);\n    options.includeMargin = null;\n    if (!this.layout) {\n      throw new Error('Called prefSize() but component has no layout');\n    }\n\n    let prefSizeCacheKey = this.computePrefSizeKey(options);\n    let prefSizeCached = this.prefSizeCached[prefSizeCacheKey];\n    if (!$.isEmptyObject(prefSizeCached)) {\n      $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSizeCached=' + prefSizeCached);\n      if (includeMargin) {\n        prefSizeCached = prefSizeCached.add(this.margins());\n      }\n      return prefSizeCached.clone();\n    }\n\n    let minSize = this.cssMinSize();\n    let maxSize = this.cssMaxSize();\n    if (options.widthHint || options.heightHint) {\n      this._adjustSizeHintsForPrefSize(options, minSize, maxSize);\n    }\n\n    let prefSize = this.layout.preferredLayoutSize(this.$comp, options);\n    this._adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize);\n    this.prefSizeCached[prefSizeCacheKey] = prefSize;\n\n    $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSize=' + prefSize);\n    if (includeMargin) {\n      prefSize = prefSize.add(this.margins());\n    }\n    return prefSize.clone();\n  }\n\n  computePrefSizeKey(options) {\n    return 'wHint' + scout.nvl(options.widthHint, '-1') + 'hHint' + scout.nvl(options.heightHint, '-1') + 'wOnly' + scout.nvl(options.widthOnly, '-1');\n  }\n\n  /**\n   * Remove padding, border and margin from the width and heightHint so that the actual layout does not need to take care of it.\n   * Also makes sure the hints consider the min and max size set by CSS.\n   */\n  _adjustSizeHintsForPrefSize(options, minSize, maxSize) {\n    let removeMargins = scout.nvl(options.removeMarginFromHints, true);\n    let removeInsets = scout.nvl(options.removeInsetsFromHints, true);\n    options.removeMarginFromHints = null;\n    options.removeInsetsFromHints = null;\n    if (!options.widthHint && !options.heightHint) {\n      return;\n    }\n    let margins = removeMargins ? this.margins() : new Insets();\n    let insets = removeInsets ? this.insets() : new Insets();\n    if (options.widthHint) {\n      // The order is important! Box-sizing: border-box is expected.\n      options.widthHint -= margins.horizontal();\n      options.widthHint = Math.max(options.widthHint, minSize.width);\n      options.widthHint = Math.min(options.widthHint, maxSize.width);\n      options.widthHint -= insets.horizontal();\n    }\n    if (options.heightHint) {\n      // The order is important! Box-sizing: border-box is expected.\n      options.heightHint -= margins.vertical();\n      options.heightHint = Math.max(options.heightHint, minSize.height);\n      options.heightHint = Math.min(options.heightHint, maxSize.height);\n      options.heightHint -= insets.vertical();\n    }\n  }\n\n  /**\n   * The html element may define a min or max height/height -> adjust the pref size accordingly\n   */\n  _adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize) {\n    minSize = minSize || this.cssMinSize();\n    maxSize = maxSize || this.cssMaxSize();\n    prefSize.height = Math.max(prefSize.height, minSize.height);\n    prefSize.height = Math.min(prefSize.height, maxSize.height);\n    prefSize.width = Math.max(prefSize.width, minSize.width);\n    prefSize.width = Math.min(prefSize.width, maxSize.width);\n  }\n\n  /**\n   * Returns the inset-dimensions of the component (padding and border, no margin).\n   */\n  insets(options) {\n    return graphics.insets(this.$comp, options);\n  }\n\n  margins() {\n    return graphics.margins(this.$comp);\n  }\n\n  borders() {\n    return graphics.borders(this.$comp);\n  }\n\n  cssMinSize() {\n    return graphics.cssMinSize(this.$comp);\n  }\n\n  cssMaxSize() {\n    return graphics.cssMaxSize(this.$comp);\n  }\n\n  /**\n   * Returns the size of the component, insets included.\n   * @param options, see {@link graphics#size} for details.\n   */\n  size(options) {\n    return graphics.size(this.$comp, options);\n  }\n\n  /**\n   * Sets the size of the component, insets included. Which means: the method subtracts the components insets\n   * from the given size before setting the width/height of the component.\n   *\n   * @param {Dimension} size\n   */\n  setSize(size) {\n    if (!this.isAttachedAndVisible()) {\n      // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n      return;\n    }\n    let oldSize = this.sizeCached;\n    if (!size.equals(oldSize)) {\n      this.invalidateLayout();\n    }\n    if (this.pixelBasedSizing) {\n      graphics.setSize(this.$comp, size);\n    }\n    this.validateLayout();\n  }\n\n  bounds(options) {\n    return graphics.bounds(this.$comp, options);\n  }\n\n  position() {\n    return graphics.position(this.$comp);\n  }\n\n  offsetBounds(options) {\n    return graphics.offsetBounds(this.$comp, options);\n  }\n\n  offset() {\n    return graphics.offset(this.$comp);\n  }\n\n  /**\n   * Delegation to graphics.setLocation\n   * @param location Point\n   */\n  setLocation(location) {\n    graphics.setLocation(this.$comp, location);\n  }\n\n  location() {\n    return graphics.location(this.$comp);\n  }\n\n  setBounds(bounds) {\n    if (!this.isAttachedAndVisible()) {\n      // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n      return;\n    }\n    let oldSize = this.sizeCached;\n    if (!bounds.dimension().equals(oldSize)) {\n      this.invalidateLayout();\n    }\n    if (this.pixelBasedSizing) {\n      graphics.setBounds(this.$comp, bounds);\n    }\n    this.validateLayout();\n  }\n\n  /**\n   * Sets the component to its preferred size.\n   */\n  pack() {\n    let preferredSize = this.prefSize();\n    this.setSize(preferredSize);\n  }\n\n  /**\n   * Checks whether $comp is in the DOM or has been removed or detached.<br>\n   * Also returns false if the $comp does not belong to a window (defaultView) anymore. This may happen if it belonged to a popup window which is now closed\n   */\n  isAttached() {\n    return this.$comp.isAttached() && this.$comp.window(true);\n  }\n\n  isVisible() {\n    return this.$comp.isVisible();\n  }\n\n  isAttachedAndVisible() {\n    return this.isAttached() && this.isVisible();\n  }\n\n  debug() {\n    return graphics.debugOutput(this.$comp);\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Creates a new HtmlComponent and links it to the given $comp element, so it can be\n   * retrieved again with HtmlComponent.get($comp).\n   *\n   * @memberOf HtmlComponent\n   */\n  static install($comp, session) {\n    if (!$comp) {\n      throw new Error('Missing argument \"$comp\"');\n    }\n    if (!session) {\n      throw new Error('Missing argument \"session\"');\n    }\n\n    let htmlComp = new HtmlComponent($comp, session);\n    // link DOM element with the new instance\n    $comp.data('htmlComponent', htmlComp);\n\n    return htmlComp;\n  }\n\n  /**\n   * Static method to get the HtmlComponent associated with the given DOM $comp.\n   * Throws an error when data 'htmlComponent' is not set.\n   *\n   * @memberOf HtmlComponent\n   */\n  static get($comp) {\n    let htmlComp = this.optGet($comp);\n    if (!htmlComp) {\n      let details = '';\n      if ($comp) {\n        details = '\\nClass: ' + $comp.attr('class');\n        details += '\\nId: ' + $comp.attr('id');\n        details += '\\nAttached: ' + $comp.isAttached();\n      }\n      throw new Error('data \"htmlComponent\" is undefined.' + details);\n    }\n    return htmlComp;\n  }\n\n  /**\n   * @memberOf HtmlComponent\n   */\n  static optGet($comp) {\n    return $comp && $comp.data('htmlComponent');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}