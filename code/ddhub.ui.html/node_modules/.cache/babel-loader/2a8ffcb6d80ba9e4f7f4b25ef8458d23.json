{"ast":null,"code":"/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays } from '../index';\n\n/**\n * Input is expected to be encoded. Output (toString()) is also encoded.\n * If no URL is passed, 'window.location.href' is used as input.\n */\nexport default class URL {\n  constructor(url) {\n    if (url === undefined) {\n      url = window.location.href;\n    }\n    let urlParts = /^([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/.exec(url || '');\n    // encoded\n    this.baseUrlRaw = urlParts[1];\n    this.queryPartRaw = urlParts[2];\n    this.hashPartRaw = urlParts[3];\n    // un-encoded (!)\n    this.parameterMap = URL._parse(this.queryPartRaw);\n  }\n\n  /**\n   * Checks if the given parameter exists, even if value is null or an empty string.\n   *\n   * @param param\n   * @return {boolean}\n   */\n  hasParameter(param) {\n    return this.parameterMap.hasOwnProperty(param);\n  }\n  getParameter(param) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    let value = this.parameterMap[param];\n    if (Array.isArray(value)) {\n      return value.sort(URL._sorter);\n    }\n    return value;\n  }\n  removeParameter(param) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    delete this.parameterMap[param];\n    return this;\n  }\n  setParameter(param, value) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    if (param === '') {\n      // ignore empty keys\n      return;\n    }\n    this.parameterMap[param] = value;\n    return this;\n  }\n  addParameter(param, value) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    if (param === '') {\n      // ignore empty keys\n      return;\n    }\n    URL._addToMap(this.parameterMap, param, value);\n    return this;\n  }\n\n  /**\n   * Options:\n   *\n   *   sorter:\n   *     a function to be used instead of the default lexical ordering\n   *     based function\n   *\n   *   alwaysFirst:\n   *     an array of parameter names that should always be first in the\n   *     resulting string. Among those parameters, the order in the passed\n   *     array is respected.\n   *\n   *   alwaysLast:\n   *     similar to alwaysFirst, but puts the parameters at the end of\n   *     the resulting string.\n   */\n  toString(options) {\n    let result = this.baseUrlRaw;\n    if (Object.keys(this.parameterMap).length) {\n      options = options || {};\n      let sorter = options.sorter || URL._sorter;\n      if (options.alwaysFirst || options.alwaysLast) {\n        options.alwaysFirst = arrays.ensure(options.alwaysFirst);\n        options.alwaysLast = arrays.ensure(options.alwaysLast);\n        let origSorter = sorter;\n        sorter = (a, b) => {\n          let firstA = options.alwaysFirst.indexOf(a);\n          let firstB = options.alwaysFirst.indexOf(b);\n          let lastA = options.alwaysLast.indexOf(a);\n          let lastB = options.alwaysLast.indexOf(b);\n          // If A is marked as \"alwaysFirst\", sort them A-B. If B is also marked as \"alwaysFirst\", sort them\n          // by their position in the array. If only B is marked as \"alwaysFirst\", sort them B-A.\n          if (firstA !== -1) {\n            return firstB === -1 ? -1 : firstA - firstB;\n          } else if (firstB !== -1) {\n            return 1;\n          }\n          // If A is marked as \"alwaysLast\", sort them B-A. If B is also marked as \"alwaysLast\", sort them\n          // by their position in the array. If only B is marked as \"alwaysLast\", sort them A-B.\n          if (lastA !== -1) {\n            return lastB === -1 ? 1 : lastA - lastB;\n          } else if (lastB !== -1) {\n            return -1;\n          }\n          // Default order\n          return origSorter(a, b);\n        };\n      }\n      // Built a sorted string of all formatted parameterMap entries\n      let reconstructedQueryPart = Object.keys(this.parameterMap).sort(sorter).map(key => {\n        let value = this.getParameter(key);\n        // For multiple values, generate a parameter string for each value\n        if (Array.isArray(value)) {\n          return value.map((innerKey, innerIndex) => {\n            return URL._formatQueryParam(key, value[innerIndex]);\n          }).join('&');\n        }\n        return URL._formatQueryParam(key, value);\n      }).join('&');\n      result += '?' + reconstructedQueryPart;\n    }\n    if (this.hashPartRaw) {\n      result += '#' + this.hashPartRaw;\n    }\n    return result;\n  }\n  clone() {\n    return new URL(this.toString());\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Helper function to sort arrays alphabetically, nulls in front\n   *\n   * @memberOf URL\n   */\n  static _sorter(a, b) {\n    return a === null ? -1 : b === null ? 1 : a.toString().localeCompare(b);\n  }\n\n  /**\n   * Helper function to build a query parameter with value\n   *\n   * @memberOf URL\n   */\n  //\n  static _formatQueryParam(key, value) {\n    let s = encodeURIComponent(key);\n    if (value !== undefined && value !== null) {\n      s += '=' + encodeURIComponent(value);\n    }\n    return s;\n  }\n\n  /**\n   * Helper function to add an key-value pair to a map. If the key is added multiple\n   * times, the value is converted to an array.\n   *\n   * @memberOf URL\n   */\n  static _addToMap(map, key, value) {\n    if (map === undefined) {\n      throw new Error('Argument \\'map\\' must not be null');\n    }\n    if (key === undefined) {\n      throw new Error('Argument \\'key\\' must not be null');\n    }\n    if (key in map) {\n      let oldValue = map[key];\n      if (Array.isArray(oldValue)) {\n        oldValue.push(value);\n      } else {\n        map[key] = [oldValue, value];\n      }\n    } else {\n      map[key] = value;\n    }\n  }\n\n  /**\n   * Helper function to parse the given (encoded) query string and return\n   * it as (un-encoded) map of key-value pairs.\n   *\n   * @memberOf URL\n   */\n  static _parse(queryPart) {\n    let queryString = (queryPart || '').replace(/\\+/g, ' '),\n      pattern = /([^&=]+)(=?)([^&]*)/g,\n      map = {},\n      m,\n      key,\n      value;\n    while (m = pattern.exec(queryString)) {\n      key = decodeURIComponent(m[1]);\n      value = decodeURIComponent(m[3]);\n      if (value === '' && m[2] !== '=') {\n        value = null;\n      }\n      URL._addToMap(map, key, value);\n    }\n    return map;\n  }\n}","map":{"version":3,"names":["arrays","URL","constructor","url","undefined","window","location","href","urlParts","exec","baseUrlRaw","queryPartRaw","hashPartRaw","parameterMap","_parse","hasParameter","param","hasOwnProperty","getParameter","Error","value","Array","isArray","sort","_sorter","removeParameter","setParameter","addParameter","_addToMap","toString","options","result","Object","keys","length","sorter","alwaysFirst","alwaysLast","ensure","origSorter","a","b","firstA","indexOf","firstB","lastA","lastB","reconstructedQueryPart","map","key","innerKey","innerIndex","_formatQueryParam","join","clone","localeCompare","s","encodeURIComponent","oldValue","push","queryPart","queryString","replace","pattern","m","decodeURIComponent"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/URL.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays} from '../index';\n\n/**\n * Input is expected to be encoded. Output (toString()) is also encoded.\n * If no URL is passed, 'window.location.href' is used as input.\n */\nexport default class URL {\n\n  constructor(url) {\n    if (url === undefined) {\n      url = window.location.href;\n    }\n    let urlParts = /^([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/.exec(url || '');\n    // encoded\n    this.baseUrlRaw = urlParts[1];\n    this.queryPartRaw = urlParts[2];\n    this.hashPartRaw = urlParts[3];\n    // un-encoded (!)\n    this.parameterMap = URL._parse(this.queryPartRaw);\n  }\n\n  /**\n   * Checks if the given parameter exists, even if value is null or an empty string.\n   *\n   * @param param\n   * @return {boolean}\n   */\n  hasParameter(param) {\n    return this.parameterMap.hasOwnProperty(param);\n  }\n\n  getParameter(param) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    let value = this.parameterMap[param];\n    if (Array.isArray(value)) {\n      return value.sort(URL._sorter);\n    }\n    return value;\n  }\n\n  removeParameter(param) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    delete this.parameterMap[param];\n    return this;\n  }\n\n  setParameter(param, value) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    if (param === '') { // ignore empty keys\n      return;\n    }\n    this.parameterMap[param] = value;\n    return this;\n  }\n\n  addParameter(param, value) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    if (param === '') { // ignore empty keys\n      return;\n    }\n    URL._addToMap(this.parameterMap, param, value);\n    return this;\n  }\n\n  /**\n   * Options:\n   *\n   *   sorter:\n   *     a function to be used instead of the default lexical ordering\n   *     based function\n   *\n   *   alwaysFirst:\n   *     an array of parameter names that should always be first in the\n   *     resulting string. Among those parameters, the order in the passed\n   *     array is respected.\n   *\n   *   alwaysLast:\n   *     similar to alwaysFirst, but puts the parameters at the end of\n   *     the resulting string.\n   */\n  toString(options) {\n    let result = this.baseUrlRaw;\n\n    if (Object.keys(this.parameterMap).length) {\n      options = options || {};\n      let sorter = options.sorter || URL._sorter;\n      if (options.alwaysFirst || options.alwaysLast) {\n        options.alwaysFirst = arrays.ensure(options.alwaysFirst);\n        options.alwaysLast = arrays.ensure(options.alwaysLast);\n        let origSorter = sorter;\n        sorter = (a, b) => {\n          let firstA = options.alwaysFirst.indexOf(a);\n          let firstB = options.alwaysFirst.indexOf(b);\n          let lastA = options.alwaysLast.indexOf(a);\n          let lastB = options.alwaysLast.indexOf(b);\n          // If A is marked as \"alwaysFirst\", sort them A-B. If B is also marked as \"alwaysFirst\", sort them\n          // by their position in the array. If only B is marked as \"alwaysFirst\", sort them B-A.\n          if (firstA !== -1) {\n            return (firstB === -1 ? -1 : firstA - firstB);\n          } else if (firstB !== -1) {\n            return 1;\n          }\n          // If A is marked as \"alwaysLast\", sort them B-A. If B is also marked as \"alwaysLast\", sort them\n          // by their position in the array. If only B is marked as \"alwaysLast\", sort them A-B.\n          if (lastA !== -1) {\n            return (lastB === -1 ? 1 : lastA - lastB);\n          } else if (lastB !== -1) {\n            return -1;\n          }\n          // Default order\n          return origSorter(a, b);\n        };\n      }\n      // Built a sorted string of all formatted parameterMap entries\n      let reconstructedQueryPart = Object.keys(this.parameterMap).sort(sorter).map(key => {\n        let value = this.getParameter(key);\n        // For multiple values, generate a parameter string for each value\n        if (Array.isArray(value)) {\n          return value.map(\n            (innerKey, innerIndex) => {\n              return URL._formatQueryParam(key, value[innerIndex]);\n            }\n          ).join('&');\n        }\n        return URL._formatQueryParam(key, value);\n      }).join('&');\n      result += '?' + reconstructedQueryPart;\n    }\n\n    if (this.hashPartRaw) {\n      result += '#' + this.hashPartRaw;\n    }\n\n    return result;\n  }\n\n  clone() {\n    return new URL(this.toString());\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Helper function to sort arrays alphabetically, nulls in front\n   *\n   * @memberOf URL\n   */\n  static _sorter(a, b) {\n    return a === null ? -1 : b === null ? 1 : a.toString().localeCompare(b);\n  }\n\n  /**\n   * Helper function to build a query parameter with value\n   *\n   * @memberOf URL\n   */\n  //\n  static _formatQueryParam(key, value) {\n    let s = encodeURIComponent(key);\n    if (value !== undefined && value !== null) {\n      s += '=' + encodeURIComponent(value);\n    }\n    return s;\n  }\n\n  /**\n   * Helper function to add an key-value pair to a map. If the key is added multiple\n   * times, the value is converted to an array.\n   *\n   * @memberOf URL\n   */\n  static _addToMap(map, key, value) {\n    if (map === undefined) {\n      throw new Error('Argument \\'map\\' must not be null');\n    }\n    if (key === undefined) {\n      throw new Error('Argument \\'key\\' must not be null');\n    }\n    if (key in map) {\n      let oldValue = map[key];\n      if (Array.isArray(oldValue)) {\n        oldValue.push(value);\n      } else {\n        map[key] = [oldValue, value];\n      }\n    } else {\n      map[key] = value;\n    }\n  }\n\n  /**\n   * Helper function to parse the given (encoded) query string and return\n   * it as (un-encoded) map of key-value pairs.\n   *\n   * @memberOf URL\n   */\n  static _parse(queryPart) {\n    let queryString = (queryPart || '').replace(/\\+/g, ' '),\n      pattern = /([^&=]+)(=?)([^&]*)/g,\n      map = {},\n      m, key, value;\n\n    while ((m = pattern.exec(queryString))) {\n      key = decodeURIComponent(m[1]);\n      value = decodeURIComponent(m[3]);\n      if (value === '' && m[2] !== '=') {\n        value = null;\n      }\n      URL._addToMap(map, key, value);\n    }\n    return map;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}