{"ast":null,"code":"/*\n * Copyright (c) 2014-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, scout, strings } from '../index';\nimport $ from 'jquery';\nconst CONST_REGEX = /\\${const:([^}]*)}/;\n\n/**\n * Uses Object.create(null) to create an object without a prototype. This is different to use the literal {} which links the object to Object.prototype.\n * <p>\n * Not using the literal has the advantage that the object does not contain any inherited properties like `toString` so it is not necessary to use `o.hasOwnProperty(p)`\n * instead of `p in o` to check for the existence.\n *\n * @param [object] properties optional initial properties to be set on the new created object\n */\nexport function createMap(properties) {\n  let map = Object.create(null);\n  if (properties) {\n    $.extend(map, properties);\n  }\n  return map;\n}\n\n/**\n * Copies all the properties (including the ones from the prototype.) from dest to source\n * @param {[]} [filter] an array of property names.\n * @returns {object} the destination object (the destination parameter will be modified as well)\n */\nexport function copyProperties(source, dest, filter) {\n  let propertyName;\n  filter = arrays.ensure(filter);\n  for (propertyName in source) {\n    if (filter.length === 0 || filter.indexOf(propertyName) !== -1) {\n      dest[propertyName] = source[propertyName];\n    }\n  }\n  return dest;\n}\n\n/**\n * Copies the own properties (excluding the ones from the prototype) from dest to source.\n * If a filter is specified, only the properties matching the ones in the filter are copied.\n * @param {[]} [filter] an array of property names.\n * @returns {object} the destination object (the destination parameter will be modified as well)\n */\nexport function copyOwnProperties(source, dest, filter) {\n  let propertyName;\n  filter = arrays.ensure(filter);\n  for (propertyName in source) {\n    if (Object.prototype.hasOwnProperty.call(source, propertyName) && (filter.length === 0 || filter.indexOf(propertyName) !== -1)) {\n      dest[propertyName] = source[propertyName];\n    }\n  }\n  return dest;\n}\n\n/**\n * Counts and returns the properties of a given object or map (see #createMap).\n */\nexport function countOwnProperties(obj) {\n  // map objects don't have a prototype\n  if (!Object.getPrototypeOf(obj)) {\n    return Object.keys(obj).length;\n  }\n\n  // regular objects may inherit a property through their prototype\n  // we're only interested in own properties\n  let count = 0;\n  for (let prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Copies the specified properties (including the ones from the prototype) from source to dest.\n * Properties that already exist on dest are NOT overwritten.\n */\nexport function extractProperties(source, dest, properties) {\n  properties.forEach(propertyName => {\n    if (dest[propertyName] === undefined) {\n      dest[propertyName] = source[propertyName];\n    }\n  });\n  return dest;\n}\n\n/**\n * returns\n *  - true if the obj has at least one of the given properties.\n *  - false if the obj has none of the given properties.\n *\n * @param obj\n * @param properties a single property or an array of properties\n * @returns {Boolean}\n */\nexport function someOwnProperties(obj, properties) {\n  let propArr = arrays.ensure(properties);\n  return propArr.some(prop => {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  });\n}\n\n/**\n * returns\n *  - true if the obj or its prototypes have at least one of the given properties.\n *  - false if the obj or its prototypes have none of the given properties.\n *\n * @param obj\n * @param properties a single property or an array of properties\n * @returns {Boolean}\n */\nexport function someProperties(obj, properties) {\n  let propArr = arrays.ensure(properties);\n  return propArr.some(prop => {\n    return prop in obj;\n  });\n}\n\n/**\n * @return {*}\n */\nexport function valueCopy(obj) {\n  // Nothing to be done for immutable things\n  if (obj === undefined || obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  let copy;\n  // Arrays\n  if (Array.isArray(obj)) {\n    copy = [];\n    for (let i = 0; i < obj.length; i++) {\n      copy[i] = valueCopy(obj[i]);\n    }\n    return copy;\n  }\n  // All other objects\n  copy = {};\n  for (let prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      copy[prop] = valueCopy(obj[prop]);\n    }\n  }\n  return copy;\n}\n\n/**\n * Returns the first object with the given property and propertyValue or null if there is no such object within parentObj.\n * @param parentObj\n * @param property property to search for\n * @param propertyValue value of the property\n * @returns {Object}\n */\nexport function findChildObjectByKey(parentObj, property, propertyValue) {\n  if (parentObj === undefined || parentObj === null || typeof parentObj !== 'object') {\n    return null;\n  }\n  if (parentObj[property] === propertyValue) {\n    return parentObj;\n  }\n  let child;\n  if (Array.isArray(parentObj)) {\n    for (let i = 0; i < parentObj.length; i++) {\n      child = findChildObjectByKey(parentObj[i], property, propertyValue);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  for (let prop in parentObj) {\n    if (Object.prototype.hasOwnProperty.call(parentObj, prop)) {\n      child = findChildObjectByKey(parentObj[prop], property, propertyValue);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * This function returns the value of a property from the provided object specified by the second path parameter.\n * The path consists of a dot separated series of property names (e.g. foo, foo.bar, foo.bar.baz).\n * In addition, traversing into array properties is possible by specifying a suitable filter for the element's id property in square brackets (e.g. foo[bar], foo.bar[baz]).\n *\n * Example:\n *\n * let obj = {\n *   foo: {\n *     bar: {\n *       foobar: 'val1'\n *     }\n *   },\n *   baz: [\n *     {\n *       id: 'baz1',\n *       value: 'val2'\n *     },\n *     {\n *       id: 'baz2',\n *       value: 'val3'\n *     }\n *   ]\n * }\n *\n * objects.getByPath(obj, 'foo') === obj.foo;\n * objects.getByPath(obj, 'foo.bar') === obj.foo.bar;\n * objects.getByPath(obj, 'baz[baz1]') → { id: 'baz1', value: 'val2' }\n * objects.getByPath(obj, 'baz[baz2].value') → 'val3'\n *\n * @param object The object to select a property from.\n * @param path The path for the selection.\n * @return Object Returns the selected object.\n * @throws Throws an error, if the provided parameters are malformed, or a property could not be found/a id property filter does not find any elements.\n */\nexport function getByPath(object, path) {\n  scout.assertParameter('object', object, Object);\n  scout.assertParameter('path', path);\n  const pathElementRegexString = '(\\\\w+)(?:\\\\[((?:\\\\w|\\\\.|-)+)\\\\])?';\n  const pathValidationRegex = new RegExp('^' + pathElementRegexString + '(?:\\\\.' + pathElementRegexString + ')*$');\n  if (!pathValidationRegex.test(path)) {\n    throw new Error('Malformed path expression \"' + path + '\"');\n  }\n  const pathElementRegex = new RegExp(pathElementRegexString);\n  let pathMatchedSoFar = '';\n  let currentContext = object;\n\n  // Split by dot, but only if the dot is not followed by a string containing a ] that is not preceded by a [.\n  // That excludes dots, that are part of an array filter (e.g. foo[foo.bar]).\n  // Explanation: The regular expression matches dots literally, (\\.), that are not followed (negative lookahead: (?!...)\n  // by any mount of \"not opening square brackets\" ([^[]*) followed by a closing square bracket (last closing square bracket: ])\n  path.split(/\\.(?![^[]*])/).forEach(pathElement => {\n    // After the first iteration, the current context may be null or undefined. In this case, further traversal is not possible.\n    if (isNullOrUndefined(currentContext)) {\n      throw new Error('Value selected by matched path \"' + pathMatchedSoFar + '\" is null or undefined. Further traversal not possible.');\n    }\n\n    // match path element to retrieve property name and optional array property index\n    let pathElementMatch = pathElementRegex.exec(pathElement);\n    let propertyName = pathElementMatch[1];\n    let arrayPropertyFilter = pathElementMatch[2];\n    let pathMatchedErrorContext = pathMatchedSoFar.length === 0 ? 'root level of the provided object.' : 'matched path \"' + pathMatchedSoFar + '\".';\n\n    // check if property 'propertyName' exists\n    if (!currentContext.hasOwnProperty(propertyName)) {\n      throw new Error('Property \"' + propertyName + '\" does not exist at the ' + pathMatchedErrorContext);\n    }\n    let property = currentContext[propertyName];\n\n    // check if we are trying to match an array property or not\n    if (arrayPropertyFilter) {\n      // check for correct type of property\n      if (!Array.isArray(property)) {\n        throw new Error('Path element \"' + pathElement + '\" contains array filter but property \"' + propertyName + '\" does not contain an array at the ' + pathMatchedErrorContext);\n      }\n      // find elements matching criteria and make sure that exactly one object was found\n      let matchedElements = property.filter(element => {\n        return element['id'] === arrayPropertyFilter;\n      });\n      if (matchedElements.length === 0) {\n        throw new Error('No object found with id property \"' + arrayPropertyFilter + '\" in array property \"' + propertyName + '\" at the ' + pathMatchedErrorContext);\n      } else if (matchedElements.length > 1) {\n        throw new Error('More than one object found with id property \"' + arrayPropertyFilter + '\" in array property \"' + propertyName + '\" at the ' + pathMatchedErrorContext);\n      }\n      // reassign current context to found element\n      currentContext = matchedElements[0];\n    } else {\n      // reassign current context to found property\n      currentContext = property;\n    }\n    if (pathMatchedSoFar) {\n      pathMatchedSoFar += '.';\n    }\n    pathMatchedSoFar += pathElement;\n  });\n  return currentContext;\n}\n\n/**\n * Returns true if the given object is an object, _not_ an array and not null or undefined.\n */\nexport function isPlainObject(obj) {\n  return typeof obj === 'object' && !isNullOrUndefined(obj) && !Array.isArray(obj);\n}\n\n/**\n * Null-safe access the property of an objects. Examples:\n * <ul>\n * <li><code>optProperty(obj, 'value');</code> try to access and return obj.value</li>\n * <li><code>optProperty(obj, 'foo', 'bar');</code> try to access and return obj.foo.bar</li>\n * </ul>\n *\n * @returns {*} the value of the requested property or undefined if the property does not exist on the object\n */\nexport function optProperty(obj) {\n  if (!obj) {\n    return null;\n  }\n  for (var _len = arguments.length, properties = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    properties[_key - 1] = arguments[_key];\n  }\n  let numArgs = properties.length;\n  if (numArgs === 0) {\n    return obj;\n  }\n  if (numArgs === 1) {\n    return obj[properties[0]];\n  }\n  for (let i = 0; i < numArgs - 1; i++) {\n    obj = obj[properties[i]];\n    if (!obj) {\n      return null;\n    }\n  }\n  return obj[properties[numArgs - 1]];\n}\n\n/**\n * Returns true if:\n * - obj is not undefined or null\n * - obj not isNaN\n * - obj isFinite\n *\n * This method is handy in cases where you want to check if a number is set. Since you cannot write:\n *   if (myNumber) { ...\n *\n * Because when myNumber === 0 would also resolve to false. In that case use instead:\n *   if (isNumber(myNumber)) { ...\n *\n * @param obj\n * @returns {Boolean}\n */\nexport function isNumber(obj) {\n  return obj !== null && !isNaN(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n}\nexport function isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\nexport function isNullOrUndefined(obj) {\n  return obj === null || obj === undefined;\n}\nexport function isFunction(obj) {\n  return $.isFunction(obj);\n}\nexport function isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * Checks whether the provided value is a promise or not.\n * @param {any} value The value to check.\n * @return {boolean} Returns true, in case the provided value is a thenable, false otherwise.\n *\n * Note: This method checks whether the provided value is a \"thenable\" (see https://promisesaplus.com/#terminology).\n *       Checking for promise would require to check the behavior which is not possible. So you could provide an object\n *       with a \"then\" function that does not conform to the Promises/A+ spec but this method would still return true.\n */\nexport function isPromise(value) {\n  return !!value && typeof value === 'object' && typeof value.then === 'function';\n}\n\n/**\n * Returns values from the given (map) object. By default only values of 'own' properties are returned.\n *\n * @returns {Array} an Array with values\n * @param {Object} obj\n * @param {boolean} [all] can be set to true to return all properties instead of own properties\n */\nexport function values(obj, all) {\n  let values = [];\n  if (obj) {\n    if (typeof obj.hasOwnProperty !== 'function') {\n      all = true;\n    }\n    for (let key in obj) {\n      if (all || obj.hasOwnProperty(key)) {\n        values.push(obj[key]);\n      }\n    }\n  }\n  return values;\n}\n\n/**\n * @returns {string} the key / name of a property\n */\nexport function keyByValue(obj, value) {\n  return Object.keys(obj)[values(obj).indexOf(value)];\n}\n\n/**\n * Java-like equals method. Compares the given objects by checking with ===, if that fails, the function\n * checks if both objects have an equals function and use the equals function to compare the two objects\n * by value.\n * @returns {boolean} true if both objects are equals by reference or by value\n */\nexport function equals(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  // both objects have an equals() method\n  if (objA && objB && objA.equals && objB.equals) {\n    return objA.equals(objB);\n  }\n  return false;\n}\n\n/**\n * Compare two objects and all its child elements recursively.\n * @returns {boolean} true if both objects and all child elements are equals by value or implemented equals method\n */\nexport function equalsRecursive(objA, objB) {\n  let i;\n  if (isPlainObject(objA) && isPlainObject(objB)) {\n    if (isFunction(objA.equals) && isFunction(objB.equals)) {\n      return objA.equals(objB);\n    }\n    let keysA = Object.keys(objA);\n    let keysB = Object.keys(objB);\n    if (!arrays.equalsIgnoreOrder(keysA, keysB)) {\n      return false;\n    }\n    for (i = 0; i < keysA.length; i++) {\n      if (!equalsRecursive(objA[keysA[i]], objB[keysA[i]])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (isArray(objA) && isArray(objB)) {\n    if (objA.length !== objB.length) {\n      return false;\n    }\n    for (i = 0; i < objA.length; i++) {\n      if (!equalsRecursive(objA[i], objB[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return objA === objB;\n}\n\n/**\n * Compares a list of properties of two objects by using the equals method for each property.\n */\nexport function propertiesEquals(objA, objB, properties) {\n  let i, property;\n  for (i = 0; i < properties.length; i++) {\n    property = properties[i];\n    if (!equals(objA[property], objB[property])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @returns {function} the function identified by funcName from the given object. The function will return an error\n *     if that function does not exist. Use this function if you modify an existing framework function\n *     to find problems after refactorings / renamings as soon as possible.\n */\nexport function mandatoryFunction(obj, funcName) {\n  let func = obj[funcName];\n  if (!func || typeof func !== 'function') {\n    throw new Error('Function \\'' + funcName + '\\' does not exist on object. Check if it has been renamed or moved. Object: ' + obj);\n  }\n  return func;\n}\n\n/**\n * Use this method to replace a function on a prototype of an object. It checks if that function exists\n * by calling <code>mandatoryFunction</code>.\n */\nexport function replacePrototypeFunction(obj, funcName, func, rememberOrig) {\n  let proto = obj.prototype;\n  mandatoryFunction(proto, funcName);\n  if (rememberOrig) {\n    proto[funcName + 'Orig'] = proto[funcName];\n  }\n  proto[funcName] = func;\n}\n\n/**\n * @returns a real Array for the pseudo-array 'arguments'.\n */\nexport function argumentsToArray(args) {\n  return args ? Array.prototype.slice.call(args) : [];\n}\n\n/**\n * Used to loop over 'arguments' pseudo-array with forEach.\n */\nexport function forEachArgument(args, func) {\n  return argumentsToArray(args).forEach(func);\n}\n\n/**\n * Development utility to check if overrides in JavaScript \"classes\" are correct.\n *\n * How to use:\n *   1. Start application in development mode (non-minimized).\n *   2. Open browser's development console\n *   3. Type: checkFunctionOverrides().join('\\n')\n */\nexport function checkFunctionOverrides() {\n  let whitelist = ['ModelAdapter.init', 'ModelAdapter._init', 'Calendar.init'];\n  let result1 = ['Legend:', '[!] Function includes super call, and parent function uses arguments', ' ~  Function includes super call, but parent function does not use arguments', '    Function does not include super call', '', 'Wrong number of arguments:'];\n  let result2 = ['Different argument names:'];\n  for (let prop in scout) {\n    if (!scout.hasOwnProperty(prop)) {\n      continue;\n    }\n    let o = scout[prop];\n    // Only check functions that have a \"parent\"\n    if (typeof o === 'function' && o.parent) {\n      for (let name in o.prototype) {\n        if (!o.prototype.hasOwnProperty(name)) {\n          continue;\n        }\n        let fn = o.prototype[name];\n        // Ignore constructor, inherited properties and non-functions\n        if (name === 'constructor' || !o.prototype.hasOwnProperty(name) || typeof fn !== 'function') {\n          continue;\n        }\n        let args = getFunctionArguments(fn);\n        // Check all parents\n        let parent = o.parent;\n        while (parent) {\n          let parentFn = parent.prototype[name];\n          if (parent.prototype.hasOwnProperty(name) && typeof parentFn === 'function') {\n            let parentArgs = getFunctionArguments(parentFn);\n            // Check arguments (at least all of the parent args must be present)\n            let mismatch = false;\n            for (let i = 0; i < parentArgs.length; i++) {\n              if (args.length < i || args[i] !== parentArgs[i]) {\n                mismatch = true;\n                break;\n              }\n            }\n            let fname = prop + '.' + name;\n            if (mismatch && whitelist.indexOf(fname) === -1) {\n              // && args.length !== parentArgs.length) {\n              // Collect found mismatch\n              let result = fname + '(' + args.join(', ') + ') does not correctly override ' + getPrototypeOwner(parentFn) + '.' + name + '(' + parentArgs.join(', ') + ')';\n              let includesSuperCall = fn.toString().match(new RegExp('scout.' + strings.quote(prop) + '.parent.prototype.' + strings.quote(name) + '.call\\\\(')) !== null;\n              let parentFunctionUsesArguments = false;\n              if (includesSuperCall) {\n                for (let j = 0; j < parentArgs.length; j++) {\n                  let m = parentFn.toString().match(new RegExp('[^.\\\\w]' + strings.quote(parentArgs[j]) + '[^\\\\w]', 'g'));\n                  if (m !== null && m.length > 1) {\n                    parentFunctionUsesArguments = true;\n                    break;\n                  }\n                }\n              }\n              result = (includesSuperCall ? parentFunctionUsesArguments ? '[!]' : ' ~ ' : '   ') + ' ' + result;\n              if (args.length !== parentArgs.length) {\n                result1.push(result);\n              } else {\n                result2.push(result);\n              }\n            }\n          }\n          parent = parent.parent;\n        }\n      }\n    }\n  }\n  result1.push('');\n  return result1.concat(result2);\n\n  // ----- Helper functions -----\n\n  function getFunctionArguments(fn) {\n    let FN_COMMENTS = /\\/\\*.*?\\*\\/|\\/\\/.*$/mg; // removes comments in function declaration\n    let FN_ARGS = /^function[^(]*\\((.*?)\\)/m; // fetches all arguments in m[1]\n\n    if (typeof fn !== 'function') {\n      throw new Error('Argument is not a function: ' + fn);\n    }\n    let m = fn.toString().replace(FN_COMMENTS, '').match(FN_ARGS);\n    let args = [];\n    if (m !== null) {\n      m[1].split(',').forEach((arg, i) => {\n        arg = arg.trim();\n        if (arg.length > 0) {\n          args.push(arg);\n        }\n      });\n    }\n    return args;\n  }\n  function getPrototypeOwner(fx) {\n    for (let prop in scout) {\n      if (!scout.hasOwnProperty(prop)) {\n        continue;\n      }\n      let o = scout[prop];\n      if (typeof o === 'function') {\n        for (let name in o.prototype) {\n          if (!o.prototype.hasOwnProperty(name)) {\n            continue;\n          }\n          let fn = o.prototype[name];\n          // Ignore constructor, inherited properties and non-functions\n          if (name === 'constructor' || !o.prototype.hasOwnProperty(name) || typeof fn !== 'function') {\n            continue;\n          }\n          if (fn === fx) {\n            return prop;\n          }\n        }\n      }\n    }\n    return '';\n  }\n}\n\n/**\n * @param {string} value text which contains a constant reference like '${const:FormField.LabelPosition.RIGHT}'.\n * @return {any} the resolved constant value or the unchanged input value if the constant could not be resolved.\n */\nexport function resolveConst(value, constType) {\n  if (!isString(value)) {\n    return value;\n  }\n  let result = CONST_REGEX.exec(value);\n  if (result && result.length === 2) {\n    // go down the object hierarchy starting on the given constType-object or on 'window'\n    let objectHierarchy = result[1].split('.');\n    let obj = constType || window;\n    for (let i = 0; i < objectHierarchy.length; i++) {\n      obj = obj[objectHierarchy[i]];\n      if (obj === undefined) {\n        window.console.log('Failed to resolve constant \\'' + result[1] + '\\', object is undefined');\n        return value;\n      }\n    }\n    return obj;\n  }\n  return value;\n}\n\n/**\n * @param object config An object with 2 properties: property, constType\n */\nexport function resolveConstProperty(object, config) {\n  scout.assertProperty(config, 'property');\n  scout.assertProperty(config, 'constType');\n  let value = object[config.property];\n  let resolvedValue = resolveConst(value, config.constType);\n  if (value !== resolvedValue) {\n    object[config.property] = resolvedValue;\n  }\n}\n\n/**\n * @param {object} obj\n * @returns {Boolean|undefined}\n *  - true if the obj is empty, null or undefined\n *  - false if the obj is not empty\n *  - nothing if the obj is not an object\n */\nexport function isEmpty(obj) {\n  if (isNullOrUndefined(obj)) {\n    return true;\n  }\n  if (!isPlainObject(obj)) {\n    return;\n  }\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * Converts any non-string argument to a string that can be used as an object property name.\n * Complex objects are converted to their JSON representation (instead of returning something\n * non-descriptive such as '[Object object]').\n */\nexport function ensureValidKey(key) {\n  if (key === undefined) {\n    return 'undefined';\n  }\n  if (isString(key)) {\n    return key;\n  }\n  return JSON.stringify(key);\n}\nexport default {\n  CONST_REGEX,\n  argumentsToArray,\n  checkFunctionOverrides,\n  copyOwnProperties,\n  copyProperties,\n  countOwnProperties,\n  createMap,\n  ensureValidKey,\n  equals,\n  equalsRecursive,\n  extractProperties,\n  findChildObjectByKey,\n  getByPath,\n  forEachArgument,\n  isArray,\n  isEmpty,\n  isFunction,\n  isNullOrUndefined,\n  isNumber,\n  isPlainObject,\n  isString,\n  isPromise,\n  keyByValue,\n  mandatoryFunction,\n  optProperty,\n  propertiesEquals,\n  replacePrototypeFunction,\n  resolveConst,\n  resolveConstProperty,\n  someOwnProperties,\n  someProperties,\n  valueCopy,\n  values\n};","map":{"version":3,"names":["arrays","scout","strings","$","CONST_REGEX","createMap","properties","map","Object","create","extend","copyProperties","source","dest","filter","propertyName","ensure","length","indexOf","copyOwnProperties","prototype","hasOwnProperty","call","countOwnProperties","obj","getPrototypeOf","keys","count","prop","extractProperties","forEach","undefined","someOwnProperties","propArr","some","someProperties","valueCopy","copy","Array","isArray","i","findChildObjectByKey","parentObj","property","propertyValue","child","getByPath","object","path","assertParameter","pathElementRegexString","pathValidationRegex","RegExp","test","Error","pathElementRegex","pathMatchedSoFar","currentContext","split","pathElement","isNullOrUndefined","pathElementMatch","exec","arrayPropertyFilter","pathMatchedErrorContext","matchedElements","element","isPlainObject","optProperty","numArgs","isNumber","isNaN","isFinite","parseFloat","isString","String","isFunction","isPromise","value","then","values","all","key","push","keyByValue","equals","objA","objB","equalsRecursive","keysA","keysB","equalsIgnoreOrder","propertiesEquals","mandatoryFunction","funcName","func","replacePrototypeFunction","rememberOrig","proto","argumentsToArray","args","slice","forEachArgument","checkFunctionOverrides","whitelist","result1","result2","o","parent","name","fn","getFunctionArguments","parentFn","parentArgs","mismatch","fname","result","join","getPrototypeOwner","includesSuperCall","toString","match","quote","parentFunctionUsesArguments","j","m","concat","FN_COMMENTS","FN_ARGS","replace","arg","trim","fx","resolveConst","constType","objectHierarchy","window","console","log","resolveConstProperty","config","assertProperty","resolvedValue","isEmpty","ensureValidKey","JSON","stringify"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/objects.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, scout, strings} from '../index';\nimport $ from 'jquery';\n\nconst CONST_REGEX = /\\${const:([^}]*)}/;\n\n/**\n * Uses Object.create(null) to create an object without a prototype. This is different to use the literal {} which links the object to Object.prototype.\n * <p>\n * Not using the literal has the advantage that the object does not contain any inherited properties like `toString` so it is not necessary to use `o.hasOwnProperty(p)`\n * instead of `p in o` to check for the existence.\n *\n * @param [object] properties optional initial properties to be set on the new created object\n */\nexport function createMap(properties) {\n  let map = Object.create(null);\n  if (properties) {\n    $.extend(map, properties);\n  }\n  return map;\n}\n\n/**\n * Copies all the properties (including the ones from the prototype.) from dest to source\n * @param {[]} [filter] an array of property names.\n * @returns {object} the destination object (the destination parameter will be modified as well)\n */\nexport function copyProperties(source, dest, filter) {\n  let propertyName;\n  filter = arrays.ensure(filter);\n  for (propertyName in source) {\n    if (filter.length === 0 || filter.indexOf(propertyName) !== -1) {\n      dest[propertyName] = source[propertyName];\n    }\n  }\n  return dest;\n}\n\n/**\n * Copies the own properties (excluding the ones from the prototype) from dest to source.\n * If a filter is specified, only the properties matching the ones in the filter are copied.\n * @param {[]} [filter] an array of property names.\n * @returns {object} the destination object (the destination parameter will be modified as well)\n */\nexport function copyOwnProperties(source, dest, filter) {\n  let propertyName;\n  filter = arrays.ensure(filter);\n  for (propertyName in source) {\n    if (Object.prototype.hasOwnProperty.call(source, propertyName) && (filter.length === 0 || filter.indexOf(propertyName) !== -1)) {\n      dest[propertyName] = source[propertyName];\n    }\n  }\n  return dest;\n}\n\n/**\n * Counts and returns the properties of a given object or map (see #createMap).\n */\nexport function countOwnProperties(obj) {\n  // map objects don't have a prototype\n  if (!Object.getPrototypeOf(obj)) {\n    return Object.keys(obj).length;\n  }\n\n  // regular objects may inherit a property through their prototype\n  // we're only interested in own properties\n  let count = 0;\n  for (let prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Copies the specified properties (including the ones from the prototype) from source to dest.\n * Properties that already exist on dest are NOT overwritten.\n */\nexport function extractProperties(source, dest, properties) {\n  properties.forEach(propertyName => {\n    if (dest[propertyName] === undefined) {\n      dest[propertyName] = source[propertyName];\n    }\n  });\n  return dest;\n}\n\n/**\n * returns\n *  - true if the obj has at least one of the given properties.\n *  - false if the obj has none of the given properties.\n *\n * @param obj\n * @param properties a single property or an array of properties\n * @returns {Boolean}\n */\nexport function someOwnProperties(obj, properties) {\n  let propArr = arrays.ensure(properties);\n  return propArr.some(prop => {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  });\n}\n\n/**\n * returns\n *  - true if the obj or its prototypes have at least one of the given properties.\n *  - false if the obj or its prototypes have none of the given properties.\n *\n * @param obj\n * @param properties a single property or an array of properties\n * @returns {Boolean}\n */\nexport function someProperties(obj, properties) {\n  let propArr = arrays.ensure(properties);\n  return propArr.some(prop => {\n    return prop in obj;\n  });\n}\n\n/**\n * @return {*}\n */\nexport function valueCopy(obj) {\n  // Nothing to be done for immutable things\n  if (obj === undefined || obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  let copy;\n  // Arrays\n  if (Array.isArray(obj)) {\n    copy = [];\n    for (let i = 0; i < obj.length; i++) {\n      copy[i] = valueCopy(obj[i]);\n    }\n    return copy;\n  }\n  // All other objects\n  copy = {};\n  for (let prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      copy[prop] = valueCopy(obj[prop]);\n    }\n  }\n  return copy;\n}\n\n/**\n * Returns the first object with the given property and propertyValue or null if there is no such object within parentObj.\n * @param parentObj\n * @param property property to search for\n * @param propertyValue value of the property\n * @returns {Object}\n */\nexport function findChildObjectByKey(parentObj, property, propertyValue) {\n  if (parentObj === undefined || parentObj === null || typeof parentObj !== 'object') {\n    return null;\n  }\n  if (parentObj[property] === propertyValue) {\n    return parentObj;\n  }\n  let child;\n  if (Array.isArray(parentObj)) {\n    for (let i = 0; i < parentObj.length; i++) {\n      child = findChildObjectByKey(parentObj[i], property, propertyValue);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  for (let prop in parentObj) {\n    if (Object.prototype.hasOwnProperty.call(parentObj, prop)) {\n      child = findChildObjectByKey(parentObj[prop], property, propertyValue);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * This function returns the value of a property from the provided object specified by the second path parameter.\n * The path consists of a dot separated series of property names (e.g. foo, foo.bar, foo.bar.baz).\n * In addition, traversing into array properties is possible by specifying a suitable filter for the element's id property in square brackets (e.g. foo[bar], foo.bar[baz]).\n *\n * Example:\n *\n * let obj = {\n *   foo: {\n *     bar: {\n *       foobar: 'val1'\n *     }\n *   },\n *   baz: [\n *     {\n *       id: 'baz1',\n *       value: 'val2'\n *     },\n *     {\n *       id: 'baz2',\n *       value: 'val3'\n *     }\n *   ]\n * }\n *\n * objects.getByPath(obj, 'foo') === obj.foo;\n * objects.getByPath(obj, 'foo.bar') === obj.foo.bar;\n * objects.getByPath(obj, 'baz[baz1]') → { id: 'baz1', value: 'val2' }\n * objects.getByPath(obj, 'baz[baz2].value') → 'val3'\n *\n * @param object The object to select a property from.\n * @param path The path for the selection.\n * @return Object Returns the selected object.\n * @throws Throws an error, if the provided parameters are malformed, or a property could not be found/a id property filter does not find any elements.\n */\nexport function getByPath(object, path) {\n  scout.assertParameter('object', object, Object);\n  scout.assertParameter('path', path);\n\n  const pathElementRegexString = '(\\\\w+)(?:\\\\[((?:\\\\w|\\\\.|-)+)\\\\])?';\n  const pathValidationRegex = new RegExp('^' + pathElementRegexString + '(?:\\\\.' + pathElementRegexString + ')*$');\n\n  if (!pathValidationRegex.test(path)) {\n    throw new Error('Malformed path expression \"' + path + '\"');\n  }\n\n  const pathElementRegex = new RegExp(pathElementRegexString);\n  let pathMatchedSoFar = '';\n  let currentContext = object;\n\n  // Split by dot, but only if the dot is not followed by a string containing a ] that is not preceded by a [.\n  // That excludes dots, that are part of an array filter (e.g. foo[foo.bar]).\n  // Explanation: The regular expression matches dots literally, (\\.), that are not followed (negative lookahead: (?!...)\n  // by any mount of \"not opening square brackets\" ([^[]*) followed by a closing square bracket (last closing square bracket: ])\n  path.split(/\\.(?![^[]*])/).forEach(pathElement => {\n    // After the first iteration, the current context may be null or undefined. In this case, further traversal is not possible.\n    if (isNullOrUndefined(currentContext)) {\n      throw new Error('Value selected by matched path \"' + pathMatchedSoFar + '\" is null or undefined. Further traversal not possible.');\n    }\n\n    // match path element to retrieve property name and optional array property index\n    let pathElementMatch = pathElementRegex.exec(pathElement);\n    let propertyName = pathElementMatch[1];\n    let arrayPropertyFilter = pathElementMatch[2];\n\n    let pathMatchedErrorContext = pathMatchedSoFar.length === 0 ? 'root level of the provided object.' : 'matched path \"' + pathMatchedSoFar + '\".';\n\n    // check if property 'propertyName' exists\n    if (!currentContext.hasOwnProperty(propertyName)) {\n      throw new Error('Property \"' + propertyName + '\" does not exist at the ' + pathMatchedErrorContext);\n    }\n\n    let property = currentContext[propertyName];\n\n    // check if we are trying to match an array property or not\n    if (arrayPropertyFilter) {\n      // check for correct type of property\n      if (!Array.isArray(property)) {\n        throw new Error('Path element \"' + pathElement + '\" contains array filter but property \"' + propertyName + '\" does not contain an array at the ' + pathMatchedErrorContext);\n      }\n      // find elements matching criteria and make sure that exactly one object was found\n      let matchedElements = property.filter(element => {\n        return element['id'] === arrayPropertyFilter;\n      });\n      if (matchedElements.length === 0) {\n        throw new Error('No object found with id property \"' + arrayPropertyFilter + '\" in array property \"' + propertyName + '\" at the ' + pathMatchedErrorContext);\n      } else if (matchedElements.length > 1) {\n        throw new Error('More than one object found with id property \"' + arrayPropertyFilter + '\" in array property \"' + propertyName + '\" at the ' + pathMatchedErrorContext);\n      }\n      // reassign current context to found element\n      currentContext = matchedElements[0];\n    } else {\n      // reassign current context to found property\n      currentContext = property;\n    }\n\n    if (pathMatchedSoFar) {\n      pathMatchedSoFar += '.';\n    }\n    pathMatchedSoFar += pathElement;\n  });\n\n  return currentContext;\n}\n\n/**\n * Returns true if the given object is an object, _not_ an array and not null or undefined.\n */\nexport function isPlainObject(obj) {\n  return typeof obj === 'object' &&\n    !isNullOrUndefined(obj) &&\n    !Array.isArray(obj);\n}\n\n/**\n * Null-safe access the property of an objects. Examples:\n * <ul>\n * <li><code>optProperty(obj, 'value');</code> try to access and return obj.value</li>\n * <li><code>optProperty(obj, 'foo', 'bar');</code> try to access and return obj.foo.bar</li>\n * </ul>\n *\n * @returns {*} the value of the requested property or undefined if the property does not exist on the object\n */\nexport function optProperty(obj, ...properties) {\n  if (!obj) {\n    return null;\n  }\n\n  let numArgs = properties.length;\n  if (numArgs === 0) {\n    return obj;\n  }\n  if (numArgs === 1) {\n    return obj[properties[0]];\n  }\n\n  for (let i = 0; i < numArgs - 1; i++) {\n    obj = obj[properties[i]];\n    if (!obj) {\n      return null;\n    }\n  }\n  return obj[properties[numArgs - 1]];\n}\n\n/**\n * Returns true if:\n * - obj is not undefined or null\n * - obj not isNaN\n * - obj isFinite\n *\n * This method is handy in cases where you want to check if a number is set. Since you cannot write:\n *   if (myNumber) { ...\n *\n * Because when myNumber === 0 would also resolve to false. In that case use instead:\n *   if (isNumber(myNumber)) { ...\n *\n * @param obj\n * @returns {Boolean}\n */\nexport function isNumber(obj) {\n  return obj !== null && !isNaN(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n}\n\nexport function isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nexport function isNullOrUndefined(obj) {\n  return obj === null || obj === undefined;\n}\n\nexport function isFunction(obj) {\n  return $.isFunction(obj);\n}\n\nexport function isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * Checks whether the provided value is a promise or not.\n * @param {any} value The value to check.\n * @return {boolean} Returns true, in case the provided value is a thenable, false otherwise.\n *\n * Note: This method checks whether the provided value is a \"thenable\" (see https://promisesaplus.com/#terminology).\n *       Checking for promise would require to check the behavior which is not possible. So you could provide an object\n *       with a \"then\" function that does not conform to the Promises/A+ spec but this method would still return true.\n */\nexport function isPromise(value) {\n  return !!value && typeof value === 'object' && typeof value.then === 'function';\n}\n\n/**\n * Returns values from the given (map) object. By default only values of 'own' properties are returned.\n *\n * @returns {Array} an Array with values\n * @param {Object} obj\n * @param {boolean} [all] can be set to true to return all properties instead of own properties\n */\nexport function values(obj, all) {\n  let values = [];\n  if (obj) {\n    if (typeof obj.hasOwnProperty !== 'function') {\n      all = true;\n    }\n    for (let key in obj) {\n      if (all || obj.hasOwnProperty(key)) {\n        values.push(obj[key]);\n      }\n    }\n  }\n  return values;\n}\n\n/**\n * @returns {string} the key / name of a property\n */\nexport function keyByValue(obj, value) {\n  return Object.keys(obj)[values(obj).indexOf(value)];\n}\n\n/**\n * Java-like equals method. Compares the given objects by checking with ===, if that fails, the function\n * checks if both objects have an equals function and use the equals function to compare the two objects\n * by value.\n * @returns {boolean} true if both objects are equals by reference or by value\n */\nexport function equals(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  // both objects have an equals() method\n  if (objA && objB && (objA.equals && objB.equals)) {\n    return objA.equals(objB);\n  }\n  return false;\n}\n\n/**\n * Compare two objects and all its child elements recursively.\n * @returns {boolean} true if both objects and all child elements are equals by value or implemented equals method\n */\nexport function equalsRecursive(objA, objB) {\n  let i;\n  if (isPlainObject(objA) && isPlainObject(objB)) {\n    if (isFunction(objA.equals) && isFunction(objB.equals)) {\n      return objA.equals(objB);\n    }\n    let keysA = Object.keys(objA);\n    let keysB = Object.keys(objB);\n    if (!arrays.equalsIgnoreOrder(keysA, keysB)) {\n      return false;\n    }\n    for (i = 0; i < keysA.length; i++) {\n      if (!equalsRecursive(objA[keysA[i]], objB[keysA[i]])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (isArray(objA) && isArray(objB)) {\n    if (objA.length !== objB.length) {\n      return false;\n    }\n    for (i = 0; i < objA.length; i++) {\n      if (!equalsRecursive(objA[i], objB[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return objA === objB;\n}\n\n/**\n * Compares a list of properties of two objects by using the equals method for each property.\n */\nexport function propertiesEquals(objA, objB, properties) {\n  let i, property;\n  for (i = 0; i < properties.length; i++) {\n    property = properties[i];\n    if (!equals(objA[property], objB[property])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @returns {function} the function identified by funcName from the given object. The function will return an error\n *     if that function does not exist. Use this function if you modify an existing framework function\n *     to find problems after refactorings / renamings as soon as possible.\n */\nexport function mandatoryFunction(obj, funcName) {\n  let func = obj[funcName];\n  if (!func || typeof func !== 'function') {\n    throw new Error('Function \\'' + funcName + '\\' does not exist on object. Check if it has been renamed or moved. Object: ' + obj);\n  }\n  return func;\n}\n\n/**\n * Use this method to replace a function on a prototype of an object. It checks if that function exists\n * by calling <code>mandatoryFunction</code>.\n */\nexport function replacePrototypeFunction(obj, funcName, func, rememberOrig) {\n  let proto = obj.prototype;\n  mandatoryFunction(proto, funcName);\n  if (rememberOrig) {\n    proto[funcName + 'Orig'] = proto[funcName];\n  }\n  proto[funcName] = func;\n}\n\n/**\n * @returns a real Array for the pseudo-array 'arguments'.\n */\nexport function argumentsToArray(args) {\n  return args ? Array.prototype.slice.call(args) : [];\n}\n\n/**\n * Used to loop over 'arguments' pseudo-array with forEach.\n */\nexport function forEachArgument(args, func) {\n  return argumentsToArray(args).forEach(func);\n}\n\n/**\n * Development utility to check if overrides in JavaScript \"classes\" are correct.\n *\n * How to use:\n *   1. Start application in development mode (non-minimized).\n *   2. Open browser's development console\n *   3. Type: checkFunctionOverrides().join('\\n')\n */\nexport function checkFunctionOverrides() {\n  let whitelist = [\n    'ModelAdapter.init',\n    'ModelAdapter._init',\n    'Calendar.init'\n  ];\n  let result1 = [\n    'Legend:',\n    '[!] Function includes super call, and parent function uses arguments',\n    ' ~  Function includes super call, but parent function does not use arguments',\n    '    Function does not include super call',\n    '',\n    'Wrong number of arguments:'\n  ];\n  let result2 = ['Different argument names:'];\n\n  for (let prop in scout) {\n    if (!scout.hasOwnProperty(prop)) {\n      continue;\n    }\n    let o = scout[prop];\n    // Only check functions that have a \"parent\"\n    if (typeof o === 'function' && o.parent) {\n      for (let name in o.prototype) {\n        if (!o.prototype.hasOwnProperty(name)) {\n          continue;\n        }\n        let fn = o.prototype[name];\n        // Ignore constructor, inherited properties and non-functions\n        if (name === 'constructor' || !o.prototype.hasOwnProperty(name) || typeof fn !== 'function') {\n          continue;\n        }\n        let args = getFunctionArguments(fn);\n        // Check all parents\n        let parent = o.parent;\n        while (parent) {\n          let parentFn = parent.prototype[name];\n          if (parent.prototype.hasOwnProperty(name) && typeof parentFn === 'function') {\n            let parentArgs = getFunctionArguments(parentFn);\n            // Check arguments (at least all of the parent args must be present)\n            let mismatch = false;\n            for (let i = 0; i < parentArgs.length; i++) {\n              if (args.length < i || args[i] !== parentArgs[i]) {\n                mismatch = true;\n                break;\n              }\n            }\n            let fname = prop + '.' + name;\n            if (mismatch && whitelist.indexOf(fname) === -1) { // && args.length !== parentArgs.length) {\n              // Collect found mismatch\n              let result = fname + '(' + args.join(', ') + ') does not correctly override ' + getPrototypeOwner(parentFn) + '.' + name + '(' + parentArgs.join(', ') + ')';\n              let includesSuperCall = fn.toString().match(new RegExp('scout.' + strings.quote(prop) + '.parent.prototype.' + strings.quote(name) + '.call\\\\(')) !== null;\n              let parentFunctionUsesArguments = false;\n              if (includesSuperCall) {\n                for (let j = 0; j < parentArgs.length; j++) {\n                  let m = parentFn.toString().match(new RegExp('[^.\\\\w]' + strings.quote(parentArgs[j]) + '[^\\\\w]', 'g'));\n                  if (m !== null && m.length > 1) {\n                    parentFunctionUsesArguments = true;\n                    break;\n                  }\n                }\n              }\n              result = (includesSuperCall ? parentFunctionUsesArguments ? '[!]' : ' ~ ' : '   ') + ' ' + result;\n              if (args.length !== parentArgs.length) {\n                result1.push(result);\n              } else {\n                result2.push(result);\n              }\n            }\n          }\n          parent = parent.parent;\n        }\n      }\n    }\n  }\n\n  result1.push('');\n  return result1.concat(result2);\n\n  // ----- Helper functions -----\n\n  function getFunctionArguments(fn) {\n    let FN_COMMENTS = /\\/\\*.*?\\*\\/|\\/\\/.*$/mg; // removes comments in function declaration\n    let FN_ARGS = /^function[^(]*\\((.*?)\\)/m; // fetches all arguments in m[1]\n\n    if (typeof fn !== 'function') {\n      throw new Error('Argument is not a function: ' + fn);\n    }\n\n    let m = fn.toString().replace(FN_COMMENTS, '')\n      .match(FN_ARGS);\n    let args = [];\n    if (m !== null) {\n      m[1].split(',').forEach((arg, i) => {\n        arg = arg.trim();\n        if (arg.length > 0) {\n          args.push(arg);\n        }\n      });\n    }\n    return args;\n  }\n\n  function getPrototypeOwner(fx) {\n    for (let prop in scout) {\n      if (!scout.hasOwnProperty(prop)) {\n        continue;\n      }\n      let o = scout[prop];\n      if (typeof o === 'function') {\n        for (let name in o.prototype) {\n          if (!o.prototype.hasOwnProperty(name)) {\n            continue;\n          }\n          let fn = o.prototype[name];\n          // Ignore constructor, inherited properties and non-functions\n          if (name === 'constructor' || !o.prototype.hasOwnProperty(name) || typeof fn !== 'function') {\n            continue;\n          }\n          if (fn === fx) {\n            return prop;\n          }\n        }\n      }\n    }\n    return '';\n  }\n}\n\n/**\n * @param {string} value text which contains a constant reference like '${const:FormField.LabelPosition.RIGHT}'.\n * @return {any} the resolved constant value or the unchanged input value if the constant could not be resolved.\n */\nexport function resolveConst(value, constType) {\n  if (!isString(value)) {\n    return value;\n  }\n\n  let result = CONST_REGEX.exec(value);\n  if (result && result.length === 2) {\n    // go down the object hierarchy starting on the given constType-object or on 'window'\n    let objectHierarchy = result[1].split('.');\n    let obj = constType || window;\n    for (let i = 0; i < objectHierarchy.length; i++) {\n      obj = obj[objectHierarchy[i]];\n      if (obj === undefined) {\n        window.console.log('Failed to resolve constant \\'' + result[1] + '\\', object is undefined');\n        return value;\n      }\n    }\n    return obj;\n  }\n  return value;\n}\n\n/**\n * @param object config An object with 2 properties: property, constType\n */\nexport function resolveConstProperty(object, config) {\n  scout.assertProperty(config, 'property');\n  scout.assertProperty(config, 'constType');\n  let value = object[config.property];\n  let resolvedValue = resolveConst(value, config.constType);\n  if (value !== resolvedValue) {\n    object[config.property] = resolvedValue;\n  }\n}\n\n/**\n * @param {object} obj\n * @returns {Boolean|undefined}\n *  - true if the obj is empty, null or undefined\n *  - false if the obj is not empty\n *  - nothing if the obj is not an object\n */\nexport function isEmpty(obj) {\n  if (isNullOrUndefined(obj)) {\n    return true;\n  }\n  if (!isPlainObject(obj)) {\n    return;\n  }\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * Converts any non-string argument to a string that can be used as an object property name.\n * Complex objects are converted to their JSON representation (instead of returning something\n * non-descriptive such as '[Object object]').\n */\nexport function ensureValidKey(key) {\n  if (key === undefined) {\n    return 'undefined';\n  }\n  if (isString(key)) {\n    return key;\n  }\n  return JSON.stringify(key);\n}\n\nexport default {\n  CONST_REGEX,\n  argumentsToArray,\n  checkFunctionOverrides,\n  copyOwnProperties,\n  copyProperties,\n  countOwnProperties,\n  createMap,\n  ensureValidKey,\n  equals,\n  equalsRecursive,\n  extractProperties,\n  findChildObjectByKey,\n  getByPath,\n  forEachArgument,\n  isArray,\n  isEmpty,\n  isFunction,\n  isNullOrUndefined,\n  isNumber,\n  isPlainObject,\n  isString,\n  isPromise,\n  keyByValue,\n  mandatoryFunction,\n  optProperty,\n  propertiesEquals,\n  replacePrototypeFunction,\n  resolveConst,\n  resolveConstProperty,\n  someOwnProperties,\n  someProperties,\n  valueCopy,\n  values\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}