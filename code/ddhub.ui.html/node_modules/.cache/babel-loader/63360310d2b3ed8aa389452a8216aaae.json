{"ast":null,"code":"/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, graphics, HtmlComponent, Insets, objects, scout } from '../index';\nimport $ from 'jquery';\n\n/**\n * Static function to install a scrollbar on a container.\n * When the client supports pretty native scrollbars, we use them by default.\n * Otherwise we install JS-based scrollbars. In that case the install function\n * creates a new scrollbar.js. For native scrollbars we\n * must set some additional CSS styles.\n */\n\nlet _$scrollables = {};\nlet mutationObserver;\nlet intersectionObserver;\nexport function getScrollables(session) {\n  // return scrollables for given session\n  if (session) {\n    return _$scrollables[session] || [];\n  }\n\n  // return all scrollables, no matter to which session they belong\n  let $scrollables = [];\n  objects.values(_$scrollables).forEach($scrollablesPerSession => {\n    arrays.pushAll($scrollables, $scrollablesPerSession);\n  });\n  return $scrollables;\n}\nexport function pushScrollable(session, $container) {\n  if (_$scrollables[session]) {\n    if (_$scrollables[session].indexOf($container) > -1) {\n      // already pushed\n      return;\n    }\n    _$scrollables[session].push($container);\n  } else {\n    _$scrollables[session] = [$container];\n  }\n  $.log.isTraceEnabled() && $.log.trace('Scrollable added: ' + $container.attr('class') + '. New length: ' + _$scrollables[session].length);\n}\nexport function removeScrollable(session, $container) {\n  let initLength = 0;\n  if (_$scrollables[session]) {\n    initLength = _$scrollables[session].length;\n    arrays.$remove(_$scrollables[session], $container);\n    $.log.isTraceEnabled() && $.log.trace('Scrollable removed: ' + $container.attr('class') + '. New length: ' + _$scrollables[session].length);\n    if (initLength === _$scrollables[session].length) {\n      throw new Error('scrollable could not be removed. Potential memory leak. ' + $container.attr('class'));\n    }\n  } else {\n    throw new Error('scrollable could not be removed. Potential memory leak. ' + $container.attr('class'));\n  }\n}\n\n/**\n * @param [options]\n * @param {string} [options.axis] x, y or both. Default is both.\n * @param {boolean} [options.nativeScrollbars]\n * @param {boolean} [options.hybridScrollbars]\n * @param {string|[string]} [options.scrollShadow] controls the scroll shadow behavior.\n *        <ul>\n *          <li>To define where the shadow should appear, use one of the following values: x, y, top, right, bottom, left. Multiple values can be separated by space.\n *          <li>If no positioning value is provided, it is automatically determined based on the axis.</li>\n *          <li>To adjust the style, add one of the following values: large or gradient.</li>\n *          <li>To disable the scroll shadow completely, set the value to none.</li>\n *        </ul>\n * @param {function} [options.scrollShadowCustomizer] function to customize the scroll shadow\n * @param {Session} [options.session]\n * @param {Widget} [options.parent]\n */\nexport function install($container, options) {\n  options = _createDefaultScrollToOptions(options);\n  options.axis = options.axis || 'both';\n  options.scrollShadow = options.scrollShadow || 'auto';\n\n  // Don't use native as variable name because it will break minifying (reserved keyword)\n  let nativeScrollbars = scout.nvl(options.nativeScrollbars, Device.get().hasPrettyScrollbars());\n  let hybridScrollbars = scout.nvl(options.hybridScrollbars, Device.get().canHideScrollbars());\n  if (nativeScrollbars) {\n    _installNative($container, options);\n  } else if (hybridScrollbars) {\n    $container.addClass('hybrid-scrollable');\n    _installNative($container, options);\n    _installJs($container, options);\n  } else {\n    $container.css('overflow', 'hidden');\n    _installJs($container, options);\n  }\n  let htmlContainer = HtmlComponent.optGet($container);\n  if (htmlContainer) {\n    htmlContainer.scrollable = true;\n  }\n  $container.data('scrollable', true);\n  let session = options.session || options.parent.session;\n  pushScrollable(session, $container);\n  if (options.scrollShadow) {\n    installScrollShadow($container, session, options);\n  }\n  return $container;\n}\nexport function _installNative($container, options) {\n  if (Device.get().isIos()) {\n    // On ios, container sometimes is not scrollable when installing too early\n    // Happens often with nested scrollable containers (e.g. scrollable table inside a form inside a scrollable tree data)\n    setTimeout(_installNativeInternal.bind(this, $container, options));\n  } else {\n    _installNativeInternal($container, options);\n  }\n}\nexport function _installNativeInternal($container, options) {\n  $.log.isTraceEnabled() && $.log.trace('use native scrollbars for container ' + graphics.debugOutput($container));\n  if (options.axis === 'x') {\n    $container.css('overflow-x', 'auto').css('overflow-y', 'hidden');\n  } else if (options.axis === 'y') {\n    $container.css('overflow-x', 'hidden').css('overflow-y', 'auto');\n  } else {\n    $container.css('overflow', 'auto');\n  }\n  $container.css('-webkit-overflow-scrolling', 'touch');\n}\nexport function installScrollShadow($container, session, options) {\n  if (!Device.get().supportsIntersectionObserver()) {\n    return;\n  }\n  let scrollShadowStyle = _computeScrollShadowStyle(options);\n  if (scrollShadowStyle.length === 0) {\n    return;\n  }\n  let $shadow = $container.afterDiv('scroll-shadow');\n  $shadow.toggleClass('large', scrollShadowStyle.indexOf('large') > -1);\n  $shadow.toggleClass('gradient', scrollShadowStyle.indexOf('gradient') > -1);\n  $shadow.data('scroll-shadow-parent', $container);\n  $container.data('scroll-shadow', $shadow);\n  $container.data('scroll-shadow-style', scrollShadowStyle);\n  $container.data('scroll-shadow-customizer', options.scrollShadowCustomizer);\n  let handler = () => updateScrollShadowWhileScrolling($container);\n  $container.data('scroll-shadow-handler', handler);\n  $container.on('scroll', handler);\n  updateScrollShadow($container);\n  _installMutationObserver(session);\n  _installIntersectionObserver();\n  intersectionObserver.observe($container[0]);\n\n  // this is required in addition to the intersection observer because the observer events are handled asynchronously later after all the setTimeout calls.\n  // Then the shadow might stay visible too long which has an impact on layout updates.\n  let containerElement = $container[0];\n  let visibleListener = e => {\n    if (e.target === containerElement) {\n      _onScrollableVisibleChange(containerElement, e.type === 'show');\n    }\n  };\n  $container.data('scroll-shadow-visible-listener', visibleListener);\n  $container.on('hide show', visibleListener);\n}\nexport function uninstallScrollShadow($container, session) {\n  let $shadow = $container.data('scroll-shadow');\n  if ($shadow) {\n    $shadow.remove();\n    $container.removeData('scroll-shadow');\n  }\n  $container.removeData('scroll-shadow-style');\n  $container.removeData('scroll-shadow-customizer');\n  let handler = $container.data('scroll-shadow-handler');\n  if (handler) {\n    $container.off('scroll', handler);\n    $container.removeData('scroll-shadow-handler');\n  }\n  if (intersectionObserver) {\n    intersectionObserver.unobserve($container[0]);\n  }\n  let visibleListener = $container.data('scroll-shadow-visible-listener');\n  if (visibleListener) {\n    $container.off('hide show', visibleListener);\n  }\n  let $scrollables = _$scrollables[session];\n  if (!$scrollables || !$scrollables.some($scrollable => $scrollable.data('scroll-shadow'))) {\n    _uninstallMutationObserver();\n    _uninstallIntersectionObserver();\n  }\n}\n\n/**\n * @param options\n * @return {[string]}\n */\nfunction _computeScrollShadowStyle(options) {\n  let scrollShadow = options.scrollShadow;\n  if (!scrollShadow) {\n    return [];\n  }\n  if (typeof scrollShadow === 'string') {\n    scrollShadow = scrollShadow.split(' ');\n  }\n  scrollShadow = scrollShadow.slice(); // copy to don't modify parameter\n  if (scrollShadow.indexOf('none') > -1) {\n    return [];\n  }\n  if (!arrays.containsAny(scrollShadow, ['y', 'x', 'top', 'right', 'bottom', 'left'])) {\n    // If no position was set, determine it automatically based on the axis\n    if (options.axis === 'both' || options.axis === 'y') {\n      scrollShadow.push('y');\n    }\n    if (options.axis === 'both' || options.axis === 'x') {\n      scrollShadow.push('x');\n    }\n  }\n  if (scrollShadow.indexOf('y') > -1) {\n    scrollShadow.push('top');\n    scrollShadow.push('bottom');\n  }\n  if (scrollShadow.indexOf('x') > -1) {\n    scrollShadow.push('left');\n    scrollShadow.push('right');\n  }\n  arrays.removeAll(scrollShadow, ['all', 'y', 'x', 'auto', 'none']);\n  return scrollShadow;\n}\nexport function updateScrollShadowWhileScrolling($container) {\n  let $animatingParent = $container.findUp($elem => $elem.hasAnimationClass());\n  if ($animatingParent.length > 0) {\n    // If the container is scrolled while being animated, the shadow will likely get the wrong size and/or position if the animation changes the bounds.\n    // The scroll event is mostly probably not triggered by the user directly but by the scrollable container itself, e.g. to reveal a focused / selected / checked element.\n    $animatingParent.oneAnimationEnd(() => updateScrollShadow($container));\n    return;\n  }\n  updateScrollShadow($container);\n}\nexport function updateScrollShadow($container) {\n  let $shadow = $container.data('scroll-shadow');\n  if (!$shadow) {\n    return;\n  }\n  let scrollTop = $container[0].scrollTop;\n  let scrollLeft = $container[0].scrollLeft;\n  let atTop = atStart(scrollTop);\n  let atBottom = atEnd(scrollTop, $container[0].scrollHeight, $container[0].offsetHeight);\n  let atLeft = atStart(scrollLeft);\n  let atRight = atEnd(scrollLeft, $container[0].scrollWidth, $container[0].offsetWidth);\n  let style = $container.data('scroll-shadow-style');\n  $shadow.toggleClass('top', !atTop && style.indexOf('top') > -1);\n  $shadow.toggleClass('bottom', !atBottom && style.indexOf('bottom') > -1);\n  $shadow.toggleClass('left', !atLeft && style.indexOf('left') > -1);\n  $shadow.toggleClass('right', !atRight && style.indexOf('right') > -1);\n  graphics.setBounds($shadow, graphics.bounds($container, {\n    exact: true\n  }).subtract(insets($shadow)));\n  graphics.setMargins($shadow, graphics.margins($container));\n  $shadow.css('border-radius', $container.css('border-radius'));\n  let customizer = $container.data('scroll-shadow-customizer');\n  if (customizer) {\n    customizer($container, $shadow);\n  }\n  function atStart(scrollPos) {\n    return scrollPos === 0;\n  }\n  function atEnd(scrollPos, scrollSize, offsetSize) {\n    return scrollPos + 1 >= scrollSize - offsetSize;\n  }\n  function insets($shadow) {\n    return new Insets($shadow.cssPxValue('--scroll-shadow-inset-top'), $shadow.cssPxValue('--scroll-shadow-inset-right'), $shadow.cssPxValue('--scroll-shadow-inset-bottom'), $shadow.cssPxValue('--scroll-shadow-inset-left'));\n  }\n}\n\n/**\n * Installs a dom mutation observer that tracks all scrollables in order to move the scroll shadow along with the scrollable.\n */\nfunction _installMutationObserver(session) {\n  if (mutationObserver) {\n    return;\n  }\n  mutationObserver = new MutationObserver(_onDomMutation);\n  mutationObserver.observe(session.$entryPoint[0], {\n    subtree: true,\n    childList: true\n  });\n}\nfunction _onDomMutation(mutationList, observer) {\n  mutationList.forEach(_processDomMutation);\n}\nexport function _processDomMutation(mutation) {\n  // addedNodes if of type NodeList and therefore does not support array functions\n  for (let i = 0; i < mutation.addedNodes.length; i++) {\n    let elem = mutation.addedNodes[i];\n    let $elem = $(elem);\n    if ($elem.data('scrollable')) {\n      // Move scroll shadow after scrollable when scrollable was moved (=inserted again)\n      let $scrollShadow = $elem.data('scroll-shadow');\n      if ($scrollShadow) {\n        $scrollShadow.insertAfter($elem);\n      }\n    }\n  }\n}\nfunction _uninstallMutationObserver() {\n  if (!mutationObserver) {\n    return;\n  }\n  mutationObserver.disconnect();\n  mutationObserver = null;\n}\n\n/**\n * Installs an intersection observer that tracks the visibility of a scrollable in order to update the visibility of the scroll shadow accordingly.\n */\nfunction _installIntersectionObserver() {\n  if (intersectionObserver) {\n    return;\n  }\n  intersectionObserver = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      _onScrollableVisibleChange(entry.target, entry.intersectionRatio > 0);\n    });\n  });\n}\nfunction _uninstallIntersectionObserver() {\n  if (!intersectionObserver) {\n    return;\n  }\n  intersectionObserver.disconnect();\n  intersectionObserver = null;\n}\nexport function _onScrollableVisibleChange(element, visible) {\n  let $element = $(element);\n  let $shadow = $element.data('scroll-shadow');\n  if (!$shadow) {\n    return;\n  }\n  $shadow.setVisible($element.isVisible());\n}\nexport function hasScrollShadow($container, position) {\n  if (!$container) {\n    return false;\n  }\n  let $scrollShadow = $container.data('scroll-shadow');\n  if (!$scrollShadow) {\n    return false;\n  }\n  if (!position) {\n    return true;\n  }\n  return $scrollShadow.hasClass(position);\n}\nexport function isHybridScrolling($scrollable) {\n  return $scrollable.hasClass('hybrid-scrollable');\n}\nexport function isNativeScrolling($scrollable) {\n  return scout.isOneOf('auto', $scrollable.css('overflow'), $scrollable.css('overflow-x'), $scrollable.css('overflow-y'));\n}\nexport function isJsScrolling($scrollable) {\n  return !!$scrollable.data('scrollbars');\n}\nexport function _installJs($container, options) {\n  $.log.isTraceEnabled() && $.log.trace('installing JS-scrollbars for container ' + graphics.debugOutput($container));\n  let scrollbars = arrays.ensure($container.data('scrollbars'));\n  scrollbars.forEach(scrollbar => {\n    scrollbar.destroy();\n  });\n  scrollbars = [];\n  let scrollbar;\n  if (options.axis === 'both') {\n    let scrollOptions = $.extend({}, options);\n    scrollOptions.axis = 'y';\n    scrollbar = scout.create('Scrollbar', $.extend({}, scrollOptions));\n    scrollbars.push(scrollbar);\n    scrollOptions.axis = 'x';\n    scrollOptions.mouseWheelNeedsShift = true;\n    scrollbar = scout.create('Scrollbar', $.extend({}, scrollOptions));\n    scrollbars.push(scrollbar);\n  } else {\n    scrollbar = scout.create('Scrollbar', $.extend({}, options));\n    scrollbars.push(scrollbar);\n  }\n  $container.data('scrollbars', scrollbars);\n  scrollbars.forEach(scrollbar => {\n    scrollbar.render($container);\n    scrollbar.update();\n  });\n}\n\n/**\n * Removes the js scrollbars for the $container, if there are any.<p>\n */\nexport function uninstall($container, session) {\n  if (!$container.data('scrollable')) {\n    // was not installed previously -> uninstalling not necessary\n    return;\n  }\n  let scrollbars = $container.data('scrollbars');\n  if (scrollbars) {\n    scrollbars.forEach(scrollbar => {\n      scrollbar.destroy();\n    });\n  }\n  removeScrollable(session, $container);\n  $container.removeData('scrollable');\n  $container.css('overflow', '');\n  $container.removeClass('hybrid-scrollable');\n  $container.removeData('scrollbars');\n  let htmlContainer = HtmlComponent.optGet($container);\n  if (htmlContainer) {\n    htmlContainer.scrollable = false;\n  }\n  uninstallScrollShadow($container, session);\n}\n\n/**\n * Recalculates the scrollbar size and position.\n * @param $scrollable JQuery element that has .data('scrollbars'), when $scrollable is falsy the function returns immediately\n * @param immediate set to true to immediately update the scrollbar, If set to false,\n *        it will be queued in order to prevent unnecessary updates.\n */\nexport function update($scrollable, immediate) {\n  if (!$scrollable || !$scrollable.data('scrollable')) {\n    return;\n  }\n  updateScrollShadow($scrollable);\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    if (Device.get().isIos()) {\n      _handleIosPaintBug($scrollable);\n    }\n    return;\n  }\n  if (immediate) {\n    _update(scrollbars);\n    return;\n  }\n  if ($scrollable.data('scrollbarUpdatePending')) {\n    return;\n  }\n  // Executes the update later to prevent unnecessary updates\n  setTimeout(() => {\n    _update(scrollbars);\n    $scrollable.removeData('scrollbarUpdatePending');\n  }, 0);\n  $scrollable.data('scrollbarUpdatePending', true);\n}\nexport function _update(scrollbars) {\n  // Reset the scrollbars first to make sure they don't extend the scrollSize\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.reset();\n    }\n  });\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.update();\n    }\n  });\n}\n\n/**\n * IOS has problems with nested scrollable containers. Sometimes the outer container goes completely white hiding the elements behind.\n * This happens with the following case: Main box is scrollable but there are no scrollbars because content is smaller than container.\n * In the main box there is a tab box with a scrollable table. This table has scrollbars.\n * If the width of the tab box is adjusted (which may happen if the tab item is selected and eventually prefSize called), the main box will go white.\n * <p>\n * This happens only if -webkit-overflow-scrolling is set to touch.\n * To workaround this bug the flag -webkit-overflow-scrolling will be removed if the scrollable component won't display any scrollbars\n */\n\nexport function _handleIosPaintBug($scrollable) {\n  if ($scrollable.data('scrollbarUpdatePending')) {\n    return;\n  }\n  setTimeout(() => {\n    workaround();\n    $scrollable.removeData('scrollbarUpdatePending');\n  });\n  $scrollable.data('scrollbarUpdatePending', true);\n  function workaround() {\n    let size = graphics.size($scrollable).subtract(graphics.insets($scrollable, {\n      includePadding: false,\n      includeBorder: true\n    }));\n    if ($scrollable[0].scrollHeight === size.height && $scrollable[0].scrollWidth === size.width) {\n      $scrollable.css('-webkit-overflow-scrolling', '');\n    } else {\n      $scrollable.css('-webkit-overflow-scrolling', 'touch');\n    }\n  }\n}\nexport function reset($scrollable) {\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    return;\n  }\n  scrollbars.forEach(scrollbar => {\n    scrollbar.reset();\n  });\n}\n\n/**\n * Scrolls the $scrollable to the given $element (must be a child of $scrollable)\n *\n * @param {$} $scrollable\n *          the scrollable object\n * @param {$} $element\n *          the element to scroll to\n * @param {object|string} [options]\n *          an optional options object. Short-hand version: If a string is passed instead\n *          of an object, the value is automatically converted to the option \"align\".\n * @param {string} [options.align]\n *          Specifies where the element should be positioned in the view port. Can either be 'top', 'center' or 'bottom'.\n *          If unspecified, the following rules apply:\n *          - If the element is above the visible area it will be aligned to top.\n *          - If the element is below the visible area it will be aligned to bottom.\n *          - If the element is already in the visible area no scrolling is done.\n *          Default is undefined.\n * @param {boolean} [options.animate]\n *          If true, the scroll position will be animated so that the element moves smoothly to its new position. Default is false.\n * @param {boolean} [options.stop]\n *          If true, all running animations are stopped before executing the current scroll request. Default is true.\n * @param {number} [options.scrollOffsetUp]\n *          Additional margin to assume at the top of the target element (independent from any actual CSS margin).\n *          Useful when elements are positioned outside of their boundaries (e.g. focus border). Default is 4.\n * @param {number} [options.scrollOffsetDown]\n *          Additional margin to assume at the bottom of the target element (independent from any actual CSS margin).\n *          Useful when elements are positioned outside of their boundaries (e.g. focus border). Default is 8.\n */\nexport function scrollTo($scrollable, $element, options) {\n  if (typeof options === 'string') {\n    options = {\n      align: options\n    };\n  } else {\n    options = _createDefaultScrollToOptions(options);\n  }\n  let align = options.align ? options.align.toLowerCase() : undefined;\n  let scrollTo,\n    scrollOffsetUp = scout.nvl(options.scrollOffsetUp, align === 'center' ? 0 : 4),\n    scrollOffsetDown = scout.nvl(options.scrollOffsetDown, align === 'center' ? 0 : 8),\n    scrollableH = $scrollable.height(),\n    elementBounds = graphics.offsetBounds($element),\n    scrollableBounds = graphics.offsetBounds($scrollable),\n    elementY = elementBounds.y - scrollableBounds.y,\n    elementH = elementBounds.height,\n    elementTop = elementY - scrollOffsetUp,\n    // relative to scrollable y\n    elementBottom = elementY + elementH + scrollOffsetDown;\n\n  //        ---          ^                     <-- elementTop\n  //         |           | scrollOffsetUp\n  //         |           v\n  //   +------------+    ^                     <-- elementY\n  //   |  element   |    | elementH\n  //   +------------+    v\n  //         |           ^\n  //         |           | scrollOffsetDown\n  //        ---          v                     <-- elementBottom\n\n  if (!align) {\n    // If the element is above the visible area it will be aligned to top.\n    // If the element is below the visible area it will be aligned to bottom.\n    // If the element is already in the visible area no scrolling is done.\n    align = elementTop < 0 ? 'top' : elementBottom > scrollableH ? 'bottom' : undefined;\n  }\n  if (align === 'center') {\n    // align center\n    scrollTo = $scrollable.scrollTop() + elementTop - Math.max(0, (scrollableH - elementH) / 2);\n  } else if (align === 'top') {\n    // align top\n    // Element is on the top of the view port -> scroll up\n    scrollTo = $scrollable.scrollTop() + elementTop;\n  } else if (align === 'bottom') {\n    // align bottom\n    // Element is on the Bottom of the view port -> scroll down\n    // On IE, a fractional position gets truncated when using scrollTop -> ceil to make sure the full element is visible\n    scrollTo = Math.ceil($scrollable.scrollTop() + elementBottom - scrollableH);\n\n    // If the viewport is very small, make sure the element is not moved outside on top\n    // Otherwise when calling this function again, since the element is on the top of the view port, the scroll pane would scroll down which results in flickering\n    let elementTopNew = elementTop - (scrollTo - $scrollable.scrollTop());\n    if (elementTopNew < 0) {\n      scrollTo = scrollTo + elementTopNew;\n    }\n  }\n  if (scrollTo !== undefined) {\n    scrollTop($scrollable, scrollTo, options);\n  }\n}\nexport function _createDefaultScrollToOptions(options) {\n  let defaults = {\n    animate: false,\n    stop: true\n  };\n  return $.extend({}, defaults, options);\n}\n\n/**\n * Horizontally scrolls the $scrollable to the given $element (must be a child of $scrollable)\n */\nexport function scrollHorizontalTo($scrollable, $element, options) {\n  let scrollTo,\n    scrollableW = $scrollable.width(),\n    elementBounds = graphics.bounds($element, true),\n    elementLeft = elementBounds.x,\n    elementW = elementBounds.width;\n  if (elementLeft < 0) {\n    scrollLeft($scrollable, $scrollable.scrollLeft() + elementLeft, options);\n  } else if (elementLeft + elementW > scrollableW) {\n    // On IE, a fractional position gets truncated when using scrollTop -> ceil to make sure the full element is visible\n    scrollTo = Math.ceil($scrollable.scrollLeft() + elementLeft + elementW - scrollableW);\n    scrollLeft($scrollable, scrollTo, options);\n  }\n}\n\n/**\n * @param {$} $scrollable the scrollable object\n * @param {number} scrollTop the new scroll position\n * @param {object} [options]\n * @param {boolean} [options.animate] whether the scrolling should be animated. Default is false.\n * @param {boolean} [options.stop] whether the animation should be stopped. Default is false.\n */\nexport function scrollTop($scrollable, scrollTop, options) {\n  options = _createDefaultScrollToOptions(options);\n  let scrollbarElement = scrollbar($scrollable, 'y');\n  if (scrollbarElement) {\n    scrollbarElement.notifyBeforeScroll();\n  }\n  if (options.stop) {\n    $scrollable.stop('scroll');\n  }\n\n  // Not animated\n  if (!options.animate) {\n    $scrollable.scrollTop(scrollTop);\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n    return;\n  }\n\n  // Animated\n  animateScrollTop($scrollable, scrollTop);\n  $scrollable.promise('scroll').always(() => {\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n  });\n}\n\n/**\n * @param {$} $scrollable the scrollable object\n * @param {number} scrollLeft the new scroll position\n * @param {object} [options]\n * @param {boolean} [options.animate] whether the scrolling should be animated. Default is false.\n * @param {boolean} [options.stop] whether the animation should be stopped. Default is false.\n */\nexport function scrollLeft($scrollable, scrollLeft, options) {\n  options = _createDefaultScrollToOptions(options);\n  let scrollbarElement = scrollbar($scrollable, 'x');\n  if (scrollbarElement) {\n    scrollbarElement.notifyBeforeScroll();\n  }\n  if (options.stop) {\n    $scrollable.stop('scroll');\n  }\n\n  // Not animated\n  if (!options.animate) {\n    $scrollable.scrollLeft(scrollLeft);\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n    return;\n  }\n\n  // Animated\n  animateScrollLeft($scrollable, scrollLeft);\n  $scrollable.promise('scroll').always(() => {\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n  });\n}\nfunction animateScrollTop($scrollable, scrollTop) {\n  $scrollable.animate({\n    scrollTop: scrollTop\n  }, {\n    queue: 'scroll'\n  }).dequeue('scroll');\n}\nfunction animateScrollLeft($scrollable, scrollLeft) {\n  $scrollable.animate({\n    scrollLeft: scrollLeft\n  }, {\n    queue: 'scroll'\n  }).dequeue('scroll');\n}\nexport function scrollbar($scrollable, axis) {\n  let scrollbars = $scrollable.data('scrollbars') || [];\n  return arrays.find(scrollbars, scrollbar => {\n    return scrollbar.axis === axis;\n  });\n}\nexport function scrollToBottom($scrollable, options) {\n  scrollTop($scrollable, $scrollable[0].scrollHeight - $scrollable[0].offsetHeight, options);\n}\n\n/**\n * @param location object with x and y properties\n * @param $scrollables one or more scrollables to check against\n * @returns {boolean} true if the location is visible in the current viewport of all the $scrollables, or if $scrollables is null\n */\nexport function isLocationInView(location, $scrollables) {\n  if (!$scrollables || $scrollables.length === 0) {\n    return true;\n  }\n  return $scrollables.toArray().every(scrollable => {\n    let scrollableOffsetBounds = graphics.offsetBounds($(scrollable));\n    return scrollableOffsetBounds.contains(location.x, location.y);\n  });\n}\n\n/**\n * Attaches the given handler to each scrollable parent, including $anchor if it is scrollable as well.<p>\n * Make sure you remove the handlers when not needed anymore using offScroll.\n */\nexport function onScroll($anchor, handler) {\n  handler.$scrollParents = [];\n  $anchor.scrollParents().each(function () {\n    let $scrollParent = $(this);\n    $scrollParent.on('scroll', handler);\n    handler.$scrollParents.push($scrollParent);\n  });\n}\nexport function offScroll(handler) {\n  let $scrollParents = handler.$scrollParents;\n  if (!$scrollParents) {\n    throw new Error('$scrollParents are not defined');\n  }\n  for (let i = 0; i < $scrollParents.length; i++) {\n    let $elem = $scrollParents[i];\n    $elem.off('scroll', handler);\n  }\n}\n\n/**\n * Sets the position to fixed and updates left and top position.\n * This is necessary to prevent flickering in IE.\n */\nexport function fix($elem) {\n  if (!$elem.isVisible() || $elem.css('position') === 'fixed') {\n    return;\n  }\n\n  // getBoundingClientRect used by purpose instead of graphics.offsetBounds to get exact values\n  // Also important: offset() of jquery returns getBoundingClientRect().top + window.pageYOffset.\n  // In case of IE and zoom = 125%, the pageYOffset is 1 because the height of the navigation is bigger than the height of the desktop which may be fractional.\n  let bounds = $elem[0].getBoundingClientRect();\n  $elem.css('position', 'fixed').cssLeft(bounds.left - $elem.cssMarginLeft()).cssTop(bounds.top - $elem.cssMarginTop()).cssWidth(bounds.width).cssHeight(bounds.height);\n}\n\n/**\n * Reverts the changes made by fix().\n */\nexport function unfix($elem, timeoutId, immediate) {\n  clearTimeout(timeoutId);\n  if (immediate) {\n    _unfix($elem);\n    return;\n  }\n  return setTimeout(() => {\n    _unfix($elem);\n  }, 50);\n}\nexport function _unfix($elem) {\n  $elem.css({\n    position: 'absolute',\n    left: '',\n    top: '',\n    width: '',\n    height: ''\n  });\n}\n\n/**\n * Stores the position of all scrollables that belong to an optional session.\n * @param session (optional) when no session is given, scrollables from all sessions are stored\n */\nexport function storeScrollPositions($container, session) {\n  let $scrollables = getScrollables(session);\n  if (!$scrollables) {\n    return;\n  }\n  let scrollTop, scrollLeft;\n  $scrollables.forEach($scrollable => {\n    if ($container.isOrHas($scrollable[0])) {\n      scrollTop = $scrollable.scrollTop();\n      $scrollable.data('scrollTop', scrollTop);\n      scrollLeft = $scrollable.scrollLeft();\n      $scrollable.data('scrollLeft', $scrollable.scrollLeft());\n      $.log.isTraceEnabled() && $.log.trace('Stored scroll position for ' + $scrollable.attr('class') + '. Top: ' + scrollTop + '. Left: ' + scrollLeft);\n    }\n  });\n}\n\n/**\n * Restores the position of all scrollables that belong to an optional session.\n * @param session (optional) when no session is given, scrollables from all sessions are restored\n */\nexport function restoreScrollPositions($container, session) {\n  let $scrollables = getScrollables(session);\n  if (!$scrollables) {\n    return;\n  }\n  let scrollTop, scrollLeft;\n  $scrollables.forEach($scrollable => {\n    if ($container.isOrHas($scrollable[0])) {\n      scrollTop = $scrollable.data('scrollTop');\n      if (scrollTop) {\n        $scrollable.scrollTop(scrollTop);\n        $scrollable.removeData('scrollTop');\n      }\n      scrollLeft = $scrollable.data('scrollLeft');\n      if (scrollLeft) {\n        $scrollable.scrollLeft(scrollLeft);\n        $scrollable.removeData('scrollLeft');\n      }\n      // Also make sure that scroll bar is up to date\n      // Introduced for use case: Open large table page, edit entry, press f5\n      // -> outline tab gets rendered, scrollbar gets updated with set timeout, outline tab gets detached\n      // -> update event never had any effect because it executed after detaching (due to set timeout)\n      update($scrollable);\n      $.log.isTraceEnabled() && $.log.trace('Restored scroll position for ' + $scrollable.attr('class') + '. Top: ' + scrollTop + '. Left: ' + scrollLeft);\n    }\n  });\n}\nexport function setVisible($scrollable, visible) {\n  if (!$scrollable || !$scrollable.data('scrollable')) {\n    return;\n  }\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    return;\n  }\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.$container.setVisible(visible);\n    }\n  });\n}\nexport function opacity($scrollable, opacity) {\n  if (!$scrollable || !$scrollable.data('scrollable')) {\n    return;\n  }\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    return;\n  }\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.$container.css('opacity', opacity);\n    }\n  });\n}\nexport function _getCompleteChildRowsHeightRecursive(children, getChildren, isExpanded, defaultChildHeight) {\n  let height = 0;\n  children.forEach(child => {\n    if (child.height) {\n      height += child.height;\n    } else {\n      // fallback for children with unset height\n      height += defaultChildHeight;\n    }\n    if (isExpanded(child) && getChildren(child).length > 0) {\n      height += _getCompleteChildRowsHeightRecursive(getChildren(child), getChildren, isExpanded, defaultChildHeight);\n    }\n  });\n  return height;\n}\nexport function ensureExpansionVisible(parent) {\n  let isParentExpanded = parent.isExpanded(parent.element);\n  let children = parent.getChildren(parent.element);\n  let parentPositionTop = parent.$element.position().top;\n  let parentHeight = parent.element.height;\n  let scrollTopPos = parent.$scrollable.scrollTop();\n\n  // vertical scrolling\n  if (!isParentExpanded) {\n    // parent is not expanded, make sure that at least one node above the parent is visible\n    if (parentPositionTop < parentHeight) {\n      let minScrollTop = Math.max(scrollTopPos - (parentHeight - parentPositionTop), 0);\n      scrollTop(parent.$scrollable, minScrollTop, {\n        animate: true\n      });\n    }\n  } else if (isParentExpanded && children.length > 0) {\n    // parent is expanded and has children, best effort approach to show the expansion\n    let fullDataHeight = parent.$scrollable.height();\n\n    // get childRowCount considering already expanded rows\n    let childRowsHeight = _getCompleteChildRowsHeightRecursive(children, parent.getChildren, parent.isExpanded, parent.defaultChildHeight);\n\n    // + 1.5 since its the parent's top position and we want to scroll half a row further to show that there's something after the expansion\n    let additionalHeight = childRowsHeight + 1.5 * parentHeight;\n    let scrollTo = parentPositionTop + additionalHeight;\n    // scroll as much as needed to show the expansion but make sure that the parent row (plus one more) is still visible\n    let newScrollTop = scrollTopPos + Math.min(scrollTo - fullDataHeight, parentPositionTop - parentHeight);\n    // only scroll down\n    if (newScrollTop > scrollTopPos) {\n      scrollTop(parent.$scrollable, newScrollTop, {\n        animate: true,\n        stop: false\n      });\n    }\n  }\n  if (children.length > 0) {\n    // horizontal scrolling: at least 3 levels of hierarchy should be visible (only relevant for small fields)\n    let minLevelLeft = Math.max(parent.element.level - 3, 0) * parent.nodePaddingLevel;\n    scrollLeft(parent.$scrollable, minLevelLeft, {\n      animate: true,\n      stop: false\n    });\n  }\n}\nexport default {\n  ensureExpansionVisible,\n  fix,\n  getScrollables,\n  install,\n  installScrollShadow,\n  isHybridScrolling,\n  isJsScrolling,\n  isLocationInView,\n  isNativeScrolling,\n  hasScrollShadow,\n  offScroll,\n  onScroll,\n  opacity,\n  pushScrollable,\n  removeScrollable,\n  reset,\n  restoreScrollPositions,\n  scrollHorizontalTo,\n  scrollLeft,\n  scrollTo,\n  scrollToBottom,\n  scrollTop,\n  scrollbar,\n  setVisible,\n  storeScrollPositions,\n  unfix,\n  uninstall,\n  uninstallScrollShadow,\n  update\n};","map":{"version":3,"names":["arrays","Device","graphics","HtmlComponent","Insets","objects","scout","$","_$scrollables","mutationObserver","intersectionObserver","getScrollables","session","$scrollables","values","forEach","$scrollablesPerSession","pushAll","pushScrollable","$container","indexOf","push","log","isTraceEnabled","trace","attr","length","removeScrollable","initLength","$remove","Error","install","options","_createDefaultScrollToOptions","axis","scrollShadow","nativeScrollbars","nvl","get","hasPrettyScrollbars","hybridScrollbars","canHideScrollbars","_installNative","addClass","_installJs","css","htmlContainer","optGet","scrollable","data","parent","installScrollShadow","isIos","setTimeout","_installNativeInternal","bind","debugOutput","supportsIntersectionObserver","scrollShadowStyle","_computeScrollShadowStyle","$shadow","afterDiv","toggleClass","scrollShadowCustomizer","handler","updateScrollShadowWhileScrolling","on","updateScrollShadow","_installMutationObserver","_installIntersectionObserver","observe","containerElement","visibleListener","e","target","_onScrollableVisibleChange","type","uninstallScrollShadow","remove","removeData","off","unobserve","some","$scrollable","_uninstallMutationObserver","_uninstallIntersectionObserver","split","slice","containsAny","removeAll","$animatingParent","findUp","$elem","hasAnimationClass","oneAnimationEnd","scrollTop","scrollLeft","atTop","atStart","atBottom","atEnd","scrollHeight","offsetHeight","atLeft","atRight","scrollWidth","offsetWidth","style","setBounds","bounds","exact","subtract","insets","setMargins","margins","customizer","scrollPos","scrollSize","offsetSize","cssPxValue","MutationObserver","_onDomMutation","$entryPoint","subtree","childList","mutationList","observer","_processDomMutation","mutation","i","addedNodes","elem","$scrollShadow","insertAfter","disconnect","IntersectionObserver","entries","entry","intersectionRatio","element","visible","$element","setVisible","isVisible","hasScrollShadow","position","hasClass","isHybridScrolling","isNativeScrolling","isOneOf","isJsScrolling","scrollbars","ensure","scrollbar","destroy","scrollOptions","extend","create","mouseWheelNeedsShift","render","update","uninstall","removeClass","immediate","_handleIosPaintBug","_update","rendered","reset","workaround","size","includePadding","includeBorder","height","width","scrollTo","align","toLowerCase","undefined","scrollOffsetUp","scrollOffsetDown","scrollableH","elementBounds","offsetBounds","scrollableBounds","elementY","y","elementH","elementTop","elementBottom","Math","max","ceil","elementTopNew","defaults","animate","stop","scrollHorizontalTo","scrollableW","elementLeft","x","elementW","scrollbarElement","notifyBeforeScroll","notifyAfterScroll","animateScrollTop","promise","always","animateScrollLeft","queue","dequeue","find","scrollToBottom","isLocationInView","location","toArray","every","scrollableOffsetBounds","contains","onScroll","$anchor","$scrollParents","scrollParents","each","$scrollParent","offScroll","fix","getBoundingClientRect","cssLeft","left","cssMarginLeft","cssTop","top","cssMarginTop","cssWidth","cssHeight","unfix","timeoutId","clearTimeout","_unfix","storeScrollPositions","isOrHas","restoreScrollPositions","opacity","_getCompleteChildRowsHeightRecursive","children","getChildren","isExpanded","defaultChildHeight","child","ensureExpansionVisible","isParentExpanded","parentPositionTop","parentHeight","scrollTopPos","minScrollTop","fullDataHeight","childRowsHeight","additionalHeight","newScrollTop","min","minLevelLeft","level","nodePaddingLevel"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/scrollbar/scrollbars.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, graphics, HtmlComponent, Insets, objects, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * Static function to install a scrollbar on a container.\n * When the client supports pretty native scrollbars, we use them by default.\n * Otherwise we install JS-based scrollbars. In that case the install function\n * creates a new scrollbar.js. For native scrollbars we\n * must set some additional CSS styles.\n */\n\nlet _$scrollables = {};\nlet mutationObserver;\nlet intersectionObserver;\n\nexport function getScrollables(session) {\n  // return scrollables for given session\n  if (session) {\n    return _$scrollables[session] || [];\n  }\n\n  // return all scrollables, no matter to which session they belong\n  let $scrollables = [];\n  objects.values(_$scrollables).forEach($scrollablesPerSession => {\n    arrays.pushAll($scrollables, $scrollablesPerSession);\n  });\n  return $scrollables;\n}\n\nexport function pushScrollable(session, $container) {\n  if (_$scrollables[session]) {\n    if (_$scrollables[session].indexOf($container) > -1) {\n      // already pushed\n      return;\n    }\n    _$scrollables[session].push($container);\n  } else {\n    _$scrollables[session] = [$container];\n  }\n  $.log.isTraceEnabled() && $.log.trace('Scrollable added: ' + $container.attr('class') + '. New length: ' + _$scrollables[session].length);\n}\n\nexport function removeScrollable(session, $container) {\n  let initLength = 0;\n  if (_$scrollables[session]) {\n    initLength = _$scrollables[session].length;\n    arrays.$remove(_$scrollables[session], $container);\n    $.log.isTraceEnabled() && $.log.trace('Scrollable removed: ' + $container.attr('class') + '. New length: ' + _$scrollables[session].length);\n    if (initLength === _$scrollables[session].length) {\n      throw new Error('scrollable could not be removed. Potential memory leak. ' + $container.attr('class'));\n    }\n  } else {\n    throw new Error('scrollable could not be removed. Potential memory leak. ' + $container.attr('class'));\n  }\n}\n\n/**\n * @param [options]\n * @param {string} [options.axis] x, y or both. Default is both.\n * @param {boolean} [options.nativeScrollbars]\n * @param {boolean} [options.hybridScrollbars]\n * @param {string|[string]} [options.scrollShadow] controls the scroll shadow behavior.\n *        <ul>\n *          <li>To define where the shadow should appear, use one of the following values: x, y, top, right, bottom, left. Multiple values can be separated by space.\n *          <li>If no positioning value is provided, it is automatically determined based on the axis.</li>\n *          <li>To adjust the style, add one of the following values: large or gradient.</li>\n *          <li>To disable the scroll shadow completely, set the value to none.</li>\n *        </ul>\n * @param {function} [options.scrollShadowCustomizer] function to customize the scroll shadow\n * @param {Session} [options.session]\n * @param {Widget} [options.parent]\n */\nexport function install($container, options) {\n  options = _createDefaultScrollToOptions(options);\n  options.axis = options.axis || 'both';\n  options.scrollShadow = options.scrollShadow || 'auto';\n\n  // Don't use native as variable name because it will break minifying (reserved keyword)\n  let nativeScrollbars = scout.nvl(options.nativeScrollbars, Device.get().hasPrettyScrollbars());\n  let hybridScrollbars = scout.nvl(options.hybridScrollbars, Device.get().canHideScrollbars());\n  if (nativeScrollbars) {\n    _installNative($container, options);\n  } else if (hybridScrollbars) {\n    $container.addClass('hybrid-scrollable');\n    _installNative($container, options);\n    _installJs($container, options);\n  } else {\n    $container.css('overflow', 'hidden');\n    _installJs($container, options);\n  }\n  let htmlContainer = HtmlComponent.optGet($container);\n  if (htmlContainer) {\n    htmlContainer.scrollable = true;\n  }\n  $container.data('scrollable', true);\n  let session = options.session || options.parent.session;\n  pushScrollable(session, $container);\n  if (options.scrollShadow) {\n    installScrollShadow($container, session, options);\n  }\n  return $container;\n}\n\nexport function _installNative($container, options) {\n  if (Device.get().isIos()) {\n    // On ios, container sometimes is not scrollable when installing too early\n    // Happens often with nested scrollable containers (e.g. scrollable table inside a form inside a scrollable tree data)\n    setTimeout(_installNativeInternal.bind(this, $container, options));\n  } else {\n    _installNativeInternal($container, options);\n  }\n}\n\nexport function _installNativeInternal($container, options) {\n  $.log.isTraceEnabled() && $.log.trace('use native scrollbars for container ' + graphics.debugOutput($container));\n  if (options.axis === 'x') {\n    $container\n      .css('overflow-x', 'auto')\n      .css('overflow-y', 'hidden');\n  } else if (options.axis === 'y') {\n    $container\n      .css('overflow-x', 'hidden')\n      .css('overflow-y', 'auto');\n  } else {\n    $container.css('overflow', 'auto');\n  }\n  $container.css('-webkit-overflow-scrolling', 'touch');\n}\n\nexport function installScrollShadow($container, session, options) {\n  if (!Device.get().supportsIntersectionObserver()) {\n    return;\n  }\n  let scrollShadowStyle = _computeScrollShadowStyle(options);\n  if (scrollShadowStyle.length === 0) {\n    return;\n  }\n  let $shadow = $container.afterDiv('scroll-shadow');\n  $shadow.toggleClass('large', scrollShadowStyle.indexOf('large') > -1);\n  $shadow.toggleClass('gradient', scrollShadowStyle.indexOf('gradient') > -1);\n  $shadow.data('scroll-shadow-parent', $container);\n  $container.data('scroll-shadow', $shadow);\n  $container.data('scroll-shadow-style', scrollShadowStyle);\n  $container.data('scroll-shadow-customizer', options.scrollShadowCustomizer);\n  let handler = () => updateScrollShadowWhileScrolling($container);\n  $container.data('scroll-shadow-handler', handler);\n  $container.on('scroll', handler);\n  updateScrollShadow($container);\n  _installMutationObserver(session);\n  _installIntersectionObserver();\n  intersectionObserver.observe($container[0]);\n\n  // this is required in addition to the intersection observer because the observer events are handled asynchronously later after all the setTimeout calls.\n  // Then the shadow might stay visible too long which has an impact on layout updates.\n  let containerElement = $container[0];\n  let visibleListener = e => {\n    if (e.target === containerElement) {\n      _onScrollableVisibleChange(containerElement, e.type === 'show');\n    }\n  };\n  $container.data('scroll-shadow-visible-listener', visibleListener);\n  $container.on('hide show', visibleListener);\n}\n\nexport function uninstallScrollShadow($container, session) {\n  let $shadow = $container.data('scroll-shadow');\n  if ($shadow) {\n    $shadow.remove();\n    $container.removeData('scroll-shadow');\n  }\n  $container.removeData('scroll-shadow-style');\n  $container.removeData('scroll-shadow-customizer');\n  let handler = $container.data('scroll-shadow-handler');\n  if (handler) {\n    $container.off('scroll', handler);\n    $container.removeData('scroll-shadow-handler');\n  }\n  if (intersectionObserver) {\n    intersectionObserver.unobserve($container[0]);\n  }\n  let visibleListener = $container.data('scroll-shadow-visible-listener');\n  if (visibleListener) {\n    $container.off('hide show', visibleListener);\n  }\n  let $scrollables = _$scrollables[session];\n  if (!$scrollables || !$scrollables.some($scrollable => $scrollable.data('scroll-shadow'))) {\n    _uninstallMutationObserver();\n    _uninstallIntersectionObserver();\n  }\n}\n\n/**\n * @param options\n * @return {[string]}\n */\nfunction _computeScrollShadowStyle(options) {\n  let scrollShadow = options.scrollShadow;\n  if (!scrollShadow) {\n    return [];\n  }\n  if (typeof scrollShadow === 'string') {\n    scrollShadow = scrollShadow.split(' ');\n  }\n  scrollShadow = scrollShadow.slice(); // copy to don't modify parameter\n  if (scrollShadow.indexOf('none') > -1) {\n    return [];\n  }\n  if (!arrays.containsAny(scrollShadow, ['y', 'x', 'top', 'right', 'bottom', 'left'])) {\n    // If no position was set, determine it automatically based on the axis\n    if (options.axis === 'both' || options.axis === 'y') {\n      scrollShadow.push('y');\n    }\n    if (options.axis === 'both' || options.axis === 'x') {\n      scrollShadow.push('x');\n    }\n  }\n  if (scrollShadow.indexOf('y') > -1) {\n    scrollShadow.push('top');\n    scrollShadow.push('bottom');\n  }\n  if (scrollShadow.indexOf('x') > -1) {\n    scrollShadow.push('left');\n    scrollShadow.push('right');\n  }\n  arrays.removeAll(scrollShadow, ['all', 'y', 'x', 'auto', 'none']);\n  return scrollShadow;\n}\n\nexport function updateScrollShadowWhileScrolling($container) {\n  let $animatingParent = $container.findUp($elem => $elem.hasAnimationClass());\n  if ($animatingParent.length > 0) {\n    // If the container is scrolled while being animated, the shadow will likely get the wrong size and/or position if the animation changes the bounds.\n    // The scroll event is mostly probably not triggered by the user directly but by the scrollable container itself, e.g. to reveal a focused / selected / checked element.\n    $animatingParent.oneAnimationEnd(() => updateScrollShadow($container));\n    return;\n  }\n  updateScrollShadow($container);\n}\n\nexport function updateScrollShadow($container) {\n  let $shadow = $container.data('scroll-shadow');\n  if (!$shadow) {\n    return;\n  }\n  let scrollTop = $container[0].scrollTop;\n  let scrollLeft = $container[0].scrollLeft;\n  let atTop = atStart(scrollTop);\n  let atBottom = atEnd(scrollTop, $container[0].scrollHeight, $container[0].offsetHeight);\n  let atLeft = atStart(scrollLeft);\n  let atRight = atEnd(scrollLeft, $container[0].scrollWidth, $container[0].offsetWidth);\n  let style = $container.data('scroll-shadow-style');\n  $shadow.toggleClass('top', !atTop && style.indexOf('top') > -1);\n  $shadow.toggleClass('bottom', !atBottom && style.indexOf('bottom') > -1);\n  $shadow.toggleClass('left', !atLeft && style.indexOf('left') > -1);\n  $shadow.toggleClass('right', !atRight && style.indexOf('right') > -1);\n  graphics.setBounds($shadow, graphics.bounds($container, {exact: true}).subtract(insets($shadow)));\n  graphics.setMargins($shadow, graphics.margins($container));\n  $shadow.css('border-radius', $container.css('border-radius'));\n\n  let customizer = $container.data('scroll-shadow-customizer');\n  if (customizer) {\n    customizer($container, $shadow);\n  }\n\n  function atStart(scrollPos) {\n    return scrollPos === 0;\n  }\n\n  function atEnd(scrollPos, scrollSize, offsetSize) {\n    return scrollPos + 1 >= scrollSize - offsetSize;\n  }\n\n  function insets($shadow) {\n    return new Insets($shadow.cssPxValue('--scroll-shadow-inset-top'),\n      $shadow.cssPxValue('--scroll-shadow-inset-right'),\n      $shadow.cssPxValue('--scroll-shadow-inset-bottom'),\n      $shadow.cssPxValue('--scroll-shadow-inset-left'));\n  }\n}\n\n/**\n * Installs a dom mutation observer that tracks all scrollables in order to move the scroll shadow along with the scrollable.\n */\nfunction _installMutationObserver(session) {\n  if (mutationObserver) {\n    return;\n  }\n  mutationObserver = new MutationObserver(_onDomMutation);\n  mutationObserver.observe(session.$entryPoint[0], {\n    subtree: true,\n    childList: true\n  });\n}\n\nfunction _onDomMutation(mutationList, observer) {\n  mutationList.forEach(_processDomMutation);\n}\n\nexport function _processDomMutation(mutation) {\n  // addedNodes if of type NodeList and therefore does not support array functions\n  for (let i = 0; i < mutation.addedNodes.length; i++) {\n    let elem = mutation.addedNodes[i];\n    let $elem = $(elem);\n    if ($elem.data('scrollable')) {\n      // Move scroll shadow after scrollable when scrollable was moved (=inserted again)\n      let $scrollShadow = $elem.data('scroll-shadow');\n      if ($scrollShadow) {\n        $scrollShadow.insertAfter($elem);\n      }\n    }\n  }\n}\n\nfunction _uninstallMutationObserver() {\n  if (!mutationObserver) {\n    return;\n  }\n  mutationObserver.disconnect();\n  mutationObserver = null;\n}\n\n/**\n * Installs an intersection observer that tracks the visibility of a scrollable in order to update the visibility of the scroll shadow accordingly.\n */\nfunction _installIntersectionObserver() {\n  if (intersectionObserver) {\n    return;\n  }\n  intersectionObserver = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      _onScrollableVisibleChange(entry.target, entry.intersectionRatio > 0);\n    });\n  });\n}\n\nfunction _uninstallIntersectionObserver() {\n  if (!intersectionObserver) {\n    return;\n  }\n  intersectionObserver.disconnect();\n  intersectionObserver = null;\n}\n\nexport function _onScrollableVisibleChange(element, visible) {\n  let $element = $(element);\n  let $shadow = $element.data('scroll-shadow');\n  if (!$shadow) {\n    return;\n  }\n  $shadow.setVisible($element.isVisible());\n}\n\nexport function hasScrollShadow($container, position) {\n  if (!$container) {\n    return false;\n  }\n  let $scrollShadow = $container.data('scroll-shadow');\n  if (!$scrollShadow) {\n    return false;\n  }\n  if (!position) {\n    return true;\n  }\n  return $scrollShadow.hasClass(position);\n}\n\nexport function isHybridScrolling($scrollable) {\n  return $scrollable.hasClass('hybrid-scrollable');\n}\n\nexport function isNativeScrolling($scrollable) {\n  return scout.isOneOf('auto', $scrollable.css('overflow'), $scrollable.css('overflow-x'), $scrollable.css('overflow-y'));\n}\n\nexport function isJsScrolling($scrollable) {\n  return !!$scrollable.data('scrollbars');\n}\n\nexport function _installJs($container, options) {\n  $.log.isTraceEnabled() && $.log.trace('installing JS-scrollbars for container ' + graphics.debugOutput($container));\n  let scrollbars = arrays.ensure($container.data('scrollbars'));\n  scrollbars.forEach(scrollbar => {\n    scrollbar.destroy();\n  });\n  scrollbars = [];\n  let scrollbar;\n  if (options.axis === 'both') {\n    let scrollOptions = $.extend({}, options);\n    scrollOptions.axis = 'y';\n    scrollbar = scout.create('Scrollbar', $.extend({}, scrollOptions));\n    scrollbars.push(scrollbar);\n\n    scrollOptions.axis = 'x';\n    scrollOptions.mouseWheelNeedsShift = true;\n    scrollbar = scout.create('Scrollbar', $.extend({}, scrollOptions));\n    scrollbars.push(scrollbar);\n  } else {\n    scrollbar = scout.create('Scrollbar', $.extend({}, options));\n    scrollbars.push(scrollbar);\n  }\n  $container.data('scrollbars', scrollbars);\n\n  scrollbars.forEach(scrollbar => {\n    scrollbar.render($container);\n    scrollbar.update();\n  });\n}\n\n/**\n * Removes the js scrollbars for the $container, if there are any.<p>\n */\nexport function uninstall($container, session) {\n  if (!$container.data('scrollable')) {\n    // was not installed previously -> uninstalling not necessary\n    return;\n  }\n\n  let scrollbars = $container.data('scrollbars');\n  if (scrollbars) {\n    scrollbars.forEach(scrollbar => {\n      scrollbar.destroy();\n    });\n  }\n  removeScrollable(session, $container);\n  $container.removeData('scrollable');\n  $container.css('overflow', '');\n  $container.removeClass('hybrid-scrollable');\n  $container.removeData('scrollbars');\n\n  let htmlContainer = HtmlComponent.optGet($container);\n  if (htmlContainer) {\n    htmlContainer.scrollable = false;\n  }\n  uninstallScrollShadow($container, session);\n}\n\n/**\n * Recalculates the scrollbar size and position.\n * @param $scrollable JQuery element that has .data('scrollbars'), when $scrollable is falsy the function returns immediately\n * @param immediate set to true to immediately update the scrollbar, If set to false,\n *        it will be queued in order to prevent unnecessary updates.\n */\nexport function update($scrollable, immediate) {\n  if (!$scrollable || !$scrollable.data('scrollable')) {\n    return;\n  }\n  updateScrollShadow($scrollable);\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    if (Device.get().isIos()) {\n      _handleIosPaintBug($scrollable);\n    }\n    return;\n  }\n  if (immediate) {\n    _update(scrollbars);\n    return;\n  }\n  if ($scrollable.data('scrollbarUpdatePending')) {\n    return;\n  }\n  // Executes the update later to prevent unnecessary updates\n  setTimeout(() => {\n    _update(scrollbars);\n    $scrollable.removeData('scrollbarUpdatePending');\n  }, 0);\n  $scrollable.data('scrollbarUpdatePending', true);\n}\n\nexport function _update(scrollbars) {\n  // Reset the scrollbars first to make sure they don't extend the scrollSize\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.reset();\n    }\n  });\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.update();\n    }\n  });\n}\n\n/**\n * IOS has problems with nested scrollable containers. Sometimes the outer container goes completely white hiding the elements behind.\n * This happens with the following case: Main box is scrollable but there are no scrollbars because content is smaller than container.\n * In the main box there is a tab box with a scrollable table. This table has scrollbars.\n * If the width of the tab box is adjusted (which may happen if the tab item is selected and eventually prefSize called), the main box will go white.\n * <p>\n * This happens only if -webkit-overflow-scrolling is set to touch.\n * To workaround this bug the flag -webkit-overflow-scrolling will be removed if the scrollable component won't display any scrollbars\n */\n\nexport function _handleIosPaintBug($scrollable) {\n  if ($scrollable.data('scrollbarUpdatePending')) {\n    return;\n  }\n  setTimeout(() => {\n    workaround();\n    $scrollable.removeData('scrollbarUpdatePending');\n  });\n  $scrollable.data('scrollbarUpdatePending', true);\n\n  function workaround() {\n    let size = graphics.size($scrollable).subtract(graphics.insets($scrollable, {\n      includePadding: false,\n      includeBorder: true\n    }));\n    if ($scrollable[0].scrollHeight === size.height && $scrollable[0].scrollWidth === size.width) {\n      $scrollable.css('-webkit-overflow-scrolling', '');\n    } else {\n      $scrollable.css('-webkit-overflow-scrolling', 'touch');\n    }\n  }\n}\n\nexport function reset($scrollable) {\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    return;\n  }\n  scrollbars.forEach(scrollbar => {\n    scrollbar.reset();\n  });\n}\n\n/**\n * Scrolls the $scrollable to the given $element (must be a child of $scrollable)\n *\n * @param {$} $scrollable\n *          the scrollable object\n * @param {$} $element\n *          the element to scroll to\n * @param {object|string} [options]\n *          an optional options object. Short-hand version: If a string is passed instead\n *          of an object, the value is automatically converted to the option \"align\".\n * @param {string} [options.align]\n *          Specifies where the element should be positioned in the view port. Can either be 'top', 'center' or 'bottom'.\n *          If unspecified, the following rules apply:\n *          - If the element is above the visible area it will be aligned to top.\n *          - If the element is below the visible area it will be aligned to bottom.\n *          - If the element is already in the visible area no scrolling is done.\n *          Default is undefined.\n * @param {boolean} [options.animate]\n *          If true, the scroll position will be animated so that the element moves smoothly to its new position. Default is false.\n * @param {boolean} [options.stop]\n *          If true, all running animations are stopped before executing the current scroll request. Default is true.\n * @param {number} [options.scrollOffsetUp]\n *          Additional margin to assume at the top of the target element (independent from any actual CSS margin).\n *          Useful when elements are positioned outside of their boundaries (e.g. focus border). Default is 4.\n * @param {number} [options.scrollOffsetDown]\n *          Additional margin to assume at the bottom of the target element (independent from any actual CSS margin).\n *          Useful when elements are positioned outside of their boundaries (e.g. focus border). Default is 8.\n */\nexport function scrollTo($scrollable, $element, options) {\n  if (typeof options === 'string') {\n    options = {\n      align: options\n    };\n  } else {\n    options = _createDefaultScrollToOptions(options);\n  }\n\n  let align = (options.align ? options.align.toLowerCase() : undefined);\n\n  let scrollTo,\n    scrollOffsetUp = scout.nvl(options.scrollOffsetUp, align === 'center' ? 0 : 4),\n    scrollOffsetDown = scout.nvl(options.scrollOffsetDown, align === 'center' ? 0 : 8),\n    scrollableH = $scrollable.height(),\n    elementBounds = graphics.offsetBounds($element),\n    scrollableBounds = graphics.offsetBounds($scrollable),\n    elementY = elementBounds.y - scrollableBounds.y,\n    elementH = elementBounds.height,\n    elementTop = elementY - scrollOffsetUp, // relative to scrollable y\n    elementBottom = elementY + elementH + scrollOffsetDown;\n\n  //        ---          ^                     <-- elementTop\n  //         |           | scrollOffsetUp\n  //         |           v\n  //   +------------+    ^                     <-- elementY\n  //   |  element   |    | elementH\n  //   +------------+    v\n  //         |           ^\n  //         |           | scrollOffsetDown\n  //        ---          v                     <-- elementBottom\n\n  if (!align) {\n    // If the element is above the visible area it will be aligned to top.\n    // If the element is below the visible area it will be aligned to bottom.\n    // If the element is already in the visible area no scrolling is done.\n    align = (elementTop < 0) ? 'top' : (elementBottom > scrollableH ? 'bottom' : undefined);\n  }\n\n  if (align === 'center') {\n    // align center\n    scrollTo = $scrollable.scrollTop() + elementTop - Math.max(0, (scrollableH - elementH) / 2);\n\n  } else if (align === 'top') {\n    // align top\n    // Element is on the top of the view port -> scroll up\n    scrollTo = $scrollable.scrollTop() + elementTop;\n\n  } else if (align === 'bottom') {\n    // align bottom\n    // Element is on the Bottom of the view port -> scroll down\n    // On IE, a fractional position gets truncated when using scrollTop -> ceil to make sure the full element is visible\n    scrollTo = Math.ceil($scrollable.scrollTop() + elementBottom - scrollableH);\n\n    // If the viewport is very small, make sure the element is not moved outside on top\n    // Otherwise when calling this function again, since the element is on the top of the view port, the scroll pane would scroll down which results in flickering\n    let elementTopNew = elementTop - (scrollTo - $scrollable.scrollTop());\n    if (elementTopNew < 0) {\n      scrollTo = scrollTo + elementTopNew;\n    }\n  }\n  if (scrollTo !== undefined) {\n    scrollTop($scrollable, scrollTo, options);\n  }\n}\n\nexport function _createDefaultScrollToOptions(options) {\n  let defaults = {\n    animate: false,\n    stop: true\n  };\n  return $.extend({}, defaults, options);\n}\n\n/**\n * Horizontally scrolls the $scrollable to the given $element (must be a child of $scrollable)\n */\nexport function scrollHorizontalTo($scrollable, $element, options) {\n  let scrollTo,\n    scrollableW = $scrollable.width(),\n    elementBounds = graphics.bounds($element, true),\n    elementLeft = elementBounds.x,\n    elementW = elementBounds.width;\n\n  if (elementLeft < 0) {\n    scrollLeft($scrollable, $scrollable.scrollLeft() + elementLeft, options);\n  } else if (elementLeft + elementW > scrollableW) {\n    // On IE, a fractional position gets truncated when using scrollTop -> ceil to make sure the full element is visible\n    scrollTo = Math.ceil($scrollable.scrollLeft() + elementLeft + elementW - scrollableW);\n    scrollLeft($scrollable, scrollTo, options);\n  }\n}\n\n/**\n * @param {$} $scrollable the scrollable object\n * @param {number} scrollTop the new scroll position\n * @param {object} [options]\n * @param {boolean} [options.animate] whether the scrolling should be animated. Default is false.\n * @param {boolean} [options.stop] whether the animation should be stopped. Default is false.\n */\nexport function scrollTop($scrollable, scrollTop, options) {\n  options = _createDefaultScrollToOptions(options);\n  let scrollbarElement = scrollbar($scrollable, 'y');\n  if (scrollbarElement) {\n    scrollbarElement.notifyBeforeScroll();\n  }\n\n  if (options.stop) {\n    $scrollable.stop('scroll');\n  }\n\n  // Not animated\n  if (!options.animate) {\n    $scrollable.scrollTop(scrollTop);\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n    return;\n  }\n\n  // Animated\n  animateScrollTop($scrollable, scrollTop);\n  $scrollable.promise('scroll').always(() => {\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n  });\n}\n\n/**\n * @param {$} $scrollable the scrollable object\n * @param {number} scrollLeft the new scroll position\n * @param {object} [options]\n * @param {boolean} [options.animate] whether the scrolling should be animated. Default is false.\n * @param {boolean} [options.stop] whether the animation should be stopped. Default is false.\n */\nexport function scrollLeft($scrollable, scrollLeft, options) {\n  options = _createDefaultScrollToOptions(options);\n  let scrollbarElement = scrollbar($scrollable, 'x');\n  if (scrollbarElement) {\n    scrollbarElement.notifyBeforeScroll();\n  }\n\n  if (options.stop) {\n    $scrollable.stop('scroll');\n  }\n\n  // Not animated\n  if (!options.animate) {\n    $scrollable.scrollLeft(scrollLeft);\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n    return;\n  }\n\n  // Animated\n  animateScrollLeft($scrollable, scrollLeft);\n  $scrollable.promise('scroll').always(() => {\n    if (scrollbarElement) {\n      scrollbarElement.notifyAfterScroll();\n    }\n  });\n}\n\nfunction animateScrollTop($scrollable, scrollTop) {\n  $scrollable.animate({\n    scrollTop: scrollTop\n  }, {\n    queue: 'scroll'\n  })\n    .dequeue('scroll');\n}\n\nfunction animateScrollLeft($scrollable, scrollLeft) {\n  $scrollable.animate({\n    scrollLeft: scrollLeft\n  }, {\n    queue: 'scroll'\n  })\n    .dequeue('scroll');\n}\n\nexport function scrollbar($scrollable, axis) {\n  let scrollbars = $scrollable.data('scrollbars') || [];\n  return arrays.find(scrollbars, scrollbar => {\n    return scrollbar.axis === axis;\n  });\n}\n\nexport function scrollToBottom($scrollable, options) {\n  scrollTop($scrollable, $scrollable[0].scrollHeight - $scrollable[0].offsetHeight, options);\n}\n\n/**\n * @param location object with x and y properties\n * @param $scrollables one or more scrollables to check against\n * @returns {boolean} true if the location is visible in the current viewport of all the $scrollables, or if $scrollables is null\n */\nexport function isLocationInView(location, $scrollables) {\n  if (!$scrollables || $scrollables.length === 0) {\n    return true;\n  }\n  return $scrollables.toArray().every(scrollable => {\n    let scrollableOffsetBounds = graphics.offsetBounds($(scrollable));\n    return scrollableOffsetBounds.contains(location.x, location.y);\n  });\n}\n\n/**\n * Attaches the given handler to each scrollable parent, including $anchor if it is scrollable as well.<p>\n * Make sure you remove the handlers when not needed anymore using offScroll.\n */\nexport function onScroll($anchor, handler) {\n  handler.$scrollParents = [];\n  $anchor.scrollParents().each(function() {\n    let $scrollParent = $(this);\n    $scrollParent.on('scroll', handler);\n    handler.$scrollParents.push($scrollParent);\n  });\n}\n\nexport function offScroll(handler) {\n  let $scrollParents = handler.$scrollParents;\n  if (!$scrollParents) {\n    throw new Error('$scrollParents are not defined');\n  }\n  for (let i = 0; i < $scrollParents.length; i++) {\n    let $elem = $scrollParents[i];\n    $elem.off('scroll', handler);\n  }\n}\n\n/**\n * Sets the position to fixed and updates left and top position.\n * This is necessary to prevent flickering in IE.\n */\nexport function fix($elem) {\n  if (!$elem.isVisible() || $elem.css('position') === 'fixed') {\n    return;\n  }\n\n  // getBoundingClientRect used by purpose instead of graphics.offsetBounds to get exact values\n  // Also important: offset() of jquery returns getBoundingClientRect().top + window.pageYOffset.\n  // In case of IE and zoom = 125%, the pageYOffset is 1 because the height of the navigation is bigger than the height of the desktop which may be fractional.\n  let bounds = $elem[0].getBoundingClientRect();\n  $elem\n    .css('position', 'fixed')\n    .cssLeft(bounds.left - $elem.cssMarginLeft())\n    .cssTop(bounds.top - $elem.cssMarginTop())\n    .cssWidth(bounds.width)\n    .cssHeight(bounds.height);\n}\n\n/**\n * Reverts the changes made by fix().\n */\nexport function unfix($elem, timeoutId, immediate) {\n  clearTimeout(timeoutId);\n  if (immediate) {\n    _unfix($elem);\n    return;\n  }\n  return setTimeout(() => {\n    _unfix($elem);\n  }, 50);\n}\n\nexport function _unfix($elem) {\n  $elem.css({\n    position: 'absolute',\n    left: '',\n    top: '',\n    width: '',\n    height: ''\n  });\n}\n\n/**\n * Stores the position of all scrollables that belong to an optional session.\n * @param session (optional) when no session is given, scrollables from all sessions are stored\n */\nexport function storeScrollPositions($container, session) {\n  let $scrollables = getScrollables(session);\n  if (!$scrollables) {\n    return;\n  }\n\n  let scrollTop, scrollLeft;\n  $scrollables.forEach($scrollable => {\n    if ($container.isOrHas($scrollable[0])) {\n      scrollTop = $scrollable.scrollTop();\n      $scrollable.data('scrollTop', scrollTop);\n      scrollLeft = $scrollable.scrollLeft();\n      $scrollable.data('scrollLeft', $scrollable.scrollLeft());\n      $.log.isTraceEnabled() && $.log.trace('Stored scroll position for ' + $scrollable.attr('class') + '. Top: ' + scrollTop + '. Left: ' + scrollLeft);\n    }\n  });\n}\n\n/**\n * Restores the position of all scrollables that belong to an optional session.\n * @param session (optional) when no session is given, scrollables from all sessions are restored\n */\nexport function restoreScrollPositions($container, session) {\n  let $scrollables = getScrollables(session);\n  if (!$scrollables) {\n    return;\n  }\n\n  let scrollTop, scrollLeft;\n  $scrollables.forEach($scrollable => {\n    if ($container.isOrHas($scrollable[0])) {\n      scrollTop = $scrollable.data('scrollTop');\n      if (scrollTop) {\n        $scrollable.scrollTop(scrollTop);\n        $scrollable.removeData('scrollTop');\n      }\n      scrollLeft = $scrollable.data('scrollLeft');\n      if (scrollLeft) {\n        $scrollable.scrollLeft(scrollLeft);\n        $scrollable.removeData('scrollLeft');\n      }\n      // Also make sure that scroll bar is up to date\n      // Introduced for use case: Open large table page, edit entry, press f5\n      // -> outline tab gets rendered, scrollbar gets updated with set timeout, outline tab gets detached\n      // -> update event never had any effect because it executed after detaching (due to set timeout)\n      update($scrollable);\n      $.log.isTraceEnabled() && $.log.trace('Restored scroll position for ' + $scrollable.attr('class') + '. Top: ' + scrollTop + '. Left: ' + scrollLeft);\n    }\n  });\n}\n\nexport function setVisible($scrollable, visible) {\n  if (!$scrollable || !$scrollable.data('scrollable')) {\n    return;\n  }\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    return;\n  }\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.$container.setVisible(visible);\n    }\n  });\n}\n\nexport function opacity($scrollable, opacity) {\n  if (!$scrollable || !$scrollable.data('scrollable')) {\n    return;\n  }\n  let scrollbars = $scrollable.data('scrollbars');\n  if (!scrollbars) {\n    return;\n  }\n  scrollbars.forEach(scrollbar => {\n    if (scrollbar.rendered) {\n      scrollbar.$container.css('opacity', opacity);\n    }\n  });\n}\n\nexport function _getCompleteChildRowsHeightRecursive(children, getChildren, isExpanded, defaultChildHeight) {\n  let height = 0;\n  children.forEach(child => {\n    if (child.height) {\n      height += child.height;\n    } else {\n      // fallback for children with unset height\n      height += defaultChildHeight;\n    }\n    if (isExpanded(child) && getChildren(child).length > 0) {\n      height += _getCompleteChildRowsHeightRecursive(getChildren(child), getChildren, isExpanded, defaultChildHeight);\n    }\n  });\n  return height;\n}\n\nexport function ensureExpansionVisible(parent) {\n  let isParentExpanded = parent.isExpanded(parent.element);\n  let children = parent.getChildren(parent.element);\n  let parentPositionTop = parent.$element.position().top;\n  let parentHeight = parent.element.height;\n  let scrollTopPos = parent.$scrollable.scrollTop();\n\n  // vertical scrolling\n  if (!isParentExpanded) {\n    // parent is not expanded, make sure that at least one node above the parent is visible\n    if (parentPositionTop < parentHeight) {\n      let minScrollTop = Math.max(scrollTopPos - (parentHeight - parentPositionTop), 0);\n      scrollTop(parent.$scrollable, minScrollTop, {\n        animate: true\n      });\n    }\n  } else if (isParentExpanded && children.length > 0) {\n    // parent is expanded and has children, best effort approach to show the expansion\n    let fullDataHeight = parent.$scrollable.height();\n\n    // get childRowCount considering already expanded rows\n    let childRowsHeight = _getCompleteChildRowsHeightRecursive(children, parent.getChildren, parent.isExpanded, parent.defaultChildHeight);\n\n    // + 1.5 since its the parent's top position and we want to scroll half a row further to show that there's something after the expansion\n    let additionalHeight = childRowsHeight + (1.5 * parentHeight);\n    let scrollTo = parentPositionTop + additionalHeight;\n    // scroll as much as needed to show the expansion but make sure that the parent row (plus one more) is still visible\n    let newScrollTop = scrollTopPos + Math.min(scrollTo - fullDataHeight, parentPositionTop - parentHeight);\n    // only scroll down\n    if (newScrollTop > scrollTopPos) {\n      scrollTop(parent.$scrollable, newScrollTop, {\n        animate: true,\n        stop: false\n      });\n    }\n  }\n\n  if (children.length > 0) {\n    // horizontal scrolling: at least 3 levels of hierarchy should be visible (only relevant for small fields)\n    let minLevelLeft = Math.max(parent.element.level - 3, 0) * parent.nodePaddingLevel;\n    scrollLeft(parent.$scrollable, minLevelLeft, {\n      animate: true,\n      stop: false\n    });\n  }\n}\n\nexport default {\n  ensureExpansionVisible,\n  fix,\n  getScrollables,\n  install,\n  installScrollShadow,\n  isHybridScrolling,\n  isJsScrolling,\n  isLocationInView,\n  isNativeScrolling,\n  hasScrollShadow,\n  offScroll,\n  onScroll,\n  opacity,\n  pushScrollable,\n  removeScrollable,\n  reset,\n  restoreScrollPositions,\n  scrollHorizontalTo,\n  scrollLeft,\n  scrollTo,\n  scrollToBottom,\n  scrollTop,\n  scrollbar,\n  setVisible,\n  storeScrollPositions,\n  unfix,\n  uninstall,\n  uninstallScrollShadow,\n  update\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,MAAM,EAAEC,OAAO,EAAEC,KAAK,QAAO,UAAU;AACxF,OAAOC,CAAC,MAAM,QAAQ;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa,GAAG,CAAC,CAAC;AACtB,IAAIC,gBAAgB;AACpB,IAAIC,oBAAoB;AAExB,OAAO,SAASC,cAAc,CAACC,OAAO,EAAE;EACtC;EACA,IAAIA,OAAO,EAAE;IACX,OAAOJ,aAAa,CAACI,OAAO,CAAC,IAAI,EAAE;EACrC;;EAEA;EACA,IAAIC,YAAY,GAAG,EAAE;EACrBR,OAAO,CAACS,MAAM,CAACN,aAAa,CAAC,CAACO,OAAO,CAACC,sBAAsB,IAAI;IAC9DhB,MAAM,CAACiB,OAAO,CAACJ,YAAY,EAAEG,sBAAsB,CAAC;EACtD,CAAC,CAAC;EACF,OAAOH,YAAY;AACrB;AAEA,OAAO,SAASK,cAAc,CAACN,OAAO,EAAEO,UAAU,EAAE;EAClD,IAAIX,aAAa,CAACI,OAAO,CAAC,EAAE;IAC1B,IAAIJ,aAAa,CAACI,OAAO,CAAC,CAACQ,OAAO,CAACD,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;MACnD;MACA;IACF;IACAX,aAAa,CAACI,OAAO,CAAC,CAACS,IAAI,CAACF,UAAU,CAAC;EACzC,CAAC,MAAM;IACLX,aAAa,CAACI,OAAO,CAAC,GAAG,CAACO,UAAU,CAAC;EACvC;EACAZ,CAAC,CAACe,GAAG,CAACC,cAAc,EAAE,IAAIhB,CAAC,CAACe,GAAG,CAACE,KAAK,CAAC,oBAAoB,GAAGL,UAAU,CAACM,IAAI,CAAC,OAAO,CAAC,GAAG,gBAAgB,GAAGjB,aAAa,CAACI,OAAO,CAAC,CAACc,MAAM,CAAC;AAC3I;AAEA,OAAO,SAASC,gBAAgB,CAACf,OAAO,EAAEO,UAAU,EAAE;EACpD,IAAIS,UAAU,GAAG,CAAC;EAClB,IAAIpB,aAAa,CAACI,OAAO,CAAC,EAAE;IAC1BgB,UAAU,GAAGpB,aAAa,CAACI,OAAO,CAAC,CAACc,MAAM;IAC1C1B,MAAM,CAAC6B,OAAO,CAACrB,aAAa,CAACI,OAAO,CAAC,EAAEO,UAAU,CAAC;IAClDZ,CAAC,CAACe,GAAG,CAACC,cAAc,EAAE,IAAIhB,CAAC,CAACe,GAAG,CAACE,KAAK,CAAC,sBAAsB,GAAGL,UAAU,CAACM,IAAI,CAAC,OAAO,CAAC,GAAG,gBAAgB,GAAGjB,aAAa,CAACI,OAAO,CAAC,CAACc,MAAM,CAAC;IAC3I,IAAIE,UAAU,KAAKpB,aAAa,CAACI,OAAO,CAAC,CAACc,MAAM,EAAE;MAChD,MAAM,IAAII,KAAK,CAAC,0DAA0D,GAAGX,UAAU,CAACM,IAAI,CAAC,OAAO,CAAC,CAAC;IACxG;EACF,CAAC,MAAM;IACL,MAAM,IAAIK,KAAK,CAAC,0DAA0D,GAAGX,UAAU,CAACM,IAAI,CAAC,OAAO,CAAC,CAAC;EACxG;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,OAAO,CAACZ,UAAU,EAAEa,OAAO,EAAE;EAC3CA,OAAO,GAAGC,6BAA6B,CAACD,OAAO,CAAC;EAChDA,OAAO,CAACE,IAAI,GAAGF,OAAO,CAACE,IAAI,IAAI,MAAM;EACrCF,OAAO,CAACG,YAAY,GAAGH,OAAO,CAACG,YAAY,IAAI,MAAM;;EAErD;EACA,IAAIC,gBAAgB,GAAG9B,KAAK,CAAC+B,GAAG,CAACL,OAAO,CAACI,gBAAgB,EAAEnC,MAAM,CAACqC,GAAG,EAAE,CAACC,mBAAmB,EAAE,CAAC;EAC9F,IAAIC,gBAAgB,GAAGlC,KAAK,CAAC+B,GAAG,CAACL,OAAO,CAACQ,gBAAgB,EAAEvC,MAAM,CAACqC,GAAG,EAAE,CAACG,iBAAiB,EAAE,CAAC;EAC5F,IAAIL,gBAAgB,EAAE;IACpBM,cAAc,CAACvB,UAAU,EAAEa,OAAO,CAAC;EACrC,CAAC,MAAM,IAAIQ,gBAAgB,EAAE;IAC3BrB,UAAU,CAACwB,QAAQ,CAAC,mBAAmB,CAAC;IACxCD,cAAc,CAACvB,UAAU,EAAEa,OAAO,CAAC;IACnCY,UAAU,CAACzB,UAAU,EAAEa,OAAO,CAAC;EACjC,CAAC,MAAM;IACLb,UAAU,CAAC0B,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC;IACpCD,UAAU,CAACzB,UAAU,EAAEa,OAAO,CAAC;EACjC;EACA,IAAIc,aAAa,GAAG3C,aAAa,CAAC4C,MAAM,CAAC5B,UAAU,CAAC;EACpD,IAAI2B,aAAa,EAAE;IACjBA,aAAa,CAACE,UAAU,GAAG,IAAI;EACjC;EACA7B,UAAU,CAAC8B,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC;EACnC,IAAIrC,OAAO,GAAGoB,OAAO,CAACpB,OAAO,IAAIoB,OAAO,CAACkB,MAAM,CAACtC,OAAO;EACvDM,cAAc,CAACN,OAAO,EAAEO,UAAU,CAAC;EACnC,IAAIa,OAAO,CAACG,YAAY,EAAE;IACxBgB,mBAAmB,CAAChC,UAAU,EAAEP,OAAO,EAAEoB,OAAO,CAAC;EACnD;EACA,OAAOb,UAAU;AACnB;AAEA,OAAO,SAASuB,cAAc,CAACvB,UAAU,EAAEa,OAAO,EAAE;EAClD,IAAI/B,MAAM,CAACqC,GAAG,EAAE,CAACc,KAAK,EAAE,EAAE;IACxB;IACA;IACAC,UAAU,CAACC,sBAAsB,CAACC,IAAI,CAAC,IAAI,EAAEpC,UAAU,EAAEa,OAAO,CAAC,CAAC;EACpE,CAAC,MAAM;IACLsB,sBAAsB,CAACnC,UAAU,EAAEa,OAAO,CAAC;EAC7C;AACF;AAEA,OAAO,SAASsB,sBAAsB,CAACnC,UAAU,EAAEa,OAAO,EAAE;EAC1DzB,CAAC,CAACe,GAAG,CAACC,cAAc,EAAE,IAAIhB,CAAC,CAACe,GAAG,CAACE,KAAK,CAAC,sCAAsC,GAAGtB,QAAQ,CAACsD,WAAW,CAACrC,UAAU,CAAC,CAAC;EAChH,IAAIa,OAAO,CAACE,IAAI,KAAK,GAAG,EAAE;IACxBf,UAAU,CACP0B,GAAG,CAAC,YAAY,EAAE,MAAM,CAAC,CACzBA,GAAG,CAAC,YAAY,EAAE,QAAQ,CAAC;EAChC,CAAC,MAAM,IAAIb,OAAO,CAACE,IAAI,KAAK,GAAG,EAAE;IAC/Bf,UAAU,CACP0B,GAAG,CAAC,YAAY,EAAE,QAAQ,CAAC,CAC3BA,GAAG,CAAC,YAAY,EAAE,MAAM,CAAC;EAC9B,CAAC,MAAM;IACL1B,UAAU,CAAC0B,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC;EACpC;EACA1B,UAAU,CAAC0B,GAAG,CAAC,4BAA4B,EAAE,OAAO,CAAC;AACvD;AAEA,OAAO,SAASM,mBAAmB,CAAChC,UAAU,EAAEP,OAAO,EAAEoB,OAAO,EAAE;EAChE,IAAI,CAAC/B,MAAM,CAACqC,GAAG,EAAE,CAACmB,4BAA4B,EAAE,EAAE;IAChD;EACF;EACA,IAAIC,iBAAiB,GAAGC,yBAAyB,CAAC3B,OAAO,CAAC;EAC1D,IAAI0B,iBAAiB,CAAChC,MAAM,KAAK,CAAC,EAAE;IAClC;EACF;EACA,IAAIkC,OAAO,GAAGzC,UAAU,CAAC0C,QAAQ,CAAC,eAAe,CAAC;EAClDD,OAAO,CAACE,WAAW,CAAC,OAAO,EAAEJ,iBAAiB,CAACtC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;EACrEwC,OAAO,CAACE,WAAW,CAAC,UAAU,EAAEJ,iBAAiB,CAACtC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;EAC3EwC,OAAO,CAACX,IAAI,CAAC,sBAAsB,EAAE9B,UAAU,CAAC;EAChDA,UAAU,CAAC8B,IAAI,CAAC,eAAe,EAAEW,OAAO,CAAC;EACzCzC,UAAU,CAAC8B,IAAI,CAAC,qBAAqB,EAAES,iBAAiB,CAAC;EACzDvC,UAAU,CAAC8B,IAAI,CAAC,0BAA0B,EAAEjB,OAAO,CAAC+B,sBAAsB,CAAC;EAC3E,IAAIC,OAAO,GAAG,MAAMC,gCAAgC,CAAC9C,UAAU,CAAC;EAChEA,UAAU,CAAC8B,IAAI,CAAC,uBAAuB,EAAEe,OAAO,CAAC;EACjD7C,UAAU,CAAC+C,EAAE,CAAC,QAAQ,EAAEF,OAAO,CAAC;EAChCG,kBAAkB,CAAChD,UAAU,CAAC;EAC9BiD,wBAAwB,CAACxD,OAAO,CAAC;EACjCyD,4BAA4B,EAAE;EAC9B3D,oBAAoB,CAAC4D,OAAO,CAACnD,UAAU,CAAC,CAAC,CAAC,CAAC;;EAE3C;EACA;EACA,IAAIoD,gBAAgB,GAAGpD,UAAU,CAAC,CAAC,CAAC;EACpC,IAAIqD,eAAe,GAAGC,CAAC,IAAI;IACzB,IAAIA,CAAC,CAACC,MAAM,KAAKH,gBAAgB,EAAE;MACjCI,0BAA0B,CAACJ,gBAAgB,EAAEE,CAAC,CAACG,IAAI,KAAK,MAAM,CAAC;IACjE;EACF,CAAC;EACDzD,UAAU,CAAC8B,IAAI,CAAC,gCAAgC,EAAEuB,eAAe,CAAC;EAClErD,UAAU,CAAC+C,EAAE,CAAC,WAAW,EAAEM,eAAe,CAAC;AAC7C;AAEA,OAAO,SAASK,qBAAqB,CAAC1D,UAAU,EAAEP,OAAO,EAAE;EACzD,IAAIgD,OAAO,GAAGzC,UAAU,CAAC8B,IAAI,CAAC,eAAe,CAAC;EAC9C,IAAIW,OAAO,EAAE;IACXA,OAAO,CAACkB,MAAM,EAAE;IAChB3D,UAAU,CAAC4D,UAAU,CAAC,eAAe,CAAC;EACxC;EACA5D,UAAU,CAAC4D,UAAU,CAAC,qBAAqB,CAAC;EAC5C5D,UAAU,CAAC4D,UAAU,CAAC,0BAA0B,CAAC;EACjD,IAAIf,OAAO,GAAG7C,UAAU,CAAC8B,IAAI,CAAC,uBAAuB,CAAC;EACtD,IAAIe,OAAO,EAAE;IACX7C,UAAU,CAAC6D,GAAG,CAAC,QAAQ,EAAEhB,OAAO,CAAC;IACjC7C,UAAU,CAAC4D,UAAU,CAAC,uBAAuB,CAAC;EAChD;EACA,IAAIrE,oBAAoB,EAAE;IACxBA,oBAAoB,CAACuE,SAAS,CAAC9D,UAAU,CAAC,CAAC,CAAC,CAAC;EAC/C;EACA,IAAIqD,eAAe,GAAGrD,UAAU,CAAC8B,IAAI,CAAC,gCAAgC,CAAC;EACvE,IAAIuB,eAAe,EAAE;IACnBrD,UAAU,CAAC6D,GAAG,CAAC,WAAW,EAAER,eAAe,CAAC;EAC9C;EACA,IAAI3D,YAAY,GAAGL,aAAa,CAACI,OAAO,CAAC;EACzC,IAAI,CAACC,YAAY,IAAI,CAACA,YAAY,CAACqE,IAAI,CAACC,WAAW,IAAIA,WAAW,CAAClC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE;IACzFmC,0BAA0B,EAAE;IAC5BC,8BAA8B,EAAE;EAClC;AACF;;AAEA;AACA;AACA;AACA;AACA,SAAS1B,yBAAyB,CAAC3B,OAAO,EAAE;EAC1C,IAAIG,YAAY,GAAGH,OAAO,CAACG,YAAY;EACvC,IAAI,CAACA,YAAY,EAAE;IACjB,OAAO,EAAE;EACX;EACA,IAAI,OAAOA,YAAY,KAAK,QAAQ,EAAE;IACpCA,YAAY,GAAGA,YAAY,CAACmD,KAAK,CAAC,GAAG,CAAC;EACxC;EACAnD,YAAY,GAAGA,YAAY,CAACoD,KAAK,EAAE,CAAC,CAAC;EACrC,IAAIpD,YAAY,CAACf,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE;IACrC,OAAO,EAAE;EACX;EACA,IAAI,CAACpB,MAAM,CAACwF,WAAW,CAACrD,YAAY,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC,EAAE;IACnF;IACA,IAAIH,OAAO,CAACE,IAAI,KAAK,MAAM,IAAIF,OAAO,CAACE,IAAI,KAAK,GAAG,EAAE;MACnDC,YAAY,CAACd,IAAI,CAAC,GAAG,CAAC;IACxB;IACA,IAAIW,OAAO,CAACE,IAAI,KAAK,MAAM,IAAIF,OAAO,CAACE,IAAI,KAAK,GAAG,EAAE;MACnDC,YAAY,CAACd,IAAI,CAAC,GAAG,CAAC;IACxB;EACF;EACA,IAAIc,YAAY,CAACf,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;IAClCe,YAAY,CAACd,IAAI,CAAC,KAAK,CAAC;IACxBc,YAAY,CAACd,IAAI,CAAC,QAAQ,CAAC;EAC7B;EACA,IAAIc,YAAY,CAACf,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;IAClCe,YAAY,CAACd,IAAI,CAAC,MAAM,CAAC;IACzBc,YAAY,CAACd,IAAI,CAAC,OAAO,CAAC;EAC5B;EACArB,MAAM,CAACyF,SAAS,CAACtD,YAAY,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;EACjE,OAAOA,YAAY;AACrB;AAEA,OAAO,SAAS8B,gCAAgC,CAAC9C,UAAU,EAAE;EAC3D,IAAIuE,gBAAgB,GAAGvE,UAAU,CAACwE,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACC,iBAAiB,EAAE,CAAC;EAC5E,IAAIH,gBAAgB,CAAChE,MAAM,GAAG,CAAC,EAAE;IAC/B;IACA;IACAgE,gBAAgB,CAACI,eAAe,CAAC,MAAM3B,kBAAkB,CAAChD,UAAU,CAAC,CAAC;IACtE;EACF;EACAgD,kBAAkB,CAAChD,UAAU,CAAC;AAChC;AAEA,OAAO,SAASgD,kBAAkB,CAAChD,UAAU,EAAE;EAC7C,IAAIyC,OAAO,GAAGzC,UAAU,CAAC8B,IAAI,CAAC,eAAe,CAAC;EAC9C,IAAI,CAACW,OAAO,EAAE;IACZ;EACF;EACA,IAAImC,SAAS,GAAG5E,UAAU,CAAC,CAAC,CAAC,CAAC4E,SAAS;EACvC,IAAIC,UAAU,GAAG7E,UAAU,CAAC,CAAC,CAAC,CAAC6E,UAAU;EACzC,IAAIC,KAAK,GAAGC,OAAO,CAACH,SAAS,CAAC;EAC9B,IAAII,QAAQ,GAAGC,KAAK,CAACL,SAAS,EAAE5E,UAAU,CAAC,CAAC,CAAC,CAACkF,YAAY,EAAElF,UAAU,CAAC,CAAC,CAAC,CAACmF,YAAY,CAAC;EACvF,IAAIC,MAAM,GAAGL,OAAO,CAACF,UAAU,CAAC;EAChC,IAAIQ,OAAO,GAAGJ,KAAK,CAACJ,UAAU,EAAE7E,UAAU,CAAC,CAAC,CAAC,CAACsF,WAAW,EAAEtF,UAAU,CAAC,CAAC,CAAC,CAACuF,WAAW,CAAC;EACrF,IAAIC,KAAK,GAAGxF,UAAU,CAAC8B,IAAI,CAAC,qBAAqB,CAAC;EAClDW,OAAO,CAACE,WAAW,CAAC,KAAK,EAAE,CAACmC,KAAK,IAAIU,KAAK,CAACvF,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;EAC/DwC,OAAO,CAACE,WAAW,CAAC,QAAQ,EAAE,CAACqC,QAAQ,IAAIQ,KAAK,CAACvF,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;EACxEwC,OAAO,CAACE,WAAW,CAAC,MAAM,EAAE,CAACyC,MAAM,IAAII,KAAK,CAACvF,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;EAClEwC,OAAO,CAACE,WAAW,CAAC,OAAO,EAAE,CAAC0C,OAAO,IAAIG,KAAK,CAACvF,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;EACrElB,QAAQ,CAAC0G,SAAS,CAAChD,OAAO,EAAE1D,QAAQ,CAAC2G,MAAM,CAAC1F,UAAU,EAAE;IAAC2F,KAAK,EAAE;EAAI,CAAC,CAAC,CAACC,QAAQ,CAACC,MAAM,CAACpD,OAAO,CAAC,CAAC,CAAC;EACjG1D,QAAQ,CAAC+G,UAAU,CAACrD,OAAO,EAAE1D,QAAQ,CAACgH,OAAO,CAAC/F,UAAU,CAAC,CAAC;EAC1DyC,OAAO,CAACf,GAAG,CAAC,eAAe,EAAE1B,UAAU,CAAC0B,GAAG,CAAC,eAAe,CAAC,CAAC;EAE7D,IAAIsE,UAAU,GAAGhG,UAAU,CAAC8B,IAAI,CAAC,0BAA0B,CAAC;EAC5D,IAAIkE,UAAU,EAAE;IACdA,UAAU,CAAChG,UAAU,EAAEyC,OAAO,CAAC;EACjC;EAEA,SAASsC,OAAO,CAACkB,SAAS,EAAE;IAC1B,OAAOA,SAAS,KAAK,CAAC;EACxB;EAEA,SAAShB,KAAK,CAACgB,SAAS,EAAEC,UAAU,EAAEC,UAAU,EAAE;IAChD,OAAOF,SAAS,GAAG,CAAC,IAAIC,UAAU,GAAGC,UAAU;EACjD;EAEA,SAASN,MAAM,CAACpD,OAAO,EAAE;IACvB,OAAO,IAAIxD,MAAM,CAACwD,OAAO,CAAC2D,UAAU,CAAC,2BAA2B,CAAC,EAC/D3D,OAAO,CAAC2D,UAAU,CAAC,6BAA6B,CAAC,EACjD3D,OAAO,CAAC2D,UAAU,CAAC,8BAA8B,CAAC,EAClD3D,OAAO,CAAC2D,UAAU,CAAC,4BAA4B,CAAC,CAAC;EACrD;AACF;;AAEA;AACA;AACA;AACA,SAASnD,wBAAwB,CAACxD,OAAO,EAAE;EACzC,IAAIH,gBAAgB,EAAE;IACpB;EACF;EACAA,gBAAgB,GAAG,IAAI+G,gBAAgB,CAACC,cAAc,CAAC;EACvDhH,gBAAgB,CAAC6D,OAAO,CAAC1D,OAAO,CAAC8G,WAAW,CAAC,CAAC,CAAC,EAAE;IAC/CC,OAAO,EAAE,IAAI;IACbC,SAAS,EAAE;EACb,CAAC,CAAC;AACJ;AAEA,SAASH,cAAc,CAACI,YAAY,EAAEC,QAAQ,EAAE;EAC9CD,YAAY,CAAC9G,OAAO,CAACgH,mBAAmB,CAAC;AAC3C;AAEA,OAAO,SAASA,mBAAmB,CAACC,QAAQ,EAAE;EAC5C;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACE,UAAU,CAACxG,MAAM,EAAEuG,CAAC,EAAE,EAAE;IACnD,IAAIE,IAAI,GAAGH,QAAQ,CAACE,UAAU,CAACD,CAAC,CAAC;IACjC,IAAIrC,KAAK,GAAGrF,CAAC,CAAC4H,IAAI,CAAC;IACnB,IAAIvC,KAAK,CAAC3C,IAAI,CAAC,YAAY,CAAC,EAAE;MAC5B;MACA,IAAImF,aAAa,GAAGxC,KAAK,CAAC3C,IAAI,CAAC,eAAe,CAAC;MAC/C,IAAImF,aAAa,EAAE;QACjBA,aAAa,CAACC,WAAW,CAACzC,KAAK,CAAC;MAClC;IACF;EACF;AACF;AAEA,SAASR,0BAA0B,GAAG;EACpC,IAAI,CAAC3E,gBAAgB,EAAE;IACrB;EACF;EACAA,gBAAgB,CAAC6H,UAAU,EAAE;EAC7B7H,gBAAgB,GAAG,IAAI;AACzB;;AAEA;AACA;AACA;AACA,SAAS4D,4BAA4B,GAAG;EACtC,IAAI3D,oBAAoB,EAAE;IACxB;EACF;EACAA,oBAAoB,GAAG,IAAI6H,oBAAoB,CAAC,CAACC,OAAO,EAAEV,QAAQ,KAAK;IACrEU,OAAO,CAACzH,OAAO,CAAC0H,KAAK,IAAI;MACvB9D,0BAA0B,CAAC8D,KAAK,CAAC/D,MAAM,EAAE+D,KAAK,CAACC,iBAAiB,GAAG,CAAC,CAAC;IACvE,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,SAASrD,8BAA8B,GAAG;EACxC,IAAI,CAAC3E,oBAAoB,EAAE;IACzB;EACF;EACAA,oBAAoB,CAAC4H,UAAU,EAAE;EACjC5H,oBAAoB,GAAG,IAAI;AAC7B;AAEA,OAAO,SAASiE,0BAA0B,CAACgE,OAAO,EAAEC,OAAO,EAAE;EAC3D,IAAIC,QAAQ,GAAGtI,CAAC,CAACoI,OAAO,CAAC;EACzB,IAAI/E,OAAO,GAAGiF,QAAQ,CAAC5F,IAAI,CAAC,eAAe,CAAC;EAC5C,IAAI,CAACW,OAAO,EAAE;IACZ;EACF;EACAA,OAAO,CAACkF,UAAU,CAACD,QAAQ,CAACE,SAAS,EAAE,CAAC;AAC1C;AAEA,OAAO,SAASC,eAAe,CAAC7H,UAAU,EAAE8H,QAAQ,EAAE;EACpD,IAAI,CAAC9H,UAAU,EAAE;IACf,OAAO,KAAK;EACd;EACA,IAAIiH,aAAa,GAAGjH,UAAU,CAAC8B,IAAI,CAAC,eAAe,CAAC;EACpD,IAAI,CAACmF,aAAa,EAAE;IAClB,OAAO,KAAK;EACd;EACA,IAAI,CAACa,QAAQ,EAAE;IACb,OAAO,IAAI;EACb;EACA,OAAOb,aAAa,CAACc,QAAQ,CAACD,QAAQ,CAAC;AACzC;AAEA,OAAO,SAASE,iBAAiB,CAAChE,WAAW,EAAE;EAC7C,OAAOA,WAAW,CAAC+D,QAAQ,CAAC,mBAAmB,CAAC;AAClD;AAEA,OAAO,SAASE,iBAAiB,CAACjE,WAAW,EAAE;EAC7C,OAAO7E,KAAK,CAAC+I,OAAO,CAAC,MAAM,EAAElE,WAAW,CAACtC,GAAG,CAAC,UAAU,CAAC,EAAEsC,WAAW,CAACtC,GAAG,CAAC,YAAY,CAAC,EAAEsC,WAAW,CAACtC,GAAG,CAAC,YAAY,CAAC,CAAC;AACzH;AAEA,OAAO,SAASyG,aAAa,CAACnE,WAAW,EAAE;EACzC,OAAO,CAAC,CAACA,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC;AACzC;AAEA,OAAO,SAASL,UAAU,CAACzB,UAAU,EAAEa,OAAO,EAAE;EAC9CzB,CAAC,CAACe,GAAG,CAACC,cAAc,EAAE,IAAIhB,CAAC,CAACe,GAAG,CAACE,KAAK,CAAC,yCAAyC,GAAGtB,QAAQ,CAACsD,WAAW,CAACrC,UAAU,CAAC,CAAC;EACnH,IAAIoI,UAAU,GAAGvJ,MAAM,CAACwJ,MAAM,CAACrI,UAAU,CAAC8B,IAAI,CAAC,YAAY,CAAC,CAAC;EAC7DsG,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9BA,SAAS,CAACC,OAAO,EAAE;EACrB,CAAC,CAAC;EACFH,UAAU,GAAG,EAAE;EACf,IAAIE,SAAS;EACb,IAAIzH,OAAO,CAACE,IAAI,KAAK,MAAM,EAAE;IAC3B,IAAIyH,aAAa,GAAGpJ,CAAC,CAACqJ,MAAM,CAAC,CAAC,CAAC,EAAE5H,OAAO,CAAC;IACzC2H,aAAa,CAACzH,IAAI,GAAG,GAAG;IACxBuH,SAAS,GAAGnJ,KAAK,CAACuJ,MAAM,CAAC,WAAW,EAAEtJ,CAAC,CAACqJ,MAAM,CAAC,CAAC,CAAC,EAAED,aAAa,CAAC,CAAC;IAClEJ,UAAU,CAAClI,IAAI,CAACoI,SAAS,CAAC;IAE1BE,aAAa,CAACzH,IAAI,GAAG,GAAG;IACxByH,aAAa,CAACG,oBAAoB,GAAG,IAAI;IACzCL,SAAS,GAAGnJ,KAAK,CAACuJ,MAAM,CAAC,WAAW,EAAEtJ,CAAC,CAACqJ,MAAM,CAAC,CAAC,CAAC,EAAED,aAAa,CAAC,CAAC;IAClEJ,UAAU,CAAClI,IAAI,CAACoI,SAAS,CAAC;EAC5B,CAAC,MAAM;IACLA,SAAS,GAAGnJ,KAAK,CAACuJ,MAAM,CAAC,WAAW,EAAEtJ,CAAC,CAACqJ,MAAM,CAAC,CAAC,CAAC,EAAE5H,OAAO,CAAC,CAAC;IAC5DuH,UAAU,CAAClI,IAAI,CAACoI,SAAS,CAAC;EAC5B;EACAtI,UAAU,CAAC8B,IAAI,CAAC,YAAY,EAAEsG,UAAU,CAAC;EAEzCA,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9BA,SAAS,CAACM,MAAM,CAAC5I,UAAU,CAAC;IAC5BsI,SAAS,CAACO,MAAM,EAAE;EACpB,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA,OAAO,SAASC,SAAS,CAAC9I,UAAU,EAAEP,OAAO,EAAE;EAC7C,IAAI,CAACO,UAAU,CAAC8B,IAAI,CAAC,YAAY,CAAC,EAAE;IAClC;IACA;EACF;EAEA,IAAIsG,UAAU,GAAGpI,UAAU,CAAC8B,IAAI,CAAC,YAAY,CAAC;EAC9C,IAAIsG,UAAU,EAAE;IACdA,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;MAC9BA,SAAS,CAACC,OAAO,EAAE;IACrB,CAAC,CAAC;EACJ;EACA/H,gBAAgB,CAACf,OAAO,EAAEO,UAAU,CAAC;EACrCA,UAAU,CAAC4D,UAAU,CAAC,YAAY,CAAC;EACnC5D,UAAU,CAAC0B,GAAG,CAAC,UAAU,EAAE,EAAE,CAAC;EAC9B1B,UAAU,CAAC+I,WAAW,CAAC,mBAAmB,CAAC;EAC3C/I,UAAU,CAAC4D,UAAU,CAAC,YAAY,CAAC;EAEnC,IAAIjC,aAAa,GAAG3C,aAAa,CAAC4C,MAAM,CAAC5B,UAAU,CAAC;EACpD,IAAI2B,aAAa,EAAE;IACjBA,aAAa,CAACE,UAAU,GAAG,KAAK;EAClC;EACA6B,qBAAqB,CAAC1D,UAAU,EAAEP,OAAO,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoJ,MAAM,CAAC7E,WAAW,EAAEgF,SAAS,EAAE;EAC7C,IAAI,CAAChF,WAAW,IAAI,CAACA,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC,EAAE;IACnD;EACF;EACAkB,kBAAkB,CAACgB,WAAW,CAAC;EAC/B,IAAIoE,UAAU,GAAGpE,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC;EAC/C,IAAI,CAACsG,UAAU,EAAE;IACf,IAAItJ,MAAM,CAACqC,GAAG,EAAE,CAACc,KAAK,EAAE,EAAE;MACxBgH,kBAAkB,CAACjF,WAAW,CAAC;IACjC;IACA;EACF;EACA,IAAIgF,SAAS,EAAE;IACbE,OAAO,CAACd,UAAU,CAAC;IACnB;EACF;EACA,IAAIpE,WAAW,CAAClC,IAAI,CAAC,wBAAwB,CAAC,EAAE;IAC9C;EACF;EACA;EACAI,UAAU,CAAC,MAAM;IACfgH,OAAO,CAACd,UAAU,CAAC;IACnBpE,WAAW,CAACJ,UAAU,CAAC,wBAAwB,CAAC;EAClD,CAAC,EAAE,CAAC,CAAC;EACLI,WAAW,CAAClC,IAAI,CAAC,wBAAwB,EAAE,IAAI,CAAC;AAClD;AAEA,OAAO,SAASoH,OAAO,CAACd,UAAU,EAAE;EAClC;EACAA,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9B,IAAIA,SAAS,CAACa,QAAQ,EAAE;MACtBb,SAAS,CAACc,KAAK,EAAE;IACnB;EACF,CAAC,CAAC;EACFhB,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9B,IAAIA,SAAS,CAACa,QAAQ,EAAE;MACtBb,SAAS,CAACO,MAAM,EAAE;IACpB;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,kBAAkB,CAACjF,WAAW,EAAE;EAC9C,IAAIA,WAAW,CAAClC,IAAI,CAAC,wBAAwB,CAAC,EAAE;IAC9C;EACF;EACAI,UAAU,CAAC,MAAM;IACfmH,UAAU,EAAE;IACZrF,WAAW,CAACJ,UAAU,CAAC,wBAAwB,CAAC;EAClD,CAAC,CAAC;EACFI,WAAW,CAAClC,IAAI,CAAC,wBAAwB,EAAE,IAAI,CAAC;EAEhD,SAASuH,UAAU,GAAG;IACpB,IAAIC,IAAI,GAAGvK,QAAQ,CAACuK,IAAI,CAACtF,WAAW,CAAC,CAAC4B,QAAQ,CAAC7G,QAAQ,CAAC8G,MAAM,CAAC7B,WAAW,EAAE;MAC1EuF,cAAc,EAAE,KAAK;MACrBC,aAAa,EAAE;IACjB,CAAC,CAAC,CAAC;IACH,IAAIxF,WAAW,CAAC,CAAC,CAAC,CAACkB,YAAY,KAAKoE,IAAI,CAACG,MAAM,IAAIzF,WAAW,CAAC,CAAC,CAAC,CAACsB,WAAW,KAAKgE,IAAI,CAACI,KAAK,EAAE;MAC5F1F,WAAW,CAACtC,GAAG,CAAC,4BAA4B,EAAE,EAAE,CAAC;IACnD,CAAC,MAAM;MACLsC,WAAW,CAACtC,GAAG,CAAC,4BAA4B,EAAE,OAAO,CAAC;IACxD;EACF;AACF;AAEA,OAAO,SAAS0H,KAAK,CAACpF,WAAW,EAAE;EACjC,IAAIoE,UAAU,GAAGpE,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC;EAC/C,IAAI,CAACsG,UAAU,EAAE;IACf;EACF;EACAA,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9BA,SAAS,CAACc,KAAK,EAAE;EACnB,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,QAAQ,CAAC3F,WAAW,EAAE0D,QAAQ,EAAE7G,OAAO,EAAE;EACvD,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC/BA,OAAO,GAAG;MACR+I,KAAK,EAAE/I;IACT,CAAC;EACH,CAAC,MAAM;IACLA,OAAO,GAAGC,6BAA6B,CAACD,OAAO,CAAC;EAClD;EAEA,IAAI+I,KAAK,GAAI/I,OAAO,CAAC+I,KAAK,GAAG/I,OAAO,CAAC+I,KAAK,CAACC,WAAW,EAAE,GAAGC,SAAU;EAErE,IAAIH,QAAQ;IACVI,cAAc,GAAG5K,KAAK,CAAC+B,GAAG,CAACL,OAAO,CAACkJ,cAAc,EAAEH,KAAK,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;IAC9EI,gBAAgB,GAAG7K,KAAK,CAAC+B,GAAG,CAACL,OAAO,CAACmJ,gBAAgB,EAAEJ,KAAK,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;IAClFK,WAAW,GAAGjG,WAAW,CAACyF,MAAM,EAAE;IAClCS,aAAa,GAAGnL,QAAQ,CAACoL,YAAY,CAACzC,QAAQ,CAAC;IAC/C0C,gBAAgB,GAAGrL,QAAQ,CAACoL,YAAY,CAACnG,WAAW,CAAC;IACrDqG,QAAQ,GAAGH,aAAa,CAACI,CAAC,GAAGF,gBAAgB,CAACE,CAAC;IAC/CC,QAAQ,GAAGL,aAAa,CAACT,MAAM;IAC/Be,UAAU,GAAGH,QAAQ,GAAGN,cAAc;IAAE;IACxCU,aAAa,GAAGJ,QAAQ,GAAGE,QAAQ,GAAGP,gBAAgB;;EAExD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAI,CAACJ,KAAK,EAAE;IACV;IACA;IACA;IACAA,KAAK,GAAIY,UAAU,GAAG,CAAC,GAAI,KAAK,GAAIC,aAAa,GAAGR,WAAW,GAAG,QAAQ,GAAGH,SAAU;EACzF;EAEA,IAAIF,KAAK,KAAK,QAAQ,EAAE;IACtB;IACAD,QAAQ,GAAG3F,WAAW,CAACY,SAAS,EAAE,GAAG4F,UAAU,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAACV,WAAW,GAAGM,QAAQ,IAAI,CAAC,CAAC;EAE7F,CAAC,MAAM,IAAIX,KAAK,KAAK,KAAK,EAAE;IAC1B;IACA;IACAD,QAAQ,GAAG3F,WAAW,CAACY,SAAS,EAAE,GAAG4F,UAAU;EAEjD,CAAC,MAAM,IAAIZ,KAAK,KAAK,QAAQ,EAAE;IAC7B;IACA;IACA;IACAD,QAAQ,GAAGe,IAAI,CAACE,IAAI,CAAC5G,WAAW,CAACY,SAAS,EAAE,GAAG6F,aAAa,GAAGR,WAAW,CAAC;;IAE3E;IACA;IACA,IAAIY,aAAa,GAAGL,UAAU,IAAIb,QAAQ,GAAG3F,WAAW,CAACY,SAAS,EAAE,CAAC;IACrE,IAAIiG,aAAa,GAAG,CAAC,EAAE;MACrBlB,QAAQ,GAAGA,QAAQ,GAAGkB,aAAa;IACrC;EACF;EACA,IAAIlB,QAAQ,KAAKG,SAAS,EAAE;IAC1BlF,SAAS,CAACZ,WAAW,EAAE2F,QAAQ,EAAE9I,OAAO,CAAC;EAC3C;AACF;AAEA,OAAO,SAASC,6BAA6B,CAACD,OAAO,EAAE;EACrD,IAAIiK,QAAQ,GAAG;IACbC,OAAO,EAAE,KAAK;IACdC,IAAI,EAAE;EACR,CAAC;EACD,OAAO5L,CAAC,CAACqJ,MAAM,CAAC,CAAC,CAAC,EAAEqC,QAAQ,EAAEjK,OAAO,CAAC;AACxC;;AAEA;AACA;AACA;AACA,OAAO,SAASoK,kBAAkB,CAACjH,WAAW,EAAE0D,QAAQ,EAAE7G,OAAO,EAAE;EACjE,IAAI8I,QAAQ;IACVuB,WAAW,GAAGlH,WAAW,CAAC0F,KAAK,EAAE;IACjCQ,aAAa,GAAGnL,QAAQ,CAAC2G,MAAM,CAACgC,QAAQ,EAAE,IAAI,CAAC;IAC/CyD,WAAW,GAAGjB,aAAa,CAACkB,CAAC;IAC7BC,QAAQ,GAAGnB,aAAa,CAACR,KAAK;EAEhC,IAAIyB,WAAW,GAAG,CAAC,EAAE;IACnBtG,UAAU,CAACb,WAAW,EAAEA,WAAW,CAACa,UAAU,EAAE,GAAGsG,WAAW,EAAEtK,OAAO,CAAC;EAC1E,CAAC,MAAM,IAAIsK,WAAW,GAAGE,QAAQ,GAAGH,WAAW,EAAE;IAC/C;IACAvB,QAAQ,GAAGe,IAAI,CAACE,IAAI,CAAC5G,WAAW,CAACa,UAAU,EAAE,GAAGsG,WAAW,GAAGE,QAAQ,GAAGH,WAAW,CAAC;IACrFrG,UAAU,CAACb,WAAW,EAAE2F,QAAQ,EAAE9I,OAAO,CAAC;EAC5C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS+D,SAAS,CAACZ,WAAW,EAAEY,SAAS,EAAE/D,OAAO,EAAE;EACzDA,OAAO,GAAGC,6BAA6B,CAACD,OAAO,CAAC;EAChD,IAAIyK,gBAAgB,GAAGhD,SAAS,CAACtE,WAAW,EAAE,GAAG,CAAC;EAClD,IAAIsH,gBAAgB,EAAE;IACpBA,gBAAgB,CAACC,kBAAkB,EAAE;EACvC;EAEA,IAAI1K,OAAO,CAACmK,IAAI,EAAE;IAChBhH,WAAW,CAACgH,IAAI,CAAC,QAAQ,CAAC;EAC5B;;EAEA;EACA,IAAI,CAACnK,OAAO,CAACkK,OAAO,EAAE;IACpB/G,WAAW,CAACY,SAAS,CAACA,SAAS,CAAC;IAChC,IAAI0G,gBAAgB,EAAE;MACpBA,gBAAgB,CAACE,iBAAiB,EAAE;IACtC;IACA;EACF;;EAEA;EACAC,gBAAgB,CAACzH,WAAW,EAAEY,SAAS,CAAC;EACxCZ,WAAW,CAAC0H,OAAO,CAAC,QAAQ,CAAC,CAACC,MAAM,CAAC,MAAM;IACzC,IAAIL,gBAAgB,EAAE;MACpBA,gBAAgB,CAACE,iBAAiB,EAAE;IACtC;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS3G,UAAU,CAACb,WAAW,EAAEa,UAAU,EAAEhE,OAAO,EAAE;EAC3DA,OAAO,GAAGC,6BAA6B,CAACD,OAAO,CAAC;EAChD,IAAIyK,gBAAgB,GAAGhD,SAAS,CAACtE,WAAW,EAAE,GAAG,CAAC;EAClD,IAAIsH,gBAAgB,EAAE;IACpBA,gBAAgB,CAACC,kBAAkB,EAAE;EACvC;EAEA,IAAI1K,OAAO,CAACmK,IAAI,EAAE;IAChBhH,WAAW,CAACgH,IAAI,CAAC,QAAQ,CAAC;EAC5B;;EAEA;EACA,IAAI,CAACnK,OAAO,CAACkK,OAAO,EAAE;IACpB/G,WAAW,CAACa,UAAU,CAACA,UAAU,CAAC;IAClC,IAAIyG,gBAAgB,EAAE;MACpBA,gBAAgB,CAACE,iBAAiB,EAAE;IACtC;IACA;EACF;;EAEA;EACAI,iBAAiB,CAAC5H,WAAW,EAAEa,UAAU,CAAC;EAC1Cb,WAAW,CAAC0H,OAAO,CAAC,QAAQ,CAAC,CAACC,MAAM,CAAC,MAAM;IACzC,IAAIL,gBAAgB,EAAE;MACpBA,gBAAgB,CAACE,iBAAiB,EAAE;IACtC;EACF,CAAC,CAAC;AACJ;AAEA,SAASC,gBAAgB,CAACzH,WAAW,EAAEY,SAAS,EAAE;EAChDZ,WAAW,CAAC+G,OAAO,CAAC;IAClBnG,SAAS,EAAEA;EACb,CAAC,EAAE;IACDiH,KAAK,EAAE;EACT,CAAC,CAAC,CACCC,OAAO,CAAC,QAAQ,CAAC;AACtB;AAEA,SAASF,iBAAiB,CAAC5H,WAAW,EAAEa,UAAU,EAAE;EAClDb,WAAW,CAAC+G,OAAO,CAAC;IAClBlG,UAAU,EAAEA;EACd,CAAC,EAAE;IACDgH,KAAK,EAAE;EACT,CAAC,CAAC,CACCC,OAAO,CAAC,QAAQ,CAAC;AACtB;AAEA,OAAO,SAASxD,SAAS,CAACtE,WAAW,EAAEjD,IAAI,EAAE;EAC3C,IAAIqH,UAAU,GAAGpE,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE;EACrD,OAAOjD,MAAM,CAACkN,IAAI,CAAC3D,UAAU,EAAEE,SAAS,IAAI;IAC1C,OAAOA,SAAS,CAACvH,IAAI,KAAKA,IAAI;EAChC,CAAC,CAAC;AACJ;AAEA,OAAO,SAASiL,cAAc,CAAChI,WAAW,EAAEnD,OAAO,EAAE;EACnD+D,SAAS,CAACZ,WAAW,EAAEA,WAAW,CAAC,CAAC,CAAC,CAACkB,YAAY,GAAGlB,WAAW,CAAC,CAAC,CAAC,CAACmB,YAAY,EAAEtE,OAAO,CAAC;AAC5F;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoL,gBAAgB,CAACC,QAAQ,EAAExM,YAAY,EAAE;EACvD,IAAI,CAACA,YAAY,IAAIA,YAAY,CAACa,MAAM,KAAK,CAAC,EAAE;IAC9C,OAAO,IAAI;EACb;EACA,OAAOb,YAAY,CAACyM,OAAO,EAAE,CAACC,KAAK,CAACvK,UAAU,IAAI;IAChD,IAAIwK,sBAAsB,GAAGtN,QAAQ,CAACoL,YAAY,CAAC/K,CAAC,CAACyC,UAAU,CAAC,CAAC;IACjE,OAAOwK,sBAAsB,CAACC,QAAQ,CAACJ,QAAQ,CAACd,CAAC,EAAEc,QAAQ,CAAC5B,CAAC,CAAC;EAChE,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASiC,QAAQ,CAACC,OAAO,EAAE3J,OAAO,EAAE;EACzCA,OAAO,CAAC4J,cAAc,GAAG,EAAE;EAC3BD,OAAO,CAACE,aAAa,EAAE,CAACC,IAAI,CAAC,YAAW;IACtC,IAAIC,aAAa,GAAGxN,CAAC,CAAC,IAAI,CAAC;IAC3BwN,aAAa,CAAC7J,EAAE,CAAC,QAAQ,EAAEF,OAAO,CAAC;IACnCA,OAAO,CAAC4J,cAAc,CAACvM,IAAI,CAAC0M,aAAa,CAAC;EAC5C,CAAC,CAAC;AACJ;AAEA,OAAO,SAASC,SAAS,CAAChK,OAAO,EAAE;EACjC,IAAI4J,cAAc,GAAG5J,OAAO,CAAC4J,cAAc;EAC3C,IAAI,CAACA,cAAc,EAAE;IACnB,MAAM,IAAI9L,KAAK,CAAC,gCAAgC,CAAC;EACnD;EACA,KAAK,IAAImG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2F,cAAc,CAAClM,MAAM,EAAEuG,CAAC,EAAE,EAAE;IAC9C,IAAIrC,KAAK,GAAGgI,cAAc,CAAC3F,CAAC,CAAC;IAC7BrC,KAAK,CAACZ,GAAG,CAAC,QAAQ,EAAEhB,OAAO,CAAC;EAC9B;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASiK,GAAG,CAACrI,KAAK,EAAE;EACzB,IAAI,CAACA,KAAK,CAACmD,SAAS,EAAE,IAAInD,KAAK,CAAC/C,GAAG,CAAC,UAAU,CAAC,KAAK,OAAO,EAAE;IAC3D;EACF;;EAEA;EACA;EACA;EACA,IAAIgE,MAAM,GAAGjB,KAAK,CAAC,CAAC,CAAC,CAACsI,qBAAqB,EAAE;EAC7CtI,KAAK,CACF/C,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,CACxBsL,OAAO,CAACtH,MAAM,CAACuH,IAAI,GAAGxI,KAAK,CAACyI,aAAa,EAAE,CAAC,CAC5CC,MAAM,CAACzH,MAAM,CAAC0H,GAAG,GAAG3I,KAAK,CAAC4I,YAAY,EAAE,CAAC,CACzCC,QAAQ,CAAC5H,MAAM,CAACgE,KAAK,CAAC,CACtB6D,SAAS,CAAC7H,MAAM,CAAC+D,MAAM,CAAC;AAC7B;;AAEA;AACA;AACA;AACA,OAAO,SAAS+D,KAAK,CAAC/I,KAAK,EAAEgJ,SAAS,EAAEzE,SAAS,EAAE;EACjD0E,YAAY,CAACD,SAAS,CAAC;EACvB,IAAIzE,SAAS,EAAE;IACb2E,MAAM,CAAClJ,KAAK,CAAC;IACb;EACF;EACA,OAAOvC,UAAU,CAAC,MAAM;IACtByL,MAAM,CAAClJ,KAAK,CAAC;EACf,CAAC,EAAE,EAAE,CAAC;AACR;AAEA,OAAO,SAASkJ,MAAM,CAAClJ,KAAK,EAAE;EAC5BA,KAAK,CAAC/C,GAAG,CAAC;IACRoG,QAAQ,EAAE,UAAU;IACpBmF,IAAI,EAAE,EAAE;IACRG,GAAG,EAAE,EAAE;IACP1D,KAAK,EAAE,EAAE;IACTD,MAAM,EAAE;EACV,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASmE,oBAAoB,CAAC5N,UAAU,EAAEP,OAAO,EAAE;EACxD,IAAIC,YAAY,GAAGF,cAAc,CAACC,OAAO,CAAC;EAC1C,IAAI,CAACC,YAAY,EAAE;IACjB;EACF;EAEA,IAAIkF,SAAS,EAAEC,UAAU;EACzBnF,YAAY,CAACE,OAAO,CAACoE,WAAW,IAAI;IAClC,IAAIhE,UAAU,CAAC6N,OAAO,CAAC7J,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;MACtCY,SAAS,GAAGZ,WAAW,CAACY,SAAS,EAAE;MACnCZ,WAAW,CAAClC,IAAI,CAAC,WAAW,EAAE8C,SAAS,CAAC;MACxCC,UAAU,GAAGb,WAAW,CAACa,UAAU,EAAE;MACrCb,WAAW,CAAClC,IAAI,CAAC,YAAY,EAAEkC,WAAW,CAACa,UAAU,EAAE,CAAC;MACxDzF,CAAC,CAACe,GAAG,CAACC,cAAc,EAAE,IAAIhB,CAAC,CAACe,GAAG,CAACE,KAAK,CAAC,6BAA6B,GAAG2D,WAAW,CAAC1D,IAAI,CAAC,OAAO,CAAC,GAAG,SAAS,GAAGsE,SAAS,GAAG,UAAU,GAAGC,UAAU,CAAC;IACpJ;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASiJ,sBAAsB,CAAC9N,UAAU,EAAEP,OAAO,EAAE;EAC1D,IAAIC,YAAY,GAAGF,cAAc,CAACC,OAAO,CAAC;EAC1C,IAAI,CAACC,YAAY,EAAE;IACjB;EACF;EAEA,IAAIkF,SAAS,EAAEC,UAAU;EACzBnF,YAAY,CAACE,OAAO,CAACoE,WAAW,IAAI;IAClC,IAAIhE,UAAU,CAAC6N,OAAO,CAAC7J,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;MACtCY,SAAS,GAAGZ,WAAW,CAAClC,IAAI,CAAC,WAAW,CAAC;MACzC,IAAI8C,SAAS,EAAE;QACbZ,WAAW,CAACY,SAAS,CAACA,SAAS,CAAC;QAChCZ,WAAW,CAACJ,UAAU,CAAC,WAAW,CAAC;MACrC;MACAiB,UAAU,GAAGb,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC;MAC3C,IAAI+C,UAAU,EAAE;QACdb,WAAW,CAACa,UAAU,CAACA,UAAU,CAAC;QAClCb,WAAW,CAACJ,UAAU,CAAC,YAAY,CAAC;MACtC;MACA;MACA;MACA;MACA;MACAiF,MAAM,CAAC7E,WAAW,CAAC;MACnB5E,CAAC,CAACe,GAAG,CAACC,cAAc,EAAE,IAAIhB,CAAC,CAACe,GAAG,CAACE,KAAK,CAAC,+BAA+B,GAAG2D,WAAW,CAAC1D,IAAI,CAAC,OAAO,CAAC,GAAG,SAAS,GAAGsE,SAAS,GAAG,UAAU,GAAGC,UAAU,CAAC;IACtJ;EACF,CAAC,CAAC;AACJ;AAEA,OAAO,SAAS8C,UAAU,CAAC3D,WAAW,EAAEyD,OAAO,EAAE;EAC/C,IAAI,CAACzD,WAAW,IAAI,CAACA,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC,EAAE;IACnD;EACF;EACA,IAAIsG,UAAU,GAAGpE,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC;EAC/C,IAAI,CAACsG,UAAU,EAAE;IACf;EACF;EACAA,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9B,IAAIA,SAAS,CAACa,QAAQ,EAAE;MACtBb,SAAS,CAACtI,UAAU,CAAC2H,UAAU,CAACF,OAAO,CAAC;IAC1C;EACF,CAAC,CAAC;AACJ;AAEA,OAAO,SAASsG,OAAO,CAAC/J,WAAW,EAAE+J,OAAO,EAAE;EAC5C,IAAI,CAAC/J,WAAW,IAAI,CAACA,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC,EAAE;IACnD;EACF;EACA,IAAIsG,UAAU,GAAGpE,WAAW,CAAClC,IAAI,CAAC,YAAY,CAAC;EAC/C,IAAI,CAACsG,UAAU,EAAE;IACf;EACF;EACAA,UAAU,CAACxI,OAAO,CAAC0I,SAAS,IAAI;IAC9B,IAAIA,SAAS,CAACa,QAAQ,EAAE;MACtBb,SAAS,CAACtI,UAAU,CAAC0B,GAAG,CAAC,SAAS,EAAEqM,OAAO,CAAC;IAC9C;EACF,CAAC,CAAC;AACJ;AAEA,OAAO,SAASC,oCAAoC,CAACC,QAAQ,EAAEC,WAAW,EAAEC,UAAU,EAAEC,kBAAkB,EAAE;EAC1G,IAAI3E,MAAM,GAAG,CAAC;EACdwE,QAAQ,CAACrO,OAAO,CAACyO,KAAK,IAAI;IACxB,IAAIA,KAAK,CAAC5E,MAAM,EAAE;MAChBA,MAAM,IAAI4E,KAAK,CAAC5E,MAAM;IACxB,CAAC,MAAM;MACL;MACAA,MAAM,IAAI2E,kBAAkB;IAC9B;IACA,IAAID,UAAU,CAACE,KAAK,CAAC,IAAIH,WAAW,CAACG,KAAK,CAAC,CAAC9N,MAAM,GAAG,CAAC,EAAE;MACtDkJ,MAAM,IAAIuE,oCAAoC,CAACE,WAAW,CAACG,KAAK,CAAC,EAAEH,WAAW,EAAEC,UAAU,EAAEC,kBAAkB,CAAC;IACjH;EACF,CAAC,CAAC;EACF,OAAO3E,MAAM;AACf;AAEA,OAAO,SAAS6E,sBAAsB,CAACvM,MAAM,EAAE;EAC7C,IAAIwM,gBAAgB,GAAGxM,MAAM,CAACoM,UAAU,CAACpM,MAAM,CAACyF,OAAO,CAAC;EACxD,IAAIyG,QAAQ,GAAGlM,MAAM,CAACmM,WAAW,CAACnM,MAAM,CAACyF,OAAO,CAAC;EACjD,IAAIgH,iBAAiB,GAAGzM,MAAM,CAAC2F,QAAQ,CAACI,QAAQ,EAAE,CAACsF,GAAG;EACtD,IAAIqB,YAAY,GAAG1M,MAAM,CAACyF,OAAO,CAACiC,MAAM;EACxC,IAAIiF,YAAY,GAAG3M,MAAM,CAACiC,WAAW,CAACY,SAAS,EAAE;;EAEjD;EACA,IAAI,CAAC2J,gBAAgB,EAAE;IACrB;IACA,IAAIC,iBAAiB,GAAGC,YAAY,EAAE;MACpC,IAAIE,YAAY,GAAGjE,IAAI,CAACC,GAAG,CAAC+D,YAAY,IAAID,YAAY,GAAGD,iBAAiB,CAAC,EAAE,CAAC,CAAC;MACjF5J,SAAS,CAAC7C,MAAM,CAACiC,WAAW,EAAE2K,YAAY,EAAE;QAC1C5D,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;EACF,CAAC,MAAM,IAAIwD,gBAAgB,IAAIN,QAAQ,CAAC1N,MAAM,GAAG,CAAC,EAAE;IAClD;IACA,IAAIqO,cAAc,GAAG7M,MAAM,CAACiC,WAAW,CAACyF,MAAM,EAAE;;IAEhD;IACA,IAAIoF,eAAe,GAAGb,oCAAoC,CAACC,QAAQ,EAAElM,MAAM,CAACmM,WAAW,EAAEnM,MAAM,CAACoM,UAAU,EAAEpM,MAAM,CAACqM,kBAAkB,CAAC;;IAEtI;IACA,IAAIU,gBAAgB,GAAGD,eAAe,GAAI,GAAG,GAAGJ,YAAa;IAC7D,IAAI9E,QAAQ,GAAG6E,iBAAiB,GAAGM,gBAAgB;IACnD;IACA,IAAIC,YAAY,GAAGL,YAAY,GAAGhE,IAAI,CAACsE,GAAG,CAACrF,QAAQ,GAAGiF,cAAc,EAAEJ,iBAAiB,GAAGC,YAAY,CAAC;IACvG;IACA,IAAIM,YAAY,GAAGL,YAAY,EAAE;MAC/B9J,SAAS,CAAC7C,MAAM,CAACiC,WAAW,EAAE+K,YAAY,EAAE;QAC1ChE,OAAO,EAAE,IAAI;QACbC,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;EACF;EAEA,IAAIiD,QAAQ,CAAC1N,MAAM,GAAG,CAAC,EAAE;IACvB;IACA,IAAI0O,YAAY,GAAGvE,IAAI,CAACC,GAAG,CAAC5I,MAAM,CAACyF,OAAO,CAAC0H,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,GAAGnN,MAAM,CAACoN,gBAAgB;IAClFtK,UAAU,CAAC9C,MAAM,CAACiC,WAAW,EAAEiL,YAAY,EAAE;MAC3ClE,OAAO,EAAE,IAAI;MACbC,IAAI,EAAE;IACR,CAAC,CAAC;EACJ;AACF;AAEA,eAAe;EACbsD,sBAAsB;EACtBxB,GAAG;EACHtN,cAAc;EACdoB,OAAO;EACPoB,mBAAmB;EACnBgG,iBAAiB;EACjBG,aAAa;EACb8D,gBAAgB;EAChBhE,iBAAiB;EACjBJ,eAAe;EACfgF,SAAS;EACTN,QAAQ;EACRwB,OAAO;EACPhO,cAAc;EACdS,gBAAgB;EAChB4I,KAAK;EACL0E,sBAAsB;EACtB7C,kBAAkB;EAClBpG,UAAU;EACV8E,QAAQ;EACRqC,cAAc;EACdpH,SAAS;EACT0D,SAAS;EACTX,UAAU;EACViG,oBAAoB;EACpBJ,KAAK;EACL1E,SAAS;EACTpF,qBAAqB;EACrBmF;AACF,CAAC"},"metadata":{},"sourceType":"module"}