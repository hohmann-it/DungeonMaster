{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, scout, strings } from '../index';\nimport $ from 'jquery';\n\n/**\n * Represents a robust \"call\" that, when it fails, is retried automatically for a specific\n * number of times, before failing ultimately. The call implementation must be provided\n * by a subclass by overriding the _callImpl() method.\n */\nexport default class Call {\n  constructor() {\n    // Delays in ms between retries (from left to right). The call eventually fails when this list gets empty.\n    // Example: [100, 500, 500, 500]\n    this.retryIntervals = [];\n\n    // Minimal assumed call duration (throttles consecutive calls)\n    this.minCallDuration = 500; // ms\n\n    // Counts how many times this call was actually performed (normally, only 1 try is expected)\n    this.callCounter = 0;\n    this.deferred = $.Deferred();\n    this.aborted = false;\n    this.pendingCall = null;\n    this.type = null; // Identifier for the type of call (default is 'call'), used to build the uniqueName\n    this.name = null; // Identifier for the call, used to build the uniqueName\n    this.uniqueName = null; // Unique identifier of this call instance for logging and debugging purposes\n    this.logPrefix = ''; // All log messages are prefixed with this string. It contains the uniqueName and the current state (e.g. callCounter)\n\n    // Temporary store for the arguments to the done/fail callbacks of the _callImpl() function.\n    // They will be used be _resolve() and _reject(). We could pass them through the _onCallX functions,\n    // but when a call is aborted while it is only scheduled (setTimeout), we would not have any values\n    // to pass to _reject().\n    this.result = null;\n  }\n  init(model) {\n    $.extend(this, model);\n\n    // Ensure \"retryIntervals\" is a valid array\n    if (typeof this.maxRetries === 'number') {\n      this.retryIntervals = arrays.init(this.maxRetries, 0);\n    } else {\n      // Do not modify the passed value -> create a copy\n      this.retryIntervals = this.retryIntervals ? this.retryIntervals.slice() : [];\n      // Remember initial number of retries (for logging)\n      this.maxRetries = this.retryIntervals.length;\n    }\n\n    // Assign a unique name to the call to help distinguish different calls in the log\n    this.uniqueName = scout.nvl(this.type, 'call') + '-' + Call.GLOBAL_SEQ++ + strings.box(' ', this.name, '');\n    this.initialized = true;\n  }\n  _checkInitialized() {\n    if (!this.initialized) {\n      throw new Error('Not initialized');\n    }\n  }\n  _updateLogPrefix() {\n    this.logPrefix = this.callCounter + '/' + (this.maxRetries + 1) + ' [' + this.uniqueName + '] ';\n  }\n  _resolve() {\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[RESOLVE]');\n    this.deferred.resolve(...arrays.ensure(this.result));\n  }\n  _reject() {\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[REJECT]');\n    this.deferred.reject(...arrays.ensure(this.result));\n  }\n  _setResult() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this.result = args;\n  }\n\n  // ==================================================================================\n\n  /**\n   * Performs the call with retries.\n   *\n   * Returns a promise that is ...\n   * ... RESOLVED when the call was successful (possibly after some retries).\n   * ... REJECTED when the call failed and no more retries are possible.\n   *\n   *\n   *     | (promise)\n   *     |   ^\n   *     v   |\n   *   +--------+           +---------+           .---------------.  (yes)\n   *   | call() | . . . . . | _call() | ------>  <    success?     > ------> [RESOLVE]\n   *   +--------+           +---------+           '---------------'\n   *                             ^                       |(no)\n   *                             |                       |\n   *                             |                       v\n   *                             |                .---------------.  (yes)\n   *                             |               <    aborted?     > ------> [REJECT]\n   *                             |                '---------------'\n   *                             |                       |(no)\n   *                             |                       |\n   *                             |                       v\n   *                             |                .---------------.  (no)\n   *                             |               < retry possible? > ------> [REJECT]\n   *                             |                '---------------'\n   *                             |                       |(yes)\n   *                             |        sleep          |\n   *                             +-------- %%% ----------+\n   */\n  call() {\n    this._checkInitialized();\n    this._call();\n    return this.deferred.promise();\n  }\n\n  /**\n   * Aborts the call. If the request is currently running, it is aborted (interrupted).\n   * If a retry is scheduled, that retry is cancelled.\n   *\n   * The promise returned by call() is REJECTED.\n   */\n  abort() {\n    this._checkInitialized();\n    this._abort();\n  }\n\n  // ==================================================================================\n\n  _call() {\n    if (this.aborted) {\n      throw new Error('Call is aborted');\n    }\n    this.callTimeoutId = null;\n    this.callStartTimestamp = Date.now();\n    this.callCounter++;\n    this._updateLogPrefix();\n    this.pendingCall = this._callImpl().always(() => {\n      this.pendingCall = null;\n    }).done(this._setResultDone.bind(this)).done(this._onCallDone.bind(this)).fail(this._setResultFail.bind(this)).fail(this._onCallFail.bind(this));\n  }\n\n  /**\n   * Performs the actual request.\n   *\n   * >>> This method MUST be implemented by a subclass. <<<\n   */\n  _callImpl() {\n    throw new Error('Missing implementation: _callImpl()');\n  }\n  _setResultDone() {\n    this._setResult(...arguments);\n  }\n  _setResultFail() {\n    this._setResult(...arguments);\n  }\n  _onCallDone() {\n    // Call successful -> RESOLVE\n    this._resolve();\n  }\n  _onCallFail() {\n    // Aborted? -> REJECT\n    if (this.aborted) {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Call aborted');\n      this._reject();\n      return;\n    }\n\n    // Retry impossible? -> REJECT\n    let nextInterval = this._nextRetryImpl(...arguments);\n    if (typeof nextInterval !== 'number') {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'No retries remaining');\n      this._reject();\n      return;\n    }\n\n    // Retry\n    let callDuration = Date.now() - this.callStartTimestamp;\n    let additionalDelay = Math.max(this.minCallDuration - callDuration, 0);\n    let retryInterval = nextInterval + additionalDelay;\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Try again in ' + retryInterval + ' ms...');\n    this.callTimeoutId = setTimeout(this._call.bind(this), retryInterval);\n  }\n\n  /**\n   * Checks if the call can be retried. If a number is returned, a retry is performed\n   * with a delay of the corresponding amount of milliseconds.\n   *\n   * All other values indicate that no retry must be performed. (It is recommended\n   * to return 'false' or 'null' in this case.)\n   *\n   * >>> This method MAY be overridden by a subclass. <<<\n   */\n  _nextRetryImpl() {\n    if (this.retryIntervals.length) {\n      return this.retryIntervals.shift();\n    }\n    return false;\n  }\n\n  // ==================================================================================\n\n  _abort() {\n    this.aborted = true;\n\n    // Abort while waiting for the next retry (there is no running call)\n    if (this.callTimeoutId) {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Cancelled scheduled retry');\n      clearTimeout(this.callTimeoutId);\n      this.callTimeoutId = null;\n      this._reject();\n      return;\n    }\n\n    // Abort a running call\n    this._abortImpl();\n  }\n\n  /**\n   * >>> This method MAY be overridden by a subclass. <<<\n   */\n  _abortImpl() {\n    if (this.pendingCall && typeof this.pendingCall.abort === 'function') {\n      this.pendingCall.abort();\n    }\n  }\n}\n_defineProperty(Call, \"GLOBAL_SEQ\", 0);","map":{"version":3,"names":["arrays","scout","strings","$","Call","constructor","retryIntervals","minCallDuration","callCounter","deferred","Deferred","aborted","pendingCall","type","name","uniqueName","logPrefix","result","init","model","extend","maxRetries","slice","length","nvl","GLOBAL_SEQ","box","initialized","_checkInitialized","Error","_updateLogPrefix","_resolve","log","isTraceEnabled","trace","resolve","ensure","_reject","reject","_setResult","args","call","_call","promise","abort","_abort","callTimeoutId","callStartTimestamp","Date","now","_callImpl","always","done","_setResultDone","bind","_onCallDone","fail","_setResultFail","_onCallFail","nextInterval","_nextRetryImpl","callDuration","additionalDelay","Math","max","retryInterval","setTimeout","shift","clearTimeout","_abortImpl"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/Call.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, scout, strings} from '../index';\nimport $ from 'jquery';\n\n/**\n * Represents a robust \"call\" that, when it fails, is retried automatically for a specific\n * number of times, before failing ultimately. The call implementation must be provided\n * by a subclass by overriding the _callImpl() method.\n */\nexport default class Call {\n\n  constructor() {\n    // Delays in ms between retries (from left to right). The call eventually fails when this list gets empty.\n    // Example: [100, 500, 500, 500]\n    this.retryIntervals = [];\n\n    // Minimal assumed call duration (throttles consecutive calls)\n    this.minCallDuration = 500; // ms\n\n    // Counts how many times this call was actually performed (normally, only 1 try is expected)\n    this.callCounter = 0;\n\n    this.deferred = $.Deferred();\n    this.aborted = false;\n    this.pendingCall = null;\n    this.type = null; // Identifier for the type of call (default is 'call'), used to build the uniqueName\n    this.name = null; // Identifier for the call, used to build the uniqueName\n    this.uniqueName = null; // Unique identifier of this call instance for logging and debugging purposes\n    this.logPrefix = ''; // All log messages are prefixed with this string. It contains the uniqueName and the current state (e.g. callCounter)\n\n    // Temporary store for the arguments to the done/fail callbacks of the _callImpl() function.\n    // They will be used be _resolve() and _reject(). We could pass them through the _onCallX functions,\n    // but when a call is aborted while it is only scheduled (setTimeout), we would not have any values\n    // to pass to _reject().\n    this.result = null;\n  }\n\n  static GLOBAL_SEQ = 0;\n\n  init(model) {\n    $.extend(this, model);\n\n    // Ensure \"retryIntervals\" is a valid array\n    if (typeof this.maxRetries === 'number') {\n      this.retryIntervals = arrays.init(this.maxRetries, 0);\n    } else {\n      // Do not modify the passed value -> create a copy\n      this.retryIntervals = (this.retryIntervals ? this.retryIntervals.slice() : []);\n      // Remember initial number of retries (for logging)\n      this.maxRetries = this.retryIntervals.length;\n    }\n\n    // Assign a unique name to the call to help distinguish different calls in the log\n    this.uniqueName = scout.nvl(this.type, 'call') + '-' + (Call.GLOBAL_SEQ++) + strings.box(' ', this.name, '');\n\n    this.initialized = true;\n  }\n\n  _checkInitialized() {\n    if (!this.initialized) {\n      throw new Error('Not initialized');\n    }\n  }\n\n  _updateLogPrefix() {\n    this.logPrefix = this.callCounter + '/' + (this.maxRetries + 1) + ' [' + this.uniqueName + '] ';\n  }\n\n  _resolve() {\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[RESOLVE]');\n    this.deferred.resolve(...arrays.ensure(this.result));\n  }\n\n  _reject() {\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[REJECT]');\n    this.deferred.reject(...arrays.ensure(this.result));\n  }\n\n  _setResult(...args) {\n    this.result = args;\n  }\n\n  // ==================================================================================\n\n  /**\n   * Performs the call with retries.\n   *\n   * Returns a promise that is ...\n   * ... RESOLVED when the call was successful (possibly after some retries).\n   * ... REJECTED when the call failed and no more retries are possible.\n   *\n   *\n   *     | (promise)\n   *     |   ^\n   *     v   |\n   *   +--------+           +---------+           .---------------.  (yes)\n   *   | call() | . . . . . | _call() | ------>  <    success?     > ------> [RESOLVE]\n   *   +--------+           +---------+           '---------------'\n   *                             ^                       |(no)\n   *                             |                       |\n   *                             |                       v\n   *                             |                .---------------.  (yes)\n   *                             |               <    aborted?     > ------> [REJECT]\n   *                             |                '---------------'\n   *                             |                       |(no)\n   *                             |                       |\n   *                             |                       v\n   *                             |                .---------------.  (no)\n   *                             |               < retry possible? > ------> [REJECT]\n   *                             |                '---------------'\n   *                             |                       |(yes)\n   *                             |        sleep          |\n   *                             +-------- %%% ----------+\n   */\n  call() {\n    this._checkInitialized();\n    this._call();\n    return this.deferred.promise();\n  }\n\n  /**\n   * Aborts the call. If the request is currently running, it is aborted (interrupted).\n   * If a retry is scheduled, that retry is cancelled.\n   *\n   * The promise returned by call() is REJECTED.\n   */\n  abort() {\n    this._checkInitialized();\n    this._abort();\n  }\n\n  // ==================================================================================\n\n  _call() {\n    if (this.aborted) {\n      throw new Error('Call is aborted');\n    }\n\n    this.callTimeoutId = null;\n    this.callStartTimestamp = Date.now();\n    this.callCounter++;\n    this._updateLogPrefix();\n\n    this.pendingCall = this._callImpl()\n      .always(() => {\n        this.pendingCall = null;\n      })\n      .done(this._setResultDone.bind(this))\n      .done(this._onCallDone.bind(this))\n      .fail(this._setResultFail.bind(this))\n      .fail(this._onCallFail.bind(this));\n  }\n\n  /**\n   * Performs the actual request.\n   *\n   * >>> This method MUST be implemented by a subclass. <<<\n   */\n  _callImpl() {\n    throw new Error('Missing implementation: _callImpl()');\n  }\n\n  _setResultDone(...args) {\n    this._setResult(...args);\n  }\n\n  _setResultFail(...args) {\n    this._setResult(...args);\n  }\n\n  _onCallDone() {\n    // Call successful -> RESOLVE\n    this._resolve();\n  }\n\n  _onCallFail(...args) {\n    // Aborted? -> REJECT\n    if (this.aborted) {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Call aborted');\n      this._reject();\n      return;\n    }\n\n    // Retry impossible? -> REJECT\n    let nextInterval = this._nextRetryImpl(...args);\n    if (typeof nextInterval !== 'number') {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'No retries remaining');\n      this._reject();\n      return;\n    }\n\n    // Retry\n    let callDuration = Date.now() - this.callStartTimestamp;\n    let additionalDelay = Math.max(this.minCallDuration - callDuration, 0);\n    let retryInterval = nextInterval + additionalDelay;\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Try again in ' + retryInterval + ' ms...');\n    this.callTimeoutId = setTimeout(this._call.bind(this), retryInterval);\n  }\n\n  /**\n   * Checks if the call can be retried. If a number is returned, a retry is performed\n   * with a delay of the corresponding amount of milliseconds.\n   *\n   * All other values indicate that no retry must be performed. (It is recommended\n   * to return 'false' or 'null' in this case.)\n   *\n   * >>> This method MAY be overridden by a subclass. <<<\n   */\n  _nextRetryImpl() {\n    if (this.retryIntervals.length) {\n      return this.retryIntervals.shift();\n    }\n    return false;\n  }\n\n  // ==================================================================================\n\n  _abort() {\n    this.aborted = true;\n\n    // Abort while waiting for the next retry (there is no running call)\n    if (this.callTimeoutId) {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Cancelled scheduled retry');\n      clearTimeout(this.callTimeoutId);\n      this.callTimeoutId = null;\n      this._reject();\n      return;\n    }\n\n    // Abort a running call\n    this._abortImpl();\n  }\n\n  /**\n   * >>> This method MAY be overridden by a subclass. <<<\n   */\n  _abortImpl() {\n    if (this.pendingCall && typeof this.pendingCall.abort === 'function') {\n      this.pendingCall.abort();\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}