{"ast":null,"code":"/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Accordion, arrays, EventDelegator, FilterSupport, Group, KeyStrokeContext, objects, scout, TileAccordionLayout, TileAccordionSelectionHandler, TileTextFilter } from '../../index';\nexport default class TileAccordion extends Accordion {\n  constructor() {\n    super();\n    this.exclusiveExpand = false;\n    this.gridColumnCount = null;\n    this.multiSelect = null;\n    this.selectable = null;\n    this.takeTileFiltersFromGroup = true;\n    this.tileComparator = null;\n    this.filters = [];\n    this.tileGridLayoutConfig = null;\n    this.tileGridSelectionHandler = new TileAccordionSelectionHandler(this);\n    this.withPlaceholders = null;\n    this.virtual = null;\n    this.$filterFieldContainer = null;\n    this.textFilterEnabled = false;\n    this.filterSupport = this._createFilterSupport();\n    this.createTextFilter = null;\n    this.updateTextFilterText = null;\n    this._selectionUpdateLocked = false;\n    this._tileGridPropertyChangeHandler = this._onTileGridPropertyChange.bind(this);\n    this._groupBodyHeightChangeHandler = this._onGroupBodyHeightChange.bind(this);\n  }\n\n  /**\n   * @override\n   */\n  _render() {\n    super._render();\n    this.$container.addClass('tile-accordion');\n    this.$filterFieldContainer = this.$container.prependDiv('filter-field-container');\n  }\n  _createLayout() {\n    return new TileAccordionLayout(this);\n  }\n  _renderProperties() {\n    super._renderProperties();\n    this._renderTextFilterEnabled();\n  }\n  _remove() {\n    this.filterSupport.remove();\n    super._remove();\n  }\n  _init(model) {\n    super._init(model);\n    this.setFilters(this.filters);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initGroup(group) {\n    super._initGroup(group);\n    group.body.setSelectionHandler(this.tileGridSelectionHandler);\n\n    // Copy properties from accordion to new group. If the properties are not set yet, copy them from the group to the accordion\n    // This gives the possibility to either define the properties on the accordion or on the tileGrid initially\n    if (this.gridColumnCount !== null) {\n      group.body.setGridColumnCount(this.gridColumnCount);\n    }\n    this.setProperty('gridColumnCount', group.body.gridColumnCount);\n    if (this.multiSelect !== null) {\n      group.body.setMultiSelect(this.multiSelect);\n    }\n    this.setProperty('multiSelect', group.body.multiSelect);\n    if (this.selectable !== null) {\n      group.body.setSelectable(this.selectable);\n    }\n    this.setProperty('selectable', group.body.selectable);\n    if (this.tileGridLayoutConfig !== null) {\n      group.body.setLayoutConfig(this.tileGridLayoutConfig);\n    }\n    this.setProperty('tileGridLayoutConfig', group.body.layoutConfig);\n    if (this.tileComparator !== null) {\n      group.body.setComparator(this.tileComparator);\n      group.body.sort();\n    }\n    this.setProperty('tileComparator', group.body.comparator);\n    if (this.filters.length > 0) {\n      group.body.addFilter(this.filters);\n    }\n    if (this.takeTileFiltersFromGroup) {\n      this.setFilters(group.body.filters);\n    }\n    if (this.withPlaceholders !== null) {\n      group.body.setWithPlaceholders(this.withPlaceholders);\n    }\n    this.setProperty('withPlaceholders', group.body.withPlaceholders);\n    if (this.virtual !== null) {\n      group.body.setVirtual(this.virtual);\n    }\n    this.setProperty('virtual', group.body.virtual);\n    if (group.body.selectedTiles.length > 0) {\n      this._handleSelectionChanged(group.body);\n    }\n    group.body.on('propertyChange', this._tileGridPropertyChangeHandler);\n    this._handleCollapsed(group);\n\n    // Delegate events so that consumers don't need to attach a listener to each tile grid by themselves\n    group.body.__tileAccordionEventDelegator = EventDelegator.create(group.body, this, {\n      delegateEvents: ['tileClick', 'tileAction']\n    });\n  }\n\n  /**\n   * @override\n   */\n  _deleteGroup(group) {\n    if (group.body) {\n      group.body.off('propertyChange', this._tileGridPropertyChangeHandler);\n      group.body.__tileAccordionEventDelegator.destroy();\n      group.body.__tileAccordionEventDelegator = null;\n    }\n    super._deleteGroup(group);\n  }\n\n  /**\n   * @override\n   */\n  setGroups(groups) {\n    let oldTileCount = this.getTileCount();\n    let oldFilteredTileCount = this.getFilteredTileCount();\n    let oldSelectedTileCount = this.getSelectedTileCount();\n    super.setGroups(groups);\n    let tileCount = this.getTileCount();\n    let filteredTileCount = this.getFilteredTileCount();\n    let selectedTileCount = this.getSelectedTileCount();\n\n    // Trigger artificial property changes if necessary\n    // See _onTileGridPropertyChange why parameters are null\n    if (tileCount !== oldTileCount) {\n      this.triggerPropertyChange('tiles', null, null);\n    }\n    if (filteredTileCount !== oldFilteredTileCount) {\n      this.triggerPropertyChange('filteredTiles', null, null);\n    }\n    if (selectedTileCount !== oldSelectedTileCount) {\n      this.triggerPropertyChange('selectedTiles', null, null);\n    }\n  }\n  setGridColumnCount(gridColumnCount) {\n    this.groups.forEach(group => {\n      group.body.setGridColumnCount(gridColumnCount);\n    });\n    this.setProperty('gridColumnCount', gridColumnCount);\n  }\n  setTileGridLayoutConfig(layoutConfig) {\n    this.groups.forEach(group => {\n      group.body.setLayoutConfig(layoutConfig);\n      layoutConfig = group.body.layoutConfig; // May be converted from plain object to TileGridLayoutConfig\n    });\n\n    this.setProperty('tileGridLayoutConfig', layoutConfig);\n  }\n  setWithPlaceholders(withPlaceholders) {\n    this.groups.forEach(group => {\n      group.body.setWithPlaceholders(withPlaceholders);\n    });\n    this.setProperty('withPlaceholders', withPlaceholders);\n  }\n  setVirtual(virtual) {\n    this.groups.forEach(group => {\n      group.body.setVirtual(virtual);\n    });\n    this.setProperty('virtual', virtual);\n  }\n  setSelectable(selectable) {\n    this.groups.forEach(group => {\n      group.body.setSelectable(selectable);\n    });\n    this.setProperty('selectable', selectable);\n  }\n  setMultiSelect(multiSelect) {\n    this.groups.forEach(group => {\n      group.body.setMultiSelect(multiSelect);\n    });\n    this.setProperty('multiSelect', multiSelect);\n  }\n  getGroupById(id) {\n    return arrays.find(this.groups, group => {\n      return group.id === id;\n    });\n  }\n  getGroupByTile(tile) {\n    return tile.findParent(parent => {\n      return parent instanceof Group;\n    });\n  }\n\n  /**\n   * Distribute the tiles to the corresponding groups and returns an object with group id as key and array of tiles as value.\n   * Always returns all current groups even if the given tiles may not be distributed to all groups.\n   */\n  _groupTiles(tiles) {\n    // Create a map of groups, key is the id, value is an array of tiles\n    let tilesPerGroup = {};\n    this.groups.forEach(group => {\n      tilesPerGroup[group.id] = [];\n    });\n\n    // Distribute the tiles to the corresponding groups\n    tiles.forEach(function (tile) {\n      let group = this.getGroupByTile(tile);\n      if (!group) {\n        throw new Error('No group found for tile ' + tile.id);\n      }\n      if (!tilesPerGroup[group.id]) {\n        tilesPerGroup[group.id] = [];\n      }\n      tilesPerGroup[group.id].push(tile);\n    }, this);\n    return tilesPerGroup;\n  }\n  deleteTile(tile) {\n    this.deleteTiles([tile]);\n  }\n  deleteTiles(tilesToDelete, appendPlaceholders) {\n    tilesToDelete = arrays.ensure(tilesToDelete);\n    if (tilesToDelete.length === 0) {\n      return;\n    }\n    let tiles = this.getTiles();\n    arrays.removeAll(tiles, tilesToDelete);\n    this.setTiles(tiles, appendPlaceholders);\n  }\n  deleteAllTiles() {\n    this.setTiles([]);\n  }\n\n  /**\n   * Distributes the given tiles to their corresponding groups.\n   * <p>\n   * If the list contains new tiles not assigned to a group yet, an exception will be thrown.\n   */\n  setTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    if (objects.equals(this.getTiles(), tiles)) {\n      return;\n    }\n\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    // Distribute the tiles to the corresponding groups (result may contain groups without tiles)\n    let tilesPerGroup = this._groupTiles(tiles);\n\n    // Update the tile grids\n    for (let id in tilesPerGroup) {\n      // NOSONAR\n      let group = this.getGroupById(id);\n      group.body.setTiles(tilesPerGroup[id]);\n    }\n  }\n  getTiles() {\n    let tiles = [];\n    this.groups.forEach(group => {\n      arrays.pushAll(tiles, group.body.tiles);\n    });\n    return tiles;\n  }\n  getTileCount() {\n    let count = 0;\n    this.groups.forEach(group => {\n      count += group.body.tiles.length;\n    });\n    return count;\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to add.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  addFilter(filter) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.addFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to remove.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  removeFilter(filter) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.removeFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The new filters.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  setFilters(filters) {\n    let applyFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.filterSupport.setFilters(filters, applyFilter);\n  }\n  _setFilters(filters) {\n    filters = arrays.ensure(filters);\n    this.groups.forEach(group => {\n      group.body.setFilters(filters.slice(), false);\n    });\n    this._setProperty('filters', filters.slice());\n  }\n  filter() {\n    this.filterSupport.filter();\n  }\n  _filter() {\n    this.groups.forEach(group => group.body.filter());\n  }\n\n  /**\n   * @returns {FilterSupport}\n   */\n  _createFilterSupport() {\n    return new FilterSupport({\n      widget: this,\n      $container: () => this.$filterFieldContainer,\n      filterElements: this._filter.bind(this),\n      createTextFilter: this._createTextFilter.bind(this),\n      updateTextFilterText: this._updateTextFilterText.bind(this)\n    });\n  }\n  _createTextFilter() {\n    if (objects.isFunction(this.createTextFilter)) {\n      return this.createTextFilter();\n    }\n    return new TileTextFilter();\n  }\n  _updateTextFilterText(filter, text) {\n    if (objects.isFunction(this.updateTextFilterText)) {\n      return this.updateTextFilterText(filter, text);\n    }\n    if (filter instanceof TileTextFilter) {\n      return filter.setText(text);\n    }\n    return false;\n  }\n  setTextFilterEnabled(textFilterEnabled) {\n    this.setProperty('textFilterEnabled', textFilterEnabled);\n  }\n  isTextFilterFieldVisible() {\n    return this.textFilterEnabled;\n  }\n  _renderTextFilterEnabled() {\n    this.filterSupport.renderFilterField();\n  }\n  getFilteredTiles() {\n    let tiles = [];\n    this.groups.forEach(group => {\n      arrays.pushAll(tiles, group.body.filteredTiles);\n    });\n    return tiles;\n  }\n  getFilteredTileCount() {\n    let count = 0;\n    this.groups.forEach(group => {\n      count += group.body.filteredTiles.length;\n    });\n    return count;\n  }\n\n  /**\n   * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are returned.\n   */\n  getVisibleTiles() {\n    let tiles = [];\n    this.expandedGroups().forEach(group => {\n      arrays.pushAll(tiles, group.body.filteredTiles);\n    });\n    return tiles;\n  }\n\n  /**\n   * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are counted.\n   */\n  getVisibleTileCount() {\n    let count = 0;\n    this.expandedGroups().forEach(group => {\n      count += group.body.filteredTiles.length;\n    });\n    return count;\n  }\n  findVisibleTileIndexAt(x, y, startIndex, reverse) {\n    startIndex = scout.nvl(startIndex, 0);\n    return arrays.findIndexFrom(this.getVisibleTiles(), startIndex, (tile, i) => {\n      return this.getVisibleGridX(tile) === x && this.getVisibleGridY(tile) === y;\n    }, reverse);\n  }\n\n  /**\n   * Selects the given tiles and deselects the previously selected ones.\n   */\n  selectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    // Split tiles into separate lists for each group (result may contain groups without tiles)\n    let tilesPerGroup = this._groupTiles(tiles);\n\n    // Select the tiles in the the corresponding tile grids\n    for (let id in tilesPerGroup) {\n      // NOSONAR\n      let group = this.getGroupById(id);\n      group.body.selectTiles(tilesPerGroup[id]);\n    }\n  }\n  selectTile(tile) {\n    this.selectTiles([tile]);\n  }\n\n  /**\n   * Selects all tiles. As for every selection operation: only considers filtered tiles and tiles of expanded groups\n   */\n  selectAllTiles() {\n    this.selectTiles(this.getVisibleTiles());\n  }\n  deselectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    let selectedTiles = this.getSelectedTiles().slice();\n    if (arrays.removeAll(selectedTiles, tiles)) {\n      this.selectTiles(selectedTiles);\n    }\n  }\n  deselectTile(tile) {\n    this.deselectTiles([tile]);\n  }\n  deselectAllTiles() {\n    this.selectTiles([]);\n  }\n  addTilesToSelection(tiles) {\n    tiles = arrays.ensure(tiles);\n    this.selectTiles(this.getSelectedTiles().concat(tiles));\n  }\n  addTileToSelection(tile) {\n    this.addTilesToSelection([tile]);\n  }\n  getSelectedTiles() {\n    let selectedTiles = [];\n    this.groups.forEach(group => {\n      arrays.pushAll(selectedTiles, group.body.selectedTiles);\n    });\n    return selectedTiles;\n  }\n  getSelectedTile() {\n    return this.getSelectedTiles()[0];\n  }\n  getSelectedTileCount() {\n    let count = 0;\n    this.groups.forEach(group => {\n      count += group.body.selectedTiles.length;\n    });\n    return count;\n  }\n  toggleSelection() {\n    if (this.getSelectedTileCount() === this.getVisibleTileCount()) {\n      this.deselectAllTiles();\n    } else {\n      this.selectAllTiles();\n    }\n  }\n  setTileComparator(comparator) {\n    this.groups.forEach(group => {\n      group.body.setComparator(comparator);\n    });\n    this.setProperty('tileComparator', comparator);\n  }\n  sortTiles() {\n    this.groups.forEach(group => {\n      group.body.sort();\n    });\n  }\n  setFocusedTile(tile) {\n    let groupForTile = null;\n    if (tile !== null) {\n      groupForTile = this.getGroupByTile(tile);\n    }\n    this.groups.forEach(group => {\n      if (group === groupForTile) {\n        group.body.setFocusedTile(tile);\n      } else {\n        group.body.setFocusedTile(null);\n      }\n    });\n  }\n  getFocusedTile() {\n    let focusedTile = null;\n    this.groups.some(group => {\n      if (group.body.focusedTile) {\n        focusedTile = group.body.focusedTile;\n        return true;\n      }\n      return false;\n    });\n    return focusedTile;\n  }\n  getVisibleGridRowCount() {\n    return this.expandedGroups().reduce((acc, group) => {\n      return acc + group.body.logicalGrid.gridRows;\n    }, 0);\n  }\n  getVisibleGridX(tile) {\n    return tile.gridData.x;\n  }\n  getVisibleGridY(tile) {\n    let group = this.getGroupByTile(tile);\n    let yCorr = this.getVisibleRowByGroup(group);\n    return tile.gridData.y + yCorr;\n  }\n  getGroupByVisibleRow(rowToFind) {\n    if (rowToFind < 0 || rowToFind >= this.getVisibleGridRowCount()) {\n      return null;\n    }\n    let currentIndex = 0;\n    return arrays.find(this.expandedGroups(), group => {\n      let rowCount = group.body.logicalGrid.gridRows;\n      if (currentIndex <= rowToFind && rowToFind < currentIndex + rowCount) {\n        return true;\n      }\n      currentIndex += rowCount;\n    });\n  }\n\n  /**\n   * @returns {number} the index of the row where the group is located.<p>\n   *          Example: There are 3 rows and 2 groups. The first group contains 2 rows, the second 1 row.\n   *          The index of the first group is 0, the index of the second group is 2.\n   */\n  getVisibleRowByGroup(groupToFind) {\n    let currentIndex = 0;\n    let found = this.expandedGroups().some(group => {\n      let rowCount = group.body.logicalGrid.gridRows;\n      if (group === groupToFind) {\n        return true;\n      }\n      currentIndex += rowCount;\n      return false;\n    });\n    if (!found) {\n      return -1;\n    }\n    return currentIndex;\n  }\n  expandedGroups() {\n    return this.groups.filter(group => {\n      return !group.collapsed;\n    });\n  }\n  _handleSelectionChanged(tileGrid) {\n    if (this._selectionUpdateLocked) {\n      // Don't execute when deselecting other tiles to minimize the amount of property change events\n      return;\n    }\n    let group = tileGrid.parent;\n    if (tileGrid.selectedTiles.length > 0 && group.collapsed) {\n      // Do not allow selection in a collapsed group (breaks keyboard navigation and is confusing for the user if invisible tiles are selected)\n      tileGrid.deselectAllTiles();\n      return;\n    }\n    if (!this.multiSelect && tileGrid.selectedTiles.length > 0) {\n      this._selectionUpdateLocked = true;\n      // Ensure only one grid has a selected tile if multiSelect is false\n      this.groups.forEach(group => {\n        if (group.body !== tileGrid) {\n          group.body.deselectAllTiles();\n        }\n      });\n      this._selectionUpdateLocked = false;\n    }\n  }\n  _onTileGridPropertyChange(event) {\n    // Trigger artificial property changes with newValue set to null.\n    // Reason: these property changes are fired for each grid. Creating the compound arrays using getFilteredTiles() etc.\n    // costs some time (even if only some ms) but may not be necessary at all. The consumer can still call these functions by himself.\n    // Also: oldValue cannot be estimated either way which makes it consistent\n    if (event.propertyName === 'selectedTiles') {\n      this._handleSelectionChanged(event.source);\n      this.triggerPropertyChange('selectedTiles', null, null);\n    } else if (event.propertyName === 'filteredTiles') {\n      this.triggerPropertyChange('filteredTiles', null, null);\n    } else if (event.propertyName === 'tiles') {\n      this.triggerPropertyChange('tiles', null, null);\n    }\n  }\n\n  /**\n   * @override\n   */\n  _onGroupCollapsedChange(event) {\n    super._onGroupCollapsedChange(event);\n    this._handleCollapsed(event.source);\n  }\n  _handleCollapsed(group) {\n    if (group.collapsed) {\n      // Deselect tiles of a collapsed group (this will also set focusedTile to null) -> actions on invisible elements is confusing, and key strokes only operate on visible elements, too\n      group.body.deselectAllTiles();\n    }\n    if (group.rendered) {\n      group.on('bodyHeightChange', this._groupBodyHeightChangeHandler);\n      group.one('bodyHeightChangeDone', this._onGroupBodyHeightChangeDone.bind(this));\n    }\n  }\n  _onGroupBodyHeightChange(event) {\n    this.groups.forEach(group => {\n      if (event.source === group || group.bodyAnimating) {\n        // No need to layout body for the group which is already expanding / collapsing since it does it anyway\n        // Btw: another group may be doing it as well at the same time (e.g. because of exclusiveExpand)\n        return;\n      }\n      if (group.body.virtual && group.body.htmlComp) {\n        group.body.htmlComp.layout.updateViewPort();\n      }\n    });\n  }\n  _onGroupBodyHeightChangeDone(event) {\n    event.source.off('bodyHeightChange', this._groupBodyHeightChangeHandler);\n  }\n\n  /**\n   * @returns {Tile} the first fully visible tile at the scrollTop.\n   */\n  _tileAtScrollTop(scrollTop) {\n    return arrays.find(this.getTiles().filter(tile => {\n      return tile.rendered;\n    }), tile => {\n      return tile.$container.position().top >= scrollTop;\n    }, this);\n  }\n}","map":{"version":3,"names":["Accordion","arrays","EventDelegator","FilterSupport","Group","KeyStrokeContext","objects","scout","TileAccordionLayout","TileAccordionSelectionHandler","TileTextFilter","TileAccordion","constructor","exclusiveExpand","gridColumnCount","multiSelect","selectable","takeTileFiltersFromGroup","tileComparator","filters","tileGridLayoutConfig","tileGridSelectionHandler","withPlaceholders","virtual","$filterFieldContainer","textFilterEnabled","filterSupport","_createFilterSupport","createTextFilter","updateTextFilterText","_selectionUpdateLocked","_tileGridPropertyChangeHandler","_onTileGridPropertyChange","bind","_groupBodyHeightChangeHandler","_onGroupBodyHeightChange","_render","$container","addClass","prependDiv","_createLayout","_renderProperties","_renderTextFilterEnabled","_remove","remove","_init","model","setFilters","_createKeyStrokeContext","_initGroup","group","body","setSelectionHandler","setGridColumnCount","setProperty","setMultiSelect","setSelectable","setLayoutConfig","layoutConfig","setComparator","sort","comparator","length","addFilter","setWithPlaceholders","setVirtual","selectedTiles","_handleSelectionChanged","on","_handleCollapsed","__tileAccordionEventDelegator","create","delegateEvents","_deleteGroup","off","destroy","setGroups","groups","oldTileCount","getTileCount","oldFilteredTileCount","getFilteredTileCount","oldSelectedTileCount","getSelectedTileCount","tileCount","filteredTileCount","selectedTileCount","triggerPropertyChange","forEach","setTileGridLayoutConfig","getGroupById","id","find","getGroupByTile","tile","findParent","parent","_groupTiles","tiles","tilesPerGroup","Error","push","deleteTile","deleteTiles","tilesToDelete","appendPlaceholders","ensure","getTiles","removeAll","setTiles","deleteAllTiles","equals","_createChildren","pushAll","count","filter","applyFilter","removeFilter","_setFilters","slice","_setProperty","_filter","widget","filterElements","_createTextFilter","_updateTextFilterText","isFunction","text","setText","setTextFilterEnabled","isTextFilterFieldVisible","renderFilterField","getFilteredTiles","filteredTiles","getVisibleTiles","expandedGroups","getVisibleTileCount","findVisibleTileIndexAt","x","y","startIndex","reverse","nvl","findIndexFrom","i","getVisibleGridX","getVisibleGridY","selectTiles","selectTile","selectAllTiles","deselectTiles","getSelectedTiles","deselectTile","deselectAllTiles","addTilesToSelection","concat","addTileToSelection","getSelectedTile","toggleSelection","setTileComparator","sortTiles","setFocusedTile","groupForTile","getFocusedTile","focusedTile","some","getVisibleGridRowCount","reduce","acc","logicalGrid","gridRows","gridData","yCorr","getVisibleRowByGroup","getGroupByVisibleRow","rowToFind","currentIndex","rowCount","groupToFind","found","collapsed","tileGrid","event","propertyName","source","_onGroupCollapsedChange","rendered","one","_onGroupBodyHeightChangeDone","bodyAnimating","htmlComp","layout","updateViewPort","_tileAtScrollTop","scrollTop","position","top"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/tile/accordion/TileAccordion.js"],"sourcesContent":["/*\n * Copyright (c) 2010-2022 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Accordion, arrays, EventDelegator, FilterSupport, Group, KeyStrokeContext, objects, scout, TileAccordionLayout, TileAccordionSelectionHandler, TileTextFilter} from '../../index';\n\nexport default class TileAccordion extends Accordion {\n  constructor() {\n    super();\n    this.exclusiveExpand = false;\n    this.gridColumnCount = null;\n    this.multiSelect = null;\n    this.selectable = null;\n    this.takeTileFiltersFromGroup = true;\n    this.tileComparator = null;\n    this.filters = [];\n    this.tileGridLayoutConfig = null;\n    this.tileGridSelectionHandler = new TileAccordionSelectionHandler(this);\n    this.withPlaceholders = null;\n    this.virtual = null;\n\n    this.$filterFieldContainer = null;\n    this.textFilterEnabled = false;\n    this.filterSupport = this._createFilterSupport();\n    this.createTextFilter = null;\n    this.updateTextFilterText = null;\n\n    this._selectionUpdateLocked = false;\n    this._tileGridPropertyChangeHandler = this._onTileGridPropertyChange.bind(this);\n    this._groupBodyHeightChangeHandler = this._onGroupBodyHeightChange.bind(this);\n  }\n\n  /**\n   * @override\n   */\n  _render() {\n    super._render();\n    this.$container.addClass('tile-accordion');\n    this.$filterFieldContainer = this.$container.prependDiv('filter-field-container');\n  }\n\n  _createLayout() {\n    return new TileAccordionLayout(this);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderTextFilterEnabled();\n  }\n\n  _remove() {\n    this.filterSupport.remove();\n    super._remove();\n  }\n\n  _init(model) {\n    super._init(model);\n    this.setFilters(this.filters);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initGroup(group) {\n    super._initGroup(group);\n    group.body.setSelectionHandler(this.tileGridSelectionHandler);\n\n    // Copy properties from accordion to new group. If the properties are not set yet, copy them from the group to the accordion\n    // This gives the possibility to either define the properties on the accordion or on the tileGrid initially\n    if (this.gridColumnCount !== null) {\n      group.body.setGridColumnCount(this.gridColumnCount);\n    }\n    this.setProperty('gridColumnCount', group.body.gridColumnCount);\n\n    if (this.multiSelect !== null) {\n      group.body.setMultiSelect(this.multiSelect);\n    }\n    this.setProperty('multiSelect', group.body.multiSelect);\n\n    if (this.selectable !== null) {\n      group.body.setSelectable(this.selectable);\n    }\n    this.setProperty('selectable', group.body.selectable);\n\n    if (this.tileGridLayoutConfig !== null) {\n      group.body.setLayoutConfig(this.tileGridLayoutConfig);\n    }\n    this.setProperty('tileGridLayoutConfig', group.body.layoutConfig);\n\n    if (this.tileComparator !== null) {\n      group.body.setComparator(this.tileComparator);\n      group.body.sort();\n    }\n    this.setProperty('tileComparator', group.body.comparator);\n\n    if (this.filters.length > 0) {\n      group.body.addFilter(this.filters);\n    }\n    if (this.takeTileFiltersFromGroup) {\n      this.setFilters(group.body.filters);\n    }\n\n    if (this.withPlaceholders !== null) {\n      group.body.setWithPlaceholders(this.withPlaceholders);\n    }\n    this.setProperty('withPlaceholders', group.body.withPlaceholders);\n\n    if (this.virtual !== null) {\n      group.body.setVirtual(this.virtual);\n    }\n    this.setProperty('virtual', group.body.virtual);\n\n    if (group.body.selectedTiles.length > 0) {\n      this._handleSelectionChanged(group.body);\n    }\n\n    group.body.on('propertyChange', this._tileGridPropertyChangeHandler);\n    this._handleCollapsed(group);\n\n    // Delegate events so that consumers don't need to attach a listener to each tile grid by themselves\n    group.body.__tileAccordionEventDelegator = EventDelegator.create(group.body, this, {\n      delegateEvents: ['tileClick', 'tileAction']\n    });\n  }\n\n  /**\n   * @override\n   */\n  _deleteGroup(group) {\n    if (group.body) {\n      group.body.off('propertyChange', this._tileGridPropertyChangeHandler);\n      group.body.__tileAccordionEventDelegator.destroy();\n      group.body.__tileAccordionEventDelegator = null;\n    }\n    super._deleteGroup(group);\n  }\n\n  /**\n   * @override\n   */\n  setGroups(groups) {\n    let oldTileCount = this.getTileCount();\n    let oldFilteredTileCount = this.getFilteredTileCount();\n    let oldSelectedTileCount = this.getSelectedTileCount();\n    super.setGroups(groups);\n\n    let tileCount = this.getTileCount();\n    let filteredTileCount = this.getFilteredTileCount();\n    let selectedTileCount = this.getSelectedTileCount();\n\n    // Trigger artificial property changes if necessary\n    // See _onTileGridPropertyChange why parameters are null\n    if (tileCount !== oldTileCount) {\n      this.triggerPropertyChange('tiles', null, null);\n    }\n    if (filteredTileCount !== oldFilteredTileCount) {\n      this.triggerPropertyChange('filteredTiles', null, null);\n    }\n    if (selectedTileCount !== oldSelectedTileCount) {\n      this.triggerPropertyChange('selectedTiles', null, null);\n    }\n  }\n\n  setGridColumnCount(gridColumnCount) {\n    this.groups.forEach(group => {\n      group.body.setGridColumnCount(gridColumnCount);\n    });\n    this.setProperty('gridColumnCount', gridColumnCount);\n  }\n\n  setTileGridLayoutConfig(layoutConfig) {\n    this.groups.forEach(group => {\n      group.body.setLayoutConfig(layoutConfig);\n      layoutConfig = group.body.layoutConfig; // May be converted from plain object to TileGridLayoutConfig\n    });\n    this.setProperty('tileGridLayoutConfig', layoutConfig);\n  }\n\n  setWithPlaceholders(withPlaceholders) {\n    this.groups.forEach(group => {\n      group.body.setWithPlaceholders(withPlaceholders);\n    });\n    this.setProperty('withPlaceholders', withPlaceholders);\n  }\n\n  setVirtual(virtual) {\n    this.groups.forEach(group => {\n      group.body.setVirtual(virtual);\n    });\n    this.setProperty('virtual', virtual);\n  }\n\n  setSelectable(selectable) {\n    this.groups.forEach(group => {\n      group.body.setSelectable(selectable);\n    });\n    this.setProperty('selectable', selectable);\n  }\n\n  setMultiSelect(multiSelect) {\n    this.groups.forEach(group => {\n      group.body.setMultiSelect(multiSelect);\n    });\n    this.setProperty('multiSelect', multiSelect);\n  }\n\n  getGroupById(id) {\n    return arrays.find(this.groups, group => {\n      return group.id === id;\n    });\n  }\n\n  getGroupByTile(tile) {\n    return tile.findParent(parent => {\n      return parent instanceof Group;\n    });\n  }\n\n  /**\n   * Distribute the tiles to the corresponding groups and returns an object with group id as key and array of tiles as value.\n   * Always returns all current groups even if the given tiles may not be distributed to all groups.\n   */\n  _groupTiles(tiles) {\n    // Create a map of groups, key is the id, value is an array of tiles\n    let tilesPerGroup = {};\n    this.groups.forEach(group => {\n      tilesPerGroup[group.id] = [];\n    });\n\n    // Distribute the tiles to the corresponding groups\n    tiles.forEach(function(tile) {\n      let group = this.getGroupByTile(tile);\n      if (!group) {\n        throw new Error('No group found for tile ' + tile.id);\n      }\n      if (!tilesPerGroup[group.id]) {\n        tilesPerGroup[group.id] = [];\n      }\n      tilesPerGroup[group.id].push(tile);\n    }, this);\n\n    return tilesPerGroup;\n  }\n\n  deleteTile(tile) {\n    this.deleteTiles([tile]);\n  }\n\n  deleteTiles(tilesToDelete, appendPlaceholders) {\n    tilesToDelete = arrays.ensure(tilesToDelete);\n    if (tilesToDelete.length === 0) {\n      return;\n    }\n    let tiles = this.getTiles();\n    arrays.removeAll(tiles, tilesToDelete);\n    this.setTiles(tiles, appendPlaceholders);\n  }\n\n  deleteAllTiles() {\n    this.setTiles([]);\n  }\n\n  /**\n   * Distributes the given tiles to their corresponding groups.\n   * <p>\n   * If the list contains new tiles not assigned to a group yet, an exception will be thrown.\n   */\n  setTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    if (objects.equals(this.getTiles(), tiles)) {\n      return;\n    }\n\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    // Distribute the tiles to the corresponding groups (result may contain groups without tiles)\n    let tilesPerGroup = this._groupTiles(tiles);\n\n    // Update the tile grids\n    for (let id in tilesPerGroup) { // NOSONAR\n      let group = this.getGroupById(id);\n      group.body.setTiles(tilesPerGroup[id]);\n    }\n  }\n\n  getTiles() {\n    let tiles = [];\n    this.groups.forEach(group => {\n      arrays.pushAll(tiles, group.body.tiles);\n    });\n    return tiles;\n  }\n\n  getTileCount() {\n    let count = 0;\n    this.groups.forEach(group => {\n      count += group.body.tiles.length;\n    });\n    return count;\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to add.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  addFilter(filter, applyFilter = true) {\n    this.filterSupport.addFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The filters to remove.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  removeFilter(filter, applyFilter = true) {\n    this.filterSupport.removeFilter(filter, applyFilter);\n  }\n\n  /**\n   * @param {Filter|function|(Filter|function)[]} filter The new filters.\n   * @param {boolean} applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.\n   */\n  setFilters(filters, applyFilter = true) {\n    this.filterSupport.setFilters(filters, applyFilter);\n  }\n\n  _setFilters(filters) {\n    filters = arrays.ensure(filters);\n    this.groups.forEach(group => {\n      group.body.setFilters(filters.slice(), false);\n    });\n    this._setProperty('filters', filters.slice());\n  }\n\n  filter() {\n    this.filterSupport.filter();\n  }\n\n  _filter() {\n    this.groups.forEach(group => group.body.filter());\n  }\n\n  /**\n   * @returns {FilterSupport}\n   */\n  _createFilterSupport() {\n    return new FilterSupport({\n      widget: this,\n      $container: () => this.$filterFieldContainer,\n      filterElements: this._filter.bind(this),\n      createTextFilter: this._createTextFilter.bind(this),\n      updateTextFilterText: this._updateTextFilterText.bind(this)\n    });\n  }\n\n  _createTextFilter() {\n    if (objects.isFunction(this.createTextFilter)) {\n      return this.createTextFilter();\n    }\n    return new TileTextFilter();\n  }\n\n  _updateTextFilterText(filter, text) {\n    if (objects.isFunction(this.updateTextFilterText)) {\n      return this.updateTextFilterText(filter, text);\n    }\n    if (filter instanceof TileTextFilter) {\n      return filter.setText(text);\n    }\n    return false;\n  }\n\n  setTextFilterEnabled(textFilterEnabled) {\n    this.setProperty('textFilterEnabled', textFilterEnabled);\n  }\n\n  isTextFilterFieldVisible() {\n    return this.textFilterEnabled;\n  }\n\n  _renderTextFilterEnabled() {\n    this.filterSupport.renderFilterField();\n  }\n\n  getFilteredTiles() {\n    let tiles = [];\n    this.groups.forEach(group => {\n      arrays.pushAll(tiles, group.body.filteredTiles);\n    });\n    return tiles;\n  }\n\n  getFilteredTileCount() {\n    let count = 0;\n    this.groups.forEach(group => {\n      count += group.body.filteredTiles.length;\n    });\n    return count;\n  }\n\n  /**\n   * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are returned.\n   */\n  getVisibleTiles() {\n    let tiles = [];\n    this.expandedGroups().forEach(group => {\n      arrays.pushAll(tiles, group.body.filteredTiles);\n    });\n    return tiles;\n  }\n\n  /**\n   * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are counted.\n   */\n  getVisibleTileCount() {\n    let count = 0;\n    this.expandedGroups().forEach(group => {\n      count += group.body.filteredTiles.length;\n    });\n    return count;\n  }\n\n  findVisibleTileIndexAt(x, y, startIndex, reverse) {\n    startIndex = scout.nvl(startIndex, 0);\n    return arrays.findIndexFrom(this.getVisibleTiles(), startIndex, (tile, i) => {\n      return this.getVisibleGridX(tile) === x && this.getVisibleGridY(tile) === y;\n    }, reverse);\n  }\n\n  /**\n   * Selects the given tiles and deselects the previously selected ones.\n   */\n  selectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    // Split tiles into separate lists for each group (result may contain groups without tiles)\n    let tilesPerGroup = this._groupTiles(tiles);\n\n    // Select the tiles in the the corresponding tile grids\n    for (let id in tilesPerGroup) { // NOSONAR\n      let group = this.getGroupById(id);\n      group.body.selectTiles(tilesPerGroup[id]);\n    }\n  }\n\n  selectTile(tile) {\n    this.selectTiles([tile]);\n  }\n\n  /**\n   * Selects all tiles. As for every selection operation: only considers filtered tiles and tiles of expanded groups\n   */\n  selectAllTiles() {\n    this.selectTiles(this.getVisibleTiles());\n  }\n\n  deselectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    let selectedTiles = this.getSelectedTiles().slice();\n    if (arrays.removeAll(selectedTiles, tiles)) {\n      this.selectTiles(selectedTiles);\n    }\n  }\n\n  deselectTile(tile) {\n    this.deselectTiles([tile]);\n  }\n\n  deselectAllTiles() {\n    this.selectTiles([]);\n  }\n\n  addTilesToSelection(tiles) {\n    tiles = arrays.ensure(tiles);\n    this.selectTiles(this.getSelectedTiles().concat(tiles));\n  }\n\n  addTileToSelection(tile) {\n    this.addTilesToSelection([tile]);\n  }\n\n  getSelectedTiles() {\n    let selectedTiles = [];\n    this.groups.forEach(group => {\n      arrays.pushAll(selectedTiles, group.body.selectedTiles);\n    });\n    return selectedTiles;\n  }\n\n  getSelectedTile() {\n    return this.getSelectedTiles()[0];\n  }\n\n  getSelectedTileCount() {\n    let count = 0;\n    this.groups.forEach(group => {\n      count += group.body.selectedTiles.length;\n    });\n    return count;\n  }\n\n  toggleSelection() {\n    if (this.getSelectedTileCount() === this.getVisibleTileCount()) {\n      this.deselectAllTiles();\n    } else {\n      this.selectAllTiles();\n    }\n  }\n\n  setTileComparator(comparator) {\n    this.groups.forEach(group => {\n      group.body.setComparator(comparator);\n    });\n    this.setProperty('tileComparator', comparator);\n  }\n\n  sortTiles() {\n    this.groups.forEach(group => {\n      group.body.sort();\n    });\n  }\n\n  setFocusedTile(tile) {\n    let groupForTile = null;\n    if (tile !== null) {\n      groupForTile = this.getGroupByTile(tile);\n    }\n    this.groups.forEach(group => {\n      if (group === groupForTile) {\n        group.body.setFocusedTile(tile);\n      } else {\n        group.body.setFocusedTile(null);\n      }\n    });\n  }\n\n  getFocusedTile() {\n    let focusedTile = null;\n    this.groups.some(group => {\n      if (group.body.focusedTile) {\n        focusedTile = group.body.focusedTile;\n        return true;\n      }\n      return false;\n    });\n    return focusedTile;\n  }\n\n  getVisibleGridRowCount() {\n    return this.expandedGroups().reduce((acc, group) => {\n      return acc + group.body.logicalGrid.gridRows;\n    }, 0);\n  }\n\n  getVisibleGridX(tile) {\n    return tile.gridData.x;\n  }\n\n  getVisibleGridY(tile) {\n    let group = this.getGroupByTile(tile);\n    let yCorr = this.getVisibleRowByGroup(group);\n    return tile.gridData.y + yCorr;\n  }\n\n  getGroupByVisibleRow(rowToFind) {\n    if (rowToFind < 0 || rowToFind >= this.getVisibleGridRowCount()) {\n      return null;\n    }\n    let currentIndex = 0;\n    return arrays.find(this.expandedGroups(), group => {\n      let rowCount = group.body.logicalGrid.gridRows;\n      if (currentIndex <= rowToFind && rowToFind < currentIndex + rowCount) {\n        return true;\n      }\n      currentIndex += rowCount;\n    });\n  }\n\n  /**\n   * @returns {number} the index of the row where the group is located.<p>\n   *          Example: There are 3 rows and 2 groups. The first group contains 2 rows, the second 1 row.\n   *          The index of the first group is 0, the index of the second group is 2.\n   */\n  getVisibleRowByGroup(groupToFind) {\n    let currentIndex = 0;\n    let found = this.expandedGroups().some(group => {\n      let rowCount = group.body.logicalGrid.gridRows;\n      if (group === groupToFind) {\n        return true;\n      }\n      currentIndex += rowCount;\n      return false;\n    });\n    if (!found) {\n      return -1;\n    }\n    return currentIndex;\n  }\n\n  expandedGroups() {\n    return this.groups.filter(group => {\n      return !group.collapsed;\n    });\n  }\n\n  _handleSelectionChanged(tileGrid) {\n    if (this._selectionUpdateLocked) {\n      // Don't execute when deselecting other tiles to minimize the amount of property change events\n      return;\n    }\n    let group = tileGrid.parent;\n    if (tileGrid.selectedTiles.length > 0 && group.collapsed) {\n      // Do not allow selection in a collapsed group (breaks keyboard navigation and is confusing for the user if invisible tiles are selected)\n      tileGrid.deselectAllTiles();\n      return;\n    }\n    if (!this.multiSelect && tileGrid.selectedTiles.length > 0) {\n      this._selectionUpdateLocked = true;\n      // Ensure only one grid has a selected tile if multiSelect is false\n      this.groups.forEach(group => {\n        if (group.body !== tileGrid) {\n          group.body.deselectAllTiles();\n        }\n      });\n      this._selectionUpdateLocked = false;\n    }\n  }\n\n  _onTileGridPropertyChange(event) {\n    // Trigger artificial property changes with newValue set to null.\n    // Reason: these property changes are fired for each grid. Creating the compound arrays using getFilteredTiles() etc.\n    // costs some time (even if only some ms) but may not be necessary at all. The consumer can still call these functions by himself.\n    // Also: oldValue cannot be estimated either way which makes it consistent\n    if (event.propertyName === 'selectedTiles') {\n      this._handleSelectionChanged(event.source);\n      this.triggerPropertyChange('selectedTiles', null, null);\n    } else if (event.propertyName === 'filteredTiles') {\n      this.triggerPropertyChange('filteredTiles', null, null);\n    } else if (event.propertyName === 'tiles') {\n      this.triggerPropertyChange('tiles', null, null);\n    }\n  }\n\n  /**\n   * @override\n   */\n  _onGroupCollapsedChange(event) {\n    super._onGroupCollapsedChange(event);\n\n    this._handleCollapsed(event.source);\n  }\n\n  _handleCollapsed(group) {\n    if (group.collapsed) {\n      // Deselect tiles of a collapsed group (this will also set focusedTile to null) -> actions on invisible elements is confusing, and key strokes only operate on visible elements, too\n      group.body.deselectAllTiles();\n    }\n    if (group.rendered) {\n      group.on('bodyHeightChange', this._groupBodyHeightChangeHandler);\n      group.one('bodyHeightChangeDone', this._onGroupBodyHeightChangeDone.bind(this));\n    }\n  }\n\n  _onGroupBodyHeightChange(event) {\n    this.groups.forEach(group => {\n      if (event.source === group || group.bodyAnimating) {\n        // No need to layout body for the group which is already expanding / collapsing since it does it anyway\n        // Btw: another group may be doing it as well at the same time (e.g. because of exclusiveExpand)\n        return;\n      }\n      if (group.body.virtual && group.body.htmlComp) {\n        group.body.htmlComp.layout.updateViewPort();\n      }\n    });\n  }\n\n  _onGroupBodyHeightChangeDone(event) {\n    event.source.off('bodyHeightChange', this._groupBodyHeightChangeHandler);\n  }\n\n  /**\n   * @returns {Tile} the first fully visible tile at the scrollTop.\n   */\n  _tileAtScrollTop(scrollTop) {\n    return arrays.find(this.getTiles().filter(tile => {\n      return tile.rendered;\n    }), tile => {\n      return tile.$container.position().top >= scrollTop;\n    }, this);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}