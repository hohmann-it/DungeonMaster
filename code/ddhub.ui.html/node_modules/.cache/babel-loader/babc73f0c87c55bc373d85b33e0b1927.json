{"ast":null,"code":"/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { PromiseCreator } from '../index';\nimport $ from 'jquery';\n\n/**\n * Use a promise creator to create a promise and wait until each promise has been done before the next\n * promise is created and executed.\n *\n * @param {PromiseCreator} promiseCreator this function\n * @returns {Promise}\n */\nexport function oneByOne(promiseCreator) {\n  let deferred = $.Deferred();\n  _repeat(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n  function onFail() {\n    // eslint-disable-next-line prefer-spread\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      promiseCreator.next().done(onDone).fail(onFail);\n    } else {\n      // eslint-disable-next-line prefer-spread\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n\n/**\n * Use a promise creator to create a group of promises and wait until the whole group has been executed\n * before creating and executing promises for the next group.\n *\n * @param groupSize\n * @param promiseCreator\n * @returns {Promise}\n */\nexport function groupwise(groupSize, promiseCreator) {\n  let deferred = $.Deferred();\n  _repeat(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n  function onFail() {\n    // eslint-disable-next-line prefer-spread\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      let promises = [];\n      while (promises.length < groupSize && promiseCreator.hasNext()) {\n        promises.push(promiseCreator.next());\n      }\n      $.promiseAll(promises, true).done(onDone).fail(onFail);\n    } else {\n      // eslint-disable-next-line prefer-spread\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n\n/**\n * Use a promise creator to try to keep a fixed size pool of promises of working. As soon as one\n * promise is finished, the next promise will be created and executed (as a long as there are more\n * promises available).\n *\n * @param maxPoolSize defines how many promises should be created and executed at most in parallel.\n * @param promiseCreator\n * @param timeout specifies a timeout to wait for until the next promise will be started.\n * @returns {Promise}\n */\nexport function parallel(maxPoolSize, promiseCreator, timeout) {\n  timeout = timeout || 0;\n  let deferred = $.Deferred();\n  let poolSize = 0;\n  _startNext(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    poolSize--;\n    setTimeout(_startNext.bind(this, promiseCreator), timeout);\n  }\n  function onFail() {\n    // eslint-disable-next-line prefer-spread\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n  function _startNext(promiseCreator) {\n    if (deferred.state() !== 'pending') {\n      // deferred has already been rejected or resolved, do not start anymore promises or call done handler\n      return;\n    }\n    while (promiseCreator.hasNext() && poolSize < maxPoolSize) {\n      poolSize++;\n      promiseCreator.next().done(onDone).fail(onFail);\n    }\n    if (poolSize === 0) {\n      deferred.resolve.apply(deferred, [promiseCreator.results]);\n    }\n  }\n}\nexport default {\n  groupwise,\n  oneByOne,\n  parallel\n};","map":{"version":3,"names":["PromiseCreator","$","oneByOne","promiseCreator","deferred","Deferred","_repeat","promise","onDone","setTimeout","bind","onFail","reject","apply","error","hasNext","next","done","fail","resolve","results","groupwise","groupSize","promises","length","push","promiseAll","parallel","maxPoolSize","timeout","poolSize","_startNext","state"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/util/promises.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {PromiseCreator} from '../index';\nimport $ from 'jquery';\n\n/**\n * Use a promise creator to create a promise and wait until each promise has been done before the next\n * promise is created and executed.\n *\n * @param {PromiseCreator} promiseCreator this function\n * @returns {Promise}\n */\nexport function oneByOne(promiseCreator) {\n  let deferred = $.Deferred();\n  _repeat(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n\n  function onFail() {\n    // eslint-disable-next-line prefer-spread\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      promiseCreator.next()\n        .done(onDone)\n        .fail(onFail);\n    } else {\n      // eslint-disable-next-line prefer-spread\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n\n/**\n * Use a promise creator to create a group of promises and wait until the whole group has been executed\n * before creating and executing promises for the next group.\n *\n * @param groupSize\n * @param promiseCreator\n * @returns {Promise}\n */\nexport function groupwise(groupSize, promiseCreator) {\n  let deferred = $.Deferred();\n  _repeat(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n\n  function onFail() {\n    // eslint-disable-next-line prefer-spread\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      let promises = [];\n      while (promises.length < groupSize && promiseCreator.hasNext()) {\n        promises.push(promiseCreator.next());\n      }\n      $.promiseAll(promises, true)\n        .done(onDone)\n        .fail(onFail);\n    } else {\n      // eslint-disable-next-line prefer-spread\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n\n/**\n * Use a promise creator to try to keep a fixed size pool of promises of working. As soon as one\n * promise is finished, the next promise will be created and executed (as a long as there are more\n * promises available).\n *\n * @param maxPoolSize defines how many promises should be created and executed at most in parallel.\n * @param promiseCreator\n * @param timeout specifies a timeout to wait for until the next promise will be started.\n * @returns {Promise}\n */\nexport function parallel(maxPoolSize, promiseCreator, timeout) {\n  timeout = timeout || 0;\n  let deferred = $.Deferred();\n  let poolSize = 0;\n  _startNext(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    poolSize--;\n    setTimeout(_startNext.bind(this, promiseCreator), timeout);\n  }\n\n  function onFail() {\n    // eslint-disable-next-line prefer-spread\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _startNext(promiseCreator) {\n    if (deferred.state() !== 'pending') {\n      // deferred has already been rejected or resolved, do not start anymore promises or call done handler\n      return;\n    }\n    while (promiseCreator.hasNext() && poolSize < maxPoolSize) {\n      poolSize++;\n      promiseCreator.next().done(onDone).fail(onFail);\n    }\n    if (poolSize === 0) {\n      deferred.resolve.apply(deferred, [promiseCreator.results]);\n    }\n  }\n}\n\nexport default {\n  groupwise,\n  oneByOne,\n  parallel\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}