{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { numbers, RoundingMode, scout, strings } from '../index';\n\n/**\n * Provides formatting of numbers using java format pattern.\n * <p>\n * Compared to the java DecimalFormat the following pattern characters are not considered:\n * <ul>\n *   <li>prefix and suffix</li>\n *   <li>E</li>\n *   <li>%</li>\n * </ul>\n */\nexport default class DecimalFormat {\n  constructor(locale, options) {\n    // format function will use these (defaults)\n    this.positivePrefix = '';\n    this.positiveSuffix = '';\n    this.negativePrefix = locale.decimalFormatSymbols.minusSign;\n    this.negativeSuffix = '';\n    this.groupingChar = locale.decimalFormatSymbols.groupingSeparator;\n    // we want to be lenient when it comes to grouping separators, try the locale default plus a few others\n    this.lenientGroupingChars = '\\'´`’' +\n    // apostrophe and variations\n    '\\u00B7' +\n    // middle dot\n    '\\u0020' +\n    // space\n    '\\u00A0' +\n    // no-break space\n    '\\u2009' +\n    // thin space\n    '\\u202F'; // narrow no-break space\n    this.groupLength = 0;\n    this.decimalSeparatorChar = locale.decimalFormatSymbols.decimalSeparator;\n    this.zeroBefore = 1;\n    this.zeroAfter = 0;\n    this.allAfter = 0;\n    if (typeof options === 'string') {\n      this.pattern = options;\n    }\n    options = options || {};\n    this.pattern = this.pattern || options.pattern || locale.decimalFormatPatternDefault;\n    this.multiplier = options.multiplier || 1;\n    this.roundingMode = options.roundingMode || RoundingMode.HALF_UP;\n    let SYMBOLS = DecimalFormat.PATTERN_SYMBOLS;\n    // Check if there are separate subpatterns for positive and negative numbers (\"PositivePattern;NegativePattern\")\n    let split = this.pattern.split(SYMBOLS.patternSeparator);\n    // Use the first subpattern as positive prefix/suffix\n    let positivePrefixAndSuffix = findPrefixAndSuffix(split[0]);\n    this.positivePrefix = positivePrefixAndSuffix.prefix;\n    this.positiveSuffix = positivePrefixAndSuffix.suffix;\n    if (split.length > 1) {\n      // Yes, there is a negative subpattern\n      let negativePrefixAndSuffix = findPrefixAndSuffix(split[1]);\n      this.negativePrefix = negativePrefixAndSuffix.prefix;\n      this.negativeSuffix = negativePrefixAndSuffix.suffix;\n      // from now on, only look at the positive subpattern\n      this.pattern = split[0];\n    } else {\n      // No, there is no negative subpattern, so the positive prefix/suffix are used for both positive and negative numbers.\n      // Check if there is a minus sign in the prefix/suffix.\n      if (this.positivePrefix.indexOf(SYMBOLS.minusSign) !== -1 || this.positiveSuffix.indexOf(SYMBOLS.minusSign) !== -1) {\n        // Yes, there is a minus sign in the prefix/suffix. Use this a negativePrefix/Suffix and remove the minus sign from the posistivePrefix/Suffix.\n        this.negativePrefix = this.positivePrefix.replace(SYMBOLS.minusSign, locale.decimalFormatSymbols.minusSign);\n        this.negativeSuffix = this.positiveSuffix.replace(SYMBOLS.minusSign, locale.decimalFormatSymbols.minusSign);\n        this.positivePrefix = this.positivePrefix.replace(SYMBOLS.minusSign, '');\n        this.positiveSuffix = this.positiveSuffix.replace(SYMBOLS.minusSign, '');\n      } else {\n        // No, there is no minus sign in the prefix/suffix. Therefore, use the default negativePrefix/Suffix, but append the positivePrefix/Suffix\n        this.negativePrefix = this.positivePrefix + this.negativePrefix;\n        this.negativeSuffix = this.negativeSuffix + this.positiveSuffix;\n      }\n    }\n\n    // find group length\n    let posDecimalSeparator = this.pattern.indexOf(SYMBOLS.decimalSeparator);\n    if (posDecimalSeparator === -1) {\n      posDecimalSeparator = this.pattern.length; // assume decimal separator at end\n    }\n\n    let posGroupingSeparator = this.pattern.lastIndexOf(SYMBOLS.groupingSeparator, posDecimalSeparator); // only search before decimal separator\n    if (posGroupingSeparator > 0) {\n      this.groupLength = posDecimalSeparator - posGroupingSeparator - 1;\n    }\n    this.pattern = this.pattern.replace(new RegExp('[' + SYMBOLS.groupingSeparator + ']', 'g'), '');\n\n    // split on decimal point\n    split = this.pattern.split(SYMBOLS.decimalSeparator);\n\n    // find digits before and after decimal point\n    this.zeroBefore = strings.count(split[0], SYMBOLS.zeroDigit);\n    if (split.length > 1) {\n      // has decimal point?\n      this.zeroAfter = strings.count(split[1], SYMBOLS.zeroDigit);\n      this.allAfter = this.zeroAfter + strings.count(split[1], SYMBOLS.digit);\n    }\n\n    // Returns an object with the properties 'prefix' and 'suffix', which contain all characters\n    // before or after any 'digit-like' character in the given pattern string.\n    function findPrefixAndSuffix(pattern) {\n      let result = {\n        prefix: '',\n        suffix: ''\n      };\n      // Find prefix (anything before the first 'digit-like' character)\n      let digitLikeCharacters = SYMBOLS.digit + SYMBOLS.zeroDigit + SYMBOLS.decimalSeparator + SYMBOLS.groupingSeparator;\n      let r = new RegExp('^(.*?)[' + digitLikeCharacters + '].*$');\n      let matches = r.exec(pattern);\n      if (matches !== null) {\n        // Ignore single quotes (for special, quoted characters - e.g. Java quotes percentage sign like '%')\n        result.prefix = matches[1].replace(new RegExp('\\'([^\\']+)\\'', 'g'), '$1');\n      }\n      // Find suffix (anything before the first 'digit-like' character)\n      r = new RegExp('^.*[' + digitLikeCharacters + '](.*?)$');\n      matches = r.exec(pattern);\n      if (matches !== null) {\n        // Ignore single quotes (for special, quoted characters - e.g. Java quotes percentage sign like '%')\n        result.suffix = matches[1].replace(new RegExp('\\'([^\\']+)\\'', 'g'), '$1');\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Converts the numberString into a number and applies the multiplier.\n   * @param {string} numberString\n   * @param {function} [evaluateNumberFunction] optional function for custom evaluation. The function gets a normalized string and has to return a Number\n   * @return {number|null} A number for the given numberString, if the string can be converted into a number. Throws an Error otherwise\n   */\n  parse(numberString, evaluateNumberFunction) {\n    if (strings.empty(numberString)) {\n      return null;\n    }\n    let normalizedNumberString = this.normalize(numberString);\n    evaluateNumberFunction = evaluateNumberFunction || Number;\n    let number = evaluateNumberFunction(normalizedNumberString);\n    if (isNaN(number)) {\n      throw new Error(numberString + ' is not a number (NaN)');\n    }\n    if (this.multiplier !== 1) {\n      number /= this.multiplier;\n    }\n    return number;\n  }\n  format(number, applyMultiplier) {\n    applyMultiplier = scout.nvl(applyMultiplier, true);\n    if (number === null || number === undefined) {\n      return null;\n    }\n    let prefix = this.positivePrefix;\n    let suffix = this.positiveSuffix;\n\n    // apply multiplier\n    if (applyMultiplier && this.multiplier !== 1) {\n      number *= this.multiplier;\n    }\n\n    // round\n    number = this.round(number);\n\n    // after decimal point\n    let after = '';\n    if (this.allAfter) {\n      after = number.toFixed(this.allAfter).split('.')[1];\n      for (let j = after.length - 1; j > this.zeroAfter - 1; j--) {\n        if (after[j] !== '0') {\n          break;\n        }\n        after = after.slice(0, -1);\n      }\n      if (after) {\n        // did we find any non-zero characters?\n        after = this.decimalSeparatorChar + after;\n      }\n    }\n\n    // absolute value\n    if (number < 0) {\n      prefix = this.negativePrefix;\n      suffix = this.negativeSuffix;\n      number = -number;\n    }\n\n    // before decimal point\n    let before = Math.floor(number);\n    before = before === 0 ? '' : String(before);\n    before = strings.padZeroLeft(before, this.zeroBefore);\n\n    // group digits\n    if (this.groupLength) {\n      for (let i = before.length - this.groupLength; i > 0; i -= this.groupLength) {\n        before = before.substr(0, i) + this.groupingChar + before.substr(i);\n      }\n    }\n\n    // put together and return\n    return prefix + before + after + suffix;\n  }\n\n  /**\n   * Rounds a number according to the properties of the DecimalFormat.\n   */\n  round(number, applyMultiplier) {\n    applyMultiplier = scout.nvl(applyMultiplier, true);\n    if (number === null || number === undefined) {\n      return null;\n    }\n\n    // apply multiplier\n    if (applyMultiplier && this.multiplier !== 1) {\n      number *= this.multiplier;\n    }\n    // round\n    number = numbers.round(number, this.roundingMode, this.allAfter);\n    // un-apply multiplier\n    if (applyMultiplier && this.multiplier !== 1) {\n      number /= this.multiplier;\n    }\n    return number;\n  }\n\n  /**\n   * Convert to JS number format (remove groupingChar, replace decimalSeparatorChar with '.')\n   */\n  normalize(numberString) {\n    if (!numberString) {\n      return numberString;\n    }\n    return numberString.replace(new RegExp('[' + this.groupingChar + this.lenientGroupingChars + ']', 'g'), '').replace(new RegExp('[' + this.decimalSeparatorChar + ']', 'g'), '.').replace(/\\s/g, '');\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Literal (not localized!) pattern symbols as defined in http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html\n   */\n\n  static ensure(locale, format) {\n    if (!format) {\n      return format;\n    }\n    if (format instanceof DecimalFormat) {\n      return format;\n    }\n    return new DecimalFormat(locale, format);\n  }\n}\n_defineProperty(DecimalFormat, \"PATTERN_SYMBOLS\", {\n  digit: '#',\n  zeroDigit: '0',\n  decimalSeparator: '.',\n  groupingSeparator: ',',\n  minusSign: '-',\n  patternSeparator: ';'\n});","map":{"version":3,"names":["numbers","RoundingMode","scout","strings","DecimalFormat","constructor","locale","options","positivePrefix","positiveSuffix","negativePrefix","decimalFormatSymbols","minusSign","negativeSuffix","groupingChar","groupingSeparator","lenientGroupingChars","groupLength","decimalSeparatorChar","decimalSeparator","zeroBefore","zeroAfter","allAfter","pattern","decimalFormatPatternDefault","multiplier","roundingMode","HALF_UP","SYMBOLS","PATTERN_SYMBOLS","split","patternSeparator","positivePrefixAndSuffix","findPrefixAndSuffix","prefix","suffix","length","negativePrefixAndSuffix","indexOf","replace","posDecimalSeparator","posGroupingSeparator","lastIndexOf","RegExp","count","zeroDigit","digit","result","digitLikeCharacters","r","matches","exec","parse","numberString","evaluateNumberFunction","empty","normalizedNumberString","normalize","Number","number","isNaN","Error","format","applyMultiplier","nvl","undefined","round","after","toFixed","j","slice","before","Math","floor","String","padZeroLeft","i","substr","ensure"],"sources":["C:/git/d-d-hub/code/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/text/DecimalFormat.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {numbers, RoundingMode, scout, strings} from '../index';\n\n/**\n * Provides formatting of numbers using java format pattern.\n * <p>\n * Compared to the java DecimalFormat the following pattern characters are not considered:\n * <ul>\n *   <li>prefix and suffix</li>\n *   <li>E</li>\n *   <li>%</li>\n * </ul>\n */\nexport default class DecimalFormat {\n\n  constructor(locale, options) {\n    // format function will use these (defaults)\n    this.positivePrefix = '';\n    this.positiveSuffix = '';\n    this.negativePrefix = locale.decimalFormatSymbols.minusSign;\n    this.negativeSuffix = '';\n    this.groupingChar = locale.decimalFormatSymbols.groupingSeparator;\n    // we want to be lenient when it comes to grouping separators, try the locale default plus a few others\n    this.lenientGroupingChars = '\\'´`’' + // apostrophe and variations\n      '\\u00B7' + // middle dot\n      '\\u0020' + // space\n      '\\u00A0' + // no-break space\n      '\\u2009' + // thin space\n      '\\u202F'; // narrow no-break space\n    this.groupLength = 0;\n    this.decimalSeparatorChar = locale.decimalFormatSymbols.decimalSeparator;\n    this.zeroBefore = 1;\n    this.zeroAfter = 0;\n    this.allAfter = 0;\n\n    if (typeof options === 'string') {\n      this.pattern = options;\n    }\n    options = options || {};\n    this.pattern = this.pattern || options.pattern || locale.decimalFormatPatternDefault;\n    this.multiplier = options.multiplier || 1;\n    this.roundingMode = options.roundingMode || RoundingMode.HALF_UP;\n\n    let SYMBOLS = DecimalFormat.PATTERN_SYMBOLS;\n    // Check if there are separate subpatterns for positive and negative numbers (\"PositivePattern;NegativePattern\")\n    let split = this.pattern.split(SYMBOLS.patternSeparator);\n    // Use the first subpattern as positive prefix/suffix\n    let positivePrefixAndSuffix = findPrefixAndSuffix(split[0]);\n    this.positivePrefix = positivePrefixAndSuffix.prefix;\n    this.positiveSuffix = positivePrefixAndSuffix.suffix;\n    if (split.length > 1) {\n      // Yes, there is a negative subpattern\n      let negativePrefixAndSuffix = findPrefixAndSuffix(split[1]);\n      this.negativePrefix = negativePrefixAndSuffix.prefix;\n      this.negativeSuffix = negativePrefixAndSuffix.suffix;\n      // from now on, only look at the positive subpattern\n      this.pattern = split[0];\n    } else {\n      // No, there is no negative subpattern, so the positive prefix/suffix are used for both positive and negative numbers.\n      // Check if there is a minus sign in the prefix/suffix.\n      if (this.positivePrefix.indexOf(SYMBOLS.minusSign) !== -1 || this.positiveSuffix.indexOf(SYMBOLS.minusSign) !== -1) {\n        // Yes, there is a minus sign in the prefix/suffix. Use this a negativePrefix/Suffix and remove the minus sign from the posistivePrefix/Suffix.\n        this.negativePrefix = this.positivePrefix.replace(SYMBOLS.minusSign, locale.decimalFormatSymbols.minusSign);\n        this.negativeSuffix = this.positiveSuffix.replace(SYMBOLS.minusSign, locale.decimalFormatSymbols.minusSign);\n        this.positivePrefix = this.positivePrefix.replace(SYMBOLS.minusSign, '');\n        this.positiveSuffix = this.positiveSuffix.replace(SYMBOLS.minusSign, '');\n      } else {\n        // No, there is no minus sign in the prefix/suffix. Therefore, use the default negativePrefix/Suffix, but append the positivePrefix/Suffix\n        this.negativePrefix = this.positivePrefix + this.negativePrefix;\n        this.negativeSuffix = this.negativeSuffix + this.positiveSuffix;\n      }\n    }\n\n    // find group length\n    let posDecimalSeparator = this.pattern.indexOf(SYMBOLS.decimalSeparator);\n    if (posDecimalSeparator === -1) {\n      posDecimalSeparator = this.pattern.length; // assume decimal separator at end\n    }\n    let posGroupingSeparator = this.pattern.lastIndexOf(SYMBOLS.groupingSeparator, posDecimalSeparator); // only search before decimal separator\n    if (posGroupingSeparator > 0) {\n      this.groupLength = posDecimalSeparator - posGroupingSeparator - 1;\n    }\n    this.pattern = this.pattern.replace(new RegExp('[' + SYMBOLS.groupingSeparator + ']', 'g'), '');\n\n    // split on decimal point\n    split = this.pattern.split(SYMBOLS.decimalSeparator);\n\n    // find digits before and after decimal point\n    this.zeroBefore = strings.count(split[0], SYMBOLS.zeroDigit);\n    if (split.length > 1) { // has decimal point?\n      this.zeroAfter = strings.count(split[1], SYMBOLS.zeroDigit);\n      this.allAfter = this.zeroAfter + strings.count(split[1], SYMBOLS.digit);\n    }\n\n    // Returns an object with the properties 'prefix' and 'suffix', which contain all characters\n    // before or after any 'digit-like' character in the given pattern string.\n    function findPrefixAndSuffix(pattern) {\n      let result = {\n        prefix: '',\n        suffix: ''\n      };\n      // Find prefix (anything before the first 'digit-like' character)\n      let digitLikeCharacters = SYMBOLS.digit + SYMBOLS.zeroDigit + SYMBOLS.decimalSeparator + SYMBOLS.groupingSeparator;\n      let r = new RegExp('^(.*?)[' + digitLikeCharacters + '].*$');\n      let matches = r.exec(pattern);\n      if (matches !== null) {\n        // Ignore single quotes (for special, quoted characters - e.g. Java quotes percentage sign like '%')\n        result.prefix = matches[1].replace(new RegExp('\\'([^\\']+)\\'', 'g'), '$1');\n      }\n      // Find suffix (anything before the first 'digit-like' character)\n      r = new RegExp('^.*[' + digitLikeCharacters + '](.*?)$');\n      matches = r.exec(pattern);\n      if (matches !== null) {\n        // Ignore single quotes (for special, quoted characters - e.g. Java quotes percentage sign like '%')\n        result.suffix = matches[1].replace(new RegExp('\\'([^\\']+)\\'', 'g'), '$1');\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Converts the numberString into a number and applies the multiplier.\n   * @param {string} numberString\n   * @param {function} [evaluateNumberFunction] optional function for custom evaluation. The function gets a normalized string and has to return a Number\n   * @return {number|null} A number for the given numberString, if the string can be converted into a number. Throws an Error otherwise\n   */\n  parse(numberString, evaluateNumberFunction) {\n    if (strings.empty(numberString)) {\n      return null;\n    }\n    let normalizedNumberString = this.normalize(numberString);\n    evaluateNumberFunction = evaluateNumberFunction || Number;\n    let number = evaluateNumberFunction(normalizedNumberString);\n\n    if (isNaN(number)) {\n      throw new Error(numberString + ' is not a number (NaN)');\n    }\n    if (this.multiplier !== 1) {\n      number /= this.multiplier;\n    }\n    return number;\n  }\n\n  format(number, applyMultiplier) {\n    applyMultiplier = scout.nvl(applyMultiplier, true);\n    if (number === null || number === undefined) {\n      return null;\n    }\n\n    let prefix = this.positivePrefix;\n    let suffix = this.positiveSuffix;\n\n    // apply multiplier\n    if (applyMultiplier && this.multiplier !== 1) {\n      number *= this.multiplier;\n    }\n\n    // round\n    number = this.round(number);\n\n    // after decimal point\n    let after = '';\n    if (this.allAfter) {\n      after = number.toFixed(this.allAfter).split('.')[1];\n      for (let j = after.length - 1; j > this.zeroAfter - 1; j--) {\n        if (after[j] !== '0') {\n          break;\n        }\n        after = after.slice(0, -1);\n      }\n      if (after) { // did we find any non-zero characters?\n        after = this.decimalSeparatorChar + after;\n      }\n    }\n\n    // absolute value\n    if (number < 0) {\n      prefix = this.negativePrefix;\n      suffix = this.negativeSuffix;\n      number = -number;\n    }\n\n    // before decimal point\n    let before = Math.floor(number);\n    before = (before === 0) ? '' : String(before);\n    before = strings.padZeroLeft(before, this.zeroBefore);\n\n    // group digits\n    if (this.groupLength) {\n      for (let i = before.length - this.groupLength; i > 0; i -= this.groupLength) {\n        before = before.substr(0, i) + this.groupingChar + before.substr(i);\n      }\n    }\n\n    // put together and return\n    return prefix + before + after + suffix;\n  }\n\n  /**\n   * Rounds a number according to the properties of the DecimalFormat.\n   */\n  round(number, applyMultiplier) {\n    applyMultiplier = scout.nvl(applyMultiplier, true);\n    if (number === null || number === undefined) {\n      return null;\n    }\n\n    // apply multiplier\n    if (applyMultiplier && this.multiplier !== 1) {\n      number *= this.multiplier;\n    }\n    // round\n    number = numbers.round(number, this.roundingMode, this.allAfter);\n    // un-apply multiplier\n    if (applyMultiplier && this.multiplier !== 1) {\n      number /= this.multiplier;\n    }\n    return number;\n  }\n\n  /**\n   * Convert to JS number format (remove groupingChar, replace decimalSeparatorChar with '.')\n   */\n  normalize(numberString) {\n    if (!numberString) {\n      return numberString;\n    }\n    return numberString\n      .replace(new RegExp('[' + this.groupingChar + this.lenientGroupingChars + ']', 'g'), '')\n      .replace(new RegExp('[' + this.decimalSeparatorChar + ']', 'g'), '.')\n      .replace(/\\s/g, '');\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Literal (not localized!) pattern symbols as defined in http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html\n   */\n  static PATTERN_SYMBOLS = {\n    digit: '#',\n    zeroDigit: '0',\n    decimalSeparator: '.',\n    groupingSeparator: ',',\n    minusSign: '-',\n    patternSeparator: ';'\n  };\n\n  static ensure(locale, format) {\n    if (!format) {\n      return format;\n    }\n    if (format instanceof DecimalFormat) {\n      return format;\n    }\n    return new DecimalFormat(locale, format);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}