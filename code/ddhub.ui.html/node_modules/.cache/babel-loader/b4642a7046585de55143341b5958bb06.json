{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright (c) 2014-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, BooleanColumn, comparators, DateColumn, DateFormat, dates, IconColumn, NumberColumn, objects, scout } from '../index';\nexport default class TableMatrix {\n  constructor(table, session) {\n    this.session = session;\n    this.locale = session.locale;\n    this._allData = [];\n    this._allAxis = [];\n    this._rows = table.rows;\n    this._table = table;\n  }\n  /**\n   * add data axis\n   */\n  addData(data, dataGroup) {\n    let dataAxis = [],\n      locale = this.locale;\n\n    // collect all axis\n    this._allData.push(dataAxis);\n\n    // copy column for later access\n    dataAxis.column = data;\n\n    // data always is number\n    dataAxis.format = n => locale.decimalFormat.format(n);\n\n    // count, sum, avg\n    if (dataGroup === TableMatrix.NumberGroup.COUNT) {\n      dataAxis.norm = f => 1;\n      dataAxis.group = array => array.length;\n    } else if (dataGroup === TableMatrix.NumberGroup.SUM) {\n      dataAxis.norm = f => {\n        if (isNaN(f) || f === null || f === '') {\n          return null;\n        }\n        return parseFloat(f);\n      };\n      dataAxis.group = array => array.reduce((a, b) => {\n        return a + b;\n      });\n    } else if (dataGroup === TableMatrix.NumberGroup.AVG) {\n      dataAxis.norm = f => {\n        if (isNaN(f) || f === null || f === '') {\n          return null;\n        }\n        return parseFloat(f);\n      };\n      dataAxis.group = array => {\n        let sum = array.reduce((a, b) => {\n            return a + b;\n          }),\n          count = array.reduce((a, b) => {\n            return b === null ? a : a + 1;\n          }, 0);\n        if (count === 0) {\n          return null;\n        }\n        return sum / count;\n      };\n    }\n    return dataAxis;\n  }\n\n  // add x or y Axis\n  addAxis(axis, axisGroup) {\n    let keyAxis = [],\n      locale = this.locale,\n      session = this.session,\n      getText = this.session.text.bind(this.session),\n      emptyCell = getText('ui.EmptyCell');\n\n    // collect all axis\n    this._allAxis.push(keyAxis);\n    keyAxis.column = axis;\n\n    // normalized string data\n    keyAxis.normTable = [];\n    keyAxis.sortCodeMap = {};\n\n    // add a key to the axis\n    keyAxis.add = k => {\n      if (keyAxis.indexOf(k) === -1) {\n        keyAxis.push(k);\n      }\n    };\n\n    // default functions\n    keyAxis.reorder = () => {\n      keyAxis.sort((a, b) => {\n        // make sure -empty- is at the bottom\n        if (a === null) {\n          return 1;\n        }\n        if (b === null) {\n          return -1;\n        }\n        let sortCodeA = keyAxis.sortCodeMap[a],\n          sortCodeB = keyAxis.sortCodeMap[b];\n        if (!objects.isNullOrUndefined(sortCodeA) || !objects.isNullOrUndefined(sortCodeB)) {\n          return comparators.NUMERIC.compare(sortCodeA, sortCodeB);\n        }\n        // sort others\n        return a - b;\n      });\n    };\n    keyAxis.norm = f => {\n      if (f === null || f === '') {\n        return null;\n      }\n      let index = keyAxis.normTable.indexOf(f);\n      if (index === -1) {\n        return keyAxis.normTable.push(f) - 1;\n      }\n      return index;\n    };\n    keyAxis.format = n => {\n      if (n === null) {\n        return emptyCell;\n      }\n      return keyAxis.normTable[n];\n    };\n    keyAxis.deterministicKeyToKey = deterministicKey => {\n      return keyAxis.norm(deterministicKey);\n    };\n    keyAxis.keyToDeterministicKey = key => {\n      if (key === null) {\n        return key;\n      }\n      return keyAxis.format(key);\n    };\n    keyAxis.normDeterministic = f => {\n      return keyAxis.keyToDeterministicKey(keyAxis.norm(f));\n    };\n\n    // norm and format depends of datatype and group functionality\n    if (axis instanceof DateColumn) {\n      if (axisGroup === TableMatrix.DateGroup.NONE) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return f.getTime();\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return null;\n          }\n          let format = axis.format;\n          if (format) {\n            format = DateFormat.ensure(locale, format);\n          } else {\n            format = locale.dateFormat;\n          }\n          return format.format(new Date(n));\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.YEAR) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return f.getFullYear();\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return String(n);\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.MONTH) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return f.getMonth();\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return locale.dateFormatSymbols.months[n];\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.WEEKDAY) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return (f.getDay() + 7 - locale.dateFormatSymbols.firstDayOfWeek) % 7;\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return locale.dateFormatSymbols.weekdaysOrdered[n];\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.DATE) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return dates.trunc(f).getTime();\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return dates.format(new Date(n), locale, locale.dateFormatPatternDefault);\n        };\n      }\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else if (axis instanceof NumberColumn) {\n      keyAxis.norm = f => {\n        if (isNaN(f) || f === null || f === '') {\n          return null;\n        }\n        return parseFloat(f);\n      };\n      keyAxis.format = n => {\n        if (isNaN(n) || n === null) {\n          return emptyCell;\n        }\n        return axis.decimalFormat.format(n);\n      };\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else if (axis instanceof BooleanColumn) {\n      keyAxis.norm = f => {\n        if (axis.triStateEnabled && f === null) {\n          return -1;\n        }\n        if (f === true) {\n          return 1;\n        }\n        return 0;\n      };\n      keyAxis.format = n => {\n        if (n === -1) {\n          return getText('ui.BooleanColumnGroupingMixed');\n        }\n        if (n === 0) {\n          return getText('ui.BooleanColumnGroupingFalse');\n        }\n        if (n === 1) {\n          return getText('ui.BooleanColumnGroupingTrue');\n        }\n      };\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else if (axis instanceof IconColumn) {\n      keyAxis.textIsIcon = true;\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else {\n      keyAxis.reorder = () => {\n        let comparator = comparators.TEXT;\n        comparator.install(session);\n        keyAxis.sort((a, b) => {\n          // make sure -empty- is at the bottom\n          if (a === null) {\n            return 1;\n          }\n          if (b === null) {\n            return -1;\n          }\n          let sortCodeA = keyAxis.sortCodeMap[a],\n            sortCodeB = keyAxis.sortCodeMap[b];\n          if (!objects.isNullOrUndefined(sortCodeA) || !objects.isNullOrUndefined(sortCodeB)) {\n            return comparators.NUMERIC.compare(sortCodeA, sortCodeB);\n          }\n          // sort others\n          return comparator.compare(keyAxis.format(a), keyAxis.format(b));\n        });\n      };\n    }\n    return keyAxis;\n  }\n\n  /**\n   * @returns a cube containing the results\n   */\n  calculate() {\n    let cube = {},\n      r,\n      v,\n      k,\n      data,\n      key,\n      normData,\n      normKey,\n      length = 0;\n\n    // collect data from table\n    for (r = 0; r < this._rows.length; r++) {\n      let row = this._rows[r];\n      // collect keys of x, y axis from row\n      let keys = [];\n      for (k = 0; k < this._allAxis.length; k++) {\n        let column = this._allAxis[k].column;\n        key = column.cellValueOrTextForCalculation(row);\n        normKey = this._allAxis[k].norm(key);\n        if (normKey !== undefined) {\n          this._allAxis[k].add(normKey);\n          if (column.cell(row).sortCode !== null) {\n            this._allAxis[k].sortCodeMap[normKey] = column.cell(row).sortCode;\n          }\n          keys.push(normKey);\n        }\n      }\n      keys = JSON.stringify(keys);\n\n      // collect values of data axis from row\n      let values = [];\n      for (v = 0; v < this._allData.length; v++) {\n        data = this._table.cellValue(this._allData[v].column, row);\n        normData = this._allData[v].norm(data);\n        if (normData !== undefined) {\n          values.push(normData);\n        }\n      }\n\n      // build cube\n      if (cube[keys]) {\n        cube[keys].push(values);\n      } else {\n        cube[keys] = [values];\n        length++;\n      }\n    }\n\n    // group values and find sum, min and max of data axis\n    for (v = 0; v < this._allData.length; v++) {\n      data = this._allData[v];\n      data.total = 0;\n      data.min = null;\n      data.max = null;\n      for (k in cube) {\n        if (cube.hasOwnProperty(k)) {\n          let allCell = cube[k],\n            subCell = [];\n          for (let i = 0; i < allCell.length; i++) {\n            subCell.push(allCell[i][v]);\n          }\n          let newValue = this._allData[v].group(subCell);\n          cube[k][v] = newValue;\n          data.total += newValue;\n          if (newValue === null) {\n            continue;\n          }\n          if (newValue < data.min || data.min === null) {\n            data.min = newValue;\n          }\n          if (newValue > data.max || data.min === null) {\n            data.max = newValue;\n          }\n        }\n      }\n\n      // To calculate correct y axis scale data.max must not be 0. If data.max===0-> log(data.max)=-infinity\n      if (scout.nvl(data.max, 0) === 0) {\n        data.max = 0.1;\n      }\n      let f = Math.ceil(Math.log(data.max) / Math.LN10) - 1;\n      data.max = Math.ceil(data.max / Math.pow(10, f)) * Math.pow(10, f);\n      data.max = Math.ceil(data.max / 4) * 4;\n    }\n\n    // find dimensions and sort for x, y axis\n    for (k = 0; k < this._allAxis.length; k++) {\n      key = this._allAxis[k];\n      key.min = arrays.min(key);\n      key.max = arrays.max(key);\n\n      // null value should be handled as first value (in charts)\n      if (key.indexOf(null) !== -1) {\n        key.max = key.max + 1;\n      }\n      key.reorder();\n    }\n\n    // access function used by chart\n    cube.getValue = keys => {\n      keys = JSON.stringify(keys);\n      if (cube.hasOwnProperty(keys)) {\n        return cube[keys];\n      }\n      return null;\n    };\n    cube.length = length;\n    return cube;\n  }\n  columnCount(filterNumberColumns) {\n    let c,\n      column,\n      r,\n      row,\n      cellValue,\n      columns = this.columns(filterNumberColumns),\n      colCount = [],\n      count = 0;\n    for (c = 0; c < columns.length; c++) {\n      column = columns[c];\n      colCount.push([column, []]);\n      for (r = 0; r < this._rows.length; r++) {\n        row = this._rows[r];\n        cellValue = column.cellValueOrTextForCalculation(row);\n        if (colCount[count][1].indexOf(cellValue) === -1) {\n          colCount[count][1].push(cellValue);\n        }\n      }\n      colCount[count][1] = colCount[count][1].length;\n      count++;\n    }\n    return colCount;\n  }\n  isEmpty() {\n    return this._rows.length === 0 || this.columns().length === 0;\n  }\n\n  /**\n   * @returns valid columns for table-matrix (not instance of NumberColumn and not guiOnly)\n   * @param filterNumberColumns whether or not to filter NumberColumn, default is true\n   */\n  columns(filterNumberColumns) {\n    filterNumberColumns = scout.nvl(filterNumberColumns, true);\n    return this._table.visibleColumns().filter(column => {\n      if (column.guiOnly) {\n        return false;\n      }\n      if (filterNumberColumns && column instanceof NumberColumn) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Table rows and columns are not always in a consistent state.\n   * @returns {boolean} true, if table is in a valid, consistent state\n   * */\n  isMatrixValid() {\n    return this._table.rows.length === 0 || this.columns(false).length === this._table.rows[0].cells.length;\n  }\n}\n_defineProperty(TableMatrix, \"DateGroup\", {\n  NONE: 0,\n  YEAR: 256,\n  MONTH: 257,\n  WEEKDAY: 258,\n  DATE: 259\n});\n_defineProperty(TableMatrix, \"NumberGroup\", {\n  COUNT: -1,\n  SUM: 1,\n  AVG: 2\n});","map":{"version":3,"names":["arrays","BooleanColumn","comparators","DateColumn","DateFormat","dates","IconColumn","NumberColumn","objects","scout","TableMatrix","constructor","table","session","locale","_allData","_allAxis","_rows","rows","_table","addData","data","dataGroup","dataAxis","push","column","format","n","decimalFormat","NumberGroup","COUNT","norm","f","group","array","length","SUM","isNaN","parseFloat","reduce","a","b","AVG","sum","count","addAxis","axis","axisGroup","keyAxis","getText","text","bind","emptyCell","normTable","sortCodeMap","add","k","indexOf","reorder","sort","sortCodeA","sortCodeB","isNullOrUndefined","NUMERIC","compare","index","deterministicKeyToKey","deterministicKey","keyToDeterministicKey","key","normDeterministic","DateGroup","NONE","getTime","ensure","dateFormat","Date","YEAR","getFullYear","String","MONTH","getMonth","dateFormatSymbols","months","WEEKDAY","getDay","firstDayOfWeek","weekdaysOrdered","DATE","trunc","dateFormatPatternDefault","triStateEnabled","textIsIcon","comparator","TEXT","install","calculate","cube","r","v","normData","normKey","row","keys","cellValueOrTextForCalculation","undefined","cell","sortCode","JSON","stringify","values","cellValue","total","min","max","hasOwnProperty","allCell","subCell","i","newValue","nvl","Math","ceil","log","LN10","pow","getValue","columnCount","filterNumberColumns","c","columns","colCount","isEmpty","visibleColumns","filter","guiOnly","isMatrixValid","cells"],"sources":["C:/workspace/ddhub/ddhub/node_modules/.pnpm/@eclipse-scout+core@22.0.41/node_modules/@eclipse-scout/core/src/table/TableMatrix.js"],"sourcesContent":["/*\n * Copyright (c) 2014-2021 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, BooleanColumn, comparators, DateColumn, DateFormat, dates, IconColumn, NumberColumn, objects, scout} from '../index';\n\nexport default class TableMatrix {\n\n  constructor(table, session) {\n    this.session = session;\n    this.locale = session.locale;\n    this._allData = [];\n    this._allAxis = [];\n    this._rows = table.rows;\n    this._table = table;\n  }\n\n  static DateGroup = {\n    NONE: 0,\n    YEAR: 256,\n    MONTH: 257,\n    WEEKDAY: 258,\n    DATE: 259\n  };\n\n  static NumberGroup = {\n    COUNT: -1,\n    SUM: 1,\n    AVG: 2\n  };\n\n  /**\n   * add data axis\n   */\n  addData(data, dataGroup) {\n    let dataAxis = [],\n      locale = this.locale;\n\n    // collect all axis\n    this._allData.push(dataAxis);\n\n    // copy column for later access\n    dataAxis.column = data;\n\n    // data always is number\n    dataAxis.format = n => locale.decimalFormat.format(n);\n\n    // count, sum, avg\n    if (dataGroup === TableMatrix.NumberGroup.COUNT) {\n      dataAxis.norm = f => 1;\n      dataAxis.group = array => array.length;\n    } else if (dataGroup === TableMatrix.NumberGroup.SUM) {\n      dataAxis.norm = f => {\n        if (isNaN(f) || f === null || f === '') {\n          return null;\n        }\n        return parseFloat(f);\n      };\n      dataAxis.group = array => array.reduce((a, b) => {\n        return a + b;\n      });\n    } else if (dataGroup === TableMatrix.NumberGroup.AVG) {\n      dataAxis.norm = f => {\n        if (isNaN(f) || f === null || f === '') {\n          return null;\n        }\n        return parseFloat(f);\n      };\n      dataAxis.group = array => {\n        let sum = array.reduce((a, b) => {\n            return a + b;\n          }),\n          count = array.reduce((a, b) => {\n            return (b === null ? a : a + 1);\n          }, 0);\n\n        if (count === 0) {\n          return null;\n        }\n        return sum / count;\n\n      };\n    }\n    return dataAxis;\n  }\n\n  // add x or y Axis\n  addAxis(axis, axisGroup) {\n    let keyAxis = [],\n      locale = this.locale,\n      session = this.session,\n      getText = this.session.text.bind(this.session),\n      emptyCell = getText('ui.EmptyCell');\n\n    // collect all axis\n    this._allAxis.push(keyAxis);\n    keyAxis.column = axis;\n\n    // normalized string data\n    keyAxis.normTable = [];\n\n    keyAxis.sortCodeMap = {};\n\n    // add a key to the axis\n    keyAxis.add = k => {\n      if (keyAxis.indexOf(k) === -1) {\n        keyAxis.push(k);\n      }\n    };\n\n    // default functions\n    keyAxis.reorder = () => {\n      keyAxis.sort((a, b) => {\n        // make sure -empty- is at the bottom\n        if (a === null) {\n          return 1;\n        }\n        if (b === null) {\n          return -1;\n        }\n        let sortCodeA = keyAxis.sortCodeMap[a],\n          sortCodeB = keyAxis.sortCodeMap[b];\n        if (!objects.isNullOrUndefined(sortCodeA) || !objects.isNullOrUndefined(sortCodeB)) {\n          return comparators.NUMERIC.compare(sortCodeA, sortCodeB);\n        }\n        // sort others\n        return (a - b);\n      });\n    };\n    keyAxis.norm = f => {\n      if (f === null || f === '') {\n        return null;\n      }\n      let index = keyAxis.normTable.indexOf(f);\n      if (index === -1) {\n        return keyAxis.normTable.push(f) - 1;\n      }\n      return index;\n    };\n    keyAxis.format = n => {\n      if (n === null) {\n        return emptyCell;\n      }\n      return keyAxis.normTable[n];\n    };\n    keyAxis.deterministicKeyToKey = deterministicKey => {\n      return keyAxis.norm(deterministicKey);\n    };\n    keyAxis.keyToDeterministicKey = key => {\n      if (key === null) {\n        return key;\n      }\n      return keyAxis.format(key);\n    };\n    keyAxis.normDeterministic = f => {\n      return keyAxis.keyToDeterministicKey(keyAxis.norm(f));\n    };\n\n    // norm and format depends of datatype and group functionality\n    if (axis instanceof DateColumn) {\n      if (axisGroup === TableMatrix.DateGroup.NONE) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return f.getTime();\n\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return null;\n          }\n          let format = axis.format;\n          if (format) {\n            format = DateFormat.ensure(locale, format);\n          } else {\n            format = locale.dateFormat;\n          }\n          return format.format(new Date(n));\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.YEAR) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return f.getFullYear();\n\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return String(n);\n\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.MONTH) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return f.getMonth();\n\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return locale.dateFormatSymbols.months[n];\n\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.WEEKDAY) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return (f.getDay() + 7 - locale.dateFormatSymbols.firstDayOfWeek) % 7;\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return locale.dateFormatSymbols.weekdaysOrdered[n];\n        };\n      } else if (axisGroup === TableMatrix.DateGroup.DATE) {\n        keyAxis.norm = f => {\n          if (f === null || f === '') {\n            return null;\n          }\n          return dates.trunc(f).getTime();\n        };\n        keyAxis.format = n => {\n          if (n === null) {\n            return emptyCell;\n          }\n          return dates.format(new Date(n), locale, locale.dateFormatPatternDefault);\n        };\n      }\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else if (axis instanceof NumberColumn) {\n      keyAxis.norm = f => {\n        if (isNaN(f) || f === null || f === '') {\n          return null;\n        }\n        return parseFloat(f);\n      };\n      keyAxis.format = n => {\n        if (isNaN(n) || n === null) {\n          return emptyCell;\n        }\n        return axis.decimalFormat.format(n);\n      };\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else if (axis instanceof BooleanColumn) {\n      keyAxis.norm = f => {\n        if (axis.triStateEnabled && f === null) {\n          return -1;\n        }\n        if (f === true) {\n          return 1;\n        }\n        return 0;\n      };\n      keyAxis.format = n => {\n        if (n === -1) {\n          return getText('ui.BooleanColumnGroupingMixed');\n        }\n        if (n === 0) {\n          return getText('ui.BooleanColumnGroupingFalse');\n        }\n        if (n === 1) {\n          return getText('ui.BooleanColumnGroupingTrue');\n        }\n      };\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else if (axis instanceof IconColumn) {\n      keyAxis.textIsIcon = true;\n      keyAxis.deterministicKeyToKey = deterministicKey => {\n        return deterministicKey;\n      };\n      keyAxis.keyToDeterministicKey = key => {\n        return key;\n      };\n      keyAxis.normDeterministic = f => {\n        return keyAxis.norm(f);\n      };\n    } else {\n      keyAxis.reorder = () => {\n        let comparator = comparators.TEXT;\n        comparator.install(session);\n\n        keyAxis.sort((a, b) => {\n          // make sure -empty- is at the bottom\n          if (a === null) {\n            return 1;\n          }\n          if (b === null) {\n            return -1;\n          }\n          let sortCodeA = keyAxis.sortCodeMap[a],\n            sortCodeB = keyAxis.sortCodeMap[b];\n          if (!objects.isNullOrUndefined(sortCodeA) || !objects.isNullOrUndefined(sortCodeB)) {\n            return comparators.NUMERIC.compare(sortCodeA, sortCodeB);\n          }\n          // sort others\n          return comparator.compare(keyAxis.format(a), keyAxis.format(b));\n        });\n      };\n    }\n    return keyAxis;\n  }\n\n  /**\n   * @returns a cube containing the results\n   */\n  calculate() {\n    let cube = {},\n      r, v, k, data, key, normData, normKey,\n      length = 0;\n\n    // collect data from table\n    for (r = 0; r < this._rows.length; r++) {\n      let row = this._rows[r];\n      // collect keys of x, y axis from row\n      let keys = [];\n      for (k = 0; k < this._allAxis.length; k++) {\n        let column = this._allAxis[k].column;\n        key = column.cellValueOrTextForCalculation(row);\n        normKey = this._allAxis[k].norm(key);\n\n        if (normKey !== undefined) {\n          this._allAxis[k].add(normKey);\n          if (column.cell(row).sortCode !== null) {\n            this._allAxis[k].sortCodeMap[normKey] = column.cell(row).sortCode;\n          }\n          keys.push(normKey);\n        }\n      }\n      keys = JSON.stringify(keys);\n\n      // collect values of data axis from row\n      let values = [];\n      for (v = 0; v < this._allData.length; v++) {\n        data = this._table.cellValue(this._allData[v].column, row);\n        normData = this._allData[v].norm(data);\n        if (normData !== undefined) {\n          values.push(normData);\n        }\n      }\n\n      // build cube\n      if (cube[keys]) {\n        cube[keys].push(values);\n      } else {\n        cube[keys] = [values];\n        length++;\n      }\n    }\n\n    // group values and find sum, min and max of data axis\n    for (v = 0; v < this._allData.length; v++) {\n      data = this._allData[v];\n\n      data.total = 0;\n      data.min = null;\n      data.max = null;\n\n      for (k in cube) {\n        if (cube.hasOwnProperty(k)) {\n          let allCell = cube[k],\n            subCell = [];\n\n          for (let i = 0; i < allCell.length; i++) {\n            subCell.push(allCell[i][v]);\n          }\n\n          let newValue = this._allData[v].group(subCell);\n          cube[k][v] = newValue;\n          data.total += newValue;\n\n          if (newValue === null) {\n            continue;\n          }\n\n          if (newValue < data.min || data.min === null) {\n            data.min = newValue;\n          }\n          if (newValue > data.max || data.min === null) {\n            data.max = newValue;\n          }\n        }\n      }\n\n      // To calculate correct y axis scale data.max must not be 0. If data.max===0-> log(data.max)=-infinity\n      if (scout.nvl(data.max, 0) === 0) {\n        data.max = 0.1;\n      }\n\n      let f = Math.ceil(Math.log(data.max) / Math.LN10) - 1;\n\n      data.max = Math.ceil(data.max / Math.pow(10, f)) * Math.pow(10, f);\n      data.max = Math.ceil(data.max / 4) * 4;\n    }\n\n    // find dimensions and sort for x, y axis\n    for (k = 0; k < this._allAxis.length; k++) {\n      key = this._allAxis[k];\n\n      key.min = arrays.min(key);\n      key.max = arrays.max(key);\n\n      // null value should be handled as first value (in charts)\n      if (key.indexOf(null) !== -1) {\n        key.max = key.max + 1;\n      }\n\n      key.reorder();\n    }\n\n    // access function used by chart\n    cube.getValue = keys => {\n      keys = JSON.stringify(keys);\n\n      if (cube.hasOwnProperty(keys)) {\n        return cube[keys];\n      }\n      return null;\n\n    };\n\n    cube.length = length;\n    return cube;\n  }\n\n  columnCount(filterNumberColumns) {\n    let c, column, r, row, cellValue,\n      columns = this.columns(filterNumberColumns),\n      colCount = [],\n      count = 0;\n\n    for (c = 0; c < columns.length; c++) {\n      column = columns[c];\n      colCount.push([column, []]);\n\n      for (r = 0; r < this._rows.length; r++) {\n        row = this._rows[r];\n        cellValue = column.cellValueOrTextForCalculation(row);\n        if (colCount[count][1].indexOf(cellValue) === -1) {\n          colCount[count][1].push(cellValue);\n        }\n      }\n\n      colCount[count][1] = colCount[count][1].length;\n      count++;\n    }\n    return colCount;\n  }\n\n  isEmpty() {\n    return this._rows.length === 0 || this.columns().length === 0;\n  }\n\n  /**\n   * @returns valid columns for table-matrix (not instance of NumberColumn and not guiOnly)\n   * @param filterNumberColumns whether or not to filter NumberColumn, default is true\n   */\n  columns(filterNumberColumns) {\n    filterNumberColumns = scout.nvl(filterNumberColumns, true);\n    return this._table.visibleColumns().filter(column => {\n      if (column.guiOnly) {\n        return false;\n      }\n      if (filterNumberColumns && column instanceof NumberColumn) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Table rows and columns are not always in a consistent state.\n   * @returns {boolean} true, if table is in a valid, consistent state\n   * */\n  isMatrixValid() {\n    return this._table.rows.length === 0 || this.columns(false).length === this._table.rows[0].cells.length;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}